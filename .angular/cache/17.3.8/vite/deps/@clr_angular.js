import {
  animate,
  keyframes,
  state,
  style,
  transition,
  trigger
} from "./chunk-ZKTQV5OC.js";
import {
  CheckboxControlValueAccessor,
  DefaultValueAccessor,
  FormControl,
  FormGroup,
  FormGroupDirective,
  FormGroupName,
  FormsModule,
  NG_VALIDATORS,
  NG_VALUE_ACCESSOR,
  NgControl,
  NgControlStatus,
  NgForm,
  NgModel,
  NgModelGroup,
  NgSelectOption,
  NumberValueAccessor,
  RadioControlValueAccessor,
  SelectControlValueAccessor,
  SelectMultipleControlValueAccessor,
  ɵNgSelectMultipleOption
} from "./chunk-3VKKWMAX.js";
import "./chunk-HLNL33CE.js";
import {
  C,
  H2 as H,
  a2,
  a5 as a3,
  d10 as d4,
  d2 as d,
  d3 as d2,
  d4 as d3,
  e,
  e3 as e2,
  e4 as e3,
  e7 as e4,
  i,
  l,
  n2,
  n9 as n3,
  o as o3,
  o14 as o7,
  o2 as o4,
  o23 as o8,
  o7 as o5,
  o8 as o6,
  r4 as r2,
  r5 as r3,
  r6 as r4,
  r7 as r5,
  t13 as t
} from "./chunk-EZX4VLKT.js";
import {
  a,
  css,
  html,
  m,
  m2,
  n,
  o,
  o2,
  p,
  r2 as r,
  w
} from "./chunk-EETX4G6E.js";
import {
  RouterLinkActive
} from "./chunk-HCYMSM7T.js";
import "./chunk-6DPH7TMF.js";
import {
  AsyncPipe,
  CommonModule,
  DOCUMENT,
  FormStyle,
  FormatWidth,
  NgClass,
  NgForOf,
  NgIf,
  NgSwitch,
  NgSwitchCase,
  NgTemplateOutlet,
  TranslationWidth,
  getLocaleDateFormat,
  getLocaleDayNames,
  getLocaleFirstDayOfWeek,
  getLocaleMonthNames,
  isPlatformBrowser
} from "./chunk-KH3E2GWA.js";
import {
  APP_ID,
  ApplicationRef,
  Attribute,
  CSP_NONCE,
  ChangeDetectionStrategy,
  ChangeDetectorRef,
  Component,
  ComponentFactoryResolver$1,
  ContentChild,
  ContentChildren,
  Directive,
  ElementRef,
  EnvironmentInjector,
  EventEmitter,
  HostBinding,
  HostListener,
  Inject,
  Injectable,
  InjectionToken,
  Injector,
  Input,
  InputFlags,
  IterableDiffers,
  KeyValueDiffers,
  LOCALE_ID,
  NgModule,
  NgZone,
  Optional,
  Output,
  PLATFORM_ID,
  Renderer2,
  RendererFactory2,
  Self,
  SkipSelf,
  TemplateRef,
  Type,
  ViewChild,
  ViewContainerRef,
  ViewEncapsulation$1,
  booleanAttribute,
  createComponent,
  forwardRef,
  inject,
  setClassMetadata,
  ɵɵHostDirectivesFeature,
  ɵɵInheritDefinitionFeature,
  ɵɵInputTransformsFeature,
  ɵɵNgOnChangesFeature,
  ɵɵProvidersFeature,
  ɵɵStandaloneFeature,
  ɵɵadvance,
  ɵɵattribute,
  ɵɵclassMap,
  ɵɵclassProp,
  ɵɵcontentQuery,
  ɵɵdefineComponent,
  ɵɵdefineDirective,
  ɵɵdefineInjectable,
  ɵɵdefineInjector,
  ɵɵdefineNgModule,
  ɵɵdirectiveInject,
  ɵɵelement,
  ɵɵelementContainer,
  ɵɵelementContainerEnd,
  ɵɵelementContainerStart,
  ɵɵelementEnd,
  ɵɵelementStart,
  ɵɵgetCurrentView,
  ɵɵgetInheritedFactory,
  ɵɵhostProperty,
  ɵɵinject,
  ɵɵinjectAttribute,
  ɵɵlistener,
  ɵɵloadQuery,
  ɵɵnextContext,
  ɵɵpipe,
  ɵɵpipeBind1,
  ɵɵprojection,
  ɵɵprojectionDef,
  ɵɵproperty,
  ɵɵpropertyInterpolate,
  ɵɵpropertyInterpolate1,
  ɵɵpureFunction1,
  ɵɵqueryRefresh,
  ɵɵreference,
  ɵɵresetView,
  ɵɵresolveDocument,
  ɵɵresolveWindow,
  ɵɵrestoreView,
  ɵɵstyleProp,
  ɵɵsyntheticHostListener,
  ɵɵsyntheticHostProperty,
  ɵɵtemplate,
  ɵɵtemplateRefExtractor,
  ɵɵtext,
  ɵɵtextInterpolate,
  ɵɵtextInterpolate1,
  ɵɵtextInterpolate2,
  ɵɵtextInterpolate3,
  ɵɵtwoWayBindingSet,
  ɵɵtwoWayListener,
  ɵɵtwoWayProperty,
  ɵɵviewQuery
} from "./chunk-MW7KAMEX.js";
import {
  BehaviorSubject,
  ConnectableObservable,
  Observable,
  ReplaySubject,
  Subject,
  Subscription,
  animationFrameScheduler,
  asapScheduler,
  auditTime,
  combineLatest,
  concat,
  debounceTime,
  distinctUntilChanged,
  filter,
  first,
  fromEvent,
  interval,
  isObservable,
  map,
  merge,
  of,
  pairwise,
  shareReplay,
  skip,
  skipUntil,
  startWith,
  switchMap,
  take,
  takeUntil,
  tap
} from "./chunk-S5JU3MLM.js";
import {
  __decorate
} from "./chunk-NCOMLVU7.js";
import {
  __spreadProps,
  __spreadValues
} from "./chunk-J4B6MK7R.js";

// node_modules/@angular/cdk/fesm2022/platform.mjs
var hasV8BreakIterator;
try {
  hasV8BreakIterator = typeof Intl !== "undefined" && Intl.v8BreakIterator;
} catch {
  hasV8BreakIterator = false;
}
var _Platform = class _Platform {
  constructor(_platformId) {
    this._platformId = _platformId;
    this.isBrowser = this._platformId ? isPlatformBrowser(this._platformId) : typeof document === "object" && !!document;
    this.EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent);
    this.TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent);
    this.BLINK = this.isBrowser && !!(window.chrome || hasV8BreakIterator) && typeof CSS !== "undefined" && !this.EDGE && !this.TRIDENT;
    this.WEBKIT = this.isBrowser && /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT;
    this.IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) && !("MSStream" in window);
    this.FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent);
    this.ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT;
    this.SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT;
  }
};
_Platform.ɵfac = function Platform_Factory(t3) {
  return new (t3 || _Platform)(ɵɵinject(PLATFORM_ID));
};
_Platform.ɵprov = ɵɵdefineInjectable({
  token: _Platform,
  factory: _Platform.ɵfac,
  providedIn: "root"
});
var Platform = _Platform;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Platform, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: Object,
    decorators: [{
      type: Inject,
      args: [PLATFORM_ID]
    }]
  }], null);
})();
var _PlatformModule = class _PlatformModule {
};
_PlatformModule.ɵfac = function PlatformModule_Factory(t3) {
  return new (t3 || _PlatformModule)();
};
_PlatformModule.ɵmod = ɵɵdefineNgModule({
  type: _PlatformModule
});
_PlatformModule.ɵinj = ɵɵdefineInjector({});
var PlatformModule = _PlatformModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PlatformModule, [{
    type: NgModule,
    args: [{}]
  }], null, null);
})();
var supportsPassiveEvents;
function supportsPassiveEventListeners() {
  if (supportsPassiveEvents == null && typeof window !== "undefined") {
    try {
      window.addEventListener("test", null, Object.defineProperty({}, "passive", {
        get: () => supportsPassiveEvents = true
      }));
    } finally {
      supportsPassiveEvents = supportsPassiveEvents || false;
    }
  }
  return supportsPassiveEvents;
}
function normalizePassiveListenerOptions(options) {
  return supportsPassiveEventListeners() ? options : !!options.capture;
}
var RtlScrollAxisType;
(function(RtlScrollAxisType2) {
  RtlScrollAxisType2[RtlScrollAxisType2["NORMAL"] = 0] = "NORMAL";
  RtlScrollAxisType2[RtlScrollAxisType2["NEGATED"] = 1] = "NEGATED";
  RtlScrollAxisType2[RtlScrollAxisType2["INVERTED"] = 2] = "INVERTED";
})(RtlScrollAxisType || (RtlScrollAxisType = {}));
var rtlScrollAxisType;
var scrollBehaviorSupported;
function supportsScrollBehavior() {
  if (scrollBehaviorSupported == null) {
    if (typeof document !== "object" || !document || typeof Element !== "function" || !Element) {
      scrollBehaviorSupported = false;
      return scrollBehaviorSupported;
    }
    if ("scrollBehavior" in document.documentElement.style) {
      scrollBehaviorSupported = true;
    } else {
      const scrollToFunction = Element.prototype.scrollTo;
      if (scrollToFunction) {
        scrollBehaviorSupported = !/\{\s*\[native code\]\s*\}/.test(scrollToFunction.toString());
      } else {
        scrollBehaviorSupported = false;
      }
    }
  }
  return scrollBehaviorSupported;
}
function getRtlScrollAxisType() {
  if (typeof document !== "object" || !document) {
    return RtlScrollAxisType.NORMAL;
  }
  if (rtlScrollAxisType == null) {
    const scrollContainer = document.createElement("div");
    const containerStyle = scrollContainer.style;
    scrollContainer.dir = "rtl";
    containerStyle.width = "1px";
    containerStyle.overflow = "auto";
    containerStyle.visibility = "hidden";
    containerStyle.pointerEvents = "none";
    containerStyle.position = "absolute";
    const content = document.createElement("div");
    const contentStyle = content.style;
    contentStyle.width = "2px";
    contentStyle.height = "1px";
    scrollContainer.appendChild(content);
    document.body.appendChild(scrollContainer);
    rtlScrollAxisType = RtlScrollAxisType.NORMAL;
    if (scrollContainer.scrollLeft === 0) {
      scrollContainer.scrollLeft = 1;
      rtlScrollAxisType = scrollContainer.scrollLeft === 0 ? RtlScrollAxisType.NEGATED : RtlScrollAxisType.INVERTED;
    }
    scrollContainer.remove();
  }
  return rtlScrollAxisType;
}
var shadowDomIsSupported;
function _supportsShadowDom() {
  if (shadowDomIsSupported == null) {
    const head = typeof document !== "undefined" ? document.head : null;
    shadowDomIsSupported = !!(head && (head.createShadowRoot || head.attachShadow));
  }
  return shadowDomIsSupported;
}
function _getShadowRoot(element) {
  if (_supportsShadowDom()) {
    const rootNode = element.getRootNode ? element.getRootNode() : null;
    if (typeof ShadowRoot !== "undefined" && ShadowRoot && rootNode instanceof ShadowRoot) {
      return rootNode;
    }
  }
  return null;
}
function _getFocusedElementPierceShadowDom() {
  let activeElement = typeof document !== "undefined" && document ? document.activeElement : null;
  while (activeElement && activeElement.shadowRoot) {
    const newActiveElement = activeElement.shadowRoot.activeElement;
    if (newActiveElement === activeElement) {
      break;
    } else {
      activeElement = newActiveElement;
    }
  }
  return activeElement;
}
function _getEventTarget(event) {
  return event.composedPath ? event.composedPath()[0] : event.target;
}

// node_modules/@angular/cdk/fesm2022/keycodes.mjs
var SHIFT = 16;
var CONTROL = 17;
var ALT = 18;
var META = 91;
var MAC_META = 224;

// node_modules/@angular/cdk/fesm2022/coercion.mjs
function coerceNumberProperty(value, fallbackValue = 0) {
  return _isNumberValue(value) ? Number(value) : fallbackValue;
}
function _isNumberValue(value) {
  return !isNaN(parseFloat(value)) && !isNaN(Number(value));
}
function coerceArray(value) {
  return Array.isArray(value) ? value : [value];
}
function coerceElement(elementOrRef) {
  return elementOrRef instanceof ElementRef ? elementOrRef.nativeElement : elementOrRef;
}

// node_modules/@angular/cdk/fesm2022/observers.mjs
function shouldIgnoreRecord(record) {
  if (record.type === "characterData" && record.target instanceof Comment) {
    return true;
  }
  if (record.type === "childList") {
    for (let i2 = 0; i2 < record.addedNodes.length; i2++) {
      if (!(record.addedNodes[i2] instanceof Comment)) {
        return false;
      }
    }
    for (let i2 = 0; i2 < record.removedNodes.length; i2++) {
      if (!(record.removedNodes[i2] instanceof Comment)) {
        return false;
      }
    }
    return true;
  }
  return false;
}
var _MutationObserverFactory = class _MutationObserverFactory {
  create(callback) {
    return typeof MutationObserver === "undefined" ? null : new MutationObserver(callback);
  }
};
_MutationObserverFactory.ɵfac = function MutationObserverFactory_Factory(t3) {
  return new (t3 || _MutationObserverFactory)();
};
_MutationObserverFactory.ɵprov = ɵɵdefineInjectable({
  token: _MutationObserverFactory,
  factory: _MutationObserverFactory.ɵfac,
  providedIn: "root"
});
var MutationObserverFactory = _MutationObserverFactory;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MutationObserverFactory, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var _ContentObserver = class _ContentObserver {
  constructor(_mutationObserverFactory) {
    this._mutationObserverFactory = _mutationObserverFactory;
    this._observedElements = /* @__PURE__ */ new Map();
  }
  ngOnDestroy() {
    this._observedElements.forEach((_, element) => this._cleanupObserver(element));
  }
  observe(elementOrRef) {
    const element = coerceElement(elementOrRef);
    return new Observable((observer) => {
      const stream = this._observeElement(element);
      const subscription = stream.pipe(map((records) => records.filter((record) => !shouldIgnoreRecord(record))), filter((records) => !!records.length)).subscribe(observer);
      return () => {
        subscription.unsubscribe();
        this._unobserveElement(element);
      };
    });
  }
  /**
   * Observes the given element by using the existing MutationObserver if available, or creating a
   * new one if not.
   */
  _observeElement(element) {
    if (!this._observedElements.has(element)) {
      const stream = new Subject();
      const observer = this._mutationObserverFactory.create((mutations) => stream.next(mutations));
      if (observer) {
        observer.observe(element, {
          characterData: true,
          childList: true,
          subtree: true
        });
      }
      this._observedElements.set(element, {
        observer,
        stream,
        count: 1
      });
    } else {
      this._observedElements.get(element).count++;
    }
    return this._observedElements.get(element).stream;
  }
  /**
   * Un-observes the given element and cleans up the underlying MutationObserver if nobody else is
   * observing this element.
   */
  _unobserveElement(element) {
    if (this._observedElements.has(element)) {
      this._observedElements.get(element).count--;
      if (!this._observedElements.get(element).count) {
        this._cleanupObserver(element);
      }
    }
  }
  /** Clean up the underlying MutationObserver for the specified element. */
  _cleanupObserver(element) {
    if (this._observedElements.has(element)) {
      const {
        observer,
        stream
      } = this._observedElements.get(element);
      if (observer) {
        observer.disconnect();
      }
      stream.complete();
      this._observedElements.delete(element);
    }
  }
};
_ContentObserver.ɵfac = function ContentObserver_Factory(t3) {
  return new (t3 || _ContentObserver)(ɵɵinject(MutationObserverFactory));
};
_ContentObserver.ɵprov = ɵɵdefineInjectable({
  token: _ContentObserver,
  factory: _ContentObserver.ɵfac,
  providedIn: "root"
});
var ContentObserver = _ContentObserver;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ContentObserver, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: MutationObserverFactory
  }], null);
})();
var _CdkObserveContent = class _CdkObserveContent {
  /**
   * Whether observing content is disabled. This option can be used
   * to disconnect the underlying MutationObserver until it is needed.
   */
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    this._disabled = value;
    this._disabled ? this._unsubscribe() : this._subscribe();
  }
  /** Debounce interval for emitting the changes. */
  get debounce() {
    return this._debounce;
  }
  set debounce(value) {
    this._debounce = coerceNumberProperty(value);
    this._subscribe();
  }
  constructor(_contentObserver, _elementRef, _ngZone) {
    this._contentObserver = _contentObserver;
    this._elementRef = _elementRef;
    this._ngZone = _ngZone;
    this.event = new EventEmitter();
    this._disabled = false;
    this._currentSubscription = null;
  }
  ngAfterContentInit() {
    if (!this._currentSubscription && !this.disabled) {
      this._subscribe();
    }
  }
  ngOnDestroy() {
    this._unsubscribe();
  }
  _subscribe() {
    this._unsubscribe();
    const stream = this._contentObserver.observe(this._elementRef);
    this._ngZone.runOutsideAngular(() => {
      this._currentSubscription = (this.debounce ? stream.pipe(debounceTime(this.debounce)) : stream).subscribe(this.event);
    });
  }
  _unsubscribe() {
    this._currentSubscription?.unsubscribe();
  }
};
_CdkObserveContent.ɵfac = function CdkObserveContent_Factory(t3) {
  return new (t3 || _CdkObserveContent)(ɵɵdirectiveInject(ContentObserver), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
_CdkObserveContent.ɵdir = ɵɵdefineDirective({
  type: _CdkObserveContent,
  selectors: [["", "cdkObserveContent", ""]],
  inputs: {
    disabled: [InputFlags.HasDecoratorInputTransform, "cdkObserveContentDisabled", "disabled", booleanAttribute],
    debounce: "debounce"
  },
  outputs: {
    event: "cdkObserveContent"
  },
  exportAs: ["cdkObserveContent"],
  standalone: true,
  features: [ɵɵInputTransformsFeature]
});
var CdkObserveContent = _CdkObserveContent;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkObserveContent, [{
    type: Directive,
    args: [{
      selector: "[cdkObserveContent]",
      exportAs: "cdkObserveContent",
      standalone: true
    }]
  }], () => [{
    type: ContentObserver
  }, {
    type: ElementRef
  }, {
    type: NgZone
  }], {
    event: [{
      type: Output,
      args: ["cdkObserveContent"]
    }],
    disabled: [{
      type: Input,
      args: [{
        alias: "cdkObserveContentDisabled",
        transform: booleanAttribute
      }]
    }],
    debounce: [{
      type: Input
    }]
  });
})();
var _ObserversModule = class _ObserversModule {
};
_ObserversModule.ɵfac = function ObserversModule_Factory(t3) {
  return new (t3 || _ObserversModule)();
};
_ObserversModule.ɵmod = ɵɵdefineNgModule({
  type: _ObserversModule,
  imports: [CdkObserveContent],
  exports: [CdkObserveContent]
});
_ObserversModule.ɵinj = ɵɵdefineInjector({
  providers: [MutationObserverFactory]
});
var ObserversModule = _ObserversModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ObserversModule, [{
    type: NgModule,
    args: [{
      imports: [CdkObserveContent],
      exports: [CdkObserveContent],
      providers: [MutationObserverFactory]
    }]
  }], null, null);
})();

// node_modules/@angular/cdk/fesm2022/layout.mjs
var _LayoutModule = class _LayoutModule {
};
_LayoutModule.ɵfac = function LayoutModule_Factory(t3) {
  return new (t3 || _LayoutModule)();
};
_LayoutModule.ɵmod = ɵɵdefineNgModule({
  type: _LayoutModule
});
_LayoutModule.ɵinj = ɵɵdefineInjector({});
var LayoutModule = _LayoutModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LayoutModule, [{
    type: NgModule,
    args: [{}]
  }], null, null);
})();
var mediaQueriesForWebkitCompatibility = /* @__PURE__ */ new Set();
var mediaQueryStyleNode;
var _MediaMatcher = class _MediaMatcher {
  constructor(_platform, _nonce) {
    this._platform = _platform;
    this._nonce = _nonce;
    this._matchMedia = this._platform.isBrowser && window.matchMedia ? (
      // matchMedia is bound to the window scope intentionally as it is an illegal invocation to
      // call it from a different scope.
      window.matchMedia.bind(window)
    ) : noopMatchMedia;
  }
  /**
   * Evaluates the given media query and returns the native MediaQueryList from which results
   * can be retrieved.
   * Confirms the layout engine will trigger for the selector query provided and returns the
   * MediaQueryList for the query provided.
   */
  matchMedia(query) {
    if (this._platform.WEBKIT || this._platform.BLINK) {
      createEmptyStyleRule(query, this._nonce);
    }
    return this._matchMedia(query);
  }
};
_MediaMatcher.ɵfac = function MediaMatcher_Factory(t3) {
  return new (t3 || _MediaMatcher)(ɵɵinject(Platform), ɵɵinject(CSP_NONCE, 8));
};
_MediaMatcher.ɵprov = ɵɵdefineInjectable({
  token: _MediaMatcher,
  factory: _MediaMatcher.ɵfac,
  providedIn: "root"
});
var MediaMatcher = _MediaMatcher;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MediaMatcher, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: Platform
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [CSP_NONCE]
    }]
  }], null);
})();
function createEmptyStyleRule(query, nonce) {
  if (mediaQueriesForWebkitCompatibility.has(query)) {
    return;
  }
  try {
    if (!mediaQueryStyleNode) {
      mediaQueryStyleNode = document.createElement("style");
      if (nonce) {
        mediaQueryStyleNode.setAttribute("nonce", nonce);
      }
      mediaQueryStyleNode.setAttribute("type", "text/css");
      document.head.appendChild(mediaQueryStyleNode);
    }
    if (mediaQueryStyleNode.sheet) {
      mediaQueryStyleNode.sheet.insertRule(`@media ${query} {body{ }}`, 0);
      mediaQueriesForWebkitCompatibility.add(query);
    }
  } catch (e5) {
    console.error(e5);
  }
}
function noopMatchMedia(query) {
  return {
    matches: query === "all" || query === "",
    media: query,
    addListener: () => {
    },
    removeListener: () => {
    }
  };
}
var _BreakpointObserver = class _BreakpointObserver {
  constructor(_mediaMatcher, _zone) {
    this._mediaMatcher = _mediaMatcher;
    this._zone = _zone;
    this._queries = /* @__PURE__ */ new Map();
    this._destroySubject = new Subject();
  }
  /** Completes the active subject, signalling to all other observables to complete. */
  ngOnDestroy() {
    this._destroySubject.next();
    this._destroySubject.complete();
  }
  /**
   * Whether one or more media queries match the current viewport size.
   * @param value One or more media queries to check.
   * @returns Whether any of the media queries match.
   */
  isMatched(value) {
    const queries = splitQueries(coerceArray(value));
    return queries.some((mediaQuery) => this._registerQuery(mediaQuery).mql.matches);
  }
  /**
   * Gets an observable of results for the given queries that will emit new results for any changes
   * in matching of the given queries.
   * @param value One or more media queries to check.
   * @returns A stream of matches for the given queries.
   */
  observe(value) {
    const queries = splitQueries(coerceArray(value));
    const observables = queries.map((query) => this._registerQuery(query).observable);
    let stateObservable = combineLatest(observables);
    stateObservable = concat(stateObservable.pipe(take(1)), stateObservable.pipe(skip(1), debounceTime(0)));
    return stateObservable.pipe(map((breakpointStates) => {
      const response = {
        matches: false,
        breakpoints: {}
      };
      breakpointStates.forEach(({
        matches,
        query
      }) => {
        response.matches = response.matches || matches;
        response.breakpoints[query] = matches;
      });
      return response;
    }));
  }
  /** Registers a specific query to be listened for. */
  _registerQuery(query) {
    if (this._queries.has(query)) {
      return this._queries.get(query);
    }
    const mql = this._mediaMatcher.matchMedia(query);
    const queryObservable = new Observable((observer) => {
      const handler = (e5) => this._zone.run(() => observer.next(e5));
      mql.addListener(handler);
      return () => {
        mql.removeListener(handler);
      };
    }).pipe(startWith(mql), map(({
      matches
    }) => ({
      query,
      matches
    })), takeUntil(this._destroySubject));
    const output = {
      observable: queryObservable,
      mql
    };
    this._queries.set(query, output);
    return output;
  }
};
_BreakpointObserver.ɵfac = function BreakpointObserver_Factory(t3) {
  return new (t3 || _BreakpointObserver)(ɵɵinject(MediaMatcher), ɵɵinject(NgZone));
};
_BreakpointObserver.ɵprov = ɵɵdefineInjectable({
  token: _BreakpointObserver,
  factory: _BreakpointObserver.ɵfac,
  providedIn: "root"
});
var BreakpointObserver = _BreakpointObserver;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BreakpointObserver, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: MediaMatcher
  }, {
    type: NgZone
  }], null);
})();
function splitQueries(queries) {
  return queries.map((query) => query.split(",")).reduce((a1, a22) => a1.concat(a22)).map((query) => query.trim());
}

// node_modules/@angular/cdk/fesm2022/a11y.mjs
var ID_DELIMITER = " ";
function addAriaReferencedId(el, attr, id) {
  const ids = getAriaReferenceIds(el, attr);
  id = id.trim();
  if (ids.some((existingId) => existingId.trim() === id)) {
    return;
  }
  ids.push(id);
  el.setAttribute(attr, ids.join(ID_DELIMITER));
}
function removeAriaReferencedId(el, attr, id) {
  const ids = getAriaReferenceIds(el, attr);
  id = id.trim();
  const filteredIds = ids.filter((val) => val !== id);
  if (filteredIds.length) {
    el.setAttribute(attr, filteredIds.join(ID_DELIMITER));
  } else {
    el.removeAttribute(attr);
  }
}
function getAriaReferenceIds(el, attr) {
  const attrValue = el.getAttribute(attr);
  return attrValue?.match(/\S+/g) ?? [];
}
var CDK_DESCRIBEDBY_ID_PREFIX = "cdk-describedby-message";
var CDK_DESCRIBEDBY_HOST_ATTRIBUTE = "cdk-describedby-host";
var nextId = 0;
var _AriaDescriber = class _AriaDescriber {
  constructor(_document, _platform) {
    this._platform = _platform;
    this._messageRegistry = /* @__PURE__ */ new Map();
    this._messagesContainer = null;
    this._id = `${nextId++}`;
    this._document = _document;
    this._id = inject(APP_ID) + "-" + nextId++;
  }
  describe(hostElement, message, role) {
    if (!this._canBeDescribed(hostElement, message)) {
      return;
    }
    const key = getKey(message, role);
    if (typeof message !== "string") {
      setMessageId(message, this._id);
      this._messageRegistry.set(key, {
        messageElement: message,
        referenceCount: 0
      });
    } else if (!this._messageRegistry.has(key)) {
      this._createMessageElement(message, role);
    }
    if (!this._isElementDescribedByMessage(hostElement, key)) {
      this._addMessageReference(hostElement, key);
    }
  }
  removeDescription(hostElement, message, role) {
    if (!message || !this._isElementNode(hostElement)) {
      return;
    }
    const key = getKey(message, role);
    if (this._isElementDescribedByMessage(hostElement, key)) {
      this._removeMessageReference(hostElement, key);
    }
    if (typeof message === "string") {
      const registeredMessage = this._messageRegistry.get(key);
      if (registeredMessage && registeredMessage.referenceCount === 0) {
        this._deleteMessageElement(key);
      }
    }
    if (this._messagesContainer?.childNodes.length === 0) {
      this._messagesContainer.remove();
      this._messagesContainer = null;
    }
  }
  /** Unregisters all created message elements and removes the message container. */
  ngOnDestroy() {
    const describedElements = this._document.querySelectorAll(`[${CDK_DESCRIBEDBY_HOST_ATTRIBUTE}="${this._id}"]`);
    for (let i2 = 0; i2 < describedElements.length; i2++) {
      this._removeCdkDescribedByReferenceIds(describedElements[i2]);
      describedElements[i2].removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);
    }
    this._messagesContainer?.remove();
    this._messagesContainer = null;
    this._messageRegistry.clear();
  }
  /**
   * Creates a new element in the visually hidden message container element with the message
   * as its content and adds it to the message registry.
   */
  _createMessageElement(message, role) {
    const messageElement = this._document.createElement("div");
    setMessageId(messageElement, this._id);
    messageElement.textContent = message;
    if (role) {
      messageElement.setAttribute("role", role);
    }
    this._createMessagesContainer();
    this._messagesContainer.appendChild(messageElement);
    this._messageRegistry.set(getKey(message, role), {
      messageElement,
      referenceCount: 0
    });
  }
  /** Deletes the message element from the global messages container. */
  _deleteMessageElement(key) {
    this._messageRegistry.get(key)?.messageElement?.remove();
    this._messageRegistry.delete(key);
  }
  /** Creates the global container for all aria-describedby messages. */
  _createMessagesContainer() {
    if (this._messagesContainer) {
      return;
    }
    const containerClassName = "cdk-describedby-message-container";
    const serverContainers = this._document.querySelectorAll(`.${containerClassName}[platform="server"]`);
    for (let i2 = 0; i2 < serverContainers.length; i2++) {
      serverContainers[i2].remove();
    }
    const messagesContainer = this._document.createElement("div");
    messagesContainer.style.visibility = "hidden";
    messagesContainer.classList.add(containerClassName);
    messagesContainer.classList.add("cdk-visually-hidden");
    if (this._platform && !this._platform.isBrowser) {
      messagesContainer.setAttribute("platform", "server");
    }
    this._document.body.appendChild(messagesContainer);
    this._messagesContainer = messagesContainer;
  }
  /** Removes all cdk-describedby messages that are hosted through the element. */
  _removeCdkDescribedByReferenceIds(element) {
    const originalReferenceIds = getAriaReferenceIds(element, "aria-describedby").filter((id) => id.indexOf(CDK_DESCRIBEDBY_ID_PREFIX) != 0);
    element.setAttribute("aria-describedby", originalReferenceIds.join(" "));
  }
  /**
   * Adds a message reference to the element using aria-describedby and increments the registered
   * message's reference count.
   */
  _addMessageReference(element, key) {
    const registeredMessage = this._messageRegistry.get(key);
    addAriaReferencedId(element, "aria-describedby", registeredMessage.messageElement.id);
    element.setAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE, this._id);
    registeredMessage.referenceCount++;
  }
  /**
   * Removes a message reference from the element using aria-describedby
   * and decrements the registered message's reference count.
   */
  _removeMessageReference(element, key) {
    const registeredMessage = this._messageRegistry.get(key);
    registeredMessage.referenceCount--;
    removeAriaReferencedId(element, "aria-describedby", registeredMessage.messageElement.id);
    element.removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);
  }
  /** Returns true if the element has been described by the provided message ID. */
  _isElementDescribedByMessage(element, key) {
    const referenceIds = getAriaReferenceIds(element, "aria-describedby");
    const registeredMessage = this._messageRegistry.get(key);
    const messageId = registeredMessage && registeredMessage.messageElement.id;
    return !!messageId && referenceIds.indexOf(messageId) != -1;
  }
  /** Determines whether a message can be described on a particular element. */
  _canBeDescribed(element, message) {
    if (!this._isElementNode(element)) {
      return false;
    }
    if (message && typeof message === "object") {
      return true;
    }
    const trimmedMessage = message == null ? "" : `${message}`.trim();
    const ariaLabel = element.getAttribute("aria-label");
    return trimmedMessage ? !ariaLabel || ariaLabel.trim() !== trimmedMessage : false;
  }
  /** Checks whether a node is an Element node. */
  _isElementNode(element) {
    return element.nodeType === this._document.ELEMENT_NODE;
  }
};
_AriaDescriber.ɵfac = function AriaDescriber_Factory(t3) {
  return new (t3 || _AriaDescriber)(ɵɵinject(DOCUMENT), ɵɵinject(Platform));
};
_AriaDescriber.ɵprov = ɵɵdefineInjectable({
  token: _AriaDescriber,
  factory: _AriaDescriber.ɵfac,
  providedIn: "root"
});
var AriaDescriber = _AriaDescriber;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AriaDescriber, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: Platform
  }], null);
})();
function getKey(message, role) {
  return typeof message === "string" ? `${role || ""}/${message}` : message;
}
function setMessageId(element, serviceId) {
  if (!element.id) {
    element.id = `${CDK_DESCRIBEDBY_ID_PREFIX}-${serviceId}-${nextId++}`;
  }
}
var _InteractivityChecker = class _InteractivityChecker {
  constructor(_platform) {
    this._platform = _platform;
  }
  /**
   * Gets whether an element is disabled.
   *
   * @param element Element to be checked.
   * @returns Whether the element is disabled.
   */
  isDisabled(element) {
    return element.hasAttribute("disabled");
  }
  /**
   * Gets whether an element is visible for the purposes of interactivity.
   *
   * This will capture states like `display: none` and `visibility: hidden`, but not things like
   * being clipped by an `overflow: hidden` parent or being outside the viewport.
   *
   * @returns Whether the element is visible.
   */
  isVisible(element) {
    return hasGeometry(element) && getComputedStyle(element).visibility === "visible";
  }
  /**
   * Gets whether an element can be reached via Tab key.
   * Assumes that the element has already been checked with isFocusable.
   *
   * @param element Element to be checked.
   * @returns Whether the element is tabbable.
   */
  isTabbable(element) {
    if (!this._platform.isBrowser) {
      return false;
    }
    const frameElement = getFrameElement(getWindow(element));
    if (frameElement) {
      if (getTabIndexValue(frameElement) === -1) {
        return false;
      }
      if (!this.isVisible(frameElement)) {
        return false;
      }
    }
    let nodeName = element.nodeName.toLowerCase();
    let tabIndexValue = getTabIndexValue(element);
    if (element.hasAttribute("contenteditable")) {
      return tabIndexValue !== -1;
    }
    if (nodeName === "iframe" || nodeName === "object") {
      return false;
    }
    if (this._platform.WEBKIT && this._platform.IOS && !isPotentiallyTabbableIOS(element)) {
      return false;
    }
    if (nodeName === "audio") {
      if (!element.hasAttribute("controls")) {
        return false;
      }
      return tabIndexValue !== -1;
    }
    if (nodeName === "video") {
      if (tabIndexValue === -1) {
        return false;
      }
      if (tabIndexValue !== null) {
        return true;
      }
      return this._platform.FIREFOX || element.hasAttribute("controls");
    }
    return element.tabIndex >= 0;
  }
  /**
   * Gets whether an element can be focused by the user.
   *
   * @param element Element to be checked.
   * @param config The config object with options to customize this method's behavior
   * @returns Whether the element is focusable.
   */
  isFocusable(element, config) {
    return isPotentiallyFocusable(element) && !this.isDisabled(element) && (config?.ignoreVisibility || this.isVisible(element));
  }
};
_InteractivityChecker.ɵfac = function InteractivityChecker_Factory(t3) {
  return new (t3 || _InteractivityChecker)(ɵɵinject(Platform));
};
_InteractivityChecker.ɵprov = ɵɵdefineInjectable({
  token: _InteractivityChecker,
  factory: _InteractivityChecker.ɵfac,
  providedIn: "root"
});
var InteractivityChecker = _InteractivityChecker;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(InteractivityChecker, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: Platform
  }], null);
})();
function getFrameElement(window2) {
  try {
    return window2.frameElement;
  } catch {
    return null;
  }
}
function hasGeometry(element) {
  return !!(element.offsetWidth || element.offsetHeight || typeof element.getClientRects === "function" && element.getClientRects().length);
}
function isNativeFormElement(element) {
  let nodeName = element.nodeName.toLowerCase();
  return nodeName === "input" || nodeName === "select" || nodeName === "button" || nodeName === "textarea";
}
function isHiddenInput(element) {
  return isInputElement(element) && element.type == "hidden";
}
function isAnchorWithHref(element) {
  return isAnchorElement(element) && element.hasAttribute("href");
}
function isInputElement(element) {
  return element.nodeName.toLowerCase() == "input";
}
function isAnchorElement(element) {
  return element.nodeName.toLowerCase() == "a";
}
function hasValidTabIndex(element) {
  if (!element.hasAttribute("tabindex") || element.tabIndex === void 0) {
    return false;
  }
  let tabIndex = element.getAttribute("tabindex");
  return !!(tabIndex && !isNaN(parseInt(tabIndex, 10)));
}
function getTabIndexValue(element) {
  if (!hasValidTabIndex(element)) {
    return null;
  }
  const tabIndex = parseInt(element.getAttribute("tabindex") || "", 10);
  return isNaN(tabIndex) ? -1 : tabIndex;
}
function isPotentiallyTabbableIOS(element) {
  let nodeName = element.nodeName.toLowerCase();
  let inputType = nodeName === "input" && element.type;
  return inputType === "text" || inputType === "password" || nodeName === "select" || nodeName === "textarea";
}
function isPotentiallyFocusable(element) {
  if (isHiddenInput(element)) {
    return false;
  }
  return isNativeFormElement(element) || isAnchorWithHref(element) || element.hasAttribute("contenteditable") || hasValidTabIndex(element);
}
function getWindow(node) {
  return node.ownerDocument && node.ownerDocument.defaultView || window;
}
var FocusTrap = class {
  /** Whether the focus trap is active. */
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
    if (this._startAnchor && this._endAnchor) {
      this._toggleAnchorTabIndex(value, this._startAnchor);
      this._toggleAnchorTabIndex(value, this._endAnchor);
    }
  }
  constructor(_element, _checker, _ngZone, _document, deferAnchors = false) {
    this._element = _element;
    this._checker = _checker;
    this._ngZone = _ngZone;
    this._document = _document;
    this._hasAttached = false;
    this.startAnchorListener = () => this.focusLastTabbableElement();
    this.endAnchorListener = () => this.focusFirstTabbableElement();
    this._enabled = true;
    if (!deferAnchors) {
      this.attachAnchors();
    }
  }
  /** Destroys the focus trap by cleaning up the anchors. */
  destroy() {
    const startAnchor = this._startAnchor;
    const endAnchor = this._endAnchor;
    if (startAnchor) {
      startAnchor.removeEventListener("focus", this.startAnchorListener);
      startAnchor.remove();
    }
    if (endAnchor) {
      endAnchor.removeEventListener("focus", this.endAnchorListener);
      endAnchor.remove();
    }
    this._startAnchor = this._endAnchor = null;
    this._hasAttached = false;
  }
  /**
   * Inserts the anchors into the DOM. This is usually done automatically
   * in the constructor, but can be deferred for cases like directives with `*ngIf`.
   * @returns Whether the focus trap managed to attach successfully. This may not be the case
   * if the target element isn't currently in the DOM.
   */
  attachAnchors() {
    if (this._hasAttached) {
      return true;
    }
    this._ngZone.runOutsideAngular(() => {
      if (!this._startAnchor) {
        this._startAnchor = this._createAnchor();
        this._startAnchor.addEventListener("focus", this.startAnchorListener);
      }
      if (!this._endAnchor) {
        this._endAnchor = this._createAnchor();
        this._endAnchor.addEventListener("focus", this.endAnchorListener);
      }
    });
    if (this._element.parentNode) {
      this._element.parentNode.insertBefore(this._startAnchor, this._element);
      this._element.parentNode.insertBefore(this._endAnchor, this._element.nextSibling);
      this._hasAttached = true;
    }
    return this._hasAttached;
  }
  /**
   * Waits for the zone to stabilize, then focuses the first tabbable element.
   * @returns Returns a promise that resolves with a boolean, depending
   * on whether focus was moved successfully.
   */
  focusInitialElementWhenReady(options) {
    return new Promise((resolve) => {
      this._executeOnStable(() => resolve(this.focusInitialElement(options)));
    });
  }
  /**
   * Waits for the zone to stabilize, then focuses
   * the first tabbable element within the focus trap region.
   * @returns Returns a promise that resolves with a boolean, depending
   * on whether focus was moved successfully.
   */
  focusFirstTabbableElementWhenReady(options) {
    return new Promise((resolve) => {
      this._executeOnStable(() => resolve(this.focusFirstTabbableElement(options)));
    });
  }
  /**
   * Waits for the zone to stabilize, then focuses
   * the last tabbable element within the focus trap region.
   * @returns Returns a promise that resolves with a boolean, depending
   * on whether focus was moved successfully.
   */
  focusLastTabbableElementWhenReady(options) {
    return new Promise((resolve) => {
      this._executeOnStable(() => resolve(this.focusLastTabbableElement(options)));
    });
  }
  /**
   * Get the specified boundary element of the trapped region.
   * @param bound The boundary to get (start or end of trapped region).
   * @returns The boundary element.
   */
  _getRegionBoundary(bound) {
    const markers = this._element.querySelectorAll(`[cdk-focus-region-${bound}], [cdkFocusRegion${bound}], [cdk-focus-${bound}]`);
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      for (let i2 = 0; i2 < markers.length; i2++) {
        if (markers[i2].hasAttribute(`cdk-focus-${bound}`)) {
          console.warn(`Found use of deprecated attribute 'cdk-focus-${bound}', use 'cdkFocusRegion${bound}' instead. The deprecated attribute will be removed in 8.0.0.`, markers[i2]);
        } else if (markers[i2].hasAttribute(`cdk-focus-region-${bound}`)) {
          console.warn(`Found use of deprecated attribute 'cdk-focus-region-${bound}', use 'cdkFocusRegion${bound}' instead. The deprecated attribute will be removed in 8.0.0.`, markers[i2]);
        }
      }
    }
    if (bound == "start") {
      return markers.length ? markers[0] : this._getFirstTabbableElement(this._element);
    }
    return markers.length ? markers[markers.length - 1] : this._getLastTabbableElement(this._element);
  }
  /**
   * Focuses the element that should be focused when the focus trap is initialized.
   * @returns Whether focus was moved successfully.
   */
  focusInitialElement(options) {
    const redirectToElement = this._element.querySelector(`[cdk-focus-initial], [cdkFocusInitial]`);
    if (redirectToElement) {
      if ((typeof ngDevMode === "undefined" || ngDevMode) && redirectToElement.hasAttribute(`cdk-focus-initial`)) {
        console.warn(`Found use of deprecated attribute 'cdk-focus-initial', use 'cdkFocusInitial' instead. The deprecated attribute will be removed in 8.0.0`, redirectToElement);
      }
      if ((typeof ngDevMode === "undefined" || ngDevMode) && !this._checker.isFocusable(redirectToElement)) {
        console.warn(`Element matching '[cdkFocusInitial]' is not focusable.`, redirectToElement);
      }
      if (!this._checker.isFocusable(redirectToElement)) {
        const focusableChild = this._getFirstTabbableElement(redirectToElement);
        focusableChild?.focus(options);
        return !!focusableChild;
      }
      redirectToElement.focus(options);
      return true;
    }
    return this.focusFirstTabbableElement(options);
  }
  /**
   * Focuses the first tabbable element within the focus trap region.
   * @returns Whether focus was moved successfully.
   */
  focusFirstTabbableElement(options) {
    const redirectToElement = this._getRegionBoundary("start");
    if (redirectToElement) {
      redirectToElement.focus(options);
    }
    return !!redirectToElement;
  }
  /**
   * Focuses the last tabbable element within the focus trap region.
   * @returns Whether focus was moved successfully.
   */
  focusLastTabbableElement(options) {
    const redirectToElement = this._getRegionBoundary("end");
    if (redirectToElement) {
      redirectToElement.focus(options);
    }
    return !!redirectToElement;
  }
  /**
   * Checks whether the focus trap has successfully been attached.
   */
  hasAttached() {
    return this._hasAttached;
  }
  /** Get the first tabbable element from a DOM subtree (inclusive). */
  _getFirstTabbableElement(root) {
    if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {
      return root;
    }
    const children = root.children;
    for (let i2 = 0; i2 < children.length; i2++) {
      const tabbableChild = children[i2].nodeType === this._document.ELEMENT_NODE ? this._getFirstTabbableElement(children[i2]) : null;
      if (tabbableChild) {
        return tabbableChild;
      }
    }
    return null;
  }
  /** Get the last tabbable element from a DOM subtree (inclusive). */
  _getLastTabbableElement(root) {
    if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {
      return root;
    }
    const children = root.children;
    for (let i2 = children.length - 1; i2 >= 0; i2--) {
      const tabbableChild = children[i2].nodeType === this._document.ELEMENT_NODE ? this._getLastTabbableElement(children[i2]) : null;
      if (tabbableChild) {
        return tabbableChild;
      }
    }
    return null;
  }
  /** Creates an anchor element. */
  _createAnchor() {
    const anchor = this._document.createElement("div");
    this._toggleAnchorTabIndex(this._enabled, anchor);
    anchor.classList.add("cdk-visually-hidden");
    anchor.classList.add("cdk-focus-trap-anchor");
    anchor.setAttribute("aria-hidden", "true");
    return anchor;
  }
  /**
   * Toggles the `tabindex` of an anchor, based on the enabled state of the focus trap.
   * @param isEnabled Whether the focus trap is enabled.
   * @param anchor Anchor on which to toggle the tabindex.
   */
  _toggleAnchorTabIndex(isEnabled, anchor) {
    isEnabled ? anchor.setAttribute("tabindex", "0") : anchor.removeAttribute("tabindex");
  }
  /**
   * Toggles the`tabindex` of both anchors to either trap Tab focus or allow it to escape.
   * @param enabled: Whether the anchors should trap Tab.
   */
  toggleAnchors(enabled) {
    if (this._startAnchor && this._endAnchor) {
      this._toggleAnchorTabIndex(enabled, this._startAnchor);
      this._toggleAnchorTabIndex(enabled, this._endAnchor);
    }
  }
  /** Executes a function when the zone is stable. */
  _executeOnStable(fn) {
    if (this._ngZone.isStable) {
      fn();
    } else {
      this._ngZone.onStable.pipe(take(1)).subscribe(fn);
    }
  }
};
var _FocusTrapFactory = class _FocusTrapFactory {
  constructor(_checker, _ngZone, _document) {
    this._checker = _checker;
    this._ngZone = _ngZone;
    this._document = _document;
  }
  /**
   * Creates a focus-trapped region around the given element.
   * @param element The element around which focus will be trapped.
   * @param deferCaptureElements Defers the creation of focus-capturing elements to be done
   *     manually by the user.
   * @returns The created focus trap instance.
   */
  create(element, deferCaptureElements = false) {
    return new FocusTrap(element, this._checker, this._ngZone, this._document, deferCaptureElements);
  }
};
_FocusTrapFactory.ɵfac = function FocusTrapFactory_Factory(t3) {
  return new (t3 || _FocusTrapFactory)(ɵɵinject(InteractivityChecker), ɵɵinject(NgZone), ɵɵinject(DOCUMENT));
};
_FocusTrapFactory.ɵprov = ɵɵdefineInjectable({
  token: _FocusTrapFactory,
  factory: _FocusTrapFactory.ɵfac,
  providedIn: "root"
});
var FocusTrapFactory = _FocusTrapFactory;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FocusTrapFactory, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: InteractivityChecker
  }, {
    type: NgZone
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }], null);
})();
var _CdkTrapFocus = class _CdkTrapFocus {
  /** Whether the focus trap is active. */
  get enabled() {
    return this.focusTrap?.enabled || false;
  }
  set enabled(value) {
    if (this.focusTrap) {
      this.focusTrap.enabled = value;
    }
  }
  constructor(_elementRef, _focusTrapFactory, _document) {
    this._elementRef = _elementRef;
    this._focusTrapFactory = _focusTrapFactory;
    this._previouslyFocusedElement = null;
    const platform = inject(Platform);
    if (platform.isBrowser) {
      this.focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement, true);
    }
  }
  ngOnDestroy() {
    this.focusTrap?.destroy();
    if (this._previouslyFocusedElement) {
      this._previouslyFocusedElement.focus();
      this._previouslyFocusedElement = null;
    }
  }
  ngAfterContentInit() {
    this.focusTrap?.attachAnchors();
    if (this.autoCapture) {
      this._captureFocus();
    }
  }
  ngDoCheck() {
    if (this.focusTrap && !this.focusTrap.hasAttached()) {
      this.focusTrap.attachAnchors();
    }
  }
  ngOnChanges(changes) {
    const autoCaptureChange = changes["autoCapture"];
    if (autoCaptureChange && !autoCaptureChange.firstChange && this.autoCapture && this.focusTrap?.hasAttached()) {
      this._captureFocus();
    }
  }
  _captureFocus() {
    this._previouslyFocusedElement = _getFocusedElementPierceShadowDom();
    this.focusTrap?.focusInitialElementWhenReady();
  }
};
_CdkTrapFocus.ɵfac = function CdkTrapFocus_Factory(t3) {
  return new (t3 || _CdkTrapFocus)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(FocusTrapFactory), ɵɵdirectiveInject(DOCUMENT));
};
_CdkTrapFocus.ɵdir = ɵɵdefineDirective({
  type: _CdkTrapFocus,
  selectors: [["", "cdkTrapFocus", ""]],
  inputs: {
    enabled: [InputFlags.HasDecoratorInputTransform, "cdkTrapFocus", "enabled", booleanAttribute],
    autoCapture: [InputFlags.HasDecoratorInputTransform, "cdkTrapFocusAutoCapture", "autoCapture", booleanAttribute]
  },
  exportAs: ["cdkTrapFocus"],
  standalone: true,
  features: [ɵɵInputTransformsFeature, ɵɵNgOnChangesFeature]
});
var CdkTrapFocus = _CdkTrapFocus;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkTrapFocus, [{
    type: Directive,
    args: [{
      selector: "[cdkTrapFocus]",
      exportAs: "cdkTrapFocus",
      standalone: true
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: FocusTrapFactory
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }], {
    enabled: [{
      type: Input,
      args: [{
        alias: "cdkTrapFocus",
        transform: booleanAttribute
      }]
    }],
    autoCapture: [{
      type: Input,
      args: [{
        alias: "cdkTrapFocusAutoCapture",
        transform: booleanAttribute
      }]
    }]
  });
})();
var ConfigurableFocusTrap = class extends FocusTrap {
  /** Whether the FocusTrap is enabled. */
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
    if (this._enabled) {
      this._focusTrapManager.register(this);
    } else {
      this._focusTrapManager.deregister(this);
    }
  }
  constructor(_element, _checker, _ngZone, _document, _focusTrapManager, _inertStrategy, config) {
    super(_element, _checker, _ngZone, _document, config.defer);
    this._focusTrapManager = _focusTrapManager;
    this._inertStrategy = _inertStrategy;
    this._focusTrapManager.register(this);
  }
  /** Notifies the FocusTrapManager that this FocusTrap will be destroyed. */
  destroy() {
    this._focusTrapManager.deregister(this);
    super.destroy();
  }
  /** @docs-private Implemented as part of ManagedFocusTrap. */
  _enable() {
    this._inertStrategy.preventFocus(this);
    this.toggleAnchors(true);
  }
  /** @docs-private Implemented as part of ManagedFocusTrap. */
  _disable() {
    this._inertStrategy.allowFocus(this);
    this.toggleAnchors(false);
  }
};
var FOCUS_TRAP_INERT_STRATEGY = new InjectionToken("FOCUS_TRAP_INERT_STRATEGY");
var EventListenerFocusTrapInertStrategy = class {
  constructor() {
    this._listener = null;
  }
  /** Adds a document event listener that keeps focus inside the FocusTrap. */
  preventFocus(focusTrap) {
    if (this._listener) {
      focusTrap._document.removeEventListener("focus", this._listener, true);
    }
    this._listener = (e5) => this._trapFocus(focusTrap, e5);
    focusTrap._ngZone.runOutsideAngular(() => {
      focusTrap._document.addEventListener("focus", this._listener, true);
    });
  }
  /** Removes the event listener added in preventFocus. */
  allowFocus(focusTrap) {
    if (!this._listener) {
      return;
    }
    focusTrap._document.removeEventListener("focus", this._listener, true);
    this._listener = null;
  }
  /**
   * Refocuses the first element in the FocusTrap if the focus event target was outside
   * the FocusTrap.
   *
   * This is an event listener callback. The event listener is added in runOutsideAngular,
   * so all this code runs outside Angular as well.
   */
  _trapFocus(focusTrap, event) {
    const target = event.target;
    const focusTrapRoot = focusTrap._element;
    if (target && !focusTrapRoot.contains(target) && !target.closest?.("div.cdk-overlay-pane")) {
      setTimeout(() => {
        if (focusTrap.enabled && !focusTrapRoot.contains(focusTrap._document.activeElement)) {
          focusTrap.focusFirstTabbableElement();
        }
      });
    }
  }
};
var _FocusTrapManager = class _FocusTrapManager {
  constructor() {
    this._focusTrapStack = [];
  }
  /**
   * Disables the FocusTrap at the top of the stack, and then pushes
   * the new FocusTrap onto the stack.
   */
  register(focusTrap) {
    this._focusTrapStack = this._focusTrapStack.filter((ft) => ft !== focusTrap);
    let stack = this._focusTrapStack;
    if (stack.length) {
      stack[stack.length - 1]._disable();
    }
    stack.push(focusTrap);
    focusTrap._enable();
  }
  /**
   * Removes the FocusTrap from the stack, and activates the
   * FocusTrap that is the new top of the stack.
   */
  deregister(focusTrap) {
    focusTrap._disable();
    const stack = this._focusTrapStack;
    const i2 = stack.indexOf(focusTrap);
    if (i2 !== -1) {
      stack.splice(i2, 1);
      if (stack.length) {
        stack[stack.length - 1]._enable();
      }
    }
  }
};
_FocusTrapManager.ɵfac = function FocusTrapManager_Factory(t3) {
  return new (t3 || _FocusTrapManager)();
};
_FocusTrapManager.ɵprov = ɵɵdefineInjectable({
  token: _FocusTrapManager,
  factory: _FocusTrapManager.ɵfac,
  providedIn: "root"
});
var FocusTrapManager = _FocusTrapManager;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FocusTrapManager, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var _ConfigurableFocusTrapFactory = class _ConfigurableFocusTrapFactory {
  constructor(_checker, _ngZone, _focusTrapManager, _document, _inertStrategy) {
    this._checker = _checker;
    this._ngZone = _ngZone;
    this._focusTrapManager = _focusTrapManager;
    this._document = _document;
    this._inertStrategy = _inertStrategy || new EventListenerFocusTrapInertStrategy();
  }
  create(element, config = {
    defer: false
  }) {
    let configObject;
    if (typeof config === "boolean") {
      configObject = {
        defer: config
      };
    } else {
      configObject = config;
    }
    return new ConfigurableFocusTrap(element, this._checker, this._ngZone, this._document, this._focusTrapManager, this._inertStrategy, configObject);
  }
};
_ConfigurableFocusTrapFactory.ɵfac = function ConfigurableFocusTrapFactory_Factory(t3) {
  return new (t3 || _ConfigurableFocusTrapFactory)(ɵɵinject(InteractivityChecker), ɵɵinject(NgZone), ɵɵinject(FocusTrapManager), ɵɵinject(DOCUMENT), ɵɵinject(FOCUS_TRAP_INERT_STRATEGY, 8));
};
_ConfigurableFocusTrapFactory.ɵprov = ɵɵdefineInjectable({
  token: _ConfigurableFocusTrapFactory,
  factory: _ConfigurableFocusTrapFactory.ɵfac,
  providedIn: "root"
});
var ConfigurableFocusTrapFactory = _ConfigurableFocusTrapFactory;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ConfigurableFocusTrapFactory, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: InteractivityChecker
  }, {
    type: NgZone
  }, {
    type: FocusTrapManager
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [FOCUS_TRAP_INERT_STRATEGY]
    }]
  }], null);
})();
function isFakeMousedownFromScreenReader(event) {
  return event.buttons === 0 || event.detail === 0;
}
function isFakeTouchstartFromScreenReader(event) {
  const touch = event.touches && event.touches[0] || event.changedTouches && event.changedTouches[0];
  return !!touch && touch.identifier === -1 && (touch.radiusX == null || touch.radiusX === 1) && (touch.radiusY == null || touch.radiusY === 1);
}
var INPUT_MODALITY_DETECTOR_OPTIONS = new InjectionToken("cdk-input-modality-detector-options");
var INPUT_MODALITY_DETECTOR_DEFAULT_OPTIONS = {
  ignoreKeys: [ALT, CONTROL, MAC_META, META, SHIFT]
};
var TOUCH_BUFFER_MS = 650;
var modalityEventListenerOptions = normalizePassiveListenerOptions({
  passive: true,
  capture: true
});
var _InputModalityDetector = class _InputModalityDetector {
  /** The most recently detected input modality. */
  get mostRecentModality() {
    return this._modality.value;
  }
  constructor(_platform, ngZone, document2, options) {
    this._platform = _platform;
    this._mostRecentTarget = null;
    this._modality = new BehaviorSubject(null);
    this._lastTouchMs = 0;
    this._onKeydown = (event) => {
      if (this._options?.ignoreKeys?.some((keyCode) => keyCode === event.keyCode)) {
        return;
      }
      this._modality.next("keyboard");
      this._mostRecentTarget = _getEventTarget(event);
    };
    this._onMousedown = (event) => {
      if (Date.now() - this._lastTouchMs < TOUCH_BUFFER_MS) {
        return;
      }
      this._modality.next(isFakeMousedownFromScreenReader(event) ? "keyboard" : "mouse");
      this._mostRecentTarget = _getEventTarget(event);
    };
    this._onTouchstart = (event) => {
      if (isFakeTouchstartFromScreenReader(event)) {
        this._modality.next("keyboard");
        return;
      }
      this._lastTouchMs = Date.now();
      this._modality.next("touch");
      this._mostRecentTarget = _getEventTarget(event);
    };
    this._options = __spreadValues(__spreadValues({}, INPUT_MODALITY_DETECTOR_DEFAULT_OPTIONS), options);
    this.modalityDetected = this._modality.pipe(skip(1));
    this.modalityChanged = this.modalityDetected.pipe(distinctUntilChanged());
    if (_platform.isBrowser) {
      ngZone.runOutsideAngular(() => {
        document2.addEventListener("keydown", this._onKeydown, modalityEventListenerOptions);
        document2.addEventListener("mousedown", this._onMousedown, modalityEventListenerOptions);
        document2.addEventListener("touchstart", this._onTouchstart, modalityEventListenerOptions);
      });
    }
  }
  ngOnDestroy() {
    this._modality.complete();
    if (this._platform.isBrowser) {
      document.removeEventListener("keydown", this._onKeydown, modalityEventListenerOptions);
      document.removeEventListener("mousedown", this._onMousedown, modalityEventListenerOptions);
      document.removeEventListener("touchstart", this._onTouchstart, modalityEventListenerOptions);
    }
  }
};
_InputModalityDetector.ɵfac = function InputModalityDetector_Factory(t3) {
  return new (t3 || _InputModalityDetector)(ɵɵinject(Platform), ɵɵinject(NgZone), ɵɵinject(DOCUMENT), ɵɵinject(INPUT_MODALITY_DETECTOR_OPTIONS, 8));
};
_InputModalityDetector.ɵprov = ɵɵdefineInjectable({
  token: _InputModalityDetector,
  factory: _InputModalityDetector.ɵfac,
  providedIn: "root"
});
var InputModalityDetector = _InputModalityDetector;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(InputModalityDetector, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: Platform
  }, {
    type: NgZone
  }, {
    type: Document,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [INPUT_MODALITY_DETECTOR_OPTIONS]
    }]
  }], null);
})();
var LIVE_ANNOUNCER_ELEMENT_TOKEN = new InjectionToken("liveAnnouncerElement", {
  providedIn: "root",
  factory: LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY
});
function LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY() {
  return null;
}
var LIVE_ANNOUNCER_DEFAULT_OPTIONS = new InjectionToken("LIVE_ANNOUNCER_DEFAULT_OPTIONS");
var uniqueIds = 0;
var _LiveAnnouncer = class _LiveAnnouncer {
  constructor(elementToken, _ngZone, _document, _defaultOptions) {
    this._ngZone = _ngZone;
    this._defaultOptions = _defaultOptions;
    this._document = _document;
    this._liveElement = elementToken || this._createLiveElement();
  }
  announce(message, ...args) {
    const defaultOptions = this._defaultOptions;
    let politeness;
    let duration;
    if (args.length === 1 && typeof args[0] === "number") {
      duration = args[0];
    } else {
      [politeness, duration] = args;
    }
    this.clear();
    clearTimeout(this._previousTimeout);
    if (!politeness) {
      politeness = defaultOptions && defaultOptions.politeness ? defaultOptions.politeness : "polite";
    }
    if (duration == null && defaultOptions) {
      duration = defaultOptions.duration;
    }
    this._liveElement.setAttribute("aria-live", politeness);
    if (this._liveElement.id) {
      this._exposeAnnouncerToModals(this._liveElement.id);
    }
    return this._ngZone.runOutsideAngular(() => {
      if (!this._currentPromise) {
        this._currentPromise = new Promise((resolve) => this._currentResolve = resolve);
      }
      clearTimeout(this._previousTimeout);
      this._previousTimeout = setTimeout(() => {
        this._liveElement.textContent = message;
        if (typeof duration === "number") {
          this._previousTimeout = setTimeout(() => this.clear(), duration);
        }
        this._currentResolve?.();
        this._currentPromise = this._currentResolve = void 0;
      }, 100);
      return this._currentPromise;
    });
  }
  /**
   * Clears the current text from the announcer element. Can be used to prevent
   * screen readers from reading the text out again while the user is going
   * through the page landmarks.
   */
  clear() {
    if (this._liveElement) {
      this._liveElement.textContent = "";
    }
  }
  ngOnDestroy() {
    clearTimeout(this._previousTimeout);
    this._liveElement?.remove();
    this._liveElement = null;
    this._currentResolve?.();
    this._currentPromise = this._currentResolve = void 0;
  }
  _createLiveElement() {
    const elementClass = "cdk-live-announcer-element";
    const previousElements = this._document.getElementsByClassName(elementClass);
    const liveEl = this._document.createElement("div");
    for (let i2 = 0; i2 < previousElements.length; i2++) {
      previousElements[i2].remove();
    }
    liveEl.classList.add(elementClass);
    liveEl.classList.add("cdk-visually-hidden");
    liveEl.setAttribute("aria-atomic", "true");
    liveEl.setAttribute("aria-live", "polite");
    liveEl.id = `cdk-live-announcer-${uniqueIds++}`;
    this._document.body.appendChild(liveEl);
    return liveEl;
  }
  /**
   * Some browsers won't expose the accessibility node of the live announcer element if there is an
   * `aria-modal` and the live announcer is outside of it. This method works around the issue by
   * pointing the `aria-owns` of all modals to the live announcer element.
   */
  _exposeAnnouncerToModals(id) {
    const modals = this._document.querySelectorAll('body > .cdk-overlay-container [aria-modal="true"]');
    for (let i2 = 0; i2 < modals.length; i2++) {
      const modal = modals[i2];
      const ariaOwns = modal.getAttribute("aria-owns");
      if (!ariaOwns) {
        modal.setAttribute("aria-owns", id);
      } else if (ariaOwns.indexOf(id) === -1) {
        modal.setAttribute("aria-owns", ariaOwns + " " + id);
      }
    }
  }
};
_LiveAnnouncer.ɵfac = function LiveAnnouncer_Factory(t3) {
  return new (t3 || _LiveAnnouncer)(ɵɵinject(LIVE_ANNOUNCER_ELEMENT_TOKEN, 8), ɵɵinject(NgZone), ɵɵinject(DOCUMENT), ɵɵinject(LIVE_ANNOUNCER_DEFAULT_OPTIONS, 8));
};
_LiveAnnouncer.ɵprov = ɵɵdefineInjectable({
  token: _LiveAnnouncer,
  factory: _LiveAnnouncer.ɵfac,
  providedIn: "root"
});
var LiveAnnouncer = _LiveAnnouncer;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LiveAnnouncer, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [LIVE_ANNOUNCER_ELEMENT_TOKEN]
    }]
  }, {
    type: NgZone
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [LIVE_ANNOUNCER_DEFAULT_OPTIONS]
    }]
  }], null);
})();
var _CdkAriaLive = class _CdkAriaLive {
  /** The aria-live politeness level to use when announcing messages. */
  get politeness() {
    return this._politeness;
  }
  set politeness(value) {
    this._politeness = value === "off" || value === "assertive" ? value : "polite";
    if (this._politeness === "off") {
      if (this._subscription) {
        this._subscription.unsubscribe();
        this._subscription = null;
      }
    } else if (!this._subscription) {
      this._subscription = this._ngZone.runOutsideAngular(() => {
        return this._contentObserver.observe(this._elementRef).subscribe(() => {
          const elementText = this._elementRef.nativeElement.textContent;
          if (elementText !== this._previousAnnouncedText) {
            this._liveAnnouncer.announce(elementText, this._politeness, this.duration);
            this._previousAnnouncedText = elementText;
          }
        });
      });
    }
  }
  constructor(_elementRef, _liveAnnouncer, _contentObserver, _ngZone) {
    this._elementRef = _elementRef;
    this._liveAnnouncer = _liveAnnouncer;
    this._contentObserver = _contentObserver;
    this._ngZone = _ngZone;
    this._politeness = "polite";
  }
  ngOnDestroy() {
    if (this._subscription) {
      this._subscription.unsubscribe();
    }
  }
};
_CdkAriaLive.ɵfac = function CdkAriaLive_Factory(t3) {
  return new (t3 || _CdkAriaLive)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(LiveAnnouncer), ɵɵdirectiveInject(ContentObserver), ɵɵdirectiveInject(NgZone));
};
_CdkAriaLive.ɵdir = ɵɵdefineDirective({
  type: _CdkAriaLive,
  selectors: [["", "cdkAriaLive", ""]],
  inputs: {
    politeness: [InputFlags.None, "cdkAriaLive", "politeness"],
    duration: [InputFlags.None, "cdkAriaLiveDuration", "duration"]
  },
  exportAs: ["cdkAriaLive"],
  standalone: true
});
var CdkAriaLive = _CdkAriaLive;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkAriaLive, [{
    type: Directive,
    args: [{
      selector: "[cdkAriaLive]",
      exportAs: "cdkAriaLive",
      standalone: true
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: LiveAnnouncer
  }, {
    type: ContentObserver
  }, {
    type: NgZone
  }], {
    politeness: [{
      type: Input,
      args: ["cdkAriaLive"]
    }],
    duration: [{
      type: Input,
      args: ["cdkAriaLiveDuration"]
    }]
  });
})();
var FocusMonitorDetectionMode;
(function(FocusMonitorDetectionMode2) {
  FocusMonitorDetectionMode2[FocusMonitorDetectionMode2["IMMEDIATE"] = 0] = "IMMEDIATE";
  FocusMonitorDetectionMode2[FocusMonitorDetectionMode2["EVENTUAL"] = 1] = "EVENTUAL";
})(FocusMonitorDetectionMode || (FocusMonitorDetectionMode = {}));
var FOCUS_MONITOR_DEFAULT_OPTIONS = new InjectionToken("cdk-focus-monitor-default-options");
var captureEventListenerOptions = normalizePassiveListenerOptions({
  passive: true,
  capture: true
});
var _FocusMonitor = class _FocusMonitor {
  constructor(_ngZone, _platform, _inputModalityDetector, document2, options) {
    this._ngZone = _ngZone;
    this._platform = _platform;
    this._inputModalityDetector = _inputModalityDetector;
    this._origin = null;
    this._windowFocused = false;
    this._originFromTouchInteraction = false;
    this._elementInfo = /* @__PURE__ */ new Map();
    this._monitoredElementCount = 0;
    this._rootNodeFocusListenerCount = /* @__PURE__ */ new Map();
    this._windowFocusListener = () => {
      this._windowFocused = true;
      this._windowFocusTimeoutId = window.setTimeout(() => this._windowFocused = false);
    };
    this._stopInputModalityDetector = new Subject();
    this._rootNodeFocusAndBlurListener = (event) => {
      const target = _getEventTarget(event);
      for (let element = target; element; element = element.parentElement) {
        if (event.type === "focus") {
          this._onFocus(event, element);
        } else {
          this._onBlur(event, element);
        }
      }
    };
    this._document = document2;
    this._detectionMode = options?.detectionMode || FocusMonitorDetectionMode.IMMEDIATE;
  }
  monitor(element, checkChildren = false) {
    const nativeElement = coerceElement(element);
    if (!this._platform.isBrowser || nativeElement.nodeType !== 1) {
      return of();
    }
    const rootNode = _getShadowRoot(nativeElement) || this._getDocument();
    const cachedInfo = this._elementInfo.get(nativeElement);
    if (cachedInfo) {
      if (checkChildren) {
        cachedInfo.checkChildren = true;
      }
      return cachedInfo.subject;
    }
    const info = {
      checkChildren,
      subject: new Subject(),
      rootNode
    };
    this._elementInfo.set(nativeElement, info);
    this._registerGlobalListeners(info);
    return info.subject;
  }
  stopMonitoring(element) {
    const nativeElement = coerceElement(element);
    const elementInfo = this._elementInfo.get(nativeElement);
    if (elementInfo) {
      elementInfo.subject.complete();
      this._setClasses(nativeElement);
      this._elementInfo.delete(nativeElement);
      this._removeGlobalListeners(elementInfo);
    }
  }
  focusVia(element, origin, options) {
    const nativeElement = coerceElement(element);
    const focusedElement = this._getDocument().activeElement;
    if (nativeElement === focusedElement) {
      this._getClosestElementsInfo(nativeElement).forEach(([currentElement, info]) => this._originChanged(currentElement, origin, info));
    } else {
      this._setOrigin(origin);
      if (typeof nativeElement.focus === "function") {
        nativeElement.focus(options);
      }
    }
  }
  ngOnDestroy() {
    this._elementInfo.forEach((_info, element) => this.stopMonitoring(element));
  }
  /** Access injected document if available or fallback to global document reference */
  _getDocument() {
    return this._document || document;
  }
  /** Use defaultView of injected document if available or fallback to global window reference */
  _getWindow() {
    const doc = this._getDocument();
    return doc.defaultView || window;
  }
  _getFocusOrigin(focusEventTarget) {
    if (this._origin) {
      if (this._originFromTouchInteraction) {
        return this._shouldBeAttributedToTouch(focusEventTarget) ? "touch" : "program";
      } else {
        return this._origin;
      }
    }
    if (this._windowFocused && this._lastFocusOrigin) {
      return this._lastFocusOrigin;
    }
    if (focusEventTarget && this._isLastInteractionFromInputLabel(focusEventTarget)) {
      return "mouse";
    }
    return "program";
  }
  /**
   * Returns whether the focus event should be attributed to touch. Recall that in IMMEDIATE mode, a
   * touch origin isn't immediately reset at the next tick (see _setOrigin). This means that when we
   * handle a focus event following a touch interaction, we need to determine whether (1) the focus
   * event was directly caused by the touch interaction or (2) the focus event was caused by a
   * subsequent programmatic focus call triggered by the touch interaction.
   * @param focusEventTarget The target of the focus event under examination.
   */
  _shouldBeAttributedToTouch(focusEventTarget) {
    return this._detectionMode === FocusMonitorDetectionMode.EVENTUAL || !!focusEventTarget?.contains(this._inputModalityDetector._mostRecentTarget);
  }
  /**
   * Sets the focus classes on the element based on the given focus origin.
   * @param element The element to update the classes on.
   * @param origin The focus origin.
   */
  _setClasses(element, origin) {
    element.classList.toggle("cdk-focused", !!origin);
    element.classList.toggle("cdk-touch-focused", origin === "touch");
    element.classList.toggle("cdk-keyboard-focused", origin === "keyboard");
    element.classList.toggle("cdk-mouse-focused", origin === "mouse");
    element.classList.toggle("cdk-program-focused", origin === "program");
  }
  /**
   * Updates the focus origin. If we're using immediate detection mode, we schedule an async
   * function to clear the origin at the end of a timeout. The duration of the timeout depends on
   * the origin being set.
   * @param origin The origin to set.
   * @param isFromInteraction Whether we are setting the origin from an interaction event.
   */
  _setOrigin(origin, isFromInteraction = false) {
    this._ngZone.runOutsideAngular(() => {
      this._origin = origin;
      this._originFromTouchInteraction = origin === "touch" && isFromInteraction;
      if (this._detectionMode === FocusMonitorDetectionMode.IMMEDIATE) {
        clearTimeout(this._originTimeoutId);
        const ms = this._originFromTouchInteraction ? TOUCH_BUFFER_MS : 1;
        this._originTimeoutId = setTimeout(() => this._origin = null, ms);
      }
    });
  }
  /**
   * Handles focus events on a registered element.
   * @param event The focus event.
   * @param element The monitored element.
   */
  _onFocus(event, element) {
    const elementInfo = this._elementInfo.get(element);
    const focusEventTarget = _getEventTarget(event);
    if (!elementInfo || !elementInfo.checkChildren && element !== focusEventTarget) {
      return;
    }
    this._originChanged(element, this._getFocusOrigin(focusEventTarget), elementInfo);
  }
  /**
   * Handles blur events on a registered element.
   * @param event The blur event.
   * @param element The monitored element.
   */
  _onBlur(event, element) {
    const elementInfo = this._elementInfo.get(element);
    if (!elementInfo || elementInfo.checkChildren && event.relatedTarget instanceof Node && element.contains(event.relatedTarget)) {
      return;
    }
    this._setClasses(element);
    this._emitOrigin(elementInfo, null);
  }
  _emitOrigin(info, origin) {
    if (info.subject.observers.length) {
      this._ngZone.run(() => info.subject.next(origin));
    }
  }
  _registerGlobalListeners(elementInfo) {
    if (!this._platform.isBrowser) {
      return;
    }
    const rootNode = elementInfo.rootNode;
    const rootNodeFocusListeners = this._rootNodeFocusListenerCount.get(rootNode) || 0;
    if (!rootNodeFocusListeners) {
      this._ngZone.runOutsideAngular(() => {
        rootNode.addEventListener("focus", this._rootNodeFocusAndBlurListener, captureEventListenerOptions);
        rootNode.addEventListener("blur", this._rootNodeFocusAndBlurListener, captureEventListenerOptions);
      });
    }
    this._rootNodeFocusListenerCount.set(rootNode, rootNodeFocusListeners + 1);
    if (++this._monitoredElementCount === 1) {
      this._ngZone.runOutsideAngular(() => {
        const window2 = this._getWindow();
        window2.addEventListener("focus", this._windowFocusListener);
      });
      this._inputModalityDetector.modalityDetected.pipe(takeUntil(this._stopInputModalityDetector)).subscribe((modality) => {
        this._setOrigin(
          modality,
          true
          /* isFromInteraction */
        );
      });
    }
  }
  _removeGlobalListeners(elementInfo) {
    const rootNode = elementInfo.rootNode;
    if (this._rootNodeFocusListenerCount.has(rootNode)) {
      const rootNodeFocusListeners = this._rootNodeFocusListenerCount.get(rootNode);
      if (rootNodeFocusListeners > 1) {
        this._rootNodeFocusListenerCount.set(rootNode, rootNodeFocusListeners - 1);
      } else {
        rootNode.removeEventListener("focus", this._rootNodeFocusAndBlurListener, captureEventListenerOptions);
        rootNode.removeEventListener("blur", this._rootNodeFocusAndBlurListener, captureEventListenerOptions);
        this._rootNodeFocusListenerCount.delete(rootNode);
      }
    }
    if (!--this._monitoredElementCount) {
      const window2 = this._getWindow();
      window2.removeEventListener("focus", this._windowFocusListener);
      this._stopInputModalityDetector.next();
      clearTimeout(this._windowFocusTimeoutId);
      clearTimeout(this._originTimeoutId);
    }
  }
  /** Updates all the state on an element once its focus origin has changed. */
  _originChanged(element, origin, elementInfo) {
    this._setClasses(element, origin);
    this._emitOrigin(elementInfo, origin);
    this._lastFocusOrigin = origin;
  }
  /**
   * Collects the `MonitoredElementInfo` of a particular element and
   * all of its ancestors that have enabled `checkChildren`.
   * @param element Element from which to start the search.
   */
  _getClosestElementsInfo(element) {
    const results = [];
    this._elementInfo.forEach((info, currentElement) => {
      if (currentElement === element || info.checkChildren && currentElement.contains(element)) {
        results.push([currentElement, info]);
      }
    });
    return results;
  }
  /**
   * Returns whether an interaction is likely to have come from the user clicking the `label` of
   * an `input` or `textarea` in order to focus it.
   * @param focusEventTarget Target currently receiving focus.
   */
  _isLastInteractionFromInputLabel(focusEventTarget) {
    const {
      _mostRecentTarget: mostRecentTarget,
      mostRecentModality
    } = this._inputModalityDetector;
    if (mostRecentModality !== "mouse" || !mostRecentTarget || mostRecentTarget === focusEventTarget || focusEventTarget.nodeName !== "INPUT" && focusEventTarget.nodeName !== "TEXTAREA" || focusEventTarget.disabled) {
      return false;
    }
    const labels = focusEventTarget.labels;
    if (labels) {
      for (let i2 = 0; i2 < labels.length; i2++) {
        if (labels[i2].contains(mostRecentTarget)) {
          return true;
        }
      }
    }
    return false;
  }
};
_FocusMonitor.ɵfac = function FocusMonitor_Factory(t3) {
  return new (t3 || _FocusMonitor)(ɵɵinject(NgZone), ɵɵinject(Platform), ɵɵinject(InputModalityDetector), ɵɵinject(DOCUMENT, 8), ɵɵinject(FOCUS_MONITOR_DEFAULT_OPTIONS, 8));
};
_FocusMonitor.ɵprov = ɵɵdefineInjectable({
  token: _FocusMonitor,
  factory: _FocusMonitor.ɵfac,
  providedIn: "root"
});
var FocusMonitor = _FocusMonitor;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FocusMonitor, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: NgZone
  }, {
    type: Platform
  }, {
    type: InputModalityDetector
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [FOCUS_MONITOR_DEFAULT_OPTIONS]
    }]
  }], null);
})();
var _CdkMonitorFocus = class _CdkMonitorFocus {
  constructor(_elementRef, _focusMonitor) {
    this._elementRef = _elementRef;
    this._focusMonitor = _focusMonitor;
    this._focusOrigin = null;
    this.cdkFocusChange = new EventEmitter();
  }
  get focusOrigin() {
    return this._focusOrigin;
  }
  ngAfterViewInit() {
    const element = this._elementRef.nativeElement;
    this._monitorSubscription = this._focusMonitor.monitor(element, element.nodeType === 1 && element.hasAttribute("cdkMonitorSubtreeFocus")).subscribe((origin) => {
      this._focusOrigin = origin;
      this.cdkFocusChange.emit(origin);
    });
  }
  ngOnDestroy() {
    this._focusMonitor.stopMonitoring(this._elementRef);
    if (this._monitorSubscription) {
      this._monitorSubscription.unsubscribe();
    }
  }
};
_CdkMonitorFocus.ɵfac = function CdkMonitorFocus_Factory(t3) {
  return new (t3 || _CdkMonitorFocus)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(FocusMonitor));
};
_CdkMonitorFocus.ɵdir = ɵɵdefineDirective({
  type: _CdkMonitorFocus,
  selectors: [["", "cdkMonitorElementFocus", ""], ["", "cdkMonitorSubtreeFocus", ""]],
  outputs: {
    cdkFocusChange: "cdkFocusChange"
  },
  exportAs: ["cdkMonitorFocus"],
  standalone: true
});
var CdkMonitorFocus = _CdkMonitorFocus;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkMonitorFocus, [{
    type: Directive,
    args: [{
      selector: "[cdkMonitorElementFocus], [cdkMonitorSubtreeFocus]",
      exportAs: "cdkMonitorFocus",
      standalone: true
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: FocusMonitor
  }], {
    cdkFocusChange: [{
      type: Output
    }]
  });
})();
var HighContrastMode;
(function(HighContrastMode2) {
  HighContrastMode2[HighContrastMode2["NONE"] = 0] = "NONE";
  HighContrastMode2[HighContrastMode2["BLACK_ON_WHITE"] = 1] = "BLACK_ON_WHITE";
  HighContrastMode2[HighContrastMode2["WHITE_ON_BLACK"] = 2] = "WHITE_ON_BLACK";
})(HighContrastMode || (HighContrastMode = {}));
var BLACK_ON_WHITE_CSS_CLASS = "cdk-high-contrast-black-on-white";
var WHITE_ON_BLACK_CSS_CLASS = "cdk-high-contrast-white-on-black";
var HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS = "cdk-high-contrast-active";
var _HighContrastModeDetector = class _HighContrastModeDetector {
  constructor(_platform, document2) {
    this._platform = _platform;
    this._document = document2;
    this._breakpointSubscription = inject(BreakpointObserver).observe("(forced-colors: active)").subscribe(() => {
      if (this._hasCheckedHighContrastMode) {
        this._hasCheckedHighContrastMode = false;
        this._applyBodyHighContrastModeCssClasses();
      }
    });
  }
  /** Gets the current high-contrast-mode for the page. */
  getHighContrastMode() {
    if (!this._platform.isBrowser) {
      return HighContrastMode.NONE;
    }
    const testElement = this._document.createElement("div");
    testElement.style.backgroundColor = "rgb(1,2,3)";
    testElement.style.position = "absolute";
    this._document.body.appendChild(testElement);
    const documentWindow = this._document.defaultView || window;
    const computedStyle = documentWindow && documentWindow.getComputedStyle ? documentWindow.getComputedStyle(testElement) : null;
    const computedColor = (computedStyle && computedStyle.backgroundColor || "").replace(/ /g, "");
    testElement.remove();
    switch (computedColor) {
      case "rgb(0,0,0)":
      case "rgb(45,50,54)":
      case "rgb(32,32,32)":
        return HighContrastMode.WHITE_ON_BLACK;
      case "rgb(255,255,255)":
      case "rgb(255,250,239)":
        return HighContrastMode.BLACK_ON_WHITE;
    }
    return HighContrastMode.NONE;
  }
  ngOnDestroy() {
    this._breakpointSubscription.unsubscribe();
  }
  /** Applies CSS classes indicating high-contrast mode to document body (browser-only). */
  _applyBodyHighContrastModeCssClasses() {
    if (!this._hasCheckedHighContrastMode && this._platform.isBrowser && this._document.body) {
      const bodyClasses = this._document.body.classList;
      bodyClasses.remove(HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS, BLACK_ON_WHITE_CSS_CLASS, WHITE_ON_BLACK_CSS_CLASS);
      this._hasCheckedHighContrastMode = true;
      const mode = this.getHighContrastMode();
      if (mode === HighContrastMode.BLACK_ON_WHITE) {
        bodyClasses.add(HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS, BLACK_ON_WHITE_CSS_CLASS);
      } else if (mode === HighContrastMode.WHITE_ON_BLACK) {
        bodyClasses.add(HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS, WHITE_ON_BLACK_CSS_CLASS);
      }
    }
  }
};
_HighContrastModeDetector.ɵfac = function HighContrastModeDetector_Factory(t3) {
  return new (t3 || _HighContrastModeDetector)(ɵɵinject(Platform), ɵɵinject(DOCUMENT));
};
_HighContrastModeDetector.ɵprov = ɵɵdefineInjectable({
  token: _HighContrastModeDetector,
  factory: _HighContrastModeDetector.ɵfac,
  providedIn: "root"
});
var HighContrastModeDetector = _HighContrastModeDetector;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HighContrastModeDetector, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: Platform
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }], null);
})();
var _A11yModule = class _A11yModule {
  constructor(highContrastModeDetector) {
    highContrastModeDetector._applyBodyHighContrastModeCssClasses();
  }
};
_A11yModule.ɵfac = function A11yModule_Factory(t3) {
  return new (t3 || _A11yModule)(ɵɵinject(HighContrastModeDetector));
};
_A11yModule.ɵmod = ɵɵdefineNgModule({
  type: _A11yModule,
  imports: [ObserversModule, CdkAriaLive, CdkTrapFocus, CdkMonitorFocus],
  exports: [CdkAriaLive, CdkTrapFocus, CdkMonitorFocus]
});
_A11yModule.ɵinj = ɵɵdefineInjector({
  imports: [ObserversModule]
});
var A11yModule = _A11yModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(A11yModule, [{
    type: NgModule,
    args: [{
      imports: [ObserversModule, CdkAriaLive, CdkTrapFocus, CdkMonitorFocus],
      exports: [CdkAriaLive, CdkTrapFocus, CdkMonitorFocus]
    }]
  }], () => [{
    type: HighContrastModeDetector
  }], null);
})();

// node_modules/@angular/cdk/fesm2022/bidi.mjs
var DIR_DOCUMENT = new InjectionToken("cdk-dir-doc", {
  providedIn: "root",
  factory: DIR_DOCUMENT_FACTORY
});
function DIR_DOCUMENT_FACTORY() {
  return inject(DOCUMENT);
}
var RTL_LOCALE_PATTERN = /^(ar|ckb|dv|he|iw|fa|nqo|ps|sd|ug|ur|yi|.*[-_](Adlm|Arab|Hebr|Nkoo|Rohg|Thaa))(?!.*[-_](Latn|Cyrl)($|-|_))($|-|_)/i;
function _resolveDirectionality(rawValue) {
  const value = rawValue?.toLowerCase() || "";
  if (value === "auto" && typeof navigator !== "undefined" && navigator?.language) {
    return RTL_LOCALE_PATTERN.test(navigator.language) ? "rtl" : "ltr";
  }
  return value === "rtl" ? "rtl" : "ltr";
}
var _Directionality = class _Directionality {
  constructor(_document) {
    this.value = "ltr";
    this.change = new EventEmitter();
    if (_document) {
      const bodyDir = _document.body ? _document.body.dir : null;
      const htmlDir = _document.documentElement ? _document.documentElement.dir : null;
      this.value = _resolveDirectionality(bodyDir || htmlDir || "ltr");
    }
  }
  ngOnDestroy() {
    this.change.complete();
  }
};
_Directionality.ɵfac = function Directionality_Factory(t3) {
  return new (t3 || _Directionality)(ɵɵinject(DIR_DOCUMENT, 8));
};
_Directionality.ɵprov = ɵɵdefineInjectable({
  token: _Directionality,
  factory: _Directionality.ɵfac,
  providedIn: "root"
});
var Directionality = _Directionality;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Directionality, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [DIR_DOCUMENT]
    }]
  }], null);
})();
var _Dir = class _Dir {
  constructor() {
    this._dir = "ltr";
    this._isInitialized = false;
    this.change = new EventEmitter();
  }
  /** @docs-private */
  get dir() {
    return this._dir;
  }
  set dir(value) {
    const previousValue = this._dir;
    this._dir = _resolveDirectionality(value);
    this._rawDir = value;
    if (previousValue !== this._dir && this._isInitialized) {
      this.change.emit(this._dir);
    }
  }
  /** Current layout direction of the element. */
  get value() {
    return this.dir;
  }
  /** Initialize once default value has been set. */
  ngAfterContentInit() {
    this._isInitialized = true;
  }
  ngOnDestroy() {
    this.change.complete();
  }
};
_Dir.ɵfac = function Dir_Factory(t3) {
  return new (t3 || _Dir)();
};
_Dir.ɵdir = ɵɵdefineDirective({
  type: _Dir,
  selectors: [["", "dir", ""]],
  hostVars: 1,
  hostBindings: function Dir_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("dir", ctx._rawDir);
    }
  },
  inputs: {
    dir: "dir"
  },
  outputs: {
    change: "dirChange"
  },
  exportAs: ["dir"],
  standalone: true,
  features: [ɵɵProvidersFeature([{
    provide: Directionality,
    useExisting: _Dir
  }])]
});
var Dir = _Dir;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Dir, [{
    type: Directive,
    args: [{
      selector: "[dir]",
      providers: [{
        provide: Directionality,
        useExisting: Dir
      }],
      host: {
        "[attr.dir]": "_rawDir"
      },
      exportAs: "dir",
      standalone: true
    }]
  }], null, {
    change: [{
      type: Output,
      args: ["dirChange"]
    }],
    dir: [{
      type: Input
    }]
  });
})();
var _BidiModule = class _BidiModule {
};
_BidiModule.ɵfac = function BidiModule_Factory(t3) {
  return new (t3 || _BidiModule)();
};
_BidiModule.ɵmod = ɵɵdefineNgModule({
  type: _BidiModule,
  imports: [Dir],
  exports: [Dir]
});
_BidiModule.ɵinj = ɵɵdefineInjector({});
var BidiModule = _BidiModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BidiModule, [{
    type: NgModule,
    args: [{
      imports: [Dir],
      exports: [Dir]
    }]
  }], null, null);
})();

// node_modules/@angular/cdk/fesm2022/collections.mjs
var DataSource = class {
};
function isDataSource(value) {
  return value && typeof value.connect === "function" && !(value instanceof ConnectableObservable);
}
var ArrayDataSource = class extends DataSource {
  constructor(_data) {
    super();
    this._data = _data;
  }
  connect() {
    return isObservable(this._data) ? this._data : of(this._data);
  }
  disconnect() {
  }
};
var _ViewRepeaterOperation;
(function(_ViewRepeaterOperation2) {
  _ViewRepeaterOperation2[_ViewRepeaterOperation2["REPLACED"] = 0] = "REPLACED";
  _ViewRepeaterOperation2[_ViewRepeaterOperation2["INSERTED"] = 1] = "INSERTED";
  _ViewRepeaterOperation2[_ViewRepeaterOperation2["MOVED"] = 2] = "MOVED";
  _ViewRepeaterOperation2[_ViewRepeaterOperation2["REMOVED"] = 3] = "REMOVED";
})(_ViewRepeaterOperation || (_ViewRepeaterOperation = {}));
var _VIEW_REPEATER_STRATEGY = new InjectionToken("_ViewRepeater");
var _RecycleViewRepeaterStrategy = class {
  constructor() {
    this.viewCacheSize = 20;
    this._viewCache = [];
  }
  /** Apply changes to the DOM. */
  applyChanges(changes, viewContainerRef, itemContextFactory, itemValueResolver, itemViewChanged) {
    changes.forEachOperation((record, adjustedPreviousIndex, currentIndex) => {
      let view;
      let operation;
      if (record.previousIndex == null) {
        const viewArgsFactory = () => itemContextFactory(record, adjustedPreviousIndex, currentIndex);
        view = this._insertView(viewArgsFactory, currentIndex, viewContainerRef, itemValueResolver(record));
        operation = view ? _ViewRepeaterOperation.INSERTED : _ViewRepeaterOperation.REPLACED;
      } else if (currentIndex == null) {
        this._detachAndCacheView(adjustedPreviousIndex, viewContainerRef);
        operation = _ViewRepeaterOperation.REMOVED;
      } else {
        view = this._moveView(adjustedPreviousIndex, currentIndex, viewContainerRef, itemValueResolver(record));
        operation = _ViewRepeaterOperation.MOVED;
      }
      if (itemViewChanged) {
        itemViewChanged({
          context: view?.context,
          operation,
          record
        });
      }
    });
  }
  detach() {
    for (const view of this._viewCache) {
      view.destroy();
    }
    this._viewCache = [];
  }
  /**
   * Inserts a view for a new item, either from the cache or by creating a new
   * one. Returns `undefined` if the item was inserted into a cached view.
   */
  _insertView(viewArgsFactory, currentIndex, viewContainerRef, value) {
    const cachedView = this._insertViewFromCache(currentIndex, viewContainerRef);
    if (cachedView) {
      cachedView.context.$implicit = value;
      return void 0;
    }
    const viewArgs = viewArgsFactory();
    return viewContainerRef.createEmbeddedView(viewArgs.templateRef, viewArgs.context, viewArgs.index);
  }
  /** Detaches the view at the given index and inserts into the view cache. */
  _detachAndCacheView(index, viewContainerRef) {
    const detachedView = viewContainerRef.detach(index);
    this._maybeCacheView(detachedView, viewContainerRef);
  }
  /** Moves view at the previous index to the current index. */
  _moveView(adjustedPreviousIndex, currentIndex, viewContainerRef, value) {
    const view = viewContainerRef.get(adjustedPreviousIndex);
    viewContainerRef.move(view, currentIndex);
    view.context.$implicit = value;
    return view;
  }
  /**
   * Cache the given detached view. If the cache is full, the view will be
   * destroyed.
   */
  _maybeCacheView(view, viewContainerRef) {
    if (this._viewCache.length < this.viewCacheSize) {
      this._viewCache.push(view);
    } else {
      const index = viewContainerRef.indexOf(view);
      if (index === -1) {
        view.destroy();
      } else {
        viewContainerRef.remove(index);
      }
    }
  }
  /** Inserts a recycled view from the cache at the given index. */
  _insertViewFromCache(index, viewContainerRef) {
    const cachedView = this._viewCache.pop();
    if (cachedView) {
      viewContainerRef.insert(cachedView, index);
    }
    return cachedView || null;
  }
};
var _UniqueSelectionDispatcher = class _UniqueSelectionDispatcher {
  constructor() {
    this._listeners = [];
  }
  /**
   * Notify other items that selection for the given name has been set.
   * @param id ID of the item.
   * @param name Name of the item.
   */
  notify(id, name) {
    for (let listener of this._listeners) {
      listener(id, name);
    }
  }
  /**
   * Listen for future changes to item selection.
   * @return Function used to deregister listener
   */
  listen(listener) {
    this._listeners.push(listener);
    return () => {
      this._listeners = this._listeners.filter((registered) => {
        return listener !== registered;
      });
    };
  }
  ngOnDestroy() {
    this._listeners = [];
  }
};
_UniqueSelectionDispatcher.ɵfac = function UniqueSelectionDispatcher_Factory(t3) {
  return new (t3 || _UniqueSelectionDispatcher)();
};
_UniqueSelectionDispatcher.ɵprov = ɵɵdefineInjectable({
  token: _UniqueSelectionDispatcher,
  factory: _UniqueSelectionDispatcher.ɵfac,
  providedIn: "root"
});
var UniqueSelectionDispatcher = _UniqueSelectionDispatcher;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(UniqueSelectionDispatcher, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();

// node_modules/@angular/cdk/fesm2022/scrolling.mjs
var _c0 = ["contentWrapper"];
var _c1 = ["*"];
var VIRTUAL_SCROLL_STRATEGY = new InjectionToken("VIRTUAL_SCROLL_STRATEGY");
var FixedSizeVirtualScrollStrategy = class {
  /**
   * @param itemSize The size of the items in the virtually scrolling list.
   * @param minBufferPx The minimum amount of buffer (in pixels) before needing to render more
   * @param maxBufferPx The amount of buffer (in pixels) to render when rendering more.
   */
  constructor(itemSize, minBufferPx, maxBufferPx) {
    this._scrolledIndexChange = new Subject();
    this.scrolledIndexChange = this._scrolledIndexChange.pipe(distinctUntilChanged());
    this._viewport = null;
    this._itemSize = itemSize;
    this._minBufferPx = minBufferPx;
    this._maxBufferPx = maxBufferPx;
  }
  /**
   * Attaches this scroll strategy to a viewport.
   * @param viewport The viewport to attach this strategy to.
   */
  attach(viewport) {
    this._viewport = viewport;
    this._updateTotalContentSize();
    this._updateRenderedRange();
  }
  /** Detaches this scroll strategy from the currently attached viewport. */
  detach() {
    this._scrolledIndexChange.complete();
    this._viewport = null;
  }
  /**
   * Update the item size and buffer size.
   * @param itemSize The size of the items in the virtually scrolling list.
   * @param minBufferPx The minimum amount of buffer (in pixels) before needing to render more
   * @param maxBufferPx The amount of buffer (in pixels) to render when rendering more.
   */
  updateItemAndBufferSize(itemSize, minBufferPx, maxBufferPx) {
    if (maxBufferPx < minBufferPx && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw Error("CDK virtual scroll: maxBufferPx must be greater than or equal to minBufferPx");
    }
    this._itemSize = itemSize;
    this._minBufferPx = minBufferPx;
    this._maxBufferPx = maxBufferPx;
    this._updateTotalContentSize();
    this._updateRenderedRange();
  }
  /** @docs-private Implemented as part of VirtualScrollStrategy. */
  onContentScrolled() {
    this._updateRenderedRange();
  }
  /** @docs-private Implemented as part of VirtualScrollStrategy. */
  onDataLengthChanged() {
    this._updateTotalContentSize();
    this._updateRenderedRange();
  }
  /** @docs-private Implemented as part of VirtualScrollStrategy. */
  onContentRendered() {
  }
  /** @docs-private Implemented as part of VirtualScrollStrategy. */
  onRenderedOffsetChanged() {
  }
  /**
   * Scroll to the offset for the given index.
   * @param index The index of the element to scroll to.
   * @param behavior The ScrollBehavior to use when scrolling.
   */
  scrollToIndex(index, behavior) {
    if (this._viewport) {
      this._viewport.scrollToOffset(index * this._itemSize, behavior);
    }
  }
  /** Update the viewport's total content size. */
  _updateTotalContentSize() {
    if (!this._viewport) {
      return;
    }
    this._viewport.setTotalContentSize(this._viewport.getDataLength() * this._itemSize);
  }
  /** Update the viewport's rendered range. */
  _updateRenderedRange() {
    if (!this._viewport) {
      return;
    }
    const renderedRange = this._viewport.getRenderedRange();
    const newRange = {
      start: renderedRange.start,
      end: renderedRange.end
    };
    const viewportSize = this._viewport.getViewportSize();
    const dataLength = this._viewport.getDataLength();
    let scrollOffset = this._viewport.measureScrollOffset();
    let firstVisibleIndex = this._itemSize > 0 ? scrollOffset / this._itemSize : 0;
    if (newRange.end > dataLength) {
      const maxVisibleItems = Math.ceil(viewportSize / this._itemSize);
      const newVisibleIndex = Math.max(0, Math.min(firstVisibleIndex, dataLength - maxVisibleItems));
      if (firstVisibleIndex != newVisibleIndex) {
        firstVisibleIndex = newVisibleIndex;
        scrollOffset = newVisibleIndex * this._itemSize;
        newRange.start = Math.floor(firstVisibleIndex);
      }
      newRange.end = Math.max(0, Math.min(dataLength, newRange.start + maxVisibleItems));
    }
    const startBuffer = scrollOffset - newRange.start * this._itemSize;
    if (startBuffer < this._minBufferPx && newRange.start != 0) {
      const expandStart = Math.ceil((this._maxBufferPx - startBuffer) / this._itemSize);
      newRange.start = Math.max(0, newRange.start - expandStart);
      newRange.end = Math.min(dataLength, Math.ceil(firstVisibleIndex + (viewportSize + this._minBufferPx) / this._itemSize));
    } else {
      const endBuffer = newRange.end * this._itemSize - (scrollOffset + viewportSize);
      if (endBuffer < this._minBufferPx && newRange.end != dataLength) {
        const expandEnd = Math.ceil((this._maxBufferPx - endBuffer) / this._itemSize);
        if (expandEnd > 0) {
          newRange.end = Math.min(dataLength, newRange.end + expandEnd);
          newRange.start = Math.max(0, Math.floor(firstVisibleIndex - this._minBufferPx / this._itemSize));
        }
      }
    }
    this._viewport.setRenderedRange(newRange);
    this._viewport.setRenderedContentOffset(this._itemSize * newRange.start);
    this._scrolledIndexChange.next(Math.floor(firstVisibleIndex));
  }
};
function _fixedSizeVirtualScrollStrategyFactory(fixedSizeDir) {
  return fixedSizeDir._scrollStrategy;
}
var _CdkFixedSizeVirtualScroll = class _CdkFixedSizeVirtualScroll {
  constructor() {
    this._itemSize = 20;
    this._minBufferPx = 100;
    this._maxBufferPx = 200;
    this._scrollStrategy = new FixedSizeVirtualScrollStrategy(this.itemSize, this.minBufferPx, this.maxBufferPx);
  }
  /** The size of the items in the list (in pixels). */
  get itemSize() {
    return this._itemSize;
  }
  set itemSize(value) {
    this._itemSize = coerceNumberProperty(value);
  }
  /**
   * The minimum amount of buffer rendered beyond the viewport (in pixels).
   * If the amount of buffer dips below this number, more items will be rendered. Defaults to 100px.
   */
  get minBufferPx() {
    return this._minBufferPx;
  }
  set minBufferPx(value) {
    this._minBufferPx = coerceNumberProperty(value);
  }
  /**
   * The number of pixels worth of buffer to render for when rendering new items. Defaults to 200px.
   */
  get maxBufferPx() {
    return this._maxBufferPx;
  }
  set maxBufferPx(value) {
    this._maxBufferPx = coerceNumberProperty(value);
  }
  ngOnChanges() {
    this._scrollStrategy.updateItemAndBufferSize(this.itemSize, this.minBufferPx, this.maxBufferPx);
  }
};
_CdkFixedSizeVirtualScroll.ɵfac = function CdkFixedSizeVirtualScroll_Factory(t3) {
  return new (t3 || _CdkFixedSizeVirtualScroll)();
};
_CdkFixedSizeVirtualScroll.ɵdir = ɵɵdefineDirective({
  type: _CdkFixedSizeVirtualScroll,
  selectors: [["cdk-virtual-scroll-viewport", "itemSize", ""]],
  inputs: {
    itemSize: "itemSize",
    minBufferPx: "minBufferPx",
    maxBufferPx: "maxBufferPx"
  },
  standalone: true,
  features: [ɵɵProvidersFeature([{
    provide: VIRTUAL_SCROLL_STRATEGY,
    useFactory: _fixedSizeVirtualScrollStrategyFactory,
    deps: [forwardRef(() => _CdkFixedSizeVirtualScroll)]
  }]), ɵɵNgOnChangesFeature]
});
var CdkFixedSizeVirtualScroll = _CdkFixedSizeVirtualScroll;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkFixedSizeVirtualScroll, [{
    type: Directive,
    args: [{
      selector: "cdk-virtual-scroll-viewport[itemSize]",
      standalone: true,
      providers: [{
        provide: VIRTUAL_SCROLL_STRATEGY,
        useFactory: _fixedSizeVirtualScrollStrategyFactory,
        deps: [forwardRef(() => CdkFixedSizeVirtualScroll)]
      }]
    }]
  }], null, {
    itemSize: [{
      type: Input
    }],
    minBufferPx: [{
      type: Input
    }],
    maxBufferPx: [{
      type: Input
    }]
  });
})();
var DEFAULT_SCROLL_TIME = 20;
var _ScrollDispatcher = class _ScrollDispatcher {
  constructor(_ngZone, _platform, document2) {
    this._ngZone = _ngZone;
    this._platform = _platform;
    this._scrolled = new Subject();
    this._globalSubscription = null;
    this._scrolledCount = 0;
    this.scrollContainers = /* @__PURE__ */ new Map();
    this._document = document2;
  }
  /**
   * Registers a scrollable instance with the service and listens for its scrolled events. When the
   * scrollable is scrolled, the service emits the event to its scrolled observable.
   * @param scrollable Scrollable instance to be registered.
   */
  register(scrollable) {
    if (!this.scrollContainers.has(scrollable)) {
      this.scrollContainers.set(scrollable, scrollable.elementScrolled().subscribe(() => this._scrolled.next(scrollable)));
    }
  }
  /**
   * De-registers a Scrollable reference and unsubscribes from its scroll event observable.
   * @param scrollable Scrollable instance to be deregistered.
   */
  deregister(scrollable) {
    const scrollableReference = this.scrollContainers.get(scrollable);
    if (scrollableReference) {
      scrollableReference.unsubscribe();
      this.scrollContainers.delete(scrollable);
    }
  }
  /**
   * Returns an observable that emits an event whenever any of the registered Scrollable
   * references (or window, document, or body) fire a scrolled event. Can provide a time in ms
   * to override the default "throttle" time.
   *
   * **Note:** in order to avoid hitting change detection for every scroll event,
   * all of the events emitted from this stream will be run outside the Angular zone.
   * If you need to update any data bindings as a result of a scroll event, you have
   * to run the callback using `NgZone.run`.
   */
  scrolled(auditTimeInMs = DEFAULT_SCROLL_TIME) {
    if (!this._platform.isBrowser) {
      return of();
    }
    return new Observable((observer) => {
      if (!this._globalSubscription) {
        this._addGlobalListener();
      }
      const subscription = auditTimeInMs > 0 ? this._scrolled.pipe(auditTime(auditTimeInMs)).subscribe(observer) : this._scrolled.subscribe(observer);
      this._scrolledCount++;
      return () => {
        subscription.unsubscribe();
        this._scrolledCount--;
        if (!this._scrolledCount) {
          this._removeGlobalListener();
        }
      };
    });
  }
  ngOnDestroy() {
    this._removeGlobalListener();
    this.scrollContainers.forEach((_, container) => this.deregister(container));
    this._scrolled.complete();
  }
  /**
   * Returns an observable that emits whenever any of the
   * scrollable ancestors of an element are scrolled.
   * @param elementOrElementRef Element whose ancestors to listen for.
   * @param auditTimeInMs Time to throttle the scroll events.
   */
  ancestorScrolled(elementOrElementRef, auditTimeInMs) {
    const ancestors = this.getAncestorScrollContainers(elementOrElementRef);
    return this.scrolled(auditTimeInMs).pipe(filter((target) => {
      return !target || ancestors.indexOf(target) > -1;
    }));
  }
  /** Returns all registered Scrollables that contain the provided element. */
  getAncestorScrollContainers(elementOrElementRef) {
    const scrollingContainers = [];
    this.scrollContainers.forEach((_subscription, scrollable) => {
      if (this._scrollableContainsElement(scrollable, elementOrElementRef)) {
        scrollingContainers.push(scrollable);
      }
    });
    return scrollingContainers;
  }
  /** Use defaultView of injected document if available or fallback to global window reference */
  _getWindow() {
    return this._document.defaultView || window;
  }
  /** Returns true if the element is contained within the provided Scrollable. */
  _scrollableContainsElement(scrollable, elementOrElementRef) {
    let element = coerceElement(elementOrElementRef);
    let scrollableElement = scrollable.getElementRef().nativeElement;
    do {
      if (element == scrollableElement) {
        return true;
      }
    } while (element = element.parentElement);
    return false;
  }
  /** Sets up the global scroll listeners. */
  _addGlobalListener() {
    this._globalSubscription = this._ngZone.runOutsideAngular(() => {
      const window2 = this._getWindow();
      return fromEvent(window2.document, "scroll").subscribe(() => this._scrolled.next());
    });
  }
  /** Cleans up the global scroll listener. */
  _removeGlobalListener() {
    if (this._globalSubscription) {
      this._globalSubscription.unsubscribe();
      this._globalSubscription = null;
    }
  }
};
_ScrollDispatcher.ɵfac = function ScrollDispatcher_Factory(t3) {
  return new (t3 || _ScrollDispatcher)(ɵɵinject(NgZone), ɵɵinject(Platform), ɵɵinject(DOCUMENT, 8));
};
_ScrollDispatcher.ɵprov = ɵɵdefineInjectable({
  token: _ScrollDispatcher,
  factory: _ScrollDispatcher.ɵfac,
  providedIn: "root"
});
var ScrollDispatcher = _ScrollDispatcher;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ScrollDispatcher, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: NgZone
  }, {
    type: Platform
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [DOCUMENT]
    }]
  }], null);
})();
var _CdkScrollable = class _CdkScrollable {
  constructor(elementRef, scrollDispatcher, ngZone, dir) {
    this.elementRef = elementRef;
    this.scrollDispatcher = scrollDispatcher;
    this.ngZone = ngZone;
    this.dir = dir;
    this._destroyed = new Subject();
    this._elementScrolled = new Observable((observer) => this.ngZone.runOutsideAngular(() => fromEvent(this.elementRef.nativeElement, "scroll").pipe(takeUntil(this._destroyed)).subscribe(observer)));
  }
  ngOnInit() {
    this.scrollDispatcher.register(this);
  }
  ngOnDestroy() {
    this.scrollDispatcher.deregister(this);
    this._destroyed.next();
    this._destroyed.complete();
  }
  /** Returns observable that emits when a scroll event is fired on the host element. */
  elementScrolled() {
    return this._elementScrolled;
  }
  /** Gets the ElementRef for the viewport. */
  getElementRef() {
    return this.elementRef;
  }
  /**
   * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo
   * method, since browsers are not consistent about what scrollLeft means in RTL. For this method
   * left and right always refer to the left and right side of the scrolling container irrespective
   * of the layout direction. start and end refer to left and right in an LTR context and vice-versa
   * in an RTL context.
   * @param options specified the offsets to scroll to.
   */
  scrollTo(options) {
    const el = this.elementRef.nativeElement;
    const isRtl = this.dir && this.dir.value == "rtl";
    if (options.left == null) {
      options.left = isRtl ? options.end : options.start;
    }
    if (options.right == null) {
      options.right = isRtl ? options.start : options.end;
    }
    if (options.bottom != null) {
      options.top = el.scrollHeight - el.clientHeight - options.bottom;
    }
    if (isRtl && getRtlScrollAxisType() != RtlScrollAxisType.NORMAL) {
      if (options.left != null) {
        options.right = el.scrollWidth - el.clientWidth - options.left;
      }
      if (getRtlScrollAxisType() == RtlScrollAxisType.INVERTED) {
        options.left = options.right;
      } else if (getRtlScrollAxisType() == RtlScrollAxisType.NEGATED) {
        options.left = options.right ? -options.right : options.right;
      }
    } else {
      if (options.right != null) {
        options.left = el.scrollWidth - el.clientWidth - options.right;
      }
    }
    this._applyScrollToOptions(options);
  }
  _applyScrollToOptions(options) {
    const el = this.elementRef.nativeElement;
    if (supportsScrollBehavior()) {
      el.scrollTo(options);
    } else {
      if (options.top != null) {
        el.scrollTop = options.top;
      }
      if (options.left != null) {
        el.scrollLeft = options.left;
      }
    }
  }
  /**
   * Measures the scroll offset relative to the specified edge of the viewport. This method can be
   * used instead of directly checking scrollLeft or scrollTop, since browsers are not consistent
   * about what scrollLeft means in RTL. The values returned by this method are normalized such that
   * left and right always refer to the left and right side of the scrolling container irrespective
   * of the layout direction. start and end refer to left and right in an LTR context and vice-versa
   * in an RTL context.
   * @param from The edge to measure from.
   */
  measureScrollOffset(from) {
    const LEFT = "left";
    const RIGHT = "right";
    const el = this.elementRef.nativeElement;
    if (from == "top") {
      return el.scrollTop;
    }
    if (from == "bottom") {
      return el.scrollHeight - el.clientHeight - el.scrollTop;
    }
    const isRtl = this.dir && this.dir.value == "rtl";
    if (from == "start") {
      from = isRtl ? RIGHT : LEFT;
    } else if (from == "end") {
      from = isRtl ? LEFT : RIGHT;
    }
    if (isRtl && getRtlScrollAxisType() == RtlScrollAxisType.INVERTED) {
      if (from == LEFT) {
        return el.scrollWidth - el.clientWidth - el.scrollLeft;
      } else {
        return el.scrollLeft;
      }
    } else if (isRtl && getRtlScrollAxisType() == RtlScrollAxisType.NEGATED) {
      if (from == LEFT) {
        return el.scrollLeft + el.scrollWidth - el.clientWidth;
      } else {
        return -el.scrollLeft;
      }
    } else {
      if (from == LEFT) {
        return el.scrollLeft;
      } else {
        return el.scrollWidth - el.clientWidth - el.scrollLeft;
      }
    }
  }
};
_CdkScrollable.ɵfac = function CdkScrollable_Factory(t3) {
  return new (t3 || _CdkScrollable)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ScrollDispatcher), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Directionality, 8));
};
_CdkScrollable.ɵdir = ɵɵdefineDirective({
  type: _CdkScrollable,
  selectors: [["", "cdk-scrollable", ""], ["", "cdkScrollable", ""]],
  standalone: true
});
var CdkScrollable = _CdkScrollable;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkScrollable, [{
    type: Directive,
    args: [{
      selector: "[cdk-scrollable], [cdkScrollable]",
      standalone: true
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: ScrollDispatcher
  }, {
    type: NgZone
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
var DEFAULT_RESIZE_TIME = 20;
var _ViewportRuler = class _ViewportRuler {
  constructor(_platform, ngZone, document2) {
    this._platform = _platform;
    this._change = new Subject();
    this._changeListener = (event) => {
      this._change.next(event);
    };
    this._document = document2;
    ngZone.runOutsideAngular(() => {
      if (_platform.isBrowser) {
        const window2 = this._getWindow();
        window2.addEventListener("resize", this._changeListener);
        window2.addEventListener("orientationchange", this._changeListener);
      }
      this.change().subscribe(() => this._viewportSize = null);
    });
  }
  ngOnDestroy() {
    if (this._platform.isBrowser) {
      const window2 = this._getWindow();
      window2.removeEventListener("resize", this._changeListener);
      window2.removeEventListener("orientationchange", this._changeListener);
    }
    this._change.complete();
  }
  /** Returns the viewport's width and height. */
  getViewportSize() {
    if (!this._viewportSize) {
      this._updateViewportSize();
    }
    const output = {
      width: this._viewportSize.width,
      height: this._viewportSize.height
    };
    if (!this._platform.isBrowser) {
      this._viewportSize = null;
    }
    return output;
  }
  /** Gets a DOMRect for the viewport's bounds. */
  getViewportRect() {
    const scrollPosition = this.getViewportScrollPosition();
    const {
      width,
      height
    } = this.getViewportSize();
    return {
      top: scrollPosition.top,
      left: scrollPosition.left,
      bottom: scrollPosition.top + height,
      right: scrollPosition.left + width,
      height,
      width
    };
  }
  /** Gets the (top, left) scroll position of the viewport. */
  getViewportScrollPosition() {
    if (!this._platform.isBrowser) {
      return {
        top: 0,
        left: 0
      };
    }
    const document2 = this._document;
    const window2 = this._getWindow();
    const documentElement = document2.documentElement;
    const documentRect = documentElement.getBoundingClientRect();
    const top = -documentRect.top || document2.body.scrollTop || window2.scrollY || documentElement.scrollTop || 0;
    const left = -documentRect.left || document2.body.scrollLeft || window2.scrollX || documentElement.scrollLeft || 0;
    return {
      top,
      left
    };
  }
  /**
   * Returns a stream that emits whenever the size of the viewport changes.
   * This stream emits outside of the Angular zone.
   * @param throttleTime Time in milliseconds to throttle the stream.
   */
  change(throttleTime = DEFAULT_RESIZE_TIME) {
    return throttleTime > 0 ? this._change.pipe(auditTime(throttleTime)) : this._change;
  }
  /** Use defaultView of injected document if available or fallback to global window reference */
  _getWindow() {
    return this._document.defaultView || window;
  }
  /** Updates the cached viewport size. */
  _updateViewportSize() {
    const window2 = this._getWindow();
    this._viewportSize = this._platform.isBrowser ? {
      width: window2.innerWidth,
      height: window2.innerHeight
    } : {
      width: 0,
      height: 0
    };
  }
};
_ViewportRuler.ɵfac = function ViewportRuler_Factory(t3) {
  return new (t3 || _ViewportRuler)(ɵɵinject(Platform), ɵɵinject(NgZone), ɵɵinject(DOCUMENT, 8));
};
_ViewportRuler.ɵprov = ɵɵdefineInjectable({
  token: _ViewportRuler,
  factory: _ViewportRuler.ɵfac,
  providedIn: "root"
});
var ViewportRuler = _ViewportRuler;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ViewportRuler, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: Platform
  }, {
    type: NgZone
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [DOCUMENT]
    }]
  }], null);
})();
var VIRTUAL_SCROLLABLE = new InjectionToken("VIRTUAL_SCROLLABLE");
var _CdkVirtualScrollable = class _CdkVirtualScrollable extends CdkScrollable {
  constructor(elementRef, scrollDispatcher, ngZone, dir) {
    super(elementRef, scrollDispatcher, ngZone, dir);
  }
  /**
   * Measure the viewport size for the provided orientation.
   *
   * @param orientation The orientation to measure the size from.
   */
  measureViewportSize(orientation) {
    const viewportEl = this.elementRef.nativeElement;
    return orientation === "horizontal" ? viewportEl.clientWidth : viewportEl.clientHeight;
  }
};
_CdkVirtualScrollable.ɵfac = function CdkVirtualScrollable_Factory(t3) {
  return new (t3 || _CdkVirtualScrollable)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ScrollDispatcher), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Directionality, 8));
};
_CdkVirtualScrollable.ɵdir = ɵɵdefineDirective({
  type: _CdkVirtualScrollable,
  features: [ɵɵInheritDefinitionFeature]
});
var CdkVirtualScrollable = _CdkVirtualScrollable;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkVirtualScrollable, [{
    type: Directive
  }], () => [{
    type: ElementRef
  }, {
    type: ScrollDispatcher
  }, {
    type: NgZone
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
function rangesEqual(r1, r22) {
  return r1.start == r22.start && r1.end == r22.end;
}
var SCROLL_SCHEDULER = typeof requestAnimationFrame !== "undefined" ? animationFrameScheduler : asapScheduler;
var _CdkVirtualScrollViewport = class _CdkVirtualScrollViewport extends CdkVirtualScrollable {
  /** The direction the viewport scrolls. */
  get orientation() {
    return this._orientation;
  }
  set orientation(orientation) {
    if (this._orientation !== orientation) {
      this._orientation = orientation;
      this._calculateSpacerSize();
    }
  }
  constructor(elementRef, _changeDetectorRef, ngZone, _scrollStrategy, dir, scrollDispatcher, viewportRuler, scrollable) {
    super(elementRef, scrollDispatcher, ngZone, dir);
    this.elementRef = elementRef;
    this._changeDetectorRef = _changeDetectorRef;
    this._scrollStrategy = _scrollStrategy;
    this.scrollable = scrollable;
    this._platform = inject(Platform);
    this._detachedSubject = new Subject();
    this._renderedRangeSubject = new Subject();
    this._orientation = "vertical";
    this.appendOnly = false;
    this.scrolledIndexChange = new Observable((observer) => this._scrollStrategy.scrolledIndexChange.subscribe((index) => Promise.resolve().then(() => this.ngZone.run(() => observer.next(index)))));
    this.renderedRangeStream = this._renderedRangeSubject;
    this._totalContentSize = 0;
    this._totalContentWidth = "";
    this._totalContentHeight = "";
    this._renderedRange = {
      start: 0,
      end: 0
    };
    this._dataLength = 0;
    this._viewportSize = 0;
    this._renderedContentOffset = 0;
    this._renderedContentOffsetNeedsRewrite = false;
    this._isChangeDetectionPending = false;
    this._runAfterChangeDetection = [];
    this._viewportChanges = Subscription.EMPTY;
    if (!_scrollStrategy && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw Error('Error: cdk-virtual-scroll-viewport requires the "itemSize" property to be set.');
    }
    this._viewportChanges = viewportRuler.change().subscribe(() => {
      this.checkViewportSize();
    });
    if (!this.scrollable) {
      this.elementRef.nativeElement.classList.add("cdk-virtual-scrollable");
      this.scrollable = this;
    }
  }
  ngOnInit() {
    if (!this._platform.isBrowser) {
      return;
    }
    if (this.scrollable === this) {
      super.ngOnInit();
    }
    this.ngZone.runOutsideAngular(() => Promise.resolve().then(() => {
      this._measureViewportSize();
      this._scrollStrategy.attach(this);
      this.scrollable.elementScrolled().pipe(
        // Start off with a fake scroll event so we properly detect our initial position.
        startWith(null),
        // Collect multiple events into one until the next animation frame. This way if
        // there are multiple scroll events in the same frame we only need to recheck
        // our layout once.
        auditTime(0, SCROLL_SCHEDULER),
        // Usually `elementScrolled` is completed when the scrollable is destroyed, but
        // that may not be the case if a `CdkVirtualScrollableElement` is used so we have
        // to unsubscribe here just in case.
        takeUntil(this._destroyed)
      ).subscribe(() => this._scrollStrategy.onContentScrolled());
      this._markChangeDetectionNeeded();
    }));
  }
  ngOnDestroy() {
    this.detach();
    this._scrollStrategy.detach();
    this._renderedRangeSubject.complete();
    this._detachedSubject.complete();
    this._viewportChanges.unsubscribe();
    super.ngOnDestroy();
  }
  /** Attaches a `CdkVirtualScrollRepeater` to this viewport. */
  attach(forOf) {
    if (this._forOf && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw Error("CdkVirtualScrollViewport is already attached.");
    }
    this.ngZone.runOutsideAngular(() => {
      this._forOf = forOf;
      this._forOf.dataStream.pipe(takeUntil(this._detachedSubject)).subscribe((data) => {
        const newLength = data.length;
        if (newLength !== this._dataLength) {
          this._dataLength = newLength;
          this._scrollStrategy.onDataLengthChanged();
        }
        this._doChangeDetection();
      });
    });
  }
  /** Detaches the current `CdkVirtualForOf`. */
  detach() {
    this._forOf = null;
    this._detachedSubject.next();
  }
  /** Gets the length of the data bound to this viewport (in number of items). */
  getDataLength() {
    return this._dataLength;
  }
  /** Gets the size of the viewport (in pixels). */
  getViewportSize() {
    return this._viewportSize;
  }
  // TODO(mmalerba): This is technically out of sync with what's really rendered until a render
  // cycle happens. I'm being careful to only call it after the render cycle is complete and before
  // setting it to something else, but its error prone and should probably be split into
  // `pendingRange` and `renderedRange`, the latter reflecting whats actually in the DOM.
  /** Get the current rendered range of items. */
  getRenderedRange() {
    return this._renderedRange;
  }
  measureBoundingClientRectWithScrollOffset(from) {
    return this.getElementRef().nativeElement.getBoundingClientRect()[from];
  }
  /**
   * Sets the total size of all content (in pixels), including content that is not currently
   * rendered.
   */
  setTotalContentSize(size) {
    if (this._totalContentSize !== size) {
      this._totalContentSize = size;
      this._calculateSpacerSize();
      this._markChangeDetectionNeeded();
    }
  }
  /** Sets the currently rendered range of indices. */
  setRenderedRange(range) {
    if (!rangesEqual(this._renderedRange, range)) {
      if (this.appendOnly) {
        range = {
          start: 0,
          end: Math.max(this._renderedRange.end, range.end)
        };
      }
      this._renderedRangeSubject.next(this._renderedRange = range);
      this._markChangeDetectionNeeded(() => this._scrollStrategy.onContentRendered());
    }
  }
  /**
   * Gets the offset from the start of the viewport to the start of the rendered data (in pixels).
   */
  getOffsetToRenderedContentStart() {
    return this._renderedContentOffsetNeedsRewrite ? null : this._renderedContentOffset;
  }
  /**
   * Sets the offset from the start of the viewport to either the start or end of the rendered data
   * (in pixels).
   */
  setRenderedContentOffset(offset, to = "to-start") {
    offset = this.appendOnly && to === "to-start" ? 0 : offset;
    const isRtl = this.dir && this.dir.value == "rtl";
    const isHorizontal = this.orientation == "horizontal";
    const axis = isHorizontal ? "X" : "Y";
    const axisDirection = isHorizontal && isRtl ? -1 : 1;
    let transform = `translate${axis}(${Number(axisDirection * offset)}px)`;
    this._renderedContentOffset = offset;
    if (to === "to-end") {
      transform += ` translate${axis}(-100%)`;
      this._renderedContentOffsetNeedsRewrite = true;
    }
    if (this._renderedContentTransform != transform) {
      this._renderedContentTransform = transform;
      this._markChangeDetectionNeeded(() => {
        if (this._renderedContentOffsetNeedsRewrite) {
          this._renderedContentOffset -= this.measureRenderedContentSize();
          this._renderedContentOffsetNeedsRewrite = false;
          this.setRenderedContentOffset(this._renderedContentOffset);
        } else {
          this._scrollStrategy.onRenderedOffsetChanged();
        }
      });
    }
  }
  /**
   * Scrolls to the given offset from the start of the viewport. Please note that this is not always
   * the same as setting `scrollTop` or `scrollLeft`. In a horizontal viewport with right-to-left
   * direction, this would be the equivalent of setting a fictional `scrollRight` property.
   * @param offset The offset to scroll to.
   * @param behavior The ScrollBehavior to use when scrolling. Default is behavior is `auto`.
   */
  scrollToOffset(offset, behavior = "auto") {
    const options = {
      behavior
    };
    if (this.orientation === "horizontal") {
      options.start = offset;
    } else {
      options.top = offset;
    }
    this.scrollable.scrollTo(options);
  }
  /**
   * Scrolls to the offset for the given index.
   * @param index The index of the element to scroll to.
   * @param behavior The ScrollBehavior to use when scrolling. Default is behavior is `auto`.
   */
  scrollToIndex(index, behavior = "auto") {
    this._scrollStrategy.scrollToIndex(index, behavior);
  }
  /**
   * Gets the current scroll offset from the start of the scrollable (in pixels).
   * @param from The edge to measure the offset from. Defaults to 'top' in vertical mode and 'start'
   *     in horizontal mode.
   */
  measureScrollOffset(from) {
    let measureScrollOffset;
    if (this.scrollable == this) {
      measureScrollOffset = (_from) => super.measureScrollOffset(_from);
    } else {
      measureScrollOffset = (_from) => this.scrollable.measureScrollOffset(_from);
    }
    return Math.max(0, measureScrollOffset(from ?? (this.orientation === "horizontal" ? "start" : "top")) - this.measureViewportOffset());
  }
  /**
   * Measures the offset of the viewport from the scrolling container
   * @param from The edge to measure from.
   */
  measureViewportOffset(from) {
    let fromRect;
    const LEFT = "left";
    const RIGHT = "right";
    const isRtl = this.dir?.value == "rtl";
    if (from == "start") {
      fromRect = isRtl ? RIGHT : LEFT;
    } else if (from == "end") {
      fromRect = isRtl ? LEFT : RIGHT;
    } else if (from) {
      fromRect = from;
    } else {
      fromRect = this.orientation === "horizontal" ? "left" : "top";
    }
    const scrollerClientRect = this.scrollable.measureBoundingClientRectWithScrollOffset(fromRect);
    const viewportClientRect = this.elementRef.nativeElement.getBoundingClientRect()[fromRect];
    return viewportClientRect - scrollerClientRect;
  }
  /** Measure the combined size of all of the rendered items. */
  measureRenderedContentSize() {
    const contentEl = this._contentWrapper.nativeElement;
    return this.orientation === "horizontal" ? contentEl.offsetWidth : contentEl.offsetHeight;
  }
  /**
   * Measure the total combined size of the given range. Throws if the range includes items that are
   * not rendered.
   */
  measureRangeSize(range) {
    if (!this._forOf) {
      return 0;
    }
    return this._forOf.measureRangeSize(range, this.orientation);
  }
  /** Update the viewport dimensions and re-render. */
  checkViewportSize() {
    this._measureViewportSize();
    this._scrollStrategy.onDataLengthChanged();
  }
  /** Measure the viewport size. */
  _measureViewportSize() {
    this._viewportSize = this.scrollable.measureViewportSize(this.orientation);
  }
  /** Queue up change detection to run. */
  _markChangeDetectionNeeded(runAfter) {
    if (runAfter) {
      this._runAfterChangeDetection.push(runAfter);
    }
    if (!this._isChangeDetectionPending) {
      this._isChangeDetectionPending = true;
      this.ngZone.runOutsideAngular(() => Promise.resolve().then(() => {
        this._doChangeDetection();
      }));
    }
  }
  /** Run change detection. */
  _doChangeDetection() {
    this._isChangeDetectionPending = false;
    this._contentWrapper.nativeElement.style.transform = this._renderedContentTransform;
    this.ngZone.run(() => this._changeDetectorRef.markForCheck());
    const runAfterChangeDetection = this._runAfterChangeDetection;
    this._runAfterChangeDetection = [];
    for (const fn of runAfterChangeDetection) {
      fn();
    }
  }
  /** Calculates the `style.width` and `style.height` for the spacer element. */
  _calculateSpacerSize() {
    this._totalContentHeight = this.orientation === "horizontal" ? "" : `${this._totalContentSize}px`;
    this._totalContentWidth = this.orientation === "horizontal" ? `${this._totalContentSize}px` : "";
  }
};
_CdkVirtualScrollViewport.ɵfac = function CdkVirtualScrollViewport_Factory(t3) {
  return new (t3 || _CdkVirtualScrollViewport)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(VIRTUAL_SCROLL_STRATEGY, 8), ɵɵdirectiveInject(Directionality, 8), ɵɵdirectiveInject(ScrollDispatcher), ɵɵdirectiveInject(ViewportRuler), ɵɵdirectiveInject(VIRTUAL_SCROLLABLE, 8));
};
_CdkVirtualScrollViewport.ɵcmp = ɵɵdefineComponent({
  type: _CdkVirtualScrollViewport,
  selectors: [["cdk-virtual-scroll-viewport"]],
  viewQuery: function CdkVirtualScrollViewport_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._contentWrapper = _t.first);
    }
  },
  hostAttrs: [1, "cdk-virtual-scroll-viewport"],
  hostVars: 4,
  hostBindings: function CdkVirtualScrollViewport_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("cdk-virtual-scroll-orientation-horizontal", ctx.orientation === "horizontal")("cdk-virtual-scroll-orientation-vertical", ctx.orientation !== "horizontal");
    }
  },
  inputs: {
    orientation: "orientation",
    appendOnly: [InputFlags.HasDecoratorInputTransform, "appendOnly", "appendOnly", booleanAttribute]
  },
  outputs: {
    scrolledIndexChange: "scrolledIndexChange"
  },
  standalone: true,
  features: [ɵɵProvidersFeature([{
    provide: CdkScrollable,
    useFactory: (virtualScrollable, viewport) => virtualScrollable || viewport,
    deps: [[new Optional(), new Inject(VIRTUAL_SCROLLABLE)], _CdkVirtualScrollViewport]
  }]), ɵɵInputTransformsFeature, ɵɵInheritDefinitionFeature, ɵɵStandaloneFeature],
  ngContentSelectors: _c1,
  decls: 4,
  vars: 4,
  consts: [["contentWrapper", ""], [1, "cdk-virtual-scroll-content-wrapper"], [1, "cdk-virtual-scroll-spacer"]],
  template: function CdkVirtualScrollViewport_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "div", 1, 0);
      ɵɵprojection(2);
      ɵɵelementEnd();
      ɵɵelement(3, "div", 2);
    }
    if (rf & 2) {
      ɵɵadvance(3);
      ɵɵstyleProp("width", ctx._totalContentWidth)("height", ctx._totalContentHeight);
    }
  },
  styles: ["cdk-virtual-scroll-viewport{display:block;position:relative;transform:translateZ(0)}.cdk-virtual-scrollable{overflow:auto;will-change:scroll-position;contain:strict;-webkit-overflow-scrolling:touch}.cdk-virtual-scroll-content-wrapper{position:absolute;top:0;left:0;contain:content}[dir=rtl] .cdk-virtual-scroll-content-wrapper{right:0;left:auto}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper{min-height:100%}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-left:0;padding-right:0;margin-left:0;margin-right:0;border-left-width:0;border-right-width:0;outline:none}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper{min-width:100%}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-top:0;padding-bottom:0;margin-top:0;margin-bottom:0;border-top-width:0;border-bottom-width:0;outline:none}.cdk-virtual-scroll-spacer{height:1px;transform-origin:0 0;flex:0 0 auto}[dir=rtl] .cdk-virtual-scroll-spacer{transform-origin:100% 0}"],
  encapsulation: 2,
  changeDetection: 0
});
var CdkVirtualScrollViewport = _CdkVirtualScrollViewport;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkVirtualScrollViewport, [{
    type: Component,
    args: [{
      selector: "cdk-virtual-scroll-viewport",
      host: {
        "class": "cdk-virtual-scroll-viewport",
        "[class.cdk-virtual-scroll-orientation-horizontal]": 'orientation === "horizontal"',
        "[class.cdk-virtual-scroll-orientation-vertical]": 'orientation !== "horizontal"'
      },
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: true,
      providers: [{
        provide: CdkScrollable,
        useFactory: (virtualScrollable, viewport) => virtualScrollable || viewport,
        deps: [[new Optional(), new Inject(VIRTUAL_SCROLLABLE)], CdkVirtualScrollViewport]
      }],
      template: '<!--\n  Wrap the rendered content in an element that will be used to offset it based on the scroll\n  position.\n-->\n<div #contentWrapper class="cdk-virtual-scroll-content-wrapper">\n  <ng-content></ng-content>\n</div>\n<!--\n  Spacer used to force the scrolling container to the correct size for the *total* number of items\n  so that the scrollbar captures the size of the entire data set.\n-->\n<div class="cdk-virtual-scroll-spacer"\n     [style.width]="_totalContentWidth" [style.height]="_totalContentHeight"></div>\n',
      styles: ["cdk-virtual-scroll-viewport{display:block;position:relative;transform:translateZ(0)}.cdk-virtual-scrollable{overflow:auto;will-change:scroll-position;contain:strict;-webkit-overflow-scrolling:touch}.cdk-virtual-scroll-content-wrapper{position:absolute;top:0;left:0;contain:content}[dir=rtl] .cdk-virtual-scroll-content-wrapper{right:0;left:auto}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper{min-height:100%}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-left:0;padding-right:0;margin-left:0;margin-right:0;border-left-width:0;border-right-width:0;outline:none}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper{min-width:100%}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-top:0;padding-bottom:0;margin-top:0;margin-bottom:0;border-top-width:0;border-bottom-width:0;outline:none}.cdk-virtual-scroll-spacer{height:1px;transform-origin:0 0;flex:0 0 auto}[dir=rtl] .cdk-virtual-scroll-spacer{transform-origin:100% 0}"]
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: ChangeDetectorRef
  }, {
    type: NgZone
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [VIRTUAL_SCROLL_STRATEGY]
    }]
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }, {
    type: ScrollDispatcher
  }, {
    type: ViewportRuler
  }, {
    type: CdkVirtualScrollable,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [VIRTUAL_SCROLLABLE]
    }]
  }], {
    orientation: [{
      type: Input
    }],
    appendOnly: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    scrolledIndexChange: [{
      type: Output
    }],
    _contentWrapper: [{
      type: ViewChild,
      args: ["contentWrapper", {
        static: true
      }]
    }]
  });
})();
function getOffset(orientation, direction, node) {
  const el = node;
  if (!el.getBoundingClientRect) {
    return 0;
  }
  const rect = el.getBoundingClientRect();
  if (orientation === "horizontal") {
    return direction === "start" ? rect.left : rect.right;
  }
  return direction === "start" ? rect.top : rect.bottom;
}
var _CdkVirtualForOf = class _CdkVirtualForOf {
  /** The DataSource to display. */
  get cdkVirtualForOf() {
    return this._cdkVirtualForOf;
  }
  set cdkVirtualForOf(value) {
    this._cdkVirtualForOf = value;
    if (isDataSource(value)) {
      this._dataSourceChanges.next(value);
    } else {
      this._dataSourceChanges.next(new ArrayDataSource(isObservable(value) ? value : Array.from(value || [])));
    }
  }
  /**
   * The `TrackByFunction` to use for tracking changes. The `TrackByFunction` takes the index and
   * the item and produces a value to be used as the item's identity when tracking changes.
   */
  get cdkVirtualForTrackBy() {
    return this._cdkVirtualForTrackBy;
  }
  set cdkVirtualForTrackBy(fn) {
    this._needsUpdate = true;
    this._cdkVirtualForTrackBy = fn ? (index, item) => fn(index + (this._renderedRange ? this._renderedRange.start : 0), item) : void 0;
  }
  /** The template used to stamp out new elements. */
  set cdkVirtualForTemplate(value) {
    if (value) {
      this._needsUpdate = true;
      this._template = value;
    }
  }
  /**
   * The size of the cache used to store templates that are not being used for re-use later.
   * Setting the cache size to `0` will disable caching. Defaults to 20 templates.
   */
  get cdkVirtualForTemplateCacheSize() {
    return this._viewRepeater.viewCacheSize;
  }
  set cdkVirtualForTemplateCacheSize(size) {
    this._viewRepeater.viewCacheSize = coerceNumberProperty(size);
  }
  constructor(_viewContainerRef, _template, _differs, _viewRepeater, _viewport, ngZone) {
    this._viewContainerRef = _viewContainerRef;
    this._template = _template;
    this._differs = _differs;
    this._viewRepeater = _viewRepeater;
    this._viewport = _viewport;
    this.viewChange = new Subject();
    this._dataSourceChanges = new Subject();
    this.dataStream = this._dataSourceChanges.pipe(
      // Start off with null `DataSource`.
      startWith(null),
      // Bundle up the previous and current data sources so we can work with both.
      pairwise(),
      // Use `_changeDataSource` to disconnect from the previous data source and connect to the
      // new one, passing back a stream of data changes which we run through `switchMap` to give
      // us a data stream that emits the latest data from whatever the current `DataSource` is.
      switchMap(([prev, cur]) => this._changeDataSource(prev, cur)),
      // Replay the last emitted data when someone subscribes.
      shareReplay(1)
    );
    this._differ = null;
    this._needsUpdate = false;
    this._destroyed = new Subject();
    this.dataStream.subscribe((data) => {
      this._data = data;
      this._onRenderedDataChange();
    });
    this._viewport.renderedRangeStream.pipe(takeUntil(this._destroyed)).subscribe((range) => {
      this._renderedRange = range;
      if (this.viewChange.observers.length) {
        ngZone.run(() => this.viewChange.next(this._renderedRange));
      }
      this._onRenderedDataChange();
    });
    this._viewport.attach(this);
  }
  /**
   * Measures the combined size (width for horizontal orientation, height for vertical) of all items
   * in the specified range. Throws an error if the range includes items that are not currently
   * rendered.
   */
  measureRangeSize(range, orientation) {
    if (range.start >= range.end) {
      return 0;
    }
    if ((range.start < this._renderedRange.start || range.end > this._renderedRange.end) && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw Error(`Error: attempted to measure an item that isn't rendered.`);
    }
    const renderedStartIndex = range.start - this._renderedRange.start;
    const rangeLen = range.end - range.start;
    let firstNode;
    let lastNode;
    for (let i2 = 0; i2 < rangeLen; i2++) {
      const view = this._viewContainerRef.get(i2 + renderedStartIndex);
      if (view && view.rootNodes.length) {
        firstNode = lastNode = view.rootNodes[0];
        break;
      }
    }
    for (let i2 = rangeLen - 1; i2 > -1; i2--) {
      const view = this._viewContainerRef.get(i2 + renderedStartIndex);
      if (view && view.rootNodes.length) {
        lastNode = view.rootNodes[view.rootNodes.length - 1];
        break;
      }
    }
    return firstNode && lastNode ? getOffset(orientation, "end", lastNode) - getOffset(orientation, "start", firstNode) : 0;
  }
  ngDoCheck() {
    if (this._differ && this._needsUpdate) {
      const changes = this._differ.diff(this._renderedItems);
      if (!changes) {
        this._updateContext();
      } else {
        this._applyChanges(changes);
      }
      this._needsUpdate = false;
    }
  }
  ngOnDestroy() {
    this._viewport.detach();
    this._dataSourceChanges.next(void 0);
    this._dataSourceChanges.complete();
    this.viewChange.complete();
    this._destroyed.next();
    this._destroyed.complete();
    this._viewRepeater.detach();
  }
  /** React to scroll state changes in the viewport. */
  _onRenderedDataChange() {
    if (!this._renderedRange) {
      return;
    }
    this._renderedItems = this._data.slice(this._renderedRange.start, this._renderedRange.end);
    if (!this._differ) {
      this._differ = this._differs.find(this._renderedItems).create((index, item) => {
        return this.cdkVirtualForTrackBy ? this.cdkVirtualForTrackBy(index, item) : item;
      });
    }
    this._needsUpdate = true;
  }
  /** Swap out one `DataSource` for another. */
  _changeDataSource(oldDs, newDs) {
    if (oldDs) {
      oldDs.disconnect(this);
    }
    this._needsUpdate = true;
    return newDs ? newDs.connect(this) : of();
  }
  /** Update the `CdkVirtualForOfContext` for all views. */
  _updateContext() {
    const count = this._data.length;
    let i2 = this._viewContainerRef.length;
    while (i2--) {
      const view = this._viewContainerRef.get(i2);
      view.context.index = this._renderedRange.start + i2;
      view.context.count = count;
      this._updateComputedContextProperties(view.context);
      view.detectChanges();
    }
  }
  /** Apply changes to the DOM. */
  _applyChanges(changes) {
    this._viewRepeater.applyChanges(changes, this._viewContainerRef, (record, _adjustedPreviousIndex, currentIndex) => this._getEmbeddedViewArgs(record, currentIndex), (record) => record.item);
    changes.forEachIdentityChange((record) => {
      const view = this._viewContainerRef.get(record.currentIndex);
      view.context.$implicit = record.item;
    });
    const count = this._data.length;
    let i2 = this._viewContainerRef.length;
    while (i2--) {
      const view = this._viewContainerRef.get(i2);
      view.context.index = this._renderedRange.start + i2;
      view.context.count = count;
      this._updateComputedContextProperties(view.context);
    }
  }
  /** Update the computed properties on the `CdkVirtualForOfContext`. */
  _updateComputedContextProperties(context) {
    context.first = context.index === 0;
    context.last = context.index === context.count - 1;
    context.even = context.index % 2 === 0;
    context.odd = !context.even;
  }
  _getEmbeddedViewArgs(record, index) {
    return {
      templateRef: this._template,
      context: {
        $implicit: record.item,
        // It's guaranteed that the iterable is not "undefined" or "null" because we only
        // generate views for elements if the "cdkVirtualForOf" iterable has elements.
        cdkVirtualForOf: this._cdkVirtualForOf,
        index: -1,
        count: -1,
        first: false,
        last: false,
        odd: false,
        even: false
      },
      index
    };
  }
};
_CdkVirtualForOf.ɵfac = function CdkVirtualForOf_Factory(t3) {
  return new (t3 || _CdkVirtualForOf)(ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(TemplateRef), ɵɵdirectiveInject(IterableDiffers), ɵɵdirectiveInject(_VIEW_REPEATER_STRATEGY), ɵɵdirectiveInject(CdkVirtualScrollViewport, 4), ɵɵdirectiveInject(NgZone));
};
_CdkVirtualForOf.ɵdir = ɵɵdefineDirective({
  type: _CdkVirtualForOf,
  selectors: [["", "cdkVirtualFor", "", "cdkVirtualForOf", ""]],
  inputs: {
    cdkVirtualForOf: "cdkVirtualForOf",
    cdkVirtualForTrackBy: "cdkVirtualForTrackBy",
    cdkVirtualForTemplate: "cdkVirtualForTemplate",
    cdkVirtualForTemplateCacheSize: "cdkVirtualForTemplateCacheSize"
  },
  standalone: true,
  features: [ɵɵProvidersFeature([{
    provide: _VIEW_REPEATER_STRATEGY,
    useClass: _RecycleViewRepeaterStrategy
  }])]
});
var CdkVirtualForOf = _CdkVirtualForOf;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkVirtualForOf, [{
    type: Directive,
    args: [{
      selector: "[cdkVirtualFor][cdkVirtualForOf]",
      providers: [{
        provide: _VIEW_REPEATER_STRATEGY,
        useClass: _RecycleViewRepeaterStrategy
      }],
      standalone: true
    }]
  }], () => [{
    type: ViewContainerRef
  }, {
    type: TemplateRef
  }, {
    type: IterableDiffers
  }, {
    type: _RecycleViewRepeaterStrategy,
    decorators: [{
      type: Inject,
      args: [_VIEW_REPEATER_STRATEGY]
    }]
  }, {
    type: CdkVirtualScrollViewport,
    decorators: [{
      type: SkipSelf
    }]
  }, {
    type: NgZone
  }], {
    cdkVirtualForOf: [{
      type: Input
    }],
    cdkVirtualForTrackBy: [{
      type: Input
    }],
    cdkVirtualForTemplate: [{
      type: Input
    }],
    cdkVirtualForTemplateCacheSize: [{
      type: Input
    }]
  });
})();
var _CdkVirtualScrollableElement = class _CdkVirtualScrollableElement extends CdkVirtualScrollable {
  constructor(elementRef, scrollDispatcher, ngZone, dir) {
    super(elementRef, scrollDispatcher, ngZone, dir);
  }
  measureBoundingClientRectWithScrollOffset(from) {
    return this.getElementRef().nativeElement.getBoundingClientRect()[from] - this.measureScrollOffset(from);
  }
};
_CdkVirtualScrollableElement.ɵfac = function CdkVirtualScrollableElement_Factory(t3) {
  return new (t3 || _CdkVirtualScrollableElement)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ScrollDispatcher), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Directionality, 8));
};
_CdkVirtualScrollableElement.ɵdir = ɵɵdefineDirective({
  type: _CdkVirtualScrollableElement,
  selectors: [["", "cdkVirtualScrollingElement", ""]],
  hostAttrs: [1, "cdk-virtual-scrollable"],
  standalone: true,
  features: [ɵɵProvidersFeature([{
    provide: VIRTUAL_SCROLLABLE,
    useExisting: _CdkVirtualScrollableElement
  }]), ɵɵInheritDefinitionFeature]
});
var CdkVirtualScrollableElement = _CdkVirtualScrollableElement;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkVirtualScrollableElement, [{
    type: Directive,
    args: [{
      selector: "[cdkVirtualScrollingElement]",
      providers: [{
        provide: VIRTUAL_SCROLLABLE,
        useExisting: CdkVirtualScrollableElement
      }],
      standalone: true,
      host: {
        "class": "cdk-virtual-scrollable"
      }
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: ScrollDispatcher
  }, {
    type: NgZone
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
var _CdkVirtualScrollableWindow = class _CdkVirtualScrollableWindow extends CdkVirtualScrollable {
  constructor(scrollDispatcher, ngZone, dir) {
    super(new ElementRef(document.documentElement), scrollDispatcher, ngZone, dir);
    this._elementScrolled = new Observable((observer) => this.ngZone.runOutsideAngular(() => fromEvent(document, "scroll").pipe(takeUntil(this._destroyed)).subscribe(observer)));
  }
  measureBoundingClientRectWithScrollOffset(from) {
    return this.getElementRef().nativeElement.getBoundingClientRect()[from];
  }
};
_CdkVirtualScrollableWindow.ɵfac = function CdkVirtualScrollableWindow_Factory(t3) {
  return new (t3 || _CdkVirtualScrollableWindow)(ɵɵdirectiveInject(ScrollDispatcher), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Directionality, 8));
};
_CdkVirtualScrollableWindow.ɵdir = ɵɵdefineDirective({
  type: _CdkVirtualScrollableWindow,
  selectors: [["cdk-virtual-scroll-viewport", "scrollWindow", ""]],
  standalone: true,
  features: [ɵɵProvidersFeature([{
    provide: VIRTUAL_SCROLLABLE,
    useExisting: _CdkVirtualScrollableWindow
  }]), ɵɵInheritDefinitionFeature]
});
var CdkVirtualScrollableWindow = _CdkVirtualScrollableWindow;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkVirtualScrollableWindow, [{
    type: Directive,
    args: [{
      selector: "cdk-virtual-scroll-viewport[scrollWindow]",
      providers: [{
        provide: VIRTUAL_SCROLLABLE,
        useExisting: CdkVirtualScrollableWindow
      }],
      standalone: true
    }]
  }], () => [{
    type: ScrollDispatcher
  }, {
    type: NgZone
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }], null);
})();
var _CdkScrollableModule = class _CdkScrollableModule {
};
_CdkScrollableModule.ɵfac = function CdkScrollableModule_Factory(t3) {
  return new (t3 || _CdkScrollableModule)();
};
_CdkScrollableModule.ɵmod = ɵɵdefineNgModule({
  type: _CdkScrollableModule,
  imports: [CdkScrollable],
  exports: [CdkScrollable]
});
_CdkScrollableModule.ɵinj = ɵɵdefineInjector({});
var CdkScrollableModule = _CdkScrollableModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkScrollableModule, [{
    type: NgModule,
    args: [{
      exports: [CdkScrollable],
      imports: [CdkScrollable]
    }]
  }], null, null);
})();
var _ScrollingModule = class _ScrollingModule {
};
_ScrollingModule.ɵfac = function ScrollingModule_Factory(t3) {
  return new (t3 || _ScrollingModule)();
};
_ScrollingModule.ɵmod = ɵɵdefineNgModule({
  type: _ScrollingModule,
  imports: [BidiModule, CdkScrollableModule, CdkVirtualScrollViewport, CdkFixedSizeVirtualScroll, CdkVirtualForOf, CdkVirtualScrollableWindow, CdkVirtualScrollableElement],
  exports: [BidiModule, CdkScrollableModule, CdkFixedSizeVirtualScroll, CdkVirtualForOf, CdkVirtualScrollViewport, CdkVirtualScrollableWindow, CdkVirtualScrollableElement]
});
_ScrollingModule.ɵinj = ɵɵdefineInjector({
  imports: [BidiModule, CdkScrollableModule, BidiModule, CdkScrollableModule]
});
var ScrollingModule = _ScrollingModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ScrollingModule, [{
    type: NgModule,
    args: [{
      imports: [BidiModule, CdkScrollableModule, CdkVirtualScrollViewport, CdkFixedSizeVirtualScroll, CdkVirtualForOf, CdkVirtualScrollableWindow, CdkVirtualScrollableElement],
      exports: [BidiModule, CdkScrollableModule, CdkFixedSizeVirtualScroll, CdkVirtualForOf, CdkVirtualScrollViewport, CdkVirtualScrollableWindow, CdkVirtualScrollableElement]
    }]
  }], null, null);
})();

// node_modules/@angular/cdk/fesm2022/drag-drop.mjs
function extendStyles(dest, source, importantProperties2) {
  for (let key in source) {
    if (source.hasOwnProperty(key)) {
      const value = source[key];
      if (value) {
        dest.setProperty(key, value, importantProperties2?.has(key) ? "important" : "");
      } else {
        dest.removeProperty(key);
      }
    }
  }
  return dest;
}
function toggleNativeDragInteractions(element, enable) {
  const userSelect = enable ? "" : "none";
  extendStyles(element.style, {
    "touch-action": enable ? "" : "none",
    "-webkit-user-drag": enable ? "" : "none",
    "-webkit-tap-highlight-color": enable ? "" : "transparent",
    "user-select": userSelect,
    "-ms-user-select": userSelect,
    "-webkit-user-select": userSelect,
    "-moz-user-select": userSelect
  });
}
function toggleVisibility(element, enable, importantProperties2) {
  extendStyles(element.style, {
    position: enable ? "" : "fixed",
    top: enable ? "" : "0",
    opacity: enable ? "" : "0",
    left: enable ? "" : "-999em"
  }, importantProperties2);
}
function combineTransforms(transform, initialTransform) {
  return initialTransform && initialTransform != "none" ? transform + " " + initialTransform : transform;
}
function matchElementSize(target, sourceRect) {
  target.style.width = `${sourceRect.width}px`;
  target.style.height = `${sourceRect.height}px`;
  target.style.transform = getTransform(sourceRect.left, sourceRect.top);
}
function getTransform(x, y) {
  return `translate3d(${Math.round(x)}px, ${Math.round(y)}px, 0)`;
}
function getMutableClientRect(element) {
  const rect = element.getBoundingClientRect();
  return {
    top: rect.top,
    right: rect.right,
    bottom: rect.bottom,
    left: rect.left,
    width: rect.width,
    height: rect.height,
    x: rect.x,
    y: rect.y
  };
}
function isInsideClientRect(clientRect, x, y) {
  const {
    top,
    bottom,
    left,
    right
  } = clientRect;
  return y >= top && y <= bottom && x >= left && x <= right;
}
function adjustDomRect(domRect, top, left) {
  domRect.top += top;
  domRect.bottom = domRect.top + domRect.height;
  domRect.left += left;
  domRect.right = domRect.left + domRect.width;
}
function isPointerNearDomRect(rect, threshold, pointerX, pointerY) {
  const {
    top,
    right,
    bottom,
    left,
    width,
    height
  } = rect;
  const xThreshold = width * threshold;
  const yThreshold = height * threshold;
  return pointerY > top - yThreshold && pointerY < bottom + yThreshold && pointerX > left - xThreshold && pointerX < right + xThreshold;
}
var ParentPositionTracker = class {
  constructor(_document) {
    this._document = _document;
    this.positions = /* @__PURE__ */ new Map();
  }
  /** Clears the cached positions. */
  clear() {
    this.positions.clear();
  }
  /** Caches the positions. Should be called at the beginning of a drag sequence. */
  cache(elements) {
    this.clear();
    this.positions.set(this._document, {
      scrollPosition: this.getViewportScrollPosition()
    });
    elements.forEach((element) => {
      this.positions.set(element, {
        scrollPosition: {
          top: element.scrollTop,
          left: element.scrollLeft
        },
        clientRect: getMutableClientRect(element)
      });
    });
  }
  /** Handles scrolling while a drag is taking place. */
  handleScroll(event) {
    const target = _getEventTarget(event);
    const cachedPosition = this.positions.get(target);
    if (!cachedPosition) {
      return null;
    }
    const scrollPosition = cachedPosition.scrollPosition;
    let newTop;
    let newLeft;
    if (target === this._document) {
      const viewportScrollPosition = this.getViewportScrollPosition();
      newTop = viewportScrollPosition.top;
      newLeft = viewportScrollPosition.left;
    } else {
      newTop = target.scrollTop;
      newLeft = target.scrollLeft;
    }
    const topDifference = scrollPosition.top - newTop;
    const leftDifference = scrollPosition.left - newLeft;
    this.positions.forEach((position, node) => {
      if (position.clientRect && target !== node && target.contains(node)) {
        adjustDomRect(position.clientRect, topDifference, leftDifference);
      }
    });
    scrollPosition.top = newTop;
    scrollPosition.left = newLeft;
    return {
      top: topDifference,
      left: leftDifference
    };
  }
  /**
   * Gets the scroll position of the viewport. Note that we use the scrollX and scrollY directly,
   * instead of going through the `ViewportRuler`, because the first value the ruler looks at is
   * the top/left offset of the `document.documentElement` which works for most cases, but breaks
   * if the element is offset by something like the `BlockScrollStrategy`.
   */
  getViewportScrollPosition() {
    return {
      top: window.scrollY,
      left: window.scrollX
    };
  }
};
function deepCloneNode(node) {
  const clone = node.cloneNode(true);
  const descendantsWithId = clone.querySelectorAll("[id]");
  const nodeName = node.nodeName.toLowerCase();
  clone.removeAttribute("id");
  for (let i2 = 0; i2 < descendantsWithId.length; i2++) {
    descendantsWithId[i2].removeAttribute("id");
  }
  if (nodeName === "canvas") {
    transferCanvasData(node, clone);
  } else if (nodeName === "input" || nodeName === "select" || nodeName === "textarea") {
    transferInputData(node, clone);
  }
  transferData("canvas", node, clone, transferCanvasData);
  transferData("input, textarea, select", node, clone, transferInputData);
  return clone;
}
function transferData(selector, node, clone, callback) {
  const descendantElements = node.querySelectorAll(selector);
  if (descendantElements.length) {
    const cloneElements = clone.querySelectorAll(selector);
    for (let i2 = 0; i2 < descendantElements.length; i2++) {
      callback(descendantElements[i2], cloneElements[i2]);
    }
  }
}
var cloneUniqueId = 0;
function transferInputData(source, clone) {
  if (clone.type !== "file") {
    clone.value = source.value;
  }
  if (clone.type === "radio" && clone.name) {
    clone.name = `mat-clone-${clone.name}-${cloneUniqueId++}`;
  }
}
function transferCanvasData(source, clone) {
  const context = clone.getContext("2d");
  if (context) {
    try {
      context.drawImage(source, 0, 0);
    } catch {
    }
  }
}
function getRootNode(viewRef, _document) {
  const rootNodes = viewRef.rootNodes;
  if (rootNodes.length === 1 && rootNodes[0].nodeType === _document.ELEMENT_NODE) {
    return rootNodes[0];
  }
  const wrapper = _document.createElement("div");
  rootNodes.forEach((node) => wrapper.appendChild(node));
  return wrapper;
}
function parseCssTimeUnitsToMs(value) {
  const multiplier = value.toLowerCase().indexOf("ms") > -1 ? 1 : 1e3;
  return parseFloat(value) * multiplier;
}
function getTransformTransitionDurationInMs(element) {
  const computedStyle = getComputedStyle(element);
  const transitionedProperties = parseCssPropertyValue(computedStyle, "transition-property");
  const property = transitionedProperties.find((prop) => prop === "transform" || prop === "all");
  if (!property) {
    return 0;
  }
  const propertyIndex = transitionedProperties.indexOf(property);
  const rawDurations = parseCssPropertyValue(computedStyle, "transition-duration");
  const rawDelays = parseCssPropertyValue(computedStyle, "transition-delay");
  return parseCssTimeUnitsToMs(rawDurations[propertyIndex]) + parseCssTimeUnitsToMs(rawDelays[propertyIndex]);
}
function parseCssPropertyValue(computedStyle, name) {
  const value = computedStyle.getPropertyValue(name);
  return value.split(",").map((part) => part.trim());
}
var importantProperties = /* @__PURE__ */ new Set([
  // Needs to be important, because some `mat-table` sets `position: sticky !important`. See #22781.
  "position"
]);
var PreviewRef = class {
  constructor(_document, _rootElement, _direction, _initialDomRect, _previewTemplate, _previewClass, _pickupPositionOnPage, _initialTransform, _zIndex) {
    this._document = _document;
    this._rootElement = _rootElement;
    this._direction = _direction;
    this._initialDomRect = _initialDomRect;
    this._previewTemplate = _previewTemplate;
    this._previewClass = _previewClass;
    this._pickupPositionOnPage = _pickupPositionOnPage;
    this._initialTransform = _initialTransform;
    this._zIndex = _zIndex;
  }
  attach(parent) {
    this._preview = this._createPreview();
    parent.appendChild(this._preview);
    if ("showPopover" in this._preview) {
      this._preview["showPopover"]();
    }
  }
  destroy() {
    this._preview.remove();
    this._previewEmbeddedView?.destroy();
    this._preview = this._previewEmbeddedView = null;
  }
  setTransform(value) {
    this._preview.style.transform = value;
  }
  getBoundingClientRect() {
    return this._preview.getBoundingClientRect();
  }
  addClass(className) {
    this._preview.classList.add(className);
  }
  getTransitionDuration() {
    return getTransformTransitionDurationInMs(this._preview);
  }
  addEventListener(name, handler) {
    this._preview.addEventListener(name, handler);
  }
  removeEventListener(name, handler) {
    this._preview.removeEventListener(name, handler);
  }
  _createPreview() {
    const previewConfig = this._previewTemplate;
    const previewClass = this._previewClass;
    const previewTemplate = previewConfig ? previewConfig.template : null;
    let preview;
    if (previewTemplate && previewConfig) {
      const rootRect = previewConfig.matchSize ? this._initialDomRect : null;
      const viewRef = previewConfig.viewContainer.createEmbeddedView(previewTemplate, previewConfig.context);
      viewRef.detectChanges();
      preview = getRootNode(viewRef, this._document);
      this._previewEmbeddedView = viewRef;
      if (previewConfig.matchSize) {
        matchElementSize(preview, rootRect);
      } else {
        preview.style.transform = getTransform(this._pickupPositionOnPage.x, this._pickupPositionOnPage.y);
      }
    } else {
      preview = deepCloneNode(this._rootElement);
      matchElementSize(preview, this._initialDomRect);
      if (this._initialTransform) {
        preview.style.transform = this._initialTransform;
      }
    }
    extendStyles(preview.style, {
      // It's important that we disable the pointer events on the preview, because
      // it can throw off the `document.elementFromPoint` calls in the `CdkDropList`.
      "pointer-events": "none",
      // We have to reset the margin, because it can throw off positioning relative to the viewport.
      "margin": "0",
      "position": "fixed",
      "top": "0",
      "left": "0",
      "z-index": this._zIndex + ""
    }, importantProperties);
    toggleNativeDragInteractions(preview, false);
    preview.classList.add("cdk-drag-preview");
    preview.setAttribute("popover", "manual");
    preview.setAttribute("dir", this._direction);
    if (previewClass) {
      if (Array.isArray(previewClass)) {
        previewClass.forEach((className) => preview.classList.add(className));
      } else {
        preview.classList.add(previewClass);
      }
    }
    return preview;
  }
};
var passiveEventListenerOptions = normalizePassiveListenerOptions({
  passive: true
});
var activeEventListenerOptions = normalizePassiveListenerOptions({
  passive: false
});
var activeCapturingEventOptions$1 = normalizePassiveListenerOptions({
  passive: false,
  capture: true
});
var MOUSE_EVENT_IGNORE_TIME = 800;
var dragImportantProperties = /* @__PURE__ */ new Set([
  // Needs to be important, because some `mat-table` sets `position: sticky !important`. See #22781.
  "position"
]);
var DragRef = class {
  /** Whether starting to drag this element is disabled. */
  get disabled() {
    return this._disabled || !!(this._dropContainer && this._dropContainer.disabled);
  }
  set disabled(value) {
    if (value !== this._disabled) {
      this._disabled = value;
      this._toggleNativeDragInteractions();
      this._handles.forEach((handle) => toggleNativeDragInteractions(handle, value));
    }
  }
  constructor(element, _config, _document, _ngZone, _viewportRuler, _dragDropRegistry) {
    this._config = _config;
    this._document = _document;
    this._ngZone = _ngZone;
    this._viewportRuler = _viewportRuler;
    this._dragDropRegistry = _dragDropRegistry;
    this._passiveTransform = {
      x: 0,
      y: 0
    };
    this._activeTransform = {
      x: 0,
      y: 0
    };
    this._hasStartedDragging = false;
    this._moveEvents = new Subject();
    this._pointerMoveSubscription = Subscription.EMPTY;
    this._pointerUpSubscription = Subscription.EMPTY;
    this._scrollSubscription = Subscription.EMPTY;
    this._resizeSubscription = Subscription.EMPTY;
    this._boundaryElement = null;
    this._nativeInteractionsEnabled = true;
    this._handles = [];
    this._disabledHandles = /* @__PURE__ */ new Set();
    this._direction = "ltr";
    this.dragStartDelay = 0;
    this._disabled = false;
    this.beforeStarted = new Subject();
    this.started = new Subject();
    this.released = new Subject();
    this.ended = new Subject();
    this.entered = new Subject();
    this.exited = new Subject();
    this.dropped = new Subject();
    this.moved = this._moveEvents;
    this._pointerDown = (event) => {
      this.beforeStarted.next();
      if (this._handles.length) {
        const targetHandle = this._getTargetHandle(event);
        if (targetHandle && !this._disabledHandles.has(targetHandle) && !this.disabled) {
          this._initializeDragSequence(targetHandle, event);
        }
      } else if (!this.disabled) {
        this._initializeDragSequence(this._rootElement, event);
      }
    };
    this._pointerMove = (event) => {
      const pointerPosition = this._getPointerPositionOnPage(event);
      if (!this._hasStartedDragging) {
        const distanceX = Math.abs(pointerPosition.x - this._pickupPositionOnPage.x);
        const distanceY = Math.abs(pointerPosition.y - this._pickupPositionOnPage.y);
        const isOverThreshold = distanceX + distanceY >= this._config.dragStartThreshold;
        if (isOverThreshold) {
          const isDelayElapsed = Date.now() >= this._dragStartTime + this._getDragStartDelay(event);
          const container = this._dropContainer;
          if (!isDelayElapsed) {
            this._endDragSequence(event);
            return;
          }
          if (!container || !container.isDragging() && !container.isReceiving()) {
            if (event.cancelable) {
              event.preventDefault();
            }
            this._hasStartedDragging = true;
            this._ngZone.run(() => this._startDragSequence(event));
          }
        }
        return;
      }
      if (event.cancelable) {
        event.preventDefault();
      }
      const constrainedPointerPosition = this._getConstrainedPointerPosition(pointerPosition);
      this._hasMoved = true;
      this._lastKnownPointerPosition = pointerPosition;
      this._updatePointerDirectionDelta(constrainedPointerPosition);
      if (this._dropContainer) {
        this._updateActiveDropContainer(constrainedPointerPosition, pointerPosition);
      } else {
        const offset = this.constrainPosition ? this._initialDomRect : this._pickupPositionOnPage;
        const activeTransform = this._activeTransform;
        activeTransform.x = constrainedPointerPosition.x - offset.x + this._passiveTransform.x;
        activeTransform.y = constrainedPointerPosition.y - offset.y + this._passiveTransform.y;
        this._applyRootElementTransform(activeTransform.x, activeTransform.y);
      }
      if (this._moveEvents.observers.length) {
        this._ngZone.run(() => {
          this._moveEvents.next({
            source: this,
            pointerPosition: constrainedPointerPosition,
            event,
            distance: this._getDragDistance(constrainedPointerPosition),
            delta: this._pointerDirectionDelta
          });
        });
      }
    };
    this._pointerUp = (event) => {
      this._endDragSequence(event);
    };
    this._nativeDragStart = (event) => {
      if (this._handles.length) {
        const targetHandle = this._getTargetHandle(event);
        if (targetHandle && !this._disabledHandles.has(targetHandle) && !this.disabled) {
          event.preventDefault();
        }
      } else if (!this.disabled) {
        event.preventDefault();
      }
    };
    this.withRootElement(element).withParent(_config.parentDragRef || null);
    this._parentPositions = new ParentPositionTracker(_document);
    _dragDropRegistry.registerDragItem(this);
  }
  /**
   * Returns the element that is being used as a placeholder
   * while the current element is being dragged.
   */
  getPlaceholderElement() {
    return this._placeholder;
  }
  /** Returns the root draggable element. */
  getRootElement() {
    return this._rootElement;
  }
  /**
   * Gets the currently-visible element that represents the drag item.
   * While dragging this is the placeholder, otherwise it's the root element.
   */
  getVisibleElement() {
    return this.isDragging() ? this.getPlaceholderElement() : this.getRootElement();
  }
  /** Registers the handles that can be used to drag the element. */
  withHandles(handles) {
    this._handles = handles.map((handle) => coerceElement(handle));
    this._handles.forEach((handle) => toggleNativeDragInteractions(handle, this.disabled));
    this._toggleNativeDragInteractions();
    const disabledHandles = /* @__PURE__ */ new Set();
    this._disabledHandles.forEach((handle) => {
      if (this._handles.indexOf(handle) > -1) {
        disabledHandles.add(handle);
      }
    });
    this._disabledHandles = disabledHandles;
    return this;
  }
  /**
   * Registers the template that should be used for the drag preview.
   * @param template Template that from which to stamp out the preview.
   */
  withPreviewTemplate(template) {
    this._previewTemplate = template;
    return this;
  }
  /**
   * Registers the template that should be used for the drag placeholder.
   * @param template Template that from which to stamp out the placeholder.
   */
  withPlaceholderTemplate(template) {
    this._placeholderTemplate = template;
    return this;
  }
  /**
   * Sets an alternate drag root element. The root element is the element that will be moved as
   * the user is dragging. Passing an alternate root element is useful when trying to enable
   * dragging on an element that you might not have access to.
   */
  withRootElement(rootElement) {
    const element = coerceElement(rootElement);
    if (element !== this._rootElement) {
      if (this._rootElement) {
        this._removeRootElementListeners(this._rootElement);
      }
      this._ngZone.runOutsideAngular(() => {
        element.addEventListener("mousedown", this._pointerDown, activeEventListenerOptions);
        element.addEventListener("touchstart", this._pointerDown, passiveEventListenerOptions);
        element.addEventListener("dragstart", this._nativeDragStart, activeEventListenerOptions);
      });
      this._initialTransform = void 0;
      this._rootElement = element;
    }
    if (typeof SVGElement !== "undefined" && this._rootElement instanceof SVGElement) {
      this._ownerSVGElement = this._rootElement.ownerSVGElement;
    }
    return this;
  }
  /**
   * Element to which the draggable's position will be constrained.
   */
  withBoundaryElement(boundaryElement) {
    this._boundaryElement = boundaryElement ? coerceElement(boundaryElement) : null;
    this._resizeSubscription.unsubscribe();
    if (boundaryElement) {
      this._resizeSubscription = this._viewportRuler.change(10).subscribe(() => this._containInsideBoundaryOnResize());
    }
    return this;
  }
  /** Sets the parent ref that the ref is nested in.  */
  withParent(parent) {
    this._parentDragRef = parent;
    return this;
  }
  /** Removes the dragging functionality from the DOM element. */
  dispose() {
    this._removeRootElementListeners(this._rootElement);
    if (this.isDragging()) {
      this._rootElement?.remove();
    }
    this._anchor?.remove();
    this._destroyPreview();
    this._destroyPlaceholder();
    this._dragDropRegistry.removeDragItem(this);
    this._removeListeners();
    this.beforeStarted.complete();
    this.started.complete();
    this.released.complete();
    this.ended.complete();
    this.entered.complete();
    this.exited.complete();
    this.dropped.complete();
    this._moveEvents.complete();
    this._handles = [];
    this._disabledHandles.clear();
    this._dropContainer = void 0;
    this._resizeSubscription.unsubscribe();
    this._parentPositions.clear();
    this._boundaryElement = this._rootElement = this._ownerSVGElement = this._placeholderTemplate = this._previewTemplate = this._anchor = this._parentDragRef = null;
  }
  /** Checks whether the element is currently being dragged. */
  isDragging() {
    return this._hasStartedDragging && this._dragDropRegistry.isDragging(this);
  }
  /** Resets a standalone drag item to its initial position. */
  reset() {
    this._rootElement.style.transform = this._initialTransform || "";
    this._activeTransform = {
      x: 0,
      y: 0
    };
    this._passiveTransform = {
      x: 0,
      y: 0
    };
  }
  /**
   * Sets a handle as disabled. While a handle is disabled, it'll capture and interrupt dragging.
   * @param handle Handle element that should be disabled.
   */
  disableHandle(handle) {
    if (!this._disabledHandles.has(handle) && this._handles.indexOf(handle) > -1) {
      this._disabledHandles.add(handle);
      toggleNativeDragInteractions(handle, true);
    }
  }
  /**
   * Enables a handle, if it has been disabled.
   * @param handle Handle element to be enabled.
   */
  enableHandle(handle) {
    if (this._disabledHandles.has(handle)) {
      this._disabledHandles.delete(handle);
      toggleNativeDragInteractions(handle, this.disabled);
    }
  }
  /** Sets the layout direction of the draggable item. */
  withDirection(direction) {
    this._direction = direction;
    return this;
  }
  /** Sets the container that the item is part of. */
  _withDropContainer(container) {
    this._dropContainer = container;
  }
  /**
   * Gets the current position in pixels the draggable outside of a drop container.
   */
  getFreeDragPosition() {
    const position = this.isDragging() ? this._activeTransform : this._passiveTransform;
    return {
      x: position.x,
      y: position.y
    };
  }
  /**
   * Sets the current position in pixels the draggable outside of a drop container.
   * @param value New position to be set.
   */
  setFreeDragPosition(value) {
    this._activeTransform = {
      x: 0,
      y: 0
    };
    this._passiveTransform.x = value.x;
    this._passiveTransform.y = value.y;
    if (!this._dropContainer) {
      this._applyRootElementTransform(value.x, value.y);
    }
    return this;
  }
  /**
   * Sets the container into which to insert the preview element.
   * @param value Container into which to insert the preview.
   */
  withPreviewContainer(value) {
    this._previewContainer = value;
    return this;
  }
  /** Updates the item's sort order based on the last-known pointer position. */
  _sortFromLastPointerPosition() {
    const position = this._lastKnownPointerPosition;
    if (position && this._dropContainer) {
      this._updateActiveDropContainer(this._getConstrainedPointerPosition(position), position);
    }
  }
  /** Unsubscribes from the global subscriptions. */
  _removeListeners() {
    this._pointerMoveSubscription.unsubscribe();
    this._pointerUpSubscription.unsubscribe();
    this._scrollSubscription.unsubscribe();
    this._getShadowRoot()?.removeEventListener("selectstart", shadowDomSelectStart, activeCapturingEventOptions$1);
  }
  /** Destroys the preview element and its ViewRef. */
  _destroyPreview() {
    this._preview?.destroy();
    this._preview = null;
  }
  /** Destroys the placeholder element and its ViewRef. */
  _destroyPlaceholder() {
    this._placeholder?.remove();
    this._placeholderRef?.destroy();
    this._placeholder = this._placeholderRef = null;
  }
  /**
   * Clears subscriptions and stops the dragging sequence.
   * @param event Browser event object that ended the sequence.
   */
  _endDragSequence(event) {
    if (!this._dragDropRegistry.isDragging(this)) {
      return;
    }
    this._removeListeners();
    this._dragDropRegistry.stopDragging(this);
    this._toggleNativeDragInteractions();
    if (this._handles) {
      this._rootElement.style.webkitTapHighlightColor = this._rootElementTapHighlight;
    }
    if (!this._hasStartedDragging) {
      return;
    }
    this.released.next({
      source: this,
      event
    });
    if (this._dropContainer) {
      this._dropContainer._stopScrolling();
      this._animatePreviewToPlaceholder().then(() => {
        this._cleanupDragArtifacts(event);
        this._cleanupCachedDimensions();
        this._dragDropRegistry.stopDragging(this);
      });
    } else {
      this._passiveTransform.x = this._activeTransform.x;
      const pointerPosition = this._getPointerPositionOnPage(event);
      this._passiveTransform.y = this._activeTransform.y;
      this._ngZone.run(() => {
        this.ended.next({
          source: this,
          distance: this._getDragDistance(pointerPosition),
          dropPoint: pointerPosition,
          event
        });
      });
      this._cleanupCachedDimensions();
      this._dragDropRegistry.stopDragging(this);
    }
  }
  /** Starts the dragging sequence. */
  _startDragSequence(event) {
    if (isTouchEvent(event)) {
      this._lastTouchEventTime = Date.now();
    }
    this._toggleNativeDragInteractions();
    const shadowRoot = this._getShadowRoot();
    const dropContainer = this._dropContainer;
    if (shadowRoot) {
      this._ngZone.runOutsideAngular(() => {
        shadowRoot.addEventListener("selectstart", shadowDomSelectStart, activeCapturingEventOptions$1);
      });
    }
    if (dropContainer) {
      const element = this._rootElement;
      const parent = element.parentNode;
      const placeholder = this._placeholder = this._createPlaceholderElement();
      const anchor = this._anchor = this._anchor || this._document.createComment("");
      parent.insertBefore(anchor, element);
      this._initialTransform = element.style.transform || "";
      this._preview = new PreviewRef(this._document, this._rootElement, this._direction, this._initialDomRect, this._previewTemplate || null, this.previewClass || null, this._pickupPositionOnPage, this._initialTransform, this._config.zIndex || 1e3);
      this._preview.attach(this._getPreviewInsertionPoint(parent, shadowRoot));
      toggleVisibility(element, false, dragImportantProperties);
      this._document.body.appendChild(parent.replaceChild(placeholder, element));
      this.started.next({
        source: this,
        event
      });
      dropContainer.start();
      this._initialContainer = dropContainer;
      this._initialIndex = dropContainer.getItemIndex(this);
    } else {
      this.started.next({
        source: this,
        event
      });
      this._initialContainer = this._initialIndex = void 0;
    }
    this._parentPositions.cache(dropContainer ? dropContainer.getScrollableParents() : []);
  }
  /**
   * Sets up the different variables and subscriptions
   * that will be necessary for the dragging sequence.
   * @param referenceElement Element that started the drag sequence.
   * @param event Browser event object that started the sequence.
   */
  _initializeDragSequence(referenceElement, event) {
    if (this._parentDragRef) {
      event.stopPropagation();
    }
    const isDragging = this.isDragging();
    const isTouchSequence = isTouchEvent(event);
    const isAuxiliaryMouseButton = !isTouchSequence && event.button !== 0;
    const rootElement = this._rootElement;
    const target = _getEventTarget(event);
    const isSyntheticEvent = !isTouchSequence && this._lastTouchEventTime && this._lastTouchEventTime + MOUSE_EVENT_IGNORE_TIME > Date.now();
    const isFakeEvent = isTouchSequence ? isFakeTouchstartFromScreenReader(event) : isFakeMousedownFromScreenReader(event);
    if (target && target.draggable && event.type === "mousedown") {
      event.preventDefault();
    }
    if (isDragging || isAuxiliaryMouseButton || isSyntheticEvent || isFakeEvent) {
      return;
    }
    if (this._handles.length) {
      const rootStyles = rootElement.style;
      this._rootElementTapHighlight = rootStyles.webkitTapHighlightColor || "";
      rootStyles.webkitTapHighlightColor = "transparent";
    }
    this._hasStartedDragging = this._hasMoved = false;
    this._removeListeners();
    this._initialDomRect = this._rootElement.getBoundingClientRect();
    this._pointerMoveSubscription = this._dragDropRegistry.pointerMove.subscribe(this._pointerMove);
    this._pointerUpSubscription = this._dragDropRegistry.pointerUp.subscribe(this._pointerUp);
    this._scrollSubscription = this._dragDropRegistry.scrolled(this._getShadowRoot()).subscribe((scrollEvent) => this._updateOnScroll(scrollEvent));
    if (this._boundaryElement) {
      this._boundaryRect = getMutableClientRect(this._boundaryElement);
    }
    const previewTemplate = this._previewTemplate;
    this._pickupPositionInElement = previewTemplate && previewTemplate.template && !previewTemplate.matchSize ? {
      x: 0,
      y: 0
    } : this._getPointerPositionInElement(this._initialDomRect, referenceElement, event);
    const pointerPosition = this._pickupPositionOnPage = this._lastKnownPointerPosition = this._getPointerPositionOnPage(event);
    this._pointerDirectionDelta = {
      x: 0,
      y: 0
    };
    this._pointerPositionAtLastDirectionChange = {
      x: pointerPosition.x,
      y: pointerPosition.y
    };
    this._dragStartTime = Date.now();
    this._dragDropRegistry.startDragging(this, event);
  }
  /** Cleans up the DOM artifacts that were added to facilitate the element being dragged. */
  _cleanupDragArtifacts(event) {
    toggleVisibility(this._rootElement, true, dragImportantProperties);
    this._anchor.parentNode.replaceChild(this._rootElement, this._anchor);
    this._destroyPreview();
    this._destroyPlaceholder();
    this._initialDomRect = this._boundaryRect = this._previewRect = this._initialTransform = void 0;
    this._ngZone.run(() => {
      const container = this._dropContainer;
      const currentIndex = container.getItemIndex(this);
      const pointerPosition = this._getPointerPositionOnPage(event);
      const distance = this._getDragDistance(pointerPosition);
      const isPointerOverContainer = container._isOverContainer(pointerPosition.x, pointerPosition.y);
      this.ended.next({
        source: this,
        distance,
        dropPoint: pointerPosition,
        event
      });
      this.dropped.next({
        item: this,
        currentIndex,
        previousIndex: this._initialIndex,
        container,
        previousContainer: this._initialContainer,
        isPointerOverContainer,
        distance,
        dropPoint: pointerPosition,
        event
      });
      container.drop(this, currentIndex, this._initialIndex, this._initialContainer, isPointerOverContainer, distance, pointerPosition, event);
      this._dropContainer = this._initialContainer;
    });
  }
  /**
   * Updates the item's position in its drop container, or moves it
   * into a new one, depending on its current drag position.
   */
  _updateActiveDropContainer({
    x,
    y
  }, {
    x: rawX,
    y: rawY
  }) {
    let newContainer = this._initialContainer._getSiblingContainerFromPosition(this, x, y);
    if (!newContainer && this._dropContainer !== this._initialContainer && this._initialContainer._isOverContainer(x, y)) {
      newContainer = this._initialContainer;
    }
    if (newContainer && newContainer !== this._dropContainer) {
      this._ngZone.run(() => {
        this.exited.next({
          item: this,
          container: this._dropContainer
        });
        this._dropContainer.exit(this);
        this._dropContainer = newContainer;
        this._dropContainer.enter(this, x, y, newContainer === this._initialContainer && // If we're re-entering the initial container and sorting is disabled,
        // put item the into its starting index to begin with.
        newContainer.sortingDisabled ? this._initialIndex : void 0);
        this.entered.next({
          item: this,
          container: newContainer,
          currentIndex: newContainer.getItemIndex(this)
        });
      });
    }
    if (this.isDragging()) {
      this._dropContainer._startScrollingIfNecessary(rawX, rawY);
      this._dropContainer._sortItem(this, x, y, this._pointerDirectionDelta);
      if (this.constrainPosition) {
        this._applyPreviewTransform(x, y);
      } else {
        this._applyPreviewTransform(x - this._pickupPositionInElement.x, y - this._pickupPositionInElement.y);
      }
    }
  }
  /**
   * Animates the preview element from its current position to the location of the drop placeholder.
   * @returns Promise that resolves when the animation completes.
   */
  _animatePreviewToPlaceholder() {
    if (!this._hasMoved) {
      return Promise.resolve();
    }
    const placeholderRect = this._placeholder.getBoundingClientRect();
    this._preview.addClass("cdk-drag-animating");
    this._applyPreviewTransform(placeholderRect.left, placeholderRect.top);
    const duration = this._preview.getTransitionDuration();
    if (duration === 0) {
      return Promise.resolve();
    }
    return this._ngZone.runOutsideAngular(() => {
      return new Promise((resolve) => {
        const handler = (event) => {
          if (!event || _getEventTarget(event) === this._preview && event.propertyName === "transform") {
            this._preview?.removeEventListener("transitionend", handler);
            resolve();
            clearTimeout(timeout);
          }
        };
        const timeout = setTimeout(handler, duration * 1.5);
        this._preview.addEventListener("transitionend", handler);
      });
    });
  }
  /** Creates an element that will be shown instead of the current element while dragging. */
  _createPlaceholderElement() {
    const placeholderConfig = this._placeholderTemplate;
    const placeholderTemplate = placeholderConfig ? placeholderConfig.template : null;
    let placeholder;
    if (placeholderTemplate) {
      this._placeholderRef = placeholderConfig.viewContainer.createEmbeddedView(placeholderTemplate, placeholderConfig.context);
      this._placeholderRef.detectChanges();
      placeholder = getRootNode(this._placeholderRef, this._document);
    } else {
      placeholder = deepCloneNode(this._rootElement);
    }
    placeholder.style.pointerEvents = "none";
    placeholder.classList.add("cdk-drag-placeholder");
    return placeholder;
  }
  /**
   * Figures out the coordinates at which an element was picked up.
   * @param referenceElement Element that initiated the dragging.
   * @param event Event that initiated the dragging.
   */
  _getPointerPositionInElement(elementRect, referenceElement, event) {
    const handleElement = referenceElement === this._rootElement ? null : referenceElement;
    const referenceRect = handleElement ? handleElement.getBoundingClientRect() : elementRect;
    const point = isTouchEvent(event) ? event.targetTouches[0] : event;
    const scrollPosition = this._getViewportScrollPosition();
    const x = point.pageX - referenceRect.left - scrollPosition.left;
    const y = point.pageY - referenceRect.top - scrollPosition.top;
    return {
      x: referenceRect.left - elementRect.left + x,
      y: referenceRect.top - elementRect.top + y
    };
  }
  /** Determines the point of the page that was touched by the user. */
  _getPointerPositionOnPage(event) {
    const scrollPosition = this._getViewportScrollPosition();
    const point = isTouchEvent(event) ? (
      // `touches` will be empty for start/end events so we have to fall back to `changedTouches`.
      // Also note that on real devices we're guaranteed for either `touches` or `changedTouches`
      // to have a value, but Firefox in device emulation mode has a bug where both can be empty
      // for `touchstart` and `touchend` so we fall back to a dummy object in order to avoid
      // throwing an error. The value returned here will be incorrect, but since this only
      // breaks inside a developer tool and the value is only used for secondary information,
      // we can get away with it. See https://bugzilla.mozilla.org/show_bug.cgi?id=1615824.
      event.touches[0] || event.changedTouches[0] || {
        pageX: 0,
        pageY: 0
      }
    ) : event;
    const x = point.pageX - scrollPosition.left;
    const y = point.pageY - scrollPosition.top;
    if (this._ownerSVGElement) {
      const svgMatrix = this._ownerSVGElement.getScreenCTM();
      if (svgMatrix) {
        const svgPoint = this._ownerSVGElement.createSVGPoint();
        svgPoint.x = x;
        svgPoint.y = y;
        return svgPoint.matrixTransform(svgMatrix.inverse());
      }
    }
    return {
      x,
      y
    };
  }
  /** Gets the pointer position on the page, accounting for any position constraints. */
  _getConstrainedPointerPosition(point) {
    const dropContainerLock = this._dropContainer ? this._dropContainer.lockAxis : null;
    let {
      x,
      y
    } = this.constrainPosition ? this.constrainPosition(point, this, this._initialDomRect, this._pickupPositionInElement) : point;
    if (this.lockAxis === "x" || dropContainerLock === "x") {
      y = this._pickupPositionOnPage.y - (this.constrainPosition ? this._pickupPositionInElement.y : 0);
    } else if (this.lockAxis === "y" || dropContainerLock === "y") {
      x = this._pickupPositionOnPage.x - (this.constrainPosition ? this._pickupPositionInElement.x : 0);
    }
    if (this._boundaryRect) {
      const {
        x: pickupX,
        y: pickupY
      } = !this.constrainPosition ? this._pickupPositionInElement : {
        x: 0,
        y: 0
      };
      const boundaryRect = this._boundaryRect;
      const {
        width: previewWidth,
        height: previewHeight
      } = this._getPreviewRect();
      const minY = boundaryRect.top + pickupY;
      const maxY = boundaryRect.bottom - (previewHeight - pickupY);
      const minX = boundaryRect.left + pickupX;
      const maxX = boundaryRect.right - (previewWidth - pickupX);
      x = clamp$1(x, minX, maxX);
      y = clamp$1(y, minY, maxY);
    }
    return {
      x,
      y
    };
  }
  /** Updates the current drag delta, based on the user's current pointer position on the page. */
  _updatePointerDirectionDelta(pointerPositionOnPage) {
    const {
      x,
      y
    } = pointerPositionOnPage;
    const delta = this._pointerDirectionDelta;
    const positionSinceLastChange = this._pointerPositionAtLastDirectionChange;
    const changeX = Math.abs(x - positionSinceLastChange.x);
    const changeY = Math.abs(y - positionSinceLastChange.y);
    if (changeX > this._config.pointerDirectionChangeThreshold) {
      delta.x = x > positionSinceLastChange.x ? 1 : -1;
      positionSinceLastChange.x = x;
    }
    if (changeY > this._config.pointerDirectionChangeThreshold) {
      delta.y = y > positionSinceLastChange.y ? 1 : -1;
      positionSinceLastChange.y = y;
    }
    return delta;
  }
  /** Toggles the native drag interactions, based on how many handles are registered. */
  _toggleNativeDragInteractions() {
    if (!this._rootElement || !this._handles) {
      return;
    }
    const shouldEnable = this._handles.length > 0 || !this.isDragging();
    if (shouldEnable !== this._nativeInteractionsEnabled) {
      this._nativeInteractionsEnabled = shouldEnable;
      toggleNativeDragInteractions(this._rootElement, shouldEnable);
    }
  }
  /** Removes the manually-added event listeners from the root element. */
  _removeRootElementListeners(element) {
    element.removeEventListener("mousedown", this._pointerDown, activeEventListenerOptions);
    element.removeEventListener("touchstart", this._pointerDown, passiveEventListenerOptions);
    element.removeEventListener("dragstart", this._nativeDragStart, activeEventListenerOptions);
  }
  /**
   * Applies a `transform` to the root element, taking into account any existing transforms on it.
   * @param x New transform value along the X axis.
   * @param y New transform value along the Y axis.
   */
  _applyRootElementTransform(x, y) {
    const transform = getTransform(x, y);
    const styles = this._rootElement.style;
    if (this._initialTransform == null) {
      this._initialTransform = styles.transform && styles.transform != "none" ? styles.transform : "";
    }
    styles.transform = combineTransforms(transform, this._initialTransform);
  }
  /**
   * Applies a `transform` to the preview, taking into account any existing transforms on it.
   * @param x New transform value along the X axis.
   * @param y New transform value along the Y axis.
   */
  _applyPreviewTransform(x, y) {
    const initialTransform = this._previewTemplate?.template ? void 0 : this._initialTransform;
    const transform = getTransform(x, y);
    this._preview.setTransform(combineTransforms(transform, initialTransform));
  }
  /**
   * Gets the distance that the user has dragged during the current drag sequence.
   * @param currentPosition Current position of the user's pointer.
   */
  _getDragDistance(currentPosition) {
    const pickupPosition = this._pickupPositionOnPage;
    if (pickupPosition) {
      return {
        x: currentPosition.x - pickupPosition.x,
        y: currentPosition.y - pickupPosition.y
      };
    }
    return {
      x: 0,
      y: 0
    };
  }
  /** Cleans up any cached element dimensions that we don't need after dragging has stopped. */
  _cleanupCachedDimensions() {
    this._boundaryRect = this._previewRect = void 0;
    this._parentPositions.clear();
  }
  /**
   * Checks whether the element is still inside its boundary after the viewport has been resized.
   * If not, the position is adjusted so that the element fits again.
   */
  _containInsideBoundaryOnResize() {
    let {
      x,
      y
    } = this._passiveTransform;
    if (x === 0 && y === 0 || this.isDragging() || !this._boundaryElement) {
      return;
    }
    const elementRect = this._rootElement.getBoundingClientRect();
    const boundaryRect = this._boundaryElement.getBoundingClientRect();
    if (boundaryRect.width === 0 && boundaryRect.height === 0 || elementRect.width === 0 && elementRect.height === 0) {
      return;
    }
    const leftOverflow = boundaryRect.left - elementRect.left;
    const rightOverflow = elementRect.right - boundaryRect.right;
    const topOverflow = boundaryRect.top - elementRect.top;
    const bottomOverflow = elementRect.bottom - boundaryRect.bottom;
    if (boundaryRect.width > elementRect.width) {
      if (leftOverflow > 0) {
        x += leftOverflow;
      }
      if (rightOverflow > 0) {
        x -= rightOverflow;
      }
    } else {
      x = 0;
    }
    if (boundaryRect.height > elementRect.height) {
      if (topOverflow > 0) {
        y += topOverflow;
      }
      if (bottomOverflow > 0) {
        y -= bottomOverflow;
      }
    } else {
      y = 0;
    }
    if (x !== this._passiveTransform.x || y !== this._passiveTransform.y) {
      this.setFreeDragPosition({
        y,
        x
      });
    }
  }
  /** Gets the drag start delay, based on the event type. */
  _getDragStartDelay(event) {
    const value = this.dragStartDelay;
    if (typeof value === "number") {
      return value;
    } else if (isTouchEvent(event)) {
      return value.touch;
    }
    return value ? value.mouse : 0;
  }
  /** Updates the internal state of the draggable element when scrolling has occurred. */
  _updateOnScroll(event) {
    const scrollDifference = this._parentPositions.handleScroll(event);
    if (scrollDifference) {
      const target = _getEventTarget(event);
      if (this._boundaryRect && target !== this._boundaryElement && target.contains(this._boundaryElement)) {
        adjustDomRect(this._boundaryRect, scrollDifference.top, scrollDifference.left);
      }
      this._pickupPositionOnPage.x += scrollDifference.left;
      this._pickupPositionOnPage.y += scrollDifference.top;
      if (!this._dropContainer) {
        this._activeTransform.x -= scrollDifference.left;
        this._activeTransform.y -= scrollDifference.top;
        this._applyRootElementTransform(this._activeTransform.x, this._activeTransform.y);
      }
    }
  }
  /** Gets the scroll position of the viewport. */
  _getViewportScrollPosition() {
    return this._parentPositions.positions.get(this._document)?.scrollPosition || this._parentPositions.getViewportScrollPosition();
  }
  /**
   * Lazily resolves and returns the shadow root of the element. We do this in a function, rather
   * than saving it in property directly on init, because we want to resolve it as late as possible
   * in order to ensure that the element has been moved into the shadow DOM. Doing it inside the
   * constructor might be too early if the element is inside of something like `ngFor` or `ngIf`.
   */
  _getShadowRoot() {
    if (this._cachedShadowRoot === void 0) {
      this._cachedShadowRoot = _getShadowRoot(this._rootElement);
    }
    return this._cachedShadowRoot;
  }
  /** Gets the element into which the drag preview should be inserted. */
  _getPreviewInsertionPoint(initialParent, shadowRoot) {
    const previewContainer = this._previewContainer || "global";
    if (previewContainer === "parent") {
      return initialParent;
    }
    if (previewContainer === "global") {
      const documentRef = this._document;
      return shadowRoot || documentRef.fullscreenElement || documentRef.webkitFullscreenElement || documentRef.mozFullScreenElement || documentRef.msFullscreenElement || documentRef.body;
    }
    return coerceElement(previewContainer);
  }
  /** Lazily resolves and returns the dimensions of the preview. */
  _getPreviewRect() {
    if (!this._previewRect || !this._previewRect.width && !this._previewRect.height) {
      this._previewRect = this._preview ? this._preview.getBoundingClientRect() : this._initialDomRect;
    }
    return this._previewRect;
  }
  /** Gets a handle that is the target of an event. */
  _getTargetHandle(event) {
    return this._handles.find((handle) => {
      return event.target && (event.target === handle || handle.contains(event.target));
    });
  }
};
function clamp$1(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function isTouchEvent(event) {
  return event.type[0] === "t";
}
function shadowDomSelectStart(event) {
  event.preventDefault();
}
function moveItemInArray(array, fromIndex, toIndex) {
  const from = clamp(fromIndex, array.length - 1);
  const to = clamp(toIndex, array.length - 1);
  if (from === to) {
    return;
  }
  const target = array[from];
  const delta = to < from ? -1 : 1;
  for (let i2 = from; i2 !== to; i2 += delta) {
    array[i2] = array[i2 + delta];
  }
  array[to] = target;
}
function clamp(value, max) {
  return Math.max(0, Math.min(max, value));
}
var SingleAxisSortStrategy = class {
  constructor(_element, _dragDropRegistry) {
    this._element = _element;
    this._dragDropRegistry = _dragDropRegistry;
    this._itemPositions = [];
    this.orientation = "vertical";
    this._previousSwap = {
      drag: null,
      delta: 0,
      overlaps: false
    };
  }
  /**
   * To be called when the drag sequence starts.
   * @param items Items that are currently in the list.
   */
  start(items) {
    this.withItems(items);
  }
  /**
   * To be called when an item is being sorted.
   * @param item Item to be sorted.
   * @param pointerX Position of the item along the X axis.
   * @param pointerY Position of the item along the Y axis.
   * @param pointerDelta Direction in which the pointer is moving along each axis.
   */
  sort(item, pointerX, pointerY, pointerDelta) {
    const siblings = this._itemPositions;
    const newIndex = this._getItemIndexFromPointerPosition(item, pointerX, pointerY, pointerDelta);
    if (newIndex === -1 && siblings.length > 0) {
      return null;
    }
    const isHorizontal = this.orientation === "horizontal";
    const currentIndex = siblings.findIndex((currentItem) => currentItem.drag === item);
    const siblingAtNewPosition = siblings[newIndex];
    const currentPosition = siblings[currentIndex].clientRect;
    const newPosition = siblingAtNewPosition.clientRect;
    const delta = currentIndex > newIndex ? 1 : -1;
    const itemOffset = this._getItemOffsetPx(currentPosition, newPosition, delta);
    const siblingOffset = this._getSiblingOffsetPx(currentIndex, siblings, delta);
    const oldOrder = siblings.slice();
    moveItemInArray(siblings, currentIndex, newIndex);
    siblings.forEach((sibling, index) => {
      if (oldOrder[index] === sibling) {
        return;
      }
      const isDraggedItem = sibling.drag === item;
      const offset = isDraggedItem ? itemOffset : siblingOffset;
      const elementToOffset = isDraggedItem ? item.getPlaceholderElement() : sibling.drag.getRootElement();
      sibling.offset += offset;
      if (isHorizontal) {
        elementToOffset.style.transform = combineTransforms(`translate3d(${Math.round(sibling.offset)}px, 0, 0)`, sibling.initialTransform);
        adjustDomRect(sibling.clientRect, 0, offset);
      } else {
        elementToOffset.style.transform = combineTransforms(`translate3d(0, ${Math.round(sibling.offset)}px, 0)`, sibling.initialTransform);
        adjustDomRect(sibling.clientRect, offset, 0);
      }
    });
    this._previousSwap.overlaps = isInsideClientRect(newPosition, pointerX, pointerY);
    this._previousSwap.drag = siblingAtNewPosition.drag;
    this._previousSwap.delta = isHorizontal ? pointerDelta.x : pointerDelta.y;
    return {
      previousIndex: currentIndex,
      currentIndex: newIndex
    };
  }
  /**
   * Called when an item is being moved into the container.
   * @param item Item that was moved into the container.
   * @param pointerX Position of the item along the X axis.
   * @param pointerY Position of the item along the Y axis.
   * @param index Index at which the item entered. If omitted, the container will try to figure it
   *   out automatically.
   */
  enter(item, pointerX, pointerY, index) {
    const newIndex = index == null || index < 0 ? (
      // We use the coordinates of where the item entered the drop
      // zone to figure out at which index it should be inserted.
      this._getItemIndexFromPointerPosition(item, pointerX, pointerY)
    ) : index;
    const activeDraggables = this._activeDraggables;
    const currentIndex = activeDraggables.indexOf(item);
    const placeholder = item.getPlaceholderElement();
    let newPositionReference = activeDraggables[newIndex];
    if (newPositionReference === item) {
      newPositionReference = activeDraggables[newIndex + 1];
    }
    if (!newPositionReference && (newIndex == null || newIndex === -1 || newIndex < activeDraggables.length - 1) && this._shouldEnterAsFirstChild(pointerX, pointerY)) {
      newPositionReference = activeDraggables[0];
    }
    if (currentIndex > -1) {
      activeDraggables.splice(currentIndex, 1);
    }
    if (newPositionReference && !this._dragDropRegistry.isDragging(newPositionReference)) {
      const element = newPositionReference.getRootElement();
      element.parentElement.insertBefore(placeholder, element);
      activeDraggables.splice(newIndex, 0, item);
    } else {
      coerceElement(this._element).appendChild(placeholder);
      activeDraggables.push(item);
    }
    placeholder.style.transform = "";
    this._cacheItemPositions();
  }
  /** Sets the items that are currently part of the list. */
  withItems(items) {
    this._activeDraggables = items.slice();
    this._cacheItemPositions();
  }
  /** Assigns a sort predicate to the strategy. */
  withSortPredicate(predicate) {
    this._sortPredicate = predicate;
  }
  /** Resets the strategy to its initial state before dragging was started. */
  reset() {
    this._activeDraggables.forEach((item) => {
      const rootElement = item.getRootElement();
      if (rootElement) {
        const initialTransform = this._itemPositions.find((p2) => p2.drag === item)?.initialTransform;
        rootElement.style.transform = initialTransform || "";
      }
    });
    this._itemPositions = [];
    this._activeDraggables = [];
    this._previousSwap.drag = null;
    this._previousSwap.delta = 0;
    this._previousSwap.overlaps = false;
  }
  /**
   * Gets a snapshot of items currently in the list.
   * Can include items that we dragged in from another list.
   */
  getActiveItemsSnapshot() {
    return this._activeDraggables;
  }
  /** Gets the index of a specific item. */
  getItemIndex(item) {
    const items = this.orientation === "horizontal" && this.direction === "rtl" ? this._itemPositions.slice().reverse() : this._itemPositions;
    return items.findIndex((currentItem) => currentItem.drag === item);
  }
  /** Used to notify the strategy that the scroll position has changed. */
  updateOnScroll(topDifference, leftDifference) {
    this._itemPositions.forEach(({
      clientRect
    }) => {
      adjustDomRect(clientRect, topDifference, leftDifference);
    });
    this._itemPositions.forEach(({
      drag
    }) => {
      if (this._dragDropRegistry.isDragging(drag)) {
        drag._sortFromLastPointerPosition();
      }
    });
  }
  /** Refreshes the position cache of the items and sibling containers. */
  _cacheItemPositions() {
    const isHorizontal = this.orientation === "horizontal";
    this._itemPositions = this._activeDraggables.map((drag) => {
      const elementToMeasure = drag.getVisibleElement();
      return {
        drag,
        offset: 0,
        initialTransform: elementToMeasure.style.transform || "",
        clientRect: getMutableClientRect(elementToMeasure)
      };
    }).sort((a4, b) => {
      return isHorizontal ? a4.clientRect.left - b.clientRect.left : a4.clientRect.top - b.clientRect.top;
    });
  }
  /**
   * Gets the offset in pixels by which the item that is being dragged should be moved.
   * @param currentPosition Current position of the item.
   * @param newPosition Position of the item where the current item should be moved.
   * @param delta Direction in which the user is moving.
   */
  _getItemOffsetPx(currentPosition, newPosition, delta) {
    const isHorizontal = this.orientation === "horizontal";
    let itemOffset = isHorizontal ? newPosition.left - currentPosition.left : newPosition.top - currentPosition.top;
    if (delta === -1) {
      itemOffset += isHorizontal ? newPosition.width - currentPosition.width : newPosition.height - currentPosition.height;
    }
    return itemOffset;
  }
  /**
   * Gets the offset in pixels by which the items that aren't being dragged should be moved.
   * @param currentIndex Index of the item currently being dragged.
   * @param siblings All of the items in the list.
   * @param delta Direction in which the user is moving.
   */
  _getSiblingOffsetPx(currentIndex, siblings, delta) {
    const isHorizontal = this.orientation === "horizontal";
    const currentPosition = siblings[currentIndex].clientRect;
    const immediateSibling = siblings[currentIndex + delta * -1];
    let siblingOffset = currentPosition[isHorizontal ? "width" : "height"] * delta;
    if (immediateSibling) {
      const start = isHorizontal ? "left" : "top";
      const end = isHorizontal ? "right" : "bottom";
      if (delta === -1) {
        siblingOffset -= immediateSibling.clientRect[start] - currentPosition[end];
      } else {
        siblingOffset += currentPosition[start] - immediateSibling.clientRect[end];
      }
    }
    return siblingOffset;
  }
  /**
   * Checks if pointer is entering in the first position
   * @param pointerX Position of the user's pointer along the X axis.
   * @param pointerY Position of the user's pointer along the Y axis.
   */
  _shouldEnterAsFirstChild(pointerX, pointerY) {
    if (!this._activeDraggables.length) {
      return false;
    }
    const itemPositions = this._itemPositions;
    const isHorizontal = this.orientation === "horizontal";
    const reversed = itemPositions[0].drag !== this._activeDraggables[0];
    if (reversed) {
      const lastItemRect = itemPositions[itemPositions.length - 1].clientRect;
      return isHorizontal ? pointerX >= lastItemRect.right : pointerY >= lastItemRect.bottom;
    } else {
      const firstItemRect = itemPositions[0].clientRect;
      return isHorizontal ? pointerX <= firstItemRect.left : pointerY <= firstItemRect.top;
    }
  }
  /**
   * Gets the index of an item in the drop container, based on the position of the user's pointer.
   * @param item Item that is being sorted.
   * @param pointerX Position of the user's pointer along the X axis.
   * @param pointerY Position of the user's pointer along the Y axis.
   * @param delta Direction in which the user is moving their pointer.
   */
  _getItemIndexFromPointerPosition(item, pointerX, pointerY, delta) {
    const isHorizontal = this.orientation === "horizontal";
    const index = this._itemPositions.findIndex(({
      drag,
      clientRect
    }) => {
      if (drag === item) {
        return false;
      }
      if (delta) {
        const direction = isHorizontal ? delta.x : delta.y;
        if (drag === this._previousSwap.drag && this._previousSwap.overlaps && direction === this._previousSwap.delta) {
          return false;
        }
      }
      return isHorizontal ? (
        // Round these down since most browsers report client rects with
        // sub-pixel precision, whereas the pointer coordinates are rounded to pixels.
        pointerX >= Math.floor(clientRect.left) && pointerX < Math.floor(clientRect.right)
      ) : pointerY >= Math.floor(clientRect.top) && pointerY < Math.floor(clientRect.bottom);
    });
    return index === -1 || !this._sortPredicate(index, item) ? -1 : index;
  }
};
var DROP_PROXIMITY_THRESHOLD = 0.05;
var SCROLL_PROXIMITY_THRESHOLD = 0.05;
var AutoScrollVerticalDirection;
(function(AutoScrollVerticalDirection2) {
  AutoScrollVerticalDirection2[AutoScrollVerticalDirection2["NONE"] = 0] = "NONE";
  AutoScrollVerticalDirection2[AutoScrollVerticalDirection2["UP"] = 1] = "UP";
  AutoScrollVerticalDirection2[AutoScrollVerticalDirection2["DOWN"] = 2] = "DOWN";
})(AutoScrollVerticalDirection || (AutoScrollVerticalDirection = {}));
var AutoScrollHorizontalDirection;
(function(AutoScrollHorizontalDirection2) {
  AutoScrollHorizontalDirection2[AutoScrollHorizontalDirection2["NONE"] = 0] = "NONE";
  AutoScrollHorizontalDirection2[AutoScrollHorizontalDirection2["LEFT"] = 1] = "LEFT";
  AutoScrollHorizontalDirection2[AutoScrollHorizontalDirection2["RIGHT"] = 2] = "RIGHT";
})(AutoScrollHorizontalDirection || (AutoScrollHorizontalDirection = {}));
var DropListRef = class {
  constructor(element, _dragDropRegistry, _document, _ngZone, _viewportRuler) {
    this._dragDropRegistry = _dragDropRegistry;
    this._ngZone = _ngZone;
    this._viewportRuler = _viewportRuler;
    this.disabled = false;
    this.sortingDisabled = false;
    this.autoScrollDisabled = false;
    this.autoScrollStep = 2;
    this.enterPredicate = () => true;
    this.sortPredicate = () => true;
    this.beforeStarted = new Subject();
    this.entered = new Subject();
    this.exited = new Subject();
    this.dropped = new Subject();
    this.sorted = new Subject();
    this.receivingStarted = new Subject();
    this.receivingStopped = new Subject();
    this._isDragging = false;
    this._draggables = [];
    this._siblings = [];
    this._activeSiblings = /* @__PURE__ */ new Set();
    this._viewportScrollSubscription = Subscription.EMPTY;
    this._verticalScrollDirection = AutoScrollVerticalDirection.NONE;
    this._horizontalScrollDirection = AutoScrollHorizontalDirection.NONE;
    this._stopScrollTimers = new Subject();
    this._cachedShadowRoot = null;
    this._startScrollInterval = () => {
      this._stopScrolling();
      interval(0, animationFrameScheduler).pipe(takeUntil(this._stopScrollTimers)).subscribe(() => {
        const node = this._scrollNode;
        const scrollStep = this.autoScrollStep;
        if (this._verticalScrollDirection === AutoScrollVerticalDirection.UP) {
          node.scrollBy(0, -scrollStep);
        } else if (this._verticalScrollDirection === AutoScrollVerticalDirection.DOWN) {
          node.scrollBy(0, scrollStep);
        }
        if (this._horizontalScrollDirection === AutoScrollHorizontalDirection.LEFT) {
          node.scrollBy(-scrollStep, 0);
        } else if (this._horizontalScrollDirection === AutoScrollHorizontalDirection.RIGHT) {
          node.scrollBy(scrollStep, 0);
        }
      });
    };
    this.element = coerceElement(element);
    this._document = _document;
    this.withScrollableParents([this.element]);
    _dragDropRegistry.registerDropContainer(this);
    this._parentPositions = new ParentPositionTracker(_document);
    this._sortStrategy = new SingleAxisSortStrategy(this.element, _dragDropRegistry);
    this._sortStrategy.withSortPredicate((index, item) => this.sortPredicate(index, item, this));
  }
  /** Removes the drop list functionality from the DOM element. */
  dispose() {
    this._stopScrolling();
    this._stopScrollTimers.complete();
    this._viewportScrollSubscription.unsubscribe();
    this.beforeStarted.complete();
    this.entered.complete();
    this.exited.complete();
    this.dropped.complete();
    this.sorted.complete();
    this.receivingStarted.complete();
    this.receivingStopped.complete();
    this._activeSiblings.clear();
    this._scrollNode = null;
    this._parentPositions.clear();
    this._dragDropRegistry.removeDropContainer(this);
  }
  /** Whether an item from this list is currently being dragged. */
  isDragging() {
    return this._isDragging;
  }
  /** Starts dragging an item. */
  start() {
    this._draggingStarted();
    this._notifyReceivingSiblings();
  }
  /**
   * Attempts to move an item into the container.
   * @param item Item that was moved into the container.
   * @param pointerX Position of the item along the X axis.
   * @param pointerY Position of the item along the Y axis.
   * @param index Index at which the item entered. If omitted, the container will try to figure it
   *   out automatically.
   */
  enter(item, pointerX, pointerY, index) {
    this._draggingStarted();
    if (index == null && this.sortingDisabled) {
      index = this._draggables.indexOf(item);
    }
    this._sortStrategy.enter(item, pointerX, pointerY, index);
    this._cacheParentPositions();
    this._notifyReceivingSiblings();
    this.entered.next({
      item,
      container: this,
      currentIndex: this.getItemIndex(item)
    });
  }
  /**
   * Removes an item from the container after it was dragged into another container by the user.
   * @param item Item that was dragged out.
   */
  exit(item) {
    this._reset();
    this.exited.next({
      item,
      container: this
    });
  }
  /**
   * Drops an item into this container.
   * @param item Item being dropped into the container.
   * @param currentIndex Index at which the item should be inserted.
   * @param previousIndex Index of the item when dragging started.
   * @param previousContainer Container from which the item got dragged in.
   * @param isPointerOverContainer Whether the user's pointer was over the
   *    container when the item was dropped.
   * @param distance Distance the user has dragged since the start of the dragging sequence.
   * @param event Event that triggered the dropping sequence.
   *
   * @breaking-change 15.0.0 `previousIndex` and `event` parameters to become required.
   */
  drop(item, currentIndex, previousIndex, previousContainer, isPointerOverContainer, distance, dropPoint, event = {}) {
    this._reset();
    this.dropped.next({
      item,
      currentIndex,
      previousIndex,
      container: this,
      previousContainer,
      isPointerOverContainer,
      distance,
      dropPoint,
      event
    });
  }
  /**
   * Sets the draggable items that are a part of this list.
   * @param items Items that are a part of this list.
   */
  withItems(items) {
    const previousItems = this._draggables;
    this._draggables = items;
    items.forEach((item) => item._withDropContainer(this));
    if (this.isDragging()) {
      const draggedItems = previousItems.filter((item) => item.isDragging());
      if (draggedItems.every((item) => items.indexOf(item) === -1)) {
        this._reset();
      } else {
        this._sortStrategy.withItems(this._draggables);
      }
    }
    return this;
  }
  /** Sets the layout direction of the drop list. */
  withDirection(direction) {
    this._sortStrategy.direction = direction;
    return this;
  }
  /**
   * Sets the containers that are connected to this one. When two or more containers are
   * connected, the user will be allowed to transfer items between them.
   * @param connectedTo Other containers that the current containers should be connected to.
   */
  connectedTo(connectedTo) {
    this._siblings = connectedTo.slice();
    return this;
  }
  /**
   * Sets the orientation of the container.
   * @param orientation New orientation for the container.
   */
  withOrientation(orientation) {
    this._sortStrategy.orientation = orientation;
    return this;
  }
  /**
   * Sets which parent elements are can be scrolled while the user is dragging.
   * @param elements Elements that can be scrolled.
   */
  withScrollableParents(elements) {
    const element = coerceElement(this.element);
    this._scrollableElements = elements.indexOf(element) === -1 ? [element, ...elements] : elements.slice();
    return this;
  }
  /** Gets the scrollable parents that are registered with this drop container. */
  getScrollableParents() {
    return this._scrollableElements;
  }
  /**
   * Figures out the index of an item in the container.
   * @param item Item whose index should be determined.
   */
  getItemIndex(item) {
    return this._isDragging ? this._sortStrategy.getItemIndex(item) : this._draggables.indexOf(item);
  }
  /**
   * Whether the list is able to receive the item that
   * is currently being dragged inside a connected drop list.
   */
  isReceiving() {
    return this._activeSiblings.size > 0;
  }
  /**
   * Sorts an item inside the container based on its position.
   * @param item Item to be sorted.
   * @param pointerX Position of the item along the X axis.
   * @param pointerY Position of the item along the Y axis.
   * @param pointerDelta Direction in which the pointer is moving along each axis.
   */
  _sortItem(item, pointerX, pointerY, pointerDelta) {
    if (this.sortingDisabled || !this._domRect || !isPointerNearDomRect(this._domRect, DROP_PROXIMITY_THRESHOLD, pointerX, pointerY)) {
      return;
    }
    const result = this._sortStrategy.sort(item, pointerX, pointerY, pointerDelta);
    if (result) {
      this.sorted.next({
        previousIndex: result.previousIndex,
        currentIndex: result.currentIndex,
        container: this,
        item
      });
    }
  }
  /**
   * Checks whether the user's pointer is close to the edges of either the
   * viewport or the drop list and starts the auto-scroll sequence.
   * @param pointerX User's pointer position along the x axis.
   * @param pointerY User's pointer position along the y axis.
   */
  _startScrollingIfNecessary(pointerX, pointerY) {
    if (this.autoScrollDisabled) {
      return;
    }
    let scrollNode;
    let verticalScrollDirection = AutoScrollVerticalDirection.NONE;
    let horizontalScrollDirection = AutoScrollHorizontalDirection.NONE;
    this._parentPositions.positions.forEach((position, element) => {
      if (element === this._document || !position.clientRect || scrollNode) {
        return;
      }
      if (isPointerNearDomRect(position.clientRect, DROP_PROXIMITY_THRESHOLD, pointerX, pointerY)) {
        [verticalScrollDirection, horizontalScrollDirection] = getElementScrollDirections(element, position.clientRect, this._sortStrategy.direction, pointerX, pointerY);
        if (verticalScrollDirection || horizontalScrollDirection) {
          scrollNode = element;
        }
      }
    });
    if (!verticalScrollDirection && !horizontalScrollDirection) {
      const {
        width,
        height
      } = this._viewportRuler.getViewportSize();
      const domRect = {
        width,
        height,
        top: 0,
        right: width,
        bottom: height,
        left: 0
      };
      verticalScrollDirection = getVerticalScrollDirection(domRect, pointerY);
      horizontalScrollDirection = getHorizontalScrollDirection(domRect, pointerX);
      scrollNode = window;
    }
    if (scrollNode && (verticalScrollDirection !== this._verticalScrollDirection || horizontalScrollDirection !== this._horizontalScrollDirection || scrollNode !== this._scrollNode)) {
      this._verticalScrollDirection = verticalScrollDirection;
      this._horizontalScrollDirection = horizontalScrollDirection;
      this._scrollNode = scrollNode;
      if ((verticalScrollDirection || horizontalScrollDirection) && scrollNode) {
        this._ngZone.runOutsideAngular(this._startScrollInterval);
      } else {
        this._stopScrolling();
      }
    }
  }
  /** Stops any currently-running auto-scroll sequences. */
  _stopScrolling() {
    this._stopScrollTimers.next();
  }
  /** Starts the dragging sequence within the list. */
  _draggingStarted() {
    const styles = coerceElement(this.element).style;
    this.beforeStarted.next();
    this._isDragging = true;
    this._initialScrollSnap = styles.msScrollSnapType || styles.scrollSnapType || "";
    styles.scrollSnapType = styles.msScrollSnapType = "none";
    this._sortStrategy.start(this._draggables);
    this._cacheParentPositions();
    this._viewportScrollSubscription.unsubscribe();
    this._listenToScrollEvents();
  }
  /** Caches the positions of the configured scrollable parents. */
  _cacheParentPositions() {
    const element = coerceElement(this.element);
    this._parentPositions.cache(this._scrollableElements);
    this._domRect = this._parentPositions.positions.get(element).clientRect;
  }
  /** Resets the container to its initial state. */
  _reset() {
    this._isDragging = false;
    const styles = coerceElement(this.element).style;
    styles.scrollSnapType = styles.msScrollSnapType = this._initialScrollSnap;
    this._siblings.forEach((sibling) => sibling._stopReceiving(this));
    this._sortStrategy.reset();
    this._stopScrolling();
    this._viewportScrollSubscription.unsubscribe();
    this._parentPositions.clear();
  }
  /**
   * Checks whether the user's pointer is positioned over the container.
   * @param x Pointer position along the X axis.
   * @param y Pointer position along the Y axis.
   */
  _isOverContainer(x, y) {
    return this._domRect != null && isInsideClientRect(this._domRect, x, y);
  }
  /**
   * Figures out whether an item should be moved into a sibling
   * drop container, based on its current position.
   * @param item Drag item that is being moved.
   * @param x Position of the item along the X axis.
   * @param y Position of the item along the Y axis.
   */
  _getSiblingContainerFromPosition(item, x, y) {
    return this._siblings.find((sibling) => sibling._canReceive(item, x, y));
  }
  /**
   * Checks whether the drop list can receive the passed-in item.
   * @param item Item that is being dragged into the list.
   * @param x Position of the item along the X axis.
   * @param y Position of the item along the Y axis.
   */
  _canReceive(item, x, y) {
    if (!this._domRect || !isInsideClientRect(this._domRect, x, y) || !this.enterPredicate(item, this)) {
      return false;
    }
    const elementFromPoint = this._getShadowRoot().elementFromPoint(x, y);
    if (!elementFromPoint) {
      return false;
    }
    const nativeElement = coerceElement(this.element);
    return elementFromPoint === nativeElement || nativeElement.contains(elementFromPoint);
  }
  /**
   * Called by one of the connected drop lists when a dragging sequence has started.
   * @param sibling Sibling in which dragging has started.
   */
  _startReceiving(sibling, items) {
    const activeSiblings = this._activeSiblings;
    if (!activeSiblings.has(sibling) && items.every((item) => {
      return this.enterPredicate(item, this) || this._draggables.indexOf(item) > -1;
    })) {
      activeSiblings.add(sibling);
      this._cacheParentPositions();
      this._listenToScrollEvents();
      this.receivingStarted.next({
        initiator: sibling,
        receiver: this,
        items
      });
    }
  }
  /**
   * Called by a connected drop list when dragging has stopped.
   * @param sibling Sibling whose dragging has stopped.
   */
  _stopReceiving(sibling) {
    this._activeSiblings.delete(sibling);
    this._viewportScrollSubscription.unsubscribe();
    this.receivingStopped.next({
      initiator: sibling,
      receiver: this
    });
  }
  /**
   * Starts listening to scroll events on the viewport.
   * Used for updating the internal state of the list.
   */
  _listenToScrollEvents() {
    this._viewportScrollSubscription = this._dragDropRegistry.scrolled(this._getShadowRoot()).subscribe((event) => {
      if (this.isDragging()) {
        const scrollDifference = this._parentPositions.handleScroll(event);
        if (scrollDifference) {
          this._sortStrategy.updateOnScroll(scrollDifference.top, scrollDifference.left);
        }
      } else if (this.isReceiving()) {
        this._cacheParentPositions();
      }
    });
  }
  /**
   * Lazily resolves and returns the shadow root of the element. We do this in a function, rather
   * than saving it in property directly on init, because we want to resolve it as late as possible
   * in order to ensure that the element has been moved into the shadow DOM. Doing it inside the
   * constructor might be too early if the element is inside of something like `ngFor` or `ngIf`.
   */
  _getShadowRoot() {
    if (!this._cachedShadowRoot) {
      const shadowRoot = _getShadowRoot(coerceElement(this.element));
      this._cachedShadowRoot = shadowRoot || this._document;
    }
    return this._cachedShadowRoot;
  }
  /** Notifies any siblings that may potentially receive the item. */
  _notifyReceivingSiblings() {
    const draggedItems = this._sortStrategy.getActiveItemsSnapshot().filter((item) => item.isDragging());
    this._siblings.forEach((sibling) => sibling._startReceiving(this, draggedItems));
  }
};
function getVerticalScrollDirection(clientRect, pointerY) {
  const {
    top,
    bottom,
    height
  } = clientRect;
  const yThreshold = height * SCROLL_PROXIMITY_THRESHOLD;
  if (pointerY >= top - yThreshold && pointerY <= top + yThreshold) {
    return AutoScrollVerticalDirection.UP;
  } else if (pointerY >= bottom - yThreshold && pointerY <= bottom + yThreshold) {
    return AutoScrollVerticalDirection.DOWN;
  }
  return AutoScrollVerticalDirection.NONE;
}
function getHorizontalScrollDirection(clientRect, pointerX) {
  const {
    left,
    right,
    width
  } = clientRect;
  const xThreshold = width * SCROLL_PROXIMITY_THRESHOLD;
  if (pointerX >= left - xThreshold && pointerX <= left + xThreshold) {
    return AutoScrollHorizontalDirection.LEFT;
  } else if (pointerX >= right - xThreshold && pointerX <= right + xThreshold) {
    return AutoScrollHorizontalDirection.RIGHT;
  }
  return AutoScrollHorizontalDirection.NONE;
}
function getElementScrollDirections(element, clientRect, direction, pointerX, pointerY) {
  const computedVertical = getVerticalScrollDirection(clientRect, pointerY);
  const computedHorizontal = getHorizontalScrollDirection(clientRect, pointerX);
  let verticalScrollDirection = AutoScrollVerticalDirection.NONE;
  let horizontalScrollDirection = AutoScrollHorizontalDirection.NONE;
  if (computedVertical) {
    const scrollTop = element.scrollTop;
    if (computedVertical === AutoScrollVerticalDirection.UP) {
      if (scrollTop > 0) {
        verticalScrollDirection = AutoScrollVerticalDirection.UP;
      }
    } else if (element.scrollHeight - scrollTop > element.clientHeight) {
      verticalScrollDirection = AutoScrollVerticalDirection.DOWN;
    }
  }
  if (computedHorizontal) {
    const scrollLeft = element.scrollLeft;
    if (direction === "rtl") {
      if (computedHorizontal === AutoScrollHorizontalDirection.RIGHT) {
        if (scrollLeft < 0) {
          horizontalScrollDirection = AutoScrollHorizontalDirection.RIGHT;
        }
      } else if (element.scrollWidth + scrollLeft > element.clientWidth) {
        horizontalScrollDirection = AutoScrollHorizontalDirection.LEFT;
      }
    } else {
      if (computedHorizontal === AutoScrollHorizontalDirection.LEFT) {
        if (scrollLeft > 0) {
          horizontalScrollDirection = AutoScrollHorizontalDirection.LEFT;
        }
      } else if (element.scrollWidth - scrollLeft > element.clientWidth) {
        horizontalScrollDirection = AutoScrollHorizontalDirection.RIGHT;
      }
    }
  }
  return [verticalScrollDirection, horizontalScrollDirection];
}
var activeCapturingEventOptions = normalizePassiveListenerOptions({
  passive: false,
  capture: true
});
var activeApps = /* @__PURE__ */ new Set();
var __ResetsLoader = class __ResetsLoader {
};
__ResetsLoader.ɵfac = function _ResetsLoader_Factory(t3) {
  return new (t3 || __ResetsLoader)();
};
__ResetsLoader.ɵcmp = ɵɵdefineComponent({
  type: __ResetsLoader,
  selectors: [["ng-component"]],
  hostAttrs: ["cdk-drag-resets-container", ""],
  standalone: true,
  features: [ɵɵStandaloneFeature],
  decls: 0,
  vars: 0,
  template: function _ResetsLoader_Template(rf, ctx) {
  },
  styles: ["@layer cdk-resets{.cdk-drag-preview{background:none;border:none;padding:0;color:inherit}}"],
  encapsulation: 2,
  changeDetection: 0
});
var _ResetsLoader = __ResetsLoader;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(_ResetsLoader, [{
    type: Component,
    args: [{
      standalone: true,
      encapsulation: ViewEncapsulation$1.None,
      template: "",
      changeDetection: ChangeDetectionStrategy.OnPush,
      host: {
        "cdk-drag-resets-container": ""
      },
      styles: ["@layer cdk-resets{.cdk-drag-preview{background:none;border:none;padding:0;color:inherit}}"]
    }]
  }], null, null);
})();
var _DragDropRegistry = class _DragDropRegistry {
  constructor(_ngZone, _document) {
    this._ngZone = _ngZone;
    this._appRef = inject(ApplicationRef);
    this._environmentInjector = inject(EnvironmentInjector);
    this._dropInstances = /* @__PURE__ */ new Set();
    this._dragInstances = /* @__PURE__ */ new Set();
    this._activeDragInstances = [];
    this._globalListeners = /* @__PURE__ */ new Map();
    this._draggingPredicate = (item) => item.isDragging();
    this.pointerMove = new Subject();
    this.pointerUp = new Subject();
    this.scroll = new Subject();
    this._preventDefaultWhileDragging = (event) => {
      if (this._activeDragInstances.length > 0) {
        event.preventDefault();
      }
    };
    this._persistentTouchmoveListener = (event) => {
      if (this._activeDragInstances.length > 0) {
        if (this._activeDragInstances.some(this._draggingPredicate)) {
          event.preventDefault();
        }
        this.pointerMove.next(event);
      }
    };
    this._document = _document;
  }
  /** Adds a drop container to the registry. */
  registerDropContainer(drop) {
    if (!this._dropInstances.has(drop)) {
      this._dropInstances.add(drop);
    }
  }
  /** Adds a drag item instance to the registry. */
  registerDragItem(drag) {
    this._dragInstances.add(drag);
    if (this._dragInstances.size === 1) {
      this._ngZone.runOutsideAngular(() => {
        this._document.addEventListener("touchmove", this._persistentTouchmoveListener, activeCapturingEventOptions);
      });
    }
  }
  /** Removes a drop container from the registry. */
  removeDropContainer(drop) {
    this._dropInstances.delete(drop);
  }
  /** Removes a drag item instance from the registry. */
  removeDragItem(drag) {
    this._dragInstances.delete(drag);
    this.stopDragging(drag);
    if (this._dragInstances.size === 0) {
      this._document.removeEventListener("touchmove", this._persistentTouchmoveListener, activeCapturingEventOptions);
    }
  }
  /**
   * Starts the dragging sequence for a drag instance.
   * @param drag Drag instance which is being dragged.
   * @param event Event that initiated the dragging.
   */
  startDragging(drag, event) {
    if (this._activeDragInstances.indexOf(drag) > -1) {
      return;
    }
    this._loadResets();
    this._activeDragInstances.push(drag);
    if (this._activeDragInstances.length === 1) {
      const isTouchEvent2 = event.type.startsWith("touch");
      this._globalListeners.set(isTouchEvent2 ? "touchend" : "mouseup", {
        handler: (e5) => this.pointerUp.next(e5),
        options: true
      }).set("scroll", {
        handler: (e5) => this.scroll.next(e5),
        // Use capturing so that we pick up scroll changes in any scrollable nodes that aren't
        // the document. See https://github.com/angular/components/issues/17144.
        options: true
      }).set("selectstart", {
        handler: this._preventDefaultWhileDragging,
        options: activeCapturingEventOptions
      });
      if (!isTouchEvent2) {
        this._globalListeners.set("mousemove", {
          handler: (e5) => this.pointerMove.next(e5),
          options: activeCapturingEventOptions
        });
      }
      this._ngZone.runOutsideAngular(() => {
        this._globalListeners.forEach((config, name) => {
          this._document.addEventListener(name, config.handler, config.options);
        });
      });
    }
  }
  /** Stops dragging a drag item instance. */
  stopDragging(drag) {
    const index = this._activeDragInstances.indexOf(drag);
    if (index > -1) {
      this._activeDragInstances.splice(index, 1);
      if (this._activeDragInstances.length === 0) {
        this._clearGlobalListeners();
      }
    }
  }
  /** Gets whether a drag item instance is currently being dragged. */
  isDragging(drag) {
    return this._activeDragInstances.indexOf(drag) > -1;
  }
  /**
   * Gets a stream that will emit when any element on the page is scrolled while an item is being
   * dragged.
   * @param shadowRoot Optional shadow root that the current dragging sequence started from.
   *   Top-level listeners won't pick up events coming from the shadow DOM so this parameter can
   *   be used to include an additional top-level listener at the shadow root level.
   */
  scrolled(shadowRoot) {
    const streams = [this.scroll];
    if (shadowRoot && shadowRoot !== this._document) {
      streams.push(new Observable((observer) => {
        return this._ngZone.runOutsideAngular(() => {
          const eventOptions = true;
          const callback = (event) => {
            if (this._activeDragInstances.length) {
              observer.next(event);
            }
          };
          shadowRoot.addEventListener("scroll", callback, eventOptions);
          return () => {
            shadowRoot.removeEventListener("scroll", callback, eventOptions);
          };
        });
      }));
    }
    return merge(...streams);
  }
  ngOnDestroy() {
    this._dragInstances.forEach((instance) => this.removeDragItem(instance));
    this._dropInstances.forEach((instance) => this.removeDropContainer(instance));
    this._clearGlobalListeners();
    this.pointerMove.complete();
    this.pointerUp.complete();
  }
  /** Clears out the global event listeners from the `document`. */
  _clearGlobalListeners() {
    this._globalListeners.forEach((config, name) => {
      this._document.removeEventListener(name, config.handler, config.options);
    });
    this._globalListeners.clear();
  }
  // TODO(crisbeto): abstract this away into something reusable.
  /** Loads the CSS resets needed for the module to work correctly. */
  _loadResets() {
    if (!activeApps.has(this._appRef)) {
      activeApps.add(this._appRef);
      const componentRef = createComponent(_ResetsLoader, {
        environmentInjector: this._environmentInjector
      });
      this._appRef.onDestroy(() => {
        activeApps.delete(this._appRef);
        if (activeApps.size === 0) {
          componentRef.destroy();
        }
      });
    }
  }
};
_DragDropRegistry.ɵfac = function DragDropRegistry_Factory(t3) {
  return new (t3 || _DragDropRegistry)(ɵɵinject(NgZone), ɵɵinject(DOCUMENT));
};
_DragDropRegistry.ɵprov = ɵɵdefineInjectable({
  token: _DragDropRegistry,
  factory: _DragDropRegistry.ɵfac,
  providedIn: "root"
});
var DragDropRegistry = _DragDropRegistry;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DragDropRegistry, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: NgZone
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }], null);
})();
var DEFAULT_CONFIG = {
  dragStartThreshold: 5,
  pointerDirectionChangeThreshold: 5
};
var _DragDrop = class _DragDrop {
  constructor(_document, _ngZone, _viewportRuler, _dragDropRegistry) {
    this._document = _document;
    this._ngZone = _ngZone;
    this._viewportRuler = _viewportRuler;
    this._dragDropRegistry = _dragDropRegistry;
  }
  /**
   * Turns an element into a draggable item.
   * @param element Element to which to attach the dragging functionality.
   * @param config Object used to configure the dragging behavior.
   */
  createDrag(element, config = DEFAULT_CONFIG) {
    return new DragRef(element, config, this._document, this._ngZone, this._viewportRuler, this._dragDropRegistry);
  }
  /**
   * Turns an element into a drop list.
   * @param element Element to which to attach the drop list functionality.
   */
  createDropList(element) {
    return new DropListRef(element, this._dragDropRegistry, this._document, this._ngZone, this._viewportRuler);
  }
};
_DragDrop.ɵfac = function DragDrop_Factory(t3) {
  return new (t3 || _DragDrop)(ɵɵinject(DOCUMENT), ɵɵinject(NgZone), ɵɵinject(ViewportRuler), ɵɵinject(DragDropRegistry));
};
_DragDrop.ɵprov = ɵɵdefineInjectable({
  token: _DragDrop,
  factory: _DragDrop.ɵfac,
  providedIn: "root"
});
var DragDrop = _DragDrop;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DragDrop, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: NgZone
  }, {
    type: ViewportRuler
  }, {
    type: DragDropRegistry
  }], null);
})();
var CDK_DRAG_PARENT = new InjectionToken("CDK_DRAG_PARENT");
function assertElementNode(node, name) {
  if (node.nodeType !== 1) {
    throw Error(`${name} must be attached to an element node. Currently attached to "${node.nodeName}".`);
  }
}
var CDK_DRAG_HANDLE = new InjectionToken("CdkDragHandle");
var _CdkDragHandle = class _CdkDragHandle {
  /** Whether starting to drag through this handle is disabled. */
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    this._disabled = value;
    this._stateChanges.next(this);
  }
  constructor(element, _parentDrag) {
    this.element = element;
    this._parentDrag = _parentDrag;
    this._stateChanges = new Subject();
    this._disabled = false;
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      assertElementNode(element.nativeElement, "cdkDragHandle");
    }
    _parentDrag?._addHandle(this);
  }
  ngOnDestroy() {
    this._parentDrag?._removeHandle(this);
    this._stateChanges.complete();
  }
};
_CdkDragHandle.ɵfac = function CdkDragHandle_Factory(t3) {
  return new (t3 || _CdkDragHandle)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(CDK_DRAG_PARENT, 12));
};
_CdkDragHandle.ɵdir = ɵɵdefineDirective({
  type: _CdkDragHandle,
  selectors: [["", "cdkDragHandle", ""]],
  hostAttrs: [1, "cdk-drag-handle"],
  inputs: {
    disabled: [InputFlags.HasDecoratorInputTransform, "cdkDragHandleDisabled", "disabled", booleanAttribute]
  },
  standalone: true,
  features: [ɵɵProvidersFeature([{
    provide: CDK_DRAG_HANDLE,
    useExisting: _CdkDragHandle
  }]), ɵɵInputTransformsFeature]
});
var CdkDragHandle = _CdkDragHandle;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkDragHandle, [{
    type: Directive,
    args: [{
      selector: "[cdkDragHandle]",
      standalone: true,
      host: {
        "class": "cdk-drag-handle"
      },
      providers: [{
        provide: CDK_DRAG_HANDLE,
        useExisting: CdkDragHandle
      }]
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [CDK_DRAG_PARENT]
    }, {
      type: Optional
    }, {
      type: SkipSelf
    }]
  }], {
    disabled: [{
      type: Input,
      args: [{
        alias: "cdkDragHandleDisabled",
        transform: booleanAttribute
      }]
    }]
  });
})();
var CDK_DRAG_CONFIG = new InjectionToken("CDK_DRAG_CONFIG");
var DRAG_HOST_CLASS = "cdk-drag";
var CDK_DROP_LIST = new InjectionToken("CdkDropList");
var _CdkDrag = class _CdkDrag {
  /** Whether starting to drag this element is disabled. */
  get disabled() {
    return this._disabled || this.dropContainer && this.dropContainer.disabled;
  }
  set disabled(value) {
    this._disabled = value;
    this._dragRef.disabled = this._disabled;
  }
  constructor(element, dropContainer, _document, _ngZone, _viewContainerRef, config, _dir, dragDrop, _changeDetectorRef, _selfHandle, _parentDrag) {
    this.element = element;
    this.dropContainer = dropContainer;
    this._ngZone = _ngZone;
    this._viewContainerRef = _viewContainerRef;
    this._dir = _dir;
    this._changeDetectorRef = _changeDetectorRef;
    this._selfHandle = _selfHandle;
    this._parentDrag = _parentDrag;
    this._destroyed = new Subject();
    this._handles = new BehaviorSubject([]);
    this.started = new EventEmitter();
    this.released = new EventEmitter();
    this.ended = new EventEmitter();
    this.entered = new EventEmitter();
    this.exited = new EventEmitter();
    this.dropped = new EventEmitter();
    this.moved = new Observable((observer) => {
      const subscription = this._dragRef.moved.pipe(map((movedEvent) => ({
        source: this,
        pointerPosition: movedEvent.pointerPosition,
        event: movedEvent.event,
        delta: movedEvent.delta,
        distance: movedEvent.distance
      }))).subscribe(observer);
      return () => {
        subscription.unsubscribe();
      };
    });
    this._dragRef = dragDrop.createDrag(element, {
      dragStartThreshold: config && config.dragStartThreshold != null ? config.dragStartThreshold : 5,
      pointerDirectionChangeThreshold: config && config.pointerDirectionChangeThreshold != null ? config.pointerDirectionChangeThreshold : 5,
      zIndex: config?.zIndex
    });
    this._dragRef.data = this;
    _CdkDrag._dragInstances.push(this);
    if (config) {
      this._assignDefaults(config);
    }
    if (dropContainer) {
      this._dragRef._withDropContainer(dropContainer._dropListRef);
      dropContainer.addItem(this);
    }
    this._syncInputs(this._dragRef);
    this._handleEvents(this._dragRef);
  }
  /**
   * Returns the element that is being used as a placeholder
   * while the current element is being dragged.
   */
  getPlaceholderElement() {
    return this._dragRef.getPlaceholderElement();
  }
  /** Returns the root draggable element. */
  getRootElement() {
    return this._dragRef.getRootElement();
  }
  /** Resets a standalone drag item to its initial position. */
  reset() {
    this._dragRef.reset();
  }
  /**
   * Gets the pixel coordinates of the draggable outside of a drop container.
   */
  getFreeDragPosition() {
    return this._dragRef.getFreeDragPosition();
  }
  /**
   * Sets the current position in pixels the draggable outside of a drop container.
   * @param value New position to be set.
   */
  setFreeDragPosition(value) {
    this._dragRef.setFreeDragPosition(value);
  }
  ngAfterViewInit() {
    this._ngZone.runOutsideAngular(() => {
      this._ngZone.onStable.pipe(take(1), takeUntil(this._destroyed)).subscribe(() => {
        this._updateRootElement();
        this._setupHandlesListener();
        if (this.freeDragPosition) {
          this._dragRef.setFreeDragPosition(this.freeDragPosition);
        }
      });
    });
  }
  ngOnChanges(changes) {
    const rootSelectorChange = changes["rootElementSelector"];
    const positionChange = changes["freeDragPosition"];
    if (rootSelectorChange && !rootSelectorChange.firstChange) {
      this._updateRootElement();
    }
    if (positionChange && !positionChange.firstChange && this.freeDragPosition) {
      this._dragRef.setFreeDragPosition(this.freeDragPosition);
    }
  }
  ngOnDestroy() {
    if (this.dropContainer) {
      this.dropContainer.removeItem(this);
    }
    const index = _CdkDrag._dragInstances.indexOf(this);
    if (index > -1) {
      _CdkDrag._dragInstances.splice(index, 1);
    }
    this._ngZone.runOutsideAngular(() => {
      this._handles.complete();
      this._destroyed.next();
      this._destroyed.complete();
      this._dragRef.dispose();
    });
  }
  _addHandle(handle) {
    const handles = this._handles.getValue();
    handles.push(handle);
    this._handles.next(handles);
  }
  _removeHandle(handle) {
    const handles = this._handles.getValue();
    const index = handles.indexOf(handle);
    if (index > -1) {
      handles.splice(index, 1);
      this._handles.next(handles);
    }
  }
  _setPreviewTemplate(preview) {
    this._previewTemplate = preview;
  }
  _resetPreviewTemplate(preview) {
    if (preview === this._previewTemplate) {
      this._previewTemplate = null;
    }
  }
  _setPlaceholderTemplate(placeholder) {
    this._placeholderTemplate = placeholder;
  }
  _resetPlaceholderTemplate(placeholder) {
    if (placeholder === this._placeholderTemplate) {
      this._placeholderTemplate = null;
    }
  }
  /** Syncs the root element with the `DragRef`. */
  _updateRootElement() {
    const element = this.element.nativeElement;
    let rootElement = element;
    if (this.rootElementSelector) {
      rootElement = element.closest !== void 0 ? element.closest(this.rootElementSelector) : (
        // Comment tag doesn't have closest method, so use parent's one.
        element.parentElement?.closest(this.rootElementSelector)
      );
    }
    if (rootElement && (typeof ngDevMode === "undefined" || ngDevMode)) {
      assertElementNode(rootElement, "cdkDrag");
    }
    this._dragRef.withRootElement(rootElement || element);
  }
  /** Gets the boundary element, based on the `boundaryElement` value. */
  _getBoundaryElement() {
    const boundary = this.boundaryElement;
    if (!boundary) {
      return null;
    }
    if (typeof boundary === "string") {
      return this.element.nativeElement.closest(boundary);
    }
    return coerceElement(boundary);
  }
  /** Syncs the inputs of the CdkDrag with the options of the underlying DragRef. */
  _syncInputs(ref) {
    ref.beforeStarted.subscribe(() => {
      if (!ref.isDragging()) {
        const dir = this._dir;
        const dragStartDelay = this.dragStartDelay;
        const placeholder = this._placeholderTemplate ? {
          template: this._placeholderTemplate.templateRef,
          context: this._placeholderTemplate.data,
          viewContainer: this._viewContainerRef
        } : null;
        const preview = this._previewTemplate ? {
          template: this._previewTemplate.templateRef,
          context: this._previewTemplate.data,
          matchSize: this._previewTemplate.matchSize,
          viewContainer: this._viewContainerRef
        } : null;
        ref.disabled = this.disabled;
        ref.lockAxis = this.lockAxis;
        ref.dragStartDelay = typeof dragStartDelay === "object" && dragStartDelay ? dragStartDelay : coerceNumberProperty(dragStartDelay);
        ref.constrainPosition = this.constrainPosition;
        ref.previewClass = this.previewClass;
        ref.withBoundaryElement(this._getBoundaryElement()).withPlaceholderTemplate(placeholder).withPreviewTemplate(preview).withPreviewContainer(this.previewContainer || "global");
        if (dir) {
          ref.withDirection(dir.value);
        }
      }
    });
    ref.beforeStarted.pipe(take(1)).subscribe(() => {
      if (this._parentDrag) {
        ref.withParent(this._parentDrag._dragRef);
        return;
      }
      let parent = this.element.nativeElement.parentElement;
      while (parent) {
        if (parent.classList.contains(DRAG_HOST_CLASS)) {
          ref.withParent(_CdkDrag._dragInstances.find((drag) => {
            return drag.element.nativeElement === parent;
          })?._dragRef || null);
          break;
        }
        parent = parent.parentElement;
      }
    });
  }
  /** Handles the events from the underlying `DragRef`. */
  _handleEvents(ref) {
    ref.started.subscribe((startEvent) => {
      this.started.emit({
        source: this,
        event: startEvent.event
      });
      this._changeDetectorRef.markForCheck();
    });
    ref.released.subscribe((releaseEvent) => {
      this.released.emit({
        source: this,
        event: releaseEvent.event
      });
    });
    ref.ended.subscribe((endEvent) => {
      this.ended.emit({
        source: this,
        distance: endEvent.distance,
        dropPoint: endEvent.dropPoint,
        event: endEvent.event
      });
      this._changeDetectorRef.markForCheck();
    });
    ref.entered.subscribe((enterEvent) => {
      this.entered.emit({
        container: enterEvent.container.data,
        item: this,
        currentIndex: enterEvent.currentIndex
      });
    });
    ref.exited.subscribe((exitEvent) => {
      this.exited.emit({
        container: exitEvent.container.data,
        item: this
      });
    });
    ref.dropped.subscribe((dropEvent) => {
      this.dropped.emit({
        previousIndex: dropEvent.previousIndex,
        currentIndex: dropEvent.currentIndex,
        previousContainer: dropEvent.previousContainer.data,
        container: dropEvent.container.data,
        isPointerOverContainer: dropEvent.isPointerOverContainer,
        item: this,
        distance: dropEvent.distance,
        dropPoint: dropEvent.dropPoint,
        event: dropEvent.event
      });
    });
  }
  /** Assigns the default input values based on a provided config object. */
  _assignDefaults(config) {
    const {
      lockAxis,
      dragStartDelay,
      constrainPosition,
      previewClass,
      boundaryElement,
      draggingDisabled,
      rootElementSelector,
      previewContainer
    } = config;
    this.disabled = draggingDisabled == null ? false : draggingDisabled;
    this.dragStartDelay = dragStartDelay || 0;
    if (lockAxis) {
      this.lockAxis = lockAxis;
    }
    if (constrainPosition) {
      this.constrainPosition = constrainPosition;
    }
    if (previewClass) {
      this.previewClass = previewClass;
    }
    if (boundaryElement) {
      this.boundaryElement = boundaryElement;
    }
    if (rootElementSelector) {
      this.rootElementSelector = rootElementSelector;
    }
    if (previewContainer) {
      this.previewContainer = previewContainer;
    }
  }
  /** Sets up the listener that syncs the handles with the drag ref. */
  _setupHandlesListener() {
    this._handles.pipe(
      // Sync the new handles with the DragRef.
      tap((handles) => {
        const handleElements = handles.map((handle) => handle.element);
        if (this._selfHandle && this.rootElementSelector) {
          handleElements.push(this.element);
        }
        this._dragRef.withHandles(handleElements);
      }),
      // Listen if the state of any of the handles changes.
      switchMap((handles) => {
        return merge(...handles.map((item) => item._stateChanges.pipe(startWith(item))));
      }),
      takeUntil(this._destroyed)
    ).subscribe((handleInstance) => {
      const dragRef = this._dragRef;
      const handle = handleInstance.element.nativeElement;
      handleInstance.disabled ? dragRef.disableHandle(handle) : dragRef.enableHandle(handle);
    });
  }
};
_CdkDrag._dragInstances = [];
_CdkDrag.ɵfac = function CdkDrag_Factory(t3) {
  return new (t3 || _CdkDrag)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(CDK_DROP_LIST, 12), ɵɵdirectiveInject(DOCUMENT), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(CDK_DRAG_CONFIG, 8), ɵɵdirectiveInject(Directionality, 8), ɵɵdirectiveInject(DragDrop), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(CDK_DRAG_HANDLE, 10), ɵɵdirectiveInject(CDK_DRAG_PARENT, 12));
};
_CdkDrag.ɵdir = ɵɵdefineDirective({
  type: _CdkDrag,
  selectors: [["", "cdkDrag", ""]],
  hostAttrs: [1, "cdk-drag"],
  hostVars: 4,
  hostBindings: function CdkDrag_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("cdk-drag-disabled", ctx.disabled)("cdk-drag-dragging", ctx._dragRef.isDragging());
    }
  },
  inputs: {
    data: [InputFlags.None, "cdkDragData", "data"],
    lockAxis: [InputFlags.None, "cdkDragLockAxis", "lockAxis"],
    rootElementSelector: [InputFlags.None, "cdkDragRootElement", "rootElementSelector"],
    boundaryElement: [InputFlags.None, "cdkDragBoundary", "boundaryElement"],
    dragStartDelay: [InputFlags.None, "cdkDragStartDelay", "dragStartDelay"],
    freeDragPosition: [InputFlags.None, "cdkDragFreeDragPosition", "freeDragPosition"],
    disabled: [InputFlags.HasDecoratorInputTransform, "cdkDragDisabled", "disabled", booleanAttribute],
    constrainPosition: [InputFlags.None, "cdkDragConstrainPosition", "constrainPosition"],
    previewClass: [InputFlags.None, "cdkDragPreviewClass", "previewClass"],
    previewContainer: [InputFlags.None, "cdkDragPreviewContainer", "previewContainer"]
  },
  outputs: {
    started: "cdkDragStarted",
    released: "cdkDragReleased",
    ended: "cdkDragEnded",
    entered: "cdkDragEntered",
    exited: "cdkDragExited",
    dropped: "cdkDragDropped",
    moved: "cdkDragMoved"
  },
  exportAs: ["cdkDrag"],
  standalone: true,
  features: [ɵɵProvidersFeature([{
    provide: CDK_DRAG_PARENT,
    useExisting: _CdkDrag
  }]), ɵɵInputTransformsFeature, ɵɵNgOnChangesFeature]
});
var CdkDrag = _CdkDrag;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkDrag, [{
    type: Directive,
    args: [{
      selector: "[cdkDrag]",
      exportAs: "cdkDrag",
      standalone: true,
      host: {
        "class": DRAG_HOST_CLASS,
        "[class.cdk-drag-disabled]": "disabled",
        "[class.cdk-drag-dragging]": "_dragRef.isDragging()"
      },
      providers: [{
        provide: CDK_DRAG_PARENT,
        useExisting: CdkDrag
      }]
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [CDK_DROP_LIST]
    }, {
      type: Optional
    }, {
      type: SkipSelf
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: NgZone
  }, {
    type: ViewContainerRef
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [CDK_DRAG_CONFIG]
    }]
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }, {
    type: DragDrop
  }, {
    type: ChangeDetectorRef
  }, {
    type: CdkDragHandle,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [CDK_DRAG_HANDLE]
    }]
  }, {
    type: CdkDrag,
    decorators: [{
      type: Optional
    }, {
      type: SkipSelf
    }, {
      type: Inject,
      args: [CDK_DRAG_PARENT]
    }]
  }], {
    data: [{
      type: Input,
      args: ["cdkDragData"]
    }],
    lockAxis: [{
      type: Input,
      args: ["cdkDragLockAxis"]
    }],
    rootElementSelector: [{
      type: Input,
      args: ["cdkDragRootElement"]
    }],
    boundaryElement: [{
      type: Input,
      args: ["cdkDragBoundary"]
    }],
    dragStartDelay: [{
      type: Input,
      args: ["cdkDragStartDelay"]
    }],
    freeDragPosition: [{
      type: Input,
      args: ["cdkDragFreeDragPosition"]
    }],
    disabled: [{
      type: Input,
      args: [{
        alias: "cdkDragDisabled",
        transform: booleanAttribute
      }]
    }],
    constrainPosition: [{
      type: Input,
      args: ["cdkDragConstrainPosition"]
    }],
    previewClass: [{
      type: Input,
      args: ["cdkDragPreviewClass"]
    }],
    previewContainer: [{
      type: Input,
      args: ["cdkDragPreviewContainer"]
    }],
    started: [{
      type: Output,
      args: ["cdkDragStarted"]
    }],
    released: [{
      type: Output,
      args: ["cdkDragReleased"]
    }],
    ended: [{
      type: Output,
      args: ["cdkDragEnded"]
    }],
    entered: [{
      type: Output,
      args: ["cdkDragEntered"]
    }],
    exited: [{
      type: Output,
      args: ["cdkDragExited"]
    }],
    dropped: [{
      type: Output,
      args: ["cdkDragDropped"]
    }],
    moved: [{
      type: Output,
      args: ["cdkDragMoved"]
    }]
  });
})();
var CDK_DROP_LIST_GROUP = new InjectionToken("CdkDropListGroup");
var _CdkDropListGroup = class _CdkDropListGroup {
  constructor() {
    this._items = /* @__PURE__ */ new Set();
    this.disabled = false;
  }
  ngOnDestroy() {
    this._items.clear();
  }
};
_CdkDropListGroup.ɵfac = function CdkDropListGroup_Factory(t3) {
  return new (t3 || _CdkDropListGroup)();
};
_CdkDropListGroup.ɵdir = ɵɵdefineDirective({
  type: _CdkDropListGroup,
  selectors: [["", "cdkDropListGroup", ""]],
  inputs: {
    disabled: [InputFlags.HasDecoratorInputTransform, "cdkDropListGroupDisabled", "disabled", booleanAttribute]
  },
  exportAs: ["cdkDropListGroup"],
  standalone: true,
  features: [ɵɵProvidersFeature([{
    provide: CDK_DROP_LIST_GROUP,
    useExisting: _CdkDropListGroup
  }]), ɵɵInputTransformsFeature]
});
var CdkDropListGroup = _CdkDropListGroup;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkDropListGroup, [{
    type: Directive,
    args: [{
      selector: "[cdkDropListGroup]",
      exportAs: "cdkDropListGroup",
      standalone: true,
      providers: [{
        provide: CDK_DROP_LIST_GROUP,
        useExisting: CdkDropListGroup
      }]
    }]
  }], null, {
    disabled: [{
      type: Input,
      args: [{
        alias: "cdkDropListGroupDisabled",
        transform: booleanAttribute
      }]
    }]
  });
})();
var _uniqueIdCounter = 0;
var _CdkDropList = class _CdkDropList {
  /** Whether starting a dragging sequence from this container is disabled. */
  get disabled() {
    return this._disabled || !!this._group && this._group.disabled;
  }
  set disabled(value) {
    this._dropListRef.disabled = this._disabled = value;
  }
  constructor(element, dragDrop, _changeDetectorRef, _scrollDispatcher, _dir, _group, config) {
    this.element = element;
    this._changeDetectorRef = _changeDetectorRef;
    this._scrollDispatcher = _scrollDispatcher;
    this._dir = _dir;
    this._group = _group;
    this._destroyed = new Subject();
    this.connectedTo = [];
    this.id = `cdk-drop-list-${_uniqueIdCounter++}`;
    this.enterPredicate = () => true;
    this.sortPredicate = () => true;
    this.dropped = new EventEmitter();
    this.entered = new EventEmitter();
    this.exited = new EventEmitter();
    this.sorted = new EventEmitter();
    this._unsortedItems = /* @__PURE__ */ new Set();
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      assertElementNode(element.nativeElement, "cdkDropList");
    }
    this._dropListRef = dragDrop.createDropList(element);
    this._dropListRef.data = this;
    if (config) {
      this._assignDefaults(config);
    }
    this._dropListRef.enterPredicate = (drag, drop) => {
      return this.enterPredicate(drag.data, drop.data);
    };
    this._dropListRef.sortPredicate = (index, drag, drop) => {
      return this.sortPredicate(index, drag.data, drop.data);
    };
    this._setupInputSyncSubscription(this._dropListRef);
    this._handleEvents(this._dropListRef);
    _CdkDropList._dropLists.push(this);
    if (_group) {
      _group._items.add(this);
    }
  }
  /** Registers an items with the drop list. */
  addItem(item) {
    this._unsortedItems.add(item);
    if (this._dropListRef.isDragging()) {
      this._syncItemsWithRef();
    }
  }
  /** Removes an item from the drop list. */
  removeItem(item) {
    this._unsortedItems.delete(item);
    if (this._dropListRef.isDragging()) {
      this._syncItemsWithRef();
    }
  }
  /** Gets the registered items in the list, sorted by their position in the DOM. */
  getSortedItems() {
    return Array.from(this._unsortedItems).sort((a4, b) => {
      const documentPosition = a4._dragRef.getVisibleElement().compareDocumentPosition(b._dragRef.getVisibleElement());
      return documentPosition & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : 1;
    });
  }
  ngOnDestroy() {
    const index = _CdkDropList._dropLists.indexOf(this);
    if (index > -1) {
      _CdkDropList._dropLists.splice(index, 1);
    }
    if (this._group) {
      this._group._items.delete(this);
    }
    this._unsortedItems.clear();
    this._dropListRef.dispose();
    this._destroyed.next();
    this._destroyed.complete();
  }
  /** Syncs the inputs of the CdkDropList with the options of the underlying DropListRef. */
  _setupInputSyncSubscription(ref) {
    if (this._dir) {
      this._dir.change.pipe(startWith(this._dir.value), takeUntil(this._destroyed)).subscribe((value) => ref.withDirection(value));
    }
    ref.beforeStarted.subscribe(() => {
      const siblings = coerceArray(this.connectedTo).map((drop) => {
        if (typeof drop === "string") {
          const correspondingDropList = _CdkDropList._dropLists.find((list) => list.id === drop);
          if (!correspondingDropList && (typeof ngDevMode === "undefined" || ngDevMode)) {
            console.warn(`CdkDropList could not find connected drop list with id "${drop}"`);
          }
          return correspondingDropList;
        }
        return drop;
      });
      if (this._group) {
        this._group._items.forEach((drop) => {
          if (siblings.indexOf(drop) === -1) {
            siblings.push(drop);
          }
        });
      }
      if (!this._scrollableParentsResolved) {
        const scrollableParents = this._scrollDispatcher.getAncestorScrollContainers(this.element).map((scrollable) => scrollable.getElementRef().nativeElement);
        this._dropListRef.withScrollableParents(scrollableParents);
        this._scrollableParentsResolved = true;
      }
      ref.disabled = this.disabled;
      ref.lockAxis = this.lockAxis;
      ref.sortingDisabled = this.sortingDisabled;
      ref.autoScrollDisabled = this.autoScrollDisabled;
      ref.autoScrollStep = coerceNumberProperty(this.autoScrollStep, 2);
      ref.connectedTo(siblings.filter((drop) => drop && drop !== this).map((list) => list._dropListRef)).withOrientation(this.orientation);
    });
  }
  /** Handles events from the underlying DropListRef. */
  _handleEvents(ref) {
    ref.beforeStarted.subscribe(() => {
      this._syncItemsWithRef();
      this._changeDetectorRef.markForCheck();
    });
    ref.entered.subscribe((event) => {
      this.entered.emit({
        container: this,
        item: event.item.data,
        currentIndex: event.currentIndex
      });
    });
    ref.exited.subscribe((event) => {
      this.exited.emit({
        container: this,
        item: event.item.data
      });
      this._changeDetectorRef.markForCheck();
    });
    ref.sorted.subscribe((event) => {
      this.sorted.emit({
        previousIndex: event.previousIndex,
        currentIndex: event.currentIndex,
        container: this,
        item: event.item.data
      });
    });
    ref.dropped.subscribe((dropEvent) => {
      this.dropped.emit({
        previousIndex: dropEvent.previousIndex,
        currentIndex: dropEvent.currentIndex,
        previousContainer: dropEvent.previousContainer.data,
        container: dropEvent.container.data,
        item: dropEvent.item.data,
        isPointerOverContainer: dropEvent.isPointerOverContainer,
        distance: dropEvent.distance,
        dropPoint: dropEvent.dropPoint,
        event: dropEvent.event
      });
      this._changeDetectorRef.markForCheck();
    });
    merge(ref.receivingStarted, ref.receivingStopped).subscribe(() => this._changeDetectorRef.markForCheck());
  }
  /** Assigns the default input values based on a provided config object. */
  _assignDefaults(config) {
    const {
      lockAxis,
      draggingDisabled,
      sortingDisabled,
      listAutoScrollDisabled,
      listOrientation
    } = config;
    this.disabled = draggingDisabled == null ? false : draggingDisabled;
    this.sortingDisabled = sortingDisabled == null ? false : sortingDisabled;
    this.autoScrollDisabled = listAutoScrollDisabled == null ? false : listAutoScrollDisabled;
    this.orientation = listOrientation || "vertical";
    if (lockAxis) {
      this.lockAxis = lockAxis;
    }
  }
  /** Syncs up the registered drag items with underlying drop list ref. */
  _syncItemsWithRef() {
    this._dropListRef.withItems(this.getSortedItems().map((item) => item._dragRef));
  }
};
_CdkDropList._dropLists = [];
_CdkDropList.ɵfac = function CdkDropList_Factory(t3) {
  return new (t3 || _CdkDropList)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(DragDrop), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ScrollDispatcher), ɵɵdirectiveInject(Directionality, 8), ɵɵdirectiveInject(CDK_DROP_LIST_GROUP, 12), ɵɵdirectiveInject(CDK_DRAG_CONFIG, 8));
};
_CdkDropList.ɵdir = ɵɵdefineDirective({
  type: _CdkDropList,
  selectors: [["", "cdkDropList", ""], ["cdk-drop-list"]],
  hostAttrs: [1, "cdk-drop-list"],
  hostVars: 7,
  hostBindings: function CdkDropList_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("id", ctx.id);
      ɵɵclassProp("cdk-drop-list-disabled", ctx.disabled)("cdk-drop-list-dragging", ctx._dropListRef.isDragging())("cdk-drop-list-receiving", ctx._dropListRef.isReceiving());
    }
  },
  inputs: {
    connectedTo: [InputFlags.None, "cdkDropListConnectedTo", "connectedTo"],
    data: [InputFlags.None, "cdkDropListData", "data"],
    orientation: [InputFlags.None, "cdkDropListOrientation", "orientation"],
    id: "id",
    lockAxis: [InputFlags.None, "cdkDropListLockAxis", "lockAxis"],
    disabled: [InputFlags.HasDecoratorInputTransform, "cdkDropListDisabled", "disabled", booleanAttribute],
    sortingDisabled: [InputFlags.HasDecoratorInputTransform, "cdkDropListSortingDisabled", "sortingDisabled", booleanAttribute],
    enterPredicate: [InputFlags.None, "cdkDropListEnterPredicate", "enterPredicate"],
    sortPredicate: [InputFlags.None, "cdkDropListSortPredicate", "sortPredicate"],
    autoScrollDisabled: [InputFlags.HasDecoratorInputTransform, "cdkDropListAutoScrollDisabled", "autoScrollDisabled", booleanAttribute],
    autoScrollStep: [InputFlags.None, "cdkDropListAutoScrollStep", "autoScrollStep"]
  },
  outputs: {
    dropped: "cdkDropListDropped",
    entered: "cdkDropListEntered",
    exited: "cdkDropListExited",
    sorted: "cdkDropListSorted"
  },
  exportAs: ["cdkDropList"],
  standalone: true,
  features: [ɵɵProvidersFeature([
    // Prevent child drop lists from picking up the same group as their parent.
    {
      provide: CDK_DROP_LIST_GROUP,
      useValue: void 0
    },
    {
      provide: CDK_DROP_LIST,
      useExisting: _CdkDropList
    }
  ]), ɵɵInputTransformsFeature]
});
var CdkDropList = _CdkDropList;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkDropList, [{
    type: Directive,
    args: [{
      selector: "[cdkDropList], cdk-drop-list",
      exportAs: "cdkDropList",
      standalone: true,
      providers: [
        // Prevent child drop lists from picking up the same group as their parent.
        {
          provide: CDK_DROP_LIST_GROUP,
          useValue: void 0
        },
        {
          provide: CDK_DROP_LIST,
          useExisting: CdkDropList
        }
      ],
      host: {
        "class": "cdk-drop-list",
        "[attr.id]": "id",
        "[class.cdk-drop-list-disabled]": "disabled",
        "[class.cdk-drop-list-dragging]": "_dropListRef.isDragging()",
        "[class.cdk-drop-list-receiving]": "_dropListRef.isReceiving()"
      }
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: DragDrop
  }, {
    type: ChangeDetectorRef
  }, {
    type: ScrollDispatcher
  }, {
    type: Directionality,
    decorators: [{
      type: Optional
    }]
  }, {
    type: CdkDropListGroup,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [CDK_DROP_LIST_GROUP]
    }, {
      type: SkipSelf
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [CDK_DRAG_CONFIG]
    }]
  }], {
    connectedTo: [{
      type: Input,
      args: ["cdkDropListConnectedTo"]
    }],
    data: [{
      type: Input,
      args: ["cdkDropListData"]
    }],
    orientation: [{
      type: Input,
      args: ["cdkDropListOrientation"]
    }],
    id: [{
      type: Input
    }],
    lockAxis: [{
      type: Input,
      args: ["cdkDropListLockAxis"]
    }],
    disabled: [{
      type: Input,
      args: [{
        alias: "cdkDropListDisabled",
        transform: booleanAttribute
      }]
    }],
    sortingDisabled: [{
      type: Input,
      args: [{
        alias: "cdkDropListSortingDisabled",
        transform: booleanAttribute
      }]
    }],
    enterPredicate: [{
      type: Input,
      args: ["cdkDropListEnterPredicate"]
    }],
    sortPredicate: [{
      type: Input,
      args: ["cdkDropListSortPredicate"]
    }],
    autoScrollDisabled: [{
      type: Input,
      args: [{
        alias: "cdkDropListAutoScrollDisabled",
        transform: booleanAttribute
      }]
    }],
    autoScrollStep: [{
      type: Input,
      args: ["cdkDropListAutoScrollStep"]
    }],
    dropped: [{
      type: Output,
      args: ["cdkDropListDropped"]
    }],
    entered: [{
      type: Output,
      args: ["cdkDropListEntered"]
    }],
    exited: [{
      type: Output,
      args: ["cdkDropListExited"]
    }],
    sorted: [{
      type: Output,
      args: ["cdkDropListSorted"]
    }]
  });
})();
var CDK_DRAG_PREVIEW = new InjectionToken("CdkDragPreview");
var _CdkDragPreview = class _CdkDragPreview {
  constructor(templateRef) {
    this.templateRef = templateRef;
    this._drag = inject(CDK_DRAG_PARENT, {
      optional: true
    });
    this.matchSize = false;
    this._drag?._setPreviewTemplate(this);
  }
  ngOnDestroy() {
    this._drag?._resetPreviewTemplate(this);
  }
};
_CdkDragPreview.ɵfac = function CdkDragPreview_Factory(t3) {
  return new (t3 || _CdkDragPreview)(ɵɵdirectiveInject(TemplateRef));
};
_CdkDragPreview.ɵdir = ɵɵdefineDirective({
  type: _CdkDragPreview,
  selectors: [["ng-template", "cdkDragPreview", ""]],
  inputs: {
    data: "data",
    matchSize: [InputFlags.HasDecoratorInputTransform, "matchSize", "matchSize", booleanAttribute]
  },
  standalone: true,
  features: [ɵɵProvidersFeature([{
    provide: CDK_DRAG_PREVIEW,
    useExisting: _CdkDragPreview
  }]), ɵɵInputTransformsFeature]
});
var CdkDragPreview = _CdkDragPreview;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkDragPreview, [{
    type: Directive,
    args: [{
      selector: "ng-template[cdkDragPreview]",
      standalone: true,
      providers: [{
        provide: CDK_DRAG_PREVIEW,
        useExisting: CdkDragPreview
      }]
    }]
  }], () => [{
    type: TemplateRef
  }], {
    data: [{
      type: Input
    }],
    matchSize: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }]
  });
})();
var CDK_DRAG_PLACEHOLDER = new InjectionToken("CdkDragPlaceholder");
var _CdkDragPlaceholder = class _CdkDragPlaceholder {
  constructor(templateRef) {
    this.templateRef = templateRef;
    this._drag = inject(CDK_DRAG_PARENT, {
      optional: true
    });
    this._drag?._setPlaceholderTemplate(this);
  }
  ngOnDestroy() {
    this._drag?._resetPlaceholderTemplate(this);
  }
};
_CdkDragPlaceholder.ɵfac = function CdkDragPlaceholder_Factory(t3) {
  return new (t3 || _CdkDragPlaceholder)(ɵɵdirectiveInject(TemplateRef));
};
_CdkDragPlaceholder.ɵdir = ɵɵdefineDirective({
  type: _CdkDragPlaceholder,
  selectors: [["ng-template", "cdkDragPlaceholder", ""]],
  inputs: {
    data: "data"
  },
  standalone: true,
  features: [ɵɵProvidersFeature([{
    provide: CDK_DRAG_PLACEHOLDER,
    useExisting: _CdkDragPlaceholder
  }])]
});
var CdkDragPlaceholder = _CdkDragPlaceholder;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkDragPlaceholder, [{
    type: Directive,
    args: [{
      selector: "ng-template[cdkDragPlaceholder]",
      standalone: true,
      providers: [{
        provide: CDK_DRAG_PLACEHOLDER,
        useExisting: CdkDragPlaceholder
      }]
    }]
  }], () => [{
    type: TemplateRef
  }], {
    data: [{
      type: Input
    }]
  });
})();
var DRAG_DROP_DIRECTIVES = [CdkDropList, CdkDropListGroup, CdkDrag, CdkDragHandle, CdkDragPreview, CdkDragPlaceholder];
var _DragDropModule = class _DragDropModule {
};
_DragDropModule.ɵfac = function DragDropModule_Factory(t3) {
  return new (t3 || _DragDropModule)();
};
_DragDropModule.ɵmod = ɵɵdefineNgModule({
  type: _DragDropModule,
  imports: [CdkDropList, CdkDropListGroup, CdkDrag, CdkDragHandle, CdkDragPreview, CdkDragPlaceholder],
  exports: [CdkScrollableModule, CdkDropList, CdkDropListGroup, CdkDrag, CdkDragHandle, CdkDragPreview, CdkDragPlaceholder]
});
_DragDropModule.ɵinj = ɵɵdefineInjector({
  providers: [DragDrop],
  imports: [CdkScrollableModule]
});
var DragDropModule = _DragDropModule;
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DragDropModule, [{
    type: NgModule,
    args: [{
      imports: DRAG_DROP_DIRECTIVES,
      exports: [CdkScrollableModule, ...DRAG_DROP_DIRECTIVES],
      providers: [DragDrop]
    }]
  }], null, null);
})();

// node_modules/@cds/core/button-action/button-action.element.scss.js
var t2 = css`:host{--icon-width:var(--cds-global-space-7, calc(16 * 1rem / var(--cds-global-base, 20)));--icon-height:var(--cds-global-space-7, calc(16 * 1rem / var(--cds-global-base, 20)));--width:var(--icon-width);--height:var(--icon-width);--cursor:pointer;--color:var(--cds-global-typography-color-300, var(--cds-global-color-construction-800, #2d4048));--font-size:var(--cds-global-typography-font-size-3, calc(13 * 1rem / var(--cds-global-base, 20)));--background:transparent;--padding:0;--outline:var(--cds-alias-object-interaction-outline, Highlight solid 2px);--outline-offset:calc(var(--cds-alias-object-interaction-outline-offset, 1px) * -1);pointer-events:none;display:inline-block;outline:0!important}:host([role=button]){pointer-events:initial;cursor:var(--cursor)!important}:host([status=active]){--color:var(--cds-alias-status-info, var(--cds-global-color-blue-700, #0079ad))}::slotted([shape=close]),::slotted([shape=info-circle]),::slotted([shape=times]),:host([shape=close]),:host([shape=info-circle]){--icon-width:var(--cds-global-space-8, calc(18 * 1rem / var(--cds-global-base, 20)));--icon-height:var(--cds-global-space-8, calc(18 * 1rem / var(--cds-global-base, 20)))}:host(:hover){--color:var(--cds-alias-object-interaction-color-hover, var(--cds-global-color-construction-1000, #1b2b32))}:host(:active){--color:var(--cds-alias-object-interaction-color-active, var(--cds-global-color-construction-1000, #1b2b32))}:host(:active) .private-host{transform:translateY(calc(var(--cds-global-space-1,calc(1 * 1rem / var(--cds-global-base,20)))/ 2))}:host([disabled]){--color:var(--cds-alias-object-interaction-color-disabled, var(--cds-global-color-construction-300, #aeb8bc))}.private-host{--icon-color:var(--color);background:var(--background);padding:var(--padding);color:var(--color);font-size:var(--font-size);display:flex;justify-content:center;align-items:center;min-width:var(--width);min-height:var(--height)}::slotted(cds-icon),cds-icon{width:var(--icon-width);height:var(--icon-height);pointer-events:none}::slotted(cds-icon:not([status])),cds-icon{--color:var(--icon-color)}:host([disabled]:active){pointer-events:none!important}.private-host::after{content:"";position:absolute;left:calc(-1*var(--width) - 1);top:calc(-1*var(--height) - 1);width:var(--cds-alias-object-interaction-touch-target,calc(36 * 1rem / var(--cds-global-base,20)));height:var(--cds-alias-object-interaction-touch-target,calc(36 * 1rem / var(--cds-global-base,20)))}:host([disabled]) .private-host::after{outline:0!important}:host(:focus) .private-host::after{outline:var(--outline);outline-offset:var(--outline-offset)}@media (-webkit-min-device-pixel-ratio:0){:host(:focus) .private-host::after{outline-color:-webkit-focus-ring-color;outline-style:auto}}`;

// node_modules/@cds/core/button-action/button-action.element.js
var c = class extends m2 {
  constructor() {
    super(...arguments);
    this.i18n = a.keys.actions, this.cdsButtonAction = true;
  }
  render() {
    return html`<div class="private-host"><slot><cds-icon .shape="${this.shape ? this.shape : "ellipsis-vertical"}" .size="${this.iconSize}" ?solid="${this.pressed || this.expanded}" inner-offset="${1}"></cds-icon></slot></div>`;
  }
  updated(t3) {
    super.updated(t3), this.ariaLabel || this.readonly || n.warn("A aria-label is required for interactive cds-button-action type", this), t3.has("readonly") && (this.readonly && !this.hasAttribute("aria-label") ? this.ariaHidden = "true" : this.ariaHidden = null);
  }
};
c.styles = [o2, t2], __decorate([m({ type: String })], c.prototype, "shape", void 0), __decorate([m({ type: String, reflect: true })], c.prototype, "action", void 0), __decorate([m({ type: String })], c.prototype, "iconSize", void 0), __decorate([o()], c.prototype, "i18n", void 0), __decorate([p({ type: Boolean, reflect: true, attribute: "cds-button-action" })], c.prototype, "cdsButtonAction", void 0);

// node_modules/@cds/core/internal-components/close-button/close-button.element.js
var s = "cds-internal-close-button";
var r6 = class extends c {
  constructor() {
    super(...arguments);
    this.shape = "close";
  }
  connectedCallback() {
    super.connectedCallback(), this.ariaLabel = this.ariaLabel ? this.ariaLabel : this.i18n.close;
  }
};
__decorate([m({ type: String })], r6.prototype, "shape", void 0);

// node_modules/@cds/core/internal-components/close-button/register.js
w(s, r6), r.addIcons(o6), r.addAliases(["times", ["close"]]);

// node_modules/@clr/angular/fesm2020/clr-angular.mjs
var _c02 = ["*"];
var _c12 = [[["clr-accordion-title"], ["clr-step-title"]], [["clr-accordion-description"], ["clr-step-description"]], "*"];
var _c2 = ["clr-accordion-title, clr-step-title", "clr-accordion-description, clr-step-description", "*"];
function ClrAccordionPanel_ng_container_0_ng_container_15_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.stepErrorText(ctx_r1.panelNumber), " ");
  }
}
function ClrAccordionPanel_ng_container_0_ng_container_16_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.stepCompleteText(ctx_r1.panelNumber), " ");
  }
}
function ClrAccordionPanel_ng_container_0_div_18_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 13);
    ɵɵlistener("@toggle.done", function ClrAccordionPanel_ng_container_0_div_18_Template_div_animation_toggle_done_0_listener() {
      ɵɵrestoreView(_r3);
      const panel_r4 = ɵɵnextContext().$implicit;
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.collapsePanelOnAnimationDone(panel_r4));
    });
    ɵɵelementStart(1, "div", 14);
    ɵɵprojection(2, 2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    ɵɵproperty("@toggle", void 0);
  }
}
function ClrAccordionPanel_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "div", 2)(2, "div", 3)(3, "button", 4, 0);
    ɵɵpipe(5, "async");
    ɵɵlistener("click", function ClrAccordionPanel_ng_container_0_Template_button_click_3_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.togglePanel());
    });
    ɵɵelementStart(6, "span", 5);
    ɵɵelement(7, "cds-icon", 6);
    ɵɵelementStart(8, "span", 7);
    ɵɵtext(9);
    ɵɵelementEnd();
    ɵɵelement(10, "cds-icon", 8)(11, "cds-icon", 9);
    ɵɵelementEnd();
    ɵɵprojection(12);
    ɵɵprojection(13, 1);
    ɵɵelementEnd();
    ɵɵelementStart(14, "div", 10);
    ɵɵtemplate(15, ClrAccordionPanel_ng_container_0_ng_container_15_Template, 2, 1, "ng-container", 1)(16, ClrAccordionPanel_ng_container_0_ng_container_16_Template, 2, 1, "ng-container", 1);
    ɵɵelementEnd()();
    ɵɵelementStart(17, "div", 11);
    ɵɵtemplate(18, ClrAccordionPanel_ng_container_0_div_18_Template, 3, 1, "div", 12);
    ɵɵelementEnd()();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    let tmp_4_0;
    const panel_r4 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngClass", ctx_r1.getPanelStateClasses(panel_r4));
    ɵɵadvance(2);
    ɵɵclassProp("clr-accordion-header-has-description", ((tmp_4_0 = ɵɵpipeBind1(5, 16, ctx_r1.accordionDescription.changes)) == null ? null : tmp_4_0.length) || ctx_r1.accordionDescription.length);
    ɵɵproperty("id", ctx_r1.getAccordionHeaderId(panel_r4.templateId))("disabled", ctx_r1.isAccordion && panel_r4.disabled);
    ɵɵattribute("aria-disabled", !ctx_r1.isAccordion && panel_r4.disabled)("aria-controls", ctx_r1.getAccordionContentId(panel_r4.templateId))("aria-expanded", panel_r4.open);
    ɵɵadvance(6);
    ɵɵtextInterpolate1("", ctx_r1.panelNumber, ".");
    ɵɵadvance(6);
    ɵɵproperty("ngIf", panel_r4.status === ctx_r1.AccordionStatus.Error);
    ɵɵadvance();
    ɵɵproperty("ngIf", panel_r4.status === ctx_r1.AccordionStatus.Complete);
    ɵɵadvance();
    ɵɵproperty("@skipInitialRender", void 0)("id", ctx_r1.getAccordionContentId(panel_r4.templateId));
    ɵɵattribute("aria-hidden", !panel_r4.open)("aria-labelledby", ctx_r1.getAccordionHeaderId(panel_r4.templateId));
    ɵɵadvance();
    ɵɵproperty("ngIf", panel_r4.open);
  }
}
var _c3 = ["headerButton"];
function ClrStepperPanel_ng_container_0_ng_container_15_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.stepErrorText(ctx_r1.panelNumber), " ");
  }
}
function ClrStepperPanel_ng_container_0_ng_container_16_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtext(1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ctx_r1.stepCompleteText(ctx_r1.panelNumber), " ");
  }
}
function ClrStepperPanel_ng_container_0_div_18_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 13);
    ɵɵlistener("@toggle.done", function ClrStepperPanel_ng_container_0_div_18_Template_div_animation_toggle_done_0_listener() {
      ɵɵrestoreView(_r3);
      const panel_r4 = ɵɵnextContext().$implicit;
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.collapsePanelOnAnimationDone(panel_r4));
    });
    ɵɵelementStart(1, "div", 14);
    ɵɵprojection(2, 2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    ɵɵproperty("@toggle", void 0);
  }
}
function ClrStepperPanel_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "div", 2)(2, "div", 3)(3, "button", 4, 0);
    ɵɵpipe(5, "async");
    ɵɵlistener("click", function ClrStepperPanel_ng_container_0_Template_button_click_3_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.togglePanel());
    });
    ɵɵelementStart(6, "span", 5);
    ɵɵelement(7, "cds-icon", 6);
    ɵɵelementStart(8, "span", 7);
    ɵɵtext(9);
    ɵɵelementEnd();
    ɵɵelement(10, "cds-icon", 8)(11, "cds-icon", 9);
    ɵɵelementEnd();
    ɵɵprojection(12);
    ɵɵprojection(13, 1);
    ɵɵelementEnd();
    ɵɵelementStart(14, "div", 10);
    ɵɵtemplate(15, ClrStepperPanel_ng_container_0_ng_container_15_Template, 2, 1, "ng-container", 1)(16, ClrStepperPanel_ng_container_0_ng_container_16_Template, 2, 1, "ng-container", 1);
    ɵɵelementEnd()();
    ɵɵelementStart(17, "div", 11);
    ɵɵtemplate(18, ClrStepperPanel_ng_container_0_div_18_Template, 3, 1, "div", 12);
    ɵɵelementEnd()();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    let tmp_4_0;
    const panel_r4 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngClass", ctx_r1.getPanelStateClasses(panel_r4));
    ɵɵadvance(2);
    ɵɵclassProp("clr-accordion-header-has-description", ((tmp_4_0 = ɵɵpipeBind1(5, 16, ctx_r1.accordionDescription.changes)) == null ? null : tmp_4_0.length) || ctx_r1.accordionDescription.length);
    ɵɵproperty("id", ctx_r1.getAccordionHeaderId(panel_r4.templateId))("disabled", ctx_r1.isAccordion && panel_r4.disabled);
    ɵɵattribute("aria-disabled", !ctx_r1.isAccordion && panel_r4.disabled)("aria-controls", ctx_r1.getAccordionContentId(panel_r4.templateId))("aria-expanded", panel_r4.open);
    ɵɵadvance(6);
    ɵɵtextInterpolate1("", ctx_r1.panelNumber, ".");
    ɵɵadvance(6);
    ɵɵproperty("ngIf", panel_r4.status === ctx_r1.AccordionStatus.Error);
    ɵɵadvance();
    ɵɵproperty("ngIf", panel_r4.status === ctx_r1.AccordionStatus.Complete);
    ɵɵadvance();
    ɵɵproperty("@skipInitialRender", void 0)("id", ctx_r1.getAccordionContentId(panel_r4.templateId));
    ɵɵattribute("aria-hidden", !panel_r4.open)("aria-labelledby", ctx_r1.getAccordionHeaderId(panel_r4.templateId));
    ɵɵadvance();
    ɵɵproperty("ngIf", panel_r4.open);
  }
}
var _c4 = ["clrStepper", ""];
var _c5 = ["buttonProjectedRef"];
function ClrButton_ng_template_0_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 3);
  }
}
function ClrButton_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 1);
    ɵɵlistener("click", function ClrButton_ng_template_0_Template_button_click_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.emitClick());
    });
    ɵɵtemplate(1, ClrButton_ng_template_0_span_1_Template, 1, 0, "span", 2);
    ɵɵprojection(2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassMap(ctx_r1.classNames);
    ɵɵattribute("type", ctx_r1.type)("name", ctx_r1.name)("disabled", ctx_r1.disabled)("role", ctx_r1.role)("id", ctx_r1.id);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.loading);
  }
}
var _c6 = ["menuToggle"];
var _c7 = ["menu"];
function ClrButtonGroup_0_ng_template_0_Template(rf, ctx) {
}
function ClrButtonGroup_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ClrButtonGroup_0_ng_template_0_Template, 0, 0, "ng-template", 4);
  }
  if (rf & 2) {
    const inlineButton_r1 = ctx.$implicit;
    ɵɵproperty("ngTemplateOutlet", inlineButton_r1.templateRef);
  }
}
function ClrButtonGroup_div_1_div_4_2_ng_template_0_Template(rf, ctx) {
}
function ClrButtonGroup_div_1_div_4_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ClrButtonGroup_div_1_div_4_2_ng_template_0_Template, 0, 0, "ng-template", 4);
  }
  if (rf & 2) {
    const menuButton_r4 = ctx.$implicit;
    ɵɵproperty("ngTemplateOutlet", menuButton_r4.templateRef);
  }
}
function ClrButtonGroup_div_1_div_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 9, 1);
    ɵɵtemplate(2, ClrButtonGroup_div_1_div_4_2_Template, 1, 1, null, 2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵproperty("id", ctx_r2.popoverId);
    ɵɵattribute("id", ctx_r2.popoverId)("aria-hidden", !ctx_r2.open);
    ɵɵadvance(2);
    ɵɵproperty("ngForOf", ctx_r2.menuButtons);
  }
}
function ClrButtonGroup_div_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 5)(1, "button", 6, 0);
    ɵɵlistener("keydown.arrowup", function ClrButtonGroup_div_1_Template_button_keydown_arrowup_1_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.openMenu($event, ctx_r2.InitialFocus.LAST_ITEM));
    })("keydown.arrowdown", function ClrButtonGroup_div_1_Template_button_keydown_arrowdown_1_listener($event) {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.openMenu($event, ctx_r2.InitialFocus.FIRST_ITEM));
    });
    ɵɵelement(3, "cds-icon", 7);
    ɵɵelementEnd();
    ɵɵtemplate(4, ClrButtonGroup_div_1_div_4_Template, 3, 4, "div", 8);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("ngClass", ctx_r2.menuPosition);
    ɵɵadvance();
    ɵɵattribute("aria-controls", ctx_r2.popoverId)("aria-expanded", ctx_r2.open)("aria-label", ctx_r2.clrToggleButtonAriaLabel);
    ɵɵadvance(2);
    ɵɵattribute("title", ctx_r2.commonStrings.keys.more);
    ɵɵadvance();
    ɵɵproperty("clrPopoverContent", ctx_r2.open)("clrPopoverContentAt", ctx_r2.popoverPosition)("clrPopoverContentOutsideClickToClose", true)("clrPopoverContentScrollToClose", true);
  }
}
var _c8 = ["clrLoading", ""];
function ClrLoadingButton_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelement(1, "span", 3);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    ɵɵadvance();
    ɵɵproperty("@spinner", void 0);
  }
}
function ClrLoadingButton_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "span", 4);
    ɵɵlistener("@validated.done", function ClrLoadingButton_ng_container_2_Template_span_animation_validated_done_1_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.loadingStateChange(ctx_r1.buttonState.DEFAULT));
    });
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    ɵɵadvance();
    ɵɵproperty("@validated", void 0);
  }
}
function ClrLoadingButton_span_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 5);
    ɵɵprojection(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    ɵɵproperty("@defaultButton", void 0);
  }
}
var _c9 = [[["label"]], "*", [["clr-control-helper"]], [["clr-control-error"]], [["clr-control-success"]]];
var _c10 = ["label", "*", "clr-control-helper", "clr-control-error", "clr-control-success"];
function ClrControlContainer_label_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "label");
  }
}
function ClrControlContainer_cds_icon_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "cds-icon", 5);
  }
}
function ClrControlContainer_cds_icon_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "cds-icon", 6);
  }
}
function ClrControlContainer_ng_content_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 2, ["*ngIf", "showHelper"]);
  }
}
function ClrControlContainer_ng_content_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 3, ["*ngIf", "showInvalid"]);
  }
}
function ClrControlContainer_ng_content_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 4, ["*ngIf", "showValid"]);
  }
}
var _c11 = [[["", "clrCheckbox", ""], ["", "clrToggle", ""]], [["label"]]];
var _c122 = ["[clrCheckbox],[clrToggle]", "label"];
function ClrCheckboxWrapper_label_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "label");
  }
}
var _c13 = [[["label"]], [["clr-checkbox-wrapper"], ["clr-toggle-wrapper"]], [["clr-control-helper"]], [["clr-control-error"]], [["clr-control-success"]]];
var _c14 = ["label", "clr-checkbox-wrapper,clr-toggle-wrapper", "clr-control-helper", "clr-control-error", "clr-control-success"];
function ClrCheckboxContainer_label_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "label");
  }
}
function ClrCheckboxContainer_ng_content_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 2, ["*ngIf", "showHelper"]);
  }
}
function ClrCheckboxContainer_cds_icon_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "cds-icon", 5);
  }
}
function ClrCheckboxContainer_cds_icon_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "cds-icon", 6);
  }
}
function ClrCheckboxContainer_ng_content_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 3, ["*ngIf", "showInvalid"]);
  }
}
function ClrCheckboxContainer_ng_content_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 4, ["*ngIf", "showValid"]);
  }
}
var _c15 = ["clrKeyFocus", ""];
var _c16 = ["clrRovingTabindex", ""];
var _c17 = ["controlContainer"];
var _c18 = [[["label"]], [["clr-combobox"]], [["clr-control-helper"]], [["clr-control-error"]], [["clr-control-success"]]];
var _c19 = ["label", "clr-combobox", "clr-control-helper", "clr-control-error", "clr-control-success"];
function ClrComboboxContainer_label_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "label");
  }
}
function ClrComboboxContainer_cds_icon_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "cds-icon", 5);
  }
}
function ClrComboboxContainer_cds_icon_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "cds-icon", 6);
  }
}
function ClrComboboxContainer_ng_content_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 2, ["*ngIf", "showHelper"]);
  }
}
function ClrComboboxContainer_ng_content_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 3, ["*ngIf", "showInvalid"]);
  }
}
function ClrComboboxContainer_ng_content_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 4, ["*ngIf", "showValid"]);
  }
}
function ClrOption_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 1);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.commonStrings.keys.comboboxSelected);
  }
}
function ClrOptions_div_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 2)(1, "clr-spinner", 3);
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵelementStart(3, "span", 4);
    ɵɵtext(4);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", ctx_r0.commonStrings.keys.loading, " ");
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", ctx_r0.searchText(ctx_r0.optionSelectionService.currentInput), " ");
  }
}
function ClrOptions_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 5)(1, "span", 6);
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("id", ctx_r0.noResultsElementId);
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", ctx_r0.commonStrings.keys.comboboxNoResults, " ");
  }
}
var _c20 = ["textboxInput"];
var _c21 = ["trigger"];
var _c22 = (a0) => ({
  $implicit: a0
});
function ClrCombobox_span_1_span_1_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 18);
  }
  if (rf & 2) {
    const i_r3 = ɵɵnextContext().index;
    const ctx_r3 = ɵɵnextContext(2);
    ɵɵproperty("ngTemplateOutlet", ctx_r3.optionSelected.template)("ngTemplateOutletContext", ɵɵpureFunction1(2, _c22, ctx_r3.optionSelectionService.selectionModel.model[i_r3]));
  }
}
function ClrCombobox_span_1_span_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "span", 12)(1, "span", 13)(2, "span", 14);
    ɵɵtemplate(3, ClrCombobox_span_1_span_1_ng_container_3_Template, 1, 4, "ng-container", 15);
    ɵɵelementEnd()();
    ɵɵelementStart(4, "span", 13)(5, "button", 16);
    ɵɵlistener("click", function ClrCombobox_span_1_span_1_Template_button_click_5_listener() {
      const item_r5 = ɵɵrestoreView(_r2).$implicit;
      const ctx_r3 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r3.unselect(item_r5));
    });
    ɵɵelement(6, "cds-icon", 17);
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const i_r3 = ctx.index;
    const ctx_r3 = ɵɵnextContext(2);
    ɵɵadvance(3);
    ɵɵproperty("ngIf", ctx_r3.optionSelected);
    ɵɵadvance(2);
    ɵɵproperty("disabled", (ctx_r3.control == null ? null : ctx_r3.control.disabled) ? true : null);
    ɵɵattribute("aria-label", ctx_r3.commonStrings.keys.comboboxDelete + " " + ctx_r3.optionSelectionService.selectionModel.toString(ctx_r3.displayField, i_r3));
  }
}
function ClrCombobox_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 10);
    ɵɵtemplate(1, ClrCombobox_span_1_span_1_Template, 7, 3, "span", 11);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    ɵɵproperty("clrRovingTabindexDisabled", ctx_r3.control == null ? null : ctx_r3.control.disabled);
    ɵɵattribute("aria-label", ctx_r3.getSelectionAriaLabel())("aria-disabled", (ctx_r3.control == null ? null : ctx_r3.control.disabled) ? true : null);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r3.multiSelectModel);
  }
}
function ClrCombobox_div_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 19);
    ɵɵprojection(1);
    ɵɵelementEnd();
  }
}
var _c23 = [[["label"]], [["", "clrInput", ""]], [["clr-control-helper"]], [["clr-control-error"]], [["clr-control-success"]]];
var _c24 = ["label", "[clrInput]", "clr-control-helper", "clr-control-error", "clr-control-success"];
function ClrInputContainer_label_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "label");
  }
}
function ClrInputContainer_cds_icon_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "cds-icon", 5);
  }
}
function ClrInputContainer_cds_icon_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "cds-icon", 6);
  }
}
function ClrInputContainer_ng_content_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 2, ["*ngIf", "showHelper"]);
  }
}
function ClrInputContainer_ng_content_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 3, ["*ngIf", "showInvalid"]);
  }
}
function ClrInputContainer_ng_content_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 4, ["*ngIf", "showValid"]);
  }
}
var _c25 = [[["label"]], [["", "clrDatalistInput", ""]], [["datalist"]], [["clr-control-helper"]], [["clr-control-error"]], [["clr-control-success"]]];
var _c26 = ["label", "[clrDatalistInput]", "datalist", "clr-control-helper", "clr-control-error", "clr-control-success"];
function ClrDatalistContainer_label_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "label");
  }
}
function ClrDatalistContainer_cds_icon_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "cds-icon", 7);
  }
}
function ClrDatalistContainer_cds_icon_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "cds-icon", 8);
  }
}
function ClrDatalistContainer_ng_content_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 3, ["*ngIf", "showHelper"]);
  }
}
function ClrDatalistContainer_ng_content_11_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 4, ["*ngIf", "showInvalid"]);
  }
}
function ClrDatalistContainer_ng_content_12_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 5, ["*ngIf", "showValid"]);
  }
}
function ClrCalendar_th_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "th", 4)(1, "span");
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const day_r1 = ctx.$implicit;
    ɵɵadvance();
    ɵɵattribute("aria-label", day_r1.day);
    ɵɵadvance();
    ɵɵtextInterpolate(day_r1.narrow);
  }
}
function ClrCalendar_tr_3_td_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "td", 7);
    ɵɵelement(1, "clr-day", 8);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const dayView_r2 = ctx.$implicit;
    ɵɵadvance();
    ɵɵproperty("clrDayView", dayView_r2);
  }
}
function ClrCalendar_tr_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "tr", 5);
    ɵɵtemplate(1, ClrCalendar_tr_3_td_1_Template, 2, 1, "td", 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const row_r3 = ctx.$implicit;
    ɵɵadvance();
    ɵɵproperty("ngForOf", row_r3);
  }
}
function ClrMonthpicker_button_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 1);
    ɵɵlistener("click", function ClrMonthpicker_button_0_Template_button_click_0_listener() {
      const monthIndex_r2 = ɵɵrestoreView(_r1).index;
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.changeMonth(monthIndex_r2));
    });
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const month_r4 = ctx.$implicit;
    const monthIndex_r2 = ctx.index;
    const ctx_r2 = ɵɵnextContext();
    ɵɵclassProp("is-selected", monthIndex_r2 === ctx_r2.calendarMonthIndex);
    ɵɵattribute("tabindex", ctx_r2.getTabIndex(monthIndex_r2));
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", month_r4, " ");
  }
}
function ClrYearpicker_button_8_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 7);
    ɵɵlistener("click", function ClrYearpicker_button_8_Template_button_click_0_listener() {
      const year_r2 = ɵɵrestoreView(_r1).$implicit;
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.changeYear(year_r2));
    });
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const year_r2 = ctx.$implicit;
    const ctx_r2 = ɵɵnextContext();
    ɵɵclassProp("is-selected", year_r2 === ctx_r2.calendarYear);
    ɵɵattribute("tabindex", ctx_r2.getTabIndex(year_r2));
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", year_r2, " ");
  }
}
function ClrDatepickerViewManager_clr_monthpicker_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "clr-monthpicker");
  }
}
function ClrDatepickerViewManager_clr_yearpicker_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "clr-yearpicker");
  }
}
function ClrDatepickerViewManager_clr_daypicker_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "clr-daypicker");
  }
}
var _c27 = ["actionButton"];
var _c28 = [[["label"]], [["", "clrDate", ""]], [["clr-control-helper"]], [["clr-control-error"]], [["clr-control-success"]]];
var _c29 = ["label", "[clrDate]", "clr-control-helper", "clr-control-error", "clr-control-success"];
function ClrDateContainer_label_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "label");
  }
}
function ClrDateContainer_button_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "button", 9, 0);
    ɵɵelement(2, "cds-icon", 10);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("disabled", ctx_r0.isInputDateDisabled);
  }
}
function ClrDateContainer_clr_datepicker_view_manager_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "clr-datepicker-view-manager", 11);
  }
}
function ClrDateContainer_cds_icon_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "cds-icon", 12);
  }
}
function ClrDateContainer_cds_icon_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "cds-icon", 13);
  }
}
function ClrDateContainer_ng_content_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 2, ["*ngIf", "showHelper"]);
  }
}
function ClrDateContainer_ng_content_11_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 3, ["*ngIf", "showInvalid"]);
  }
}
function ClrDateContainer_ng_content_12_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 4, ["*ngIf", "showValid"]);
  }
}
var _c30 = ["browseButton"];
var _c31 = [[["label"]], [["", "clrFileInput", ""]], [["clr-control-helper"]], [["clr-control-error"]], [["clr-control-success"]]];
var _c32 = ["label", "[clrFileInput]", "clr-control-helper", "clr-control-error", "clr-control-success"];
function ClrFileInputContainer_label_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "label");
  }
}
function ClrFileInputContainer_button_10_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 10);
    ɵɵlistener("click", function ClrFileInputContainer_button_10_Template_button_click_0_listener() {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.clearSelectedFiles());
    });
    ɵɵelement(1, "cds-icon", 11);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵattribute("aria-label", ctx_r2.fileInput == null ? null : ctx_r2.fileInput.selection == null ? null : ctx_r2.fileInput.selection.clearFilesButtonLabel);
  }
}
function ClrFileInputContainer_cds_icon_11_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "cds-icon", 12);
  }
}
function ClrFileInputContainer_cds_icon_12_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "cds-icon", 13);
  }
}
function ClrFileInputContainer_ng_content_13_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 2, ["*ngIf", "showHelper"]);
  }
}
function ClrFileInputContainer_ng_content_14_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 3, ["*ngIf", "showInvalid"]);
  }
}
function ClrFileInputContainer_ng_content_15_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 4, ["*ngIf", "showValid"]);
  }
}
var _c33 = [[["label"]], [["", "clrPassword", ""]], [["clr-control-helper"]], [["clr-control-error"]], [["clr-control-success"]]];
var _c34 = ["label", "[clrPassword]", "clr-control-helper", "clr-control-error", "clr-control-success"];
function ClrPasswordContainer_label_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "label");
  }
}
function ClrPasswordContainer_button_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 7);
    ɵɵlistener("click", function ClrPasswordContainer_button_6_Template_button_click_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.toggle());
    });
    ɵɵelement(1, "cds-icon", 8);
    ɵɵelementStart(2, "span", 9);
    ɵɵtext(3);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("disabled", ctx_r1.control == null ? null : ctx_r1.control.disabled);
    ɵɵadvance();
    ɵɵattribute("shape", ctx_r1.show ? "eye-hide" : "eye");
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", ctx_r1.show ? ctx_r1.hidePasswordText(ctx_r1.label == null ? null : ctx_r1.label.labelText) : ctx_r1.showPasswordText(ctx_r1.label == null ? null : ctx_r1.label.labelText), " ");
  }
}
function ClrPasswordContainer_cds_icon_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "cds-icon", 10);
  }
}
function ClrPasswordContainer_cds_icon_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "cds-icon", 11);
  }
}
function ClrPasswordContainer_ng_content_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 2, ["*ngIf", "showHelper"]);
  }
}
function ClrPasswordContainer_ng_content_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 3, ["*ngIf", "showInvalid"]);
  }
}
function ClrPasswordContainer_ng_content_11_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 4, ["*ngIf", "showValid"]);
  }
}
var _c35 = [[["", "clrRadio", ""]], [["label"]]];
var _c36 = ["[clrRadio]", "label"];
function ClrRadioWrapper_label_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "label");
  }
}
var _c37 = [[["label"]], [["clr-radio-wrapper"]], [["clr-control-helper"]], [["clr-control-error"]], [["clr-control-success"]]];
var _c38 = ["label", "clr-radio-wrapper", "clr-control-helper", "clr-control-error", "clr-control-success"];
function ClrRadioContainer_label_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "label");
  }
}
function ClrRadioContainer_ng_content_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 2, ["*ngIf", "showHelper"]);
  }
}
function ClrRadioContainer_cds_icon_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "cds-icon", 5);
  }
}
function ClrRadioContainer_cds_icon_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "cds-icon", 6);
  }
}
function ClrRadioContainer_ng_content_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 3, ["*ngIf", "showInvalid"]);
  }
}
function ClrRadioContainer_ng_content_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 4, ["*ngIf", "showValid"]);
  }
}
var _c39 = [[["label"]], [["", "clrRange", ""]], [["clr-control-helper"]], [["clr-control-error"]], [["clr-control-success"]]];
var _c40 = ["label", "[clrRange]", "clr-control-helper", "clr-control-error", "clr-control-success"];
function ClrRangeContainer_label_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "label");
  }
}
function ClrRangeContainer_span_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 6);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵstyleProp("width", ctx_r0.getRangeProgressFillWidth());
  }
}
function ClrRangeContainer_cds_icon_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "cds-icon", 7);
  }
}
function ClrRangeContainer_cds_icon_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "cds-icon", 8);
  }
}
function ClrRangeContainer_ng_content_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 2, ["*ngIf", "showHelper"]);
  }
}
function ClrRangeContainer_ng_content_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 3, ["*ngIf", "showInvalid"]);
  }
}
function ClrRangeContainer_ng_content_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 4, ["*ngIf", "showValid"]);
  }
}
var _c41 = [[["label"]], [["", "clrSelect", ""]], [["clr-control-helper"]], [["clr-control-error"]], [["clr-control-success"]]];
var _c42 = ["label", "[clrSelect]", "clr-control-helper", "clr-control-error", "clr-control-success"];
function ClrSelectContainer_label_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "label");
  }
}
function ClrSelectContainer_cds_icon_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "cds-icon", 5);
  }
}
function ClrSelectContainer_cds_icon_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "cds-icon", 6);
  }
}
function ClrSelectContainer_ng_content_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 2, ["*ngIf", "showHelper"]);
  }
}
function ClrSelectContainer_ng_content_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 3, ["*ngIf", "showInvalid"]);
  }
}
function ClrSelectContainer_ng_content_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 4, ["*ngIf", "showValid"]);
  }
}
var _c43 = [[["label"]], [["", "clrTextarea", ""]], [["clr-control-helper"]], [["clr-control-error"]], [["clr-control-success"]]];
var _c44 = ["label", "[clrTextarea]", "clr-control-helper", "clr-control-error", "clr-control-success"];
function ClrTextareaContainer_label_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "label");
  }
}
function ClrTextareaContainer_cds_icon_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "cds-icon", 5);
  }
}
function ClrTextareaContainer_cds_icon_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "cds-icon", 6);
  }
}
function ClrTextareaContainer_ng_content_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 2, ["*ngIf", "showHelper"]);
  }
}
function ClrTextareaContainer_ng_content_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 3, ["*ngIf", "showInvalid"]);
  }
}
function ClrTextareaContainer_ng_content_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 4, ["*ngIf", "showValid"]);
  }
}
var _c45 = ["anchor"];
function ClrDatagridFilter_div_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 4)(1, "div", 5)(2, "button", 6);
    ɵɵelement(3, "cds-icon", 7);
    ɵɵelementEnd()();
    ɵɵprojection(4);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("id", ctx_r0.popoverId);
    ɵɵattribute("aria-label", ctx_r0.commonStrings.keys.datagridFilterDialogAriaLabel);
    ɵɵadvance(3);
    ɵɵattribute("title", ctx_r0.commonStrings.keys.close);
  }
}
var _c46 = ["input_low"];
var _c47 = ["input"];
var _c48 = ["columnPortal"];
function WrappedColumn_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0);
  }
}
var _c49 = ["resizeTracker"];
var _c50 = ["columnHandle"];
var _c51 = [[["clr-dg-filter"], ["clr-dg-string-filter"], ["clr-dg-numeric-filter"]], "*"];
var _c52 = ["clr-dg-filter, clr-dg-string-filter, clr-dg-numeric-filter", "*"];
function ClrDatagridColumn_button_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function ClrDatagridColumn_button_1_cds_icon_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "cds-icon", 10);
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵattribute("direction", ctx_r1.sortDirection);
  }
}
function ClrDatagridColumn_button_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 7);
    ɵɵlistener("click", function ClrDatagridColumn_button_1_Template_button_click_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.sort());
    });
    ɵɵtemplate(1, ClrDatagridColumn_button_1_ng_container_1_Template, 1, 0, "ng-container", 8)(2, ClrDatagridColumn_button_1_cds_icon_2_Template, 1, 1, "cds-icon", 9);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    const columnTitle_r3 = ɵɵreference(6);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", columnTitle_r3);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.sortDirection);
  }
}
function ClrDatagridColumn_clr_dg_string_filter_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "clr-dg-string-filter", 11);
    ɵɵtwoWayListener("clrFilterValueChange", function ClrDatagridColumn_clr_dg_string_filter_3_Template_clr_dg_string_filter_clrFilterValueChange_0_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      ɵɵtwoWayBindingSet(ctx_r1.filterValue, $event) || (ctx_r1.filterValue = $event);
      return ɵɵresetView($event);
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("clrFilterPlaceholder", ctx_r1.filterStringPlaceholder)("clrDgStringFilter", ctx_r1.registered);
    ɵɵtwoWayProperty("clrFilterValue", ctx_r1.filterValue);
  }
}
function ClrDatagridColumn_clr_dg_numeric_filter_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "clr-dg-numeric-filter", 12);
    ɵɵtwoWayListener("clrFilterValueChange", function ClrDatagridColumn_clr_dg_numeric_filter_4_Template_clr_dg_numeric_filter_clrFilterValueChange_0_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext();
      ɵɵtwoWayBindingSet(ctx_r1.filterValue, $event) || (ctx_r1.filterValue = $event);
      return ɵɵresetView($event);
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("clrFilterMaxPlaceholder", ctx_r1.filterNumberMaxPlaceholder)("clrFilterMinPlaceholder", ctx_r1.filterNumberMinPlaceholder)("clrDgNumericFilter", ctx_r1.registered);
    ɵɵtwoWayProperty("clrFilterValue", ctx_r1.filterValue);
  }
}
function ClrDatagridColumn_ng_template_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 1);
  }
}
function ClrDatagridColumn_span_7_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function ClrDatagridColumn_span_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 13);
    ɵɵtemplate(1, ClrDatagridColumn_span_7_ng_container_1_Template, 1, 0, "ng-container", 8);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    ɵɵnextContext();
    const columnTitle_r3 = ɵɵreference(6);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", columnTitle_r3);
  }
}
function ClrDatagridColumn_clr_dg_column_separator_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "clr-dg-column-separator");
  }
}
function ClrDatagridPlaceholder_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 4);
  }
}
function ClrDatagridPlaceholder_ng_content_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 0, ["*ngIf", "emptyDatagrid"]);
  }
}
function ClrSignpost_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "button", 1);
    ɵɵelement(2, "cds-icon", 2);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵattribute("aria-label", ctx_r0.commonStrings.keys.signpostToggle);
    ɵɵadvance();
    ɵɵattribute("title", ctx_r0.commonStrings.keys.info);
  }
}
var _c53 = ["cellPortal"];
function WrappedCell_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0);
  }
}
var _c54 = ["rowPortal"];
function WrappedRow_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0);
  }
}
var _c55 = ["detailButton"];
var _c56 = ["stickyCells"];
var _c57 = ["scrollableCells"];
var _c58 = ["calculatedCells"];
var _c59 = [[["clr-dg-row-detail"]], [["clr-dg-cell"]], [["clr-dg-action-overflow"]]];
var _c60 = ["clr-dg-row-detail", "clr-dg-cell", "clr-dg-action-overflow"];
var _c61 = (a0) => ({
  "is-replaced": a0
});
var _c62 = (a0) => ({
  "clr-form-control-disabled": a0
});
function ClrDatagridRow_div_0_clr_expandable_animation_1_ng_template_1_Template(rf, ctx) {
}
function ClrDatagridRow_div_0_clr_expandable_animation_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "clr-expandable-animation", 10);
    ɵɵtemplate(1, ClrDatagridRow_div_0_clr_expandable_animation_1_ng_template_1_Template, 0, 0, "ng-template", 11);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    const rowContent_r3 = ɵɵreference(6);
    ɵɵproperty("clrExpandTrigger", ctx_r1.expandAnimationTrigger);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", rowContent_r3);
  }
}
function ClrDatagridRow_div_0_2_ng_template_0_Template(rf, ctx) {
}
function ClrDatagridRow_div_0_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ClrDatagridRow_div_0_2_ng_template_0_Template, 0, 0, "ng-template", 11);
  }
  if (rf & 2) {
    ɵɵnextContext(2);
    const rowContent_r3 = ɵɵreference(6);
    ɵɵproperty("ngTemplateOutlet", rowContent_r3);
  }
}
function ClrDatagridRow_div_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 9);
    ɵɵlistener("mousedown", function ClrDatagridRow_div_0_Template_div_mousedown_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.clearRanges($event));
    })("click", function ClrDatagridRow_div_0_Template_div_click_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.selectRow(!ctx_r1.selected, $event));
    });
    ɵɵtemplate(1, ClrDatagridRow_div_0_clr_expandable_animation_1_Template, 2, 2, "clr-expandable-animation", 7)(2, ClrDatagridRow_div_0_2_Template, 1, 1, null, 8);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.expand.expandable);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.expand.expandable);
  }
}
function ClrDatagridRow_clr_expandable_animation_1_ng_template_1_Template(rf, ctx) {
}
function ClrDatagridRow_clr_expandable_animation_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "clr-expandable-animation", 10);
    ɵɵtemplate(1, ClrDatagridRow_clr_expandable_animation_1_ng_template_1_Template, 0, 0, "ng-template", 11);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    const rowContent_r3 = ɵɵreference(6);
    ɵɵproperty("clrExpandTrigger", ctx_r1.expandAnimationTrigger);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", rowContent_r3);
  }
}
function ClrDatagridRow_2_ng_template_0_Template(rf, ctx) {
}
function ClrDatagridRow_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ClrDatagridRow_2_ng_template_0_Template, 0, 0, "ng-template", 11);
  }
  if (rf & 2) {
    ɵɵnextContext();
    const rowContent_r3 = ɵɵreference(6);
    ɵɵproperty("ngTemplateOutlet", rowContent_r3);
  }
}
function ClrDatagridRow_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0);
  }
}
function ClrDatagridRow_ng_template_5_div_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 20)(1, "clr-checkbox-wrapper")(2, "input", 21);
    ɵɵlistener("ngModelChange", function ClrDatagridRow_ng_template_5_div_4_Template_input_ngModelChange_2_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.toggle($event));
    });
    ɵɵelementEnd();
    ɵɵelementStart(3, "label", 22);
    ɵɵlistener("click", function ClrDatagridRow_ng_template_5_div_4_Template_label_click_3_listener($event) {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.clearRanges($event));
    });
    ɵɵelementStart(4, "span", 23);
    ɵɵtext(5);
    ɵɵelementEnd()()()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("ngClass", ɵɵpureFunction1(7, _c62, !ctx_r1.clrDgSelectable));
    ɵɵadvance(2);
    ɵɵproperty("ngModel", ctx_r1.selected)("id", ctx_r1.checkboxId)("disabled", ctx_r1.clrDgSelectable ? null : true);
    ɵɵattribute("aria-disabled", ctx_r1.clrDgSelectable ? null : true);
    ɵɵadvance();
    ɵɵproperty("for", ctx_r1.checkboxId);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r1.clrDgRowSelectionLabel || ctx_r1.commonStrings.keys.select);
  }
}
function ClrDatagridRow_ng_template_5_div_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 20)(1, "clr-radio-wrapper")(2, "input", 24);
    ɵɵtwoWayListener("ngModelChange", function ClrDatagridRow_ng_template_5_div_5_Template_input_ngModelChange_2_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext(2);
      ɵɵtwoWayBindingSet(ctx_r1.selection.currentSingle, $event) || (ctx_r1.selection.currentSingle = $event);
      return ɵɵresetView($event);
    });
    ɵɵelementEnd();
    ɵɵelementStart(3, "label", 25)(4, "span", 23);
    ɵɵtext(5);
    ɵɵelementEnd()()()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("ngClass", ɵɵpureFunction1(10, _c62, !ctx_r1.clrDgSelectable));
    ɵɵadvance(2);
    ɵɵproperty("id", ctx_r1.radioId)("name", ctx_r1.selection.id + "-radio")("value", ctx_r1.item);
    ɵɵtwoWayProperty("ngModel", ctx_r1.selection.currentSingle);
    ɵɵproperty("checked", ctx_r1.selection.currentSingle === ctx_r1.item)("disabled", ctx_r1.clrDgSelectable ? null : true);
    ɵɵattribute("aria-disabled", ctx_r1.clrDgSelectable ? null : true);
    ɵɵadvance();
    ɵɵproperty("for", ctx_r1.radioId);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r1.clrDgRowSelectionLabel || ctx_r1.commonStrings.keys.select);
  }
}
function ClrDatagridRow_ng_template_5_div_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 26);
    ɵɵprojection(1, 2);
    ɵɵelementEnd();
  }
}
function ClrDatagridRow_ng_template_5_div_7_ng_container_1_button_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 30);
    ɵɵlistener("click", function ClrDatagridRow_ng_template_5_div_7_ng_container_1_button_1_Template_button_click_0_listener() {
      ɵɵrestoreView(_r6);
      const ctx_r1 = ɵɵnextContext(4);
      return ɵɵresetView(ctx_r1.toggleExpand());
    });
    ɵɵelement(1, "cds-icon", 31);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(4);
    ɵɵattribute("aria-expanded", ctx_r1.expand.expanded)("aria-label", ctx_r1.expand.expanded ? ctx_r1.clrDgDetailCloseLabel : ctx_r1.clrDgDetailOpenLabel)("aria-controls", ctx_r1.expandableId);
    ɵɵadvance();
    ɵɵattribute("direction", ctx_r1.expand.expanded ? "down" : "right")("title", ctx_r1.expand.expanded ? ctx_r1.commonStrings.keys.collapse : ctx_r1.commonStrings.keys.expand);
  }
}
function ClrDatagridRow_ng_template_5_div_7_ng_container_1_clr_spinner_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "clr-spinner", 32);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(4);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.commonStrings.keys.loading);
  }
}
function ClrDatagridRow_ng_template_5_div_7_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, ClrDatagridRow_ng_template_5_div_7_ng_container_1_button_1_Template, 2, 5, "button", 28)(2, ClrDatagridRow_ng_template_5_div_7_ng_container_1_clr_spinner_2_Template, 2, 1, "clr-spinner", 29);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.expand.loading);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.expand.loading);
  }
}
function ClrDatagridRow_ng_template_5_div_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 27);
    ɵɵtemplate(1, ClrDatagridRow_ng_template_5_div_7_ng_container_1_Template, 3, 2, "ng-container", 8);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.expand.expandable);
  }
}
function ClrDatagridRow_ng_template_5_div_8_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 33)(1, "button", 34, 5);
    ɵɵlistener("click", function ClrDatagridRow_ng_template_5_div_8_Template_button_click_1_listener() {
      ɵɵrestoreView(_r7);
      const detailButton_r8 = ɵɵreference(2);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.detailService.toggle(ctx_r1.item, detailButton_r8));
    });
    ɵɵelement(3, "cds-icon", 35);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵclassProp("is-open", ctx_r1.detailService.isRowOpen(ctx_r1.item));
    ɵɵattribute("aria-label", ctx_r1.detailService.isRowOpen(ctx_r1.item) ? ctx_r1.clrDgDetailCloseLabel : ctx_r1.clrDgDetailOpenLabel)("aria-expanded", ctx_r1.detailService.isRowOpen(ctx_r1.item))("aria-controls", ctx_r1.detailService.id);
    ɵɵadvance(2);
    ɵɵattribute("direction", ctx_r1.detailService.isRowOpen(ctx_r1.item) ? "left" : "right")("title", ctx_r1.detailService.isRowOpen(ctx_r1.item) ? ctx_r1.commonStrings.keys.close : ctx_r1.commonStrings.keys.open);
  }
}
function ClrDatagridRow_ng_template_5_14_ng_template_0_Template(rf, ctx) {
}
function ClrDatagridRow_ng_template_5_14_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ClrDatagridRow_ng_template_5_14_ng_template_0_Template, 0, 0, "ng-template", 11);
  }
  if (rf & 2) {
    ɵɵnextContext(2);
    const detail_r9 = ɵɵreference(4);
    ɵɵproperty("ngTemplateOutlet", detail_r9);
  }
}
function ClrDatagridRow_ng_template_5_15_ng_template_0_Template(rf, ctx) {
}
function ClrDatagridRow_ng_template_5_15_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, ClrDatagridRow_ng_template_5_15_ng_template_0_Template, 0, 0, "ng-template", 11);
  }
  if (rf & 2) {
    ɵɵnextContext(2);
    const detail_r9 = ɵɵreference(4);
    ɵɵproperty("ngTemplateOutlet", detail_r9);
  }
}
function ClrDatagridRow_ng_template_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 12)(1, "div", 13);
    ɵɵelementContainerStart(2, null, 3);
    ɵɵtemplate(4, ClrDatagridRow_ng_template_5_div_4_Template, 6, 9, "div", 14)(5, ClrDatagridRow_ng_template_5_div_5_Template, 6, 12, "div", 14)(6, ClrDatagridRow_ng_template_5_div_6_Template, 2, 0, "div", 15)(7, ClrDatagridRow_ng_template_5_div_7_Template, 2, 1, "div", 16)(8, ClrDatagridRow_ng_template_5_div_8_Template, 4, 7, "div", 17);
    ɵɵelementContainerEnd();
    ɵɵelementEnd();
    ɵɵelementStart(9, "div", 18)(10, "div", 19);
    ɵɵprojection(11, 1);
    ɵɵelementContainer(12, null, 4);
    ɵɵelementEnd();
    ɵɵtemplate(14, ClrDatagridRow_ng_template_5_14_Template, 1, 1, null, 8)(15, ClrDatagridRow_ng_template_5_15_Template, 1, 1, null, 8);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassProp("datagrid-row-detail-open", ctx_r1.detailService.isRowOpen(ctx_r1.item));
    ɵɵproperty("id", ctx_r1.id);
    ɵɵadvance(4);
    ɵɵproperty("ngIf", ctx_r1.selection.selectionType === ctx_r1.SELECTION_TYPE.Multi);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.selection.selectionType === ctx_r1.SELECTION_TYPE.Single);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.rowActionService.hasActionableRow);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.globalExpandable.hasExpandableRow);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.detailService.enabled);
    ɵɵadvance();
    ɵɵproperty("ngClass", ɵɵpureFunction1(11, _c61, ctx_r1.replaced && ctx_r1.expanded));
    ɵɵadvance(5);
    ɵɵproperty("ngIf", ctx_r1.replaced && !ctx_r1.expand.loading);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.replaced && !ctx_r1.expand.loading);
  }
}
var _c63 = ["datagrid"];
var _c64 = ["datagridTable"];
var _c65 = ["scrollableColumns"];
var _c66 = ["projectedDisplayColumns"];
var _c67 = ["projectedCalculationColumns"];
var _c68 = ["displayedRows"];
var _c69 = ["calculationRows"];
var _c70 = [[["clr-dg-action-bar"]], [["clr-dg-placeholder"]], [["clr-dg-footer"]], [["", "clrIfDetail", ""], ["clr-dg-detail"]]];
var _c71 = ["clr-dg-action-bar", "clr-dg-placeholder", "clr-dg-footer", "[clrIfDetail],clr-dg-detail"];
function ClrDatagrid_div_12_div_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 29)(1, "input", 30);
    ɵɵtwoWayListener("ngModelChange", function ClrDatagrid_div_12_div_1_Template_input_ngModelChange_1_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext(2);
      ɵɵtwoWayBindingSet(ctx_r1.allSelected, $event) || (ctx_r1.allSelected = $event);
      return ɵɵresetView($event);
    });
    ɵɵelementEnd();
    ɵɵelementStart(2, "label", 31)(3, "span", 32);
    ɵɵtext(4);
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("id", ctx_r1.selectAllId);
    ɵɵtwoWayProperty("ngModel", ctx_r1.allSelected);
    ɵɵattribute("aria-label", ctx_r1.commonStrings.keys.selectAll);
    ɵɵadvance();
    ɵɵproperty("for", ctx_r1.selectAllId);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r1.commonStrings.keys.selectAll);
  }
}
function ClrDatagrid_div_12_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 26);
    ɵɵlistener("keydown.space", function ClrDatagrid_div_12_Template_div_keydown_space_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.toggleAllSelected($event));
    });
    ɵɵtemplate(1, ClrDatagrid_div_12_div_1_Template, 5, 5, "div", 27);
    ɵɵelement(2, "div", 28);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.hasVirtualScroller);
  }
}
function ClrDatagrid_div_13_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 33)(1, "div", 32);
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵelement(3, "div", 28);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r1.clrDgSingleSelectionAriaLabel);
  }
}
function ClrDatagrid_div_14_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 34)(1, "div", 32);
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵelement(3, "div", 28);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r1.clrDgSingleActionableAriaLabel);
  }
}
function ClrDatagrid_div_15_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 35)(1, "div", 32);
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵelement(3, "div", 28);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r1.clrDetailExpandableAriaLabel);
  }
}
function ClrDatagrid_clr_dg_row_20_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "clr-dg-row", 36)(1, "clr-dg-cell");
    ɵɵelement(2, "clr-spinner", 37);
    ɵɵelementStart(3, "span");
    ɵɵtext(4);
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance(4);
    ɵɵtextInterpolate(ctx_r1.commonStrings.keys.loading);
  }
}
function ClrDatagrid_clr_dg_row_23_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "clr-dg-row", 36)(1, "clr-dg-cell");
    ɵɵelement(2, "clr-spinner", 37);
    ɵɵelementStart(3, "span");
    ɵɵtext(4);
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance(4);
    ɵɵtextInterpolate(ctx_r1.commonStrings.keys.loading);
  }
}
function ClrDatagrid_clr_dg_placeholder_25_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "clr-dg-placeholder");
  }
}
function ClrDatagrid_div_27_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 38)(1, "clr-spinner", 37);
    ɵɵtext(2, "Loading");
    ɵɵelementEnd()();
  }
}
function ClrDatagridActionOverflow_div_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 4);
    ɵɵlistener("click", function ClrDatagridActionOverflow_div_3_Template_div_click_0_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.closeOverflowContent($event));
    });
    ɵɵprojection(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("id", ctx_r1.popoverId);
    ɵɵattribute("aria-hidden", !ctx_r1.open)("id", ctx_r1.popoverId);
  }
}
var _c72 = ["allSelected"];
function ClrDatagridColumnToggle_div_2_li_12_ng_template_4_Template(rf, ctx) {
}
function ClrDatagridColumnToggle_div_2_li_12_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "li")(1, "clr-checkbox-wrapper")(2, "input", 13);
    ɵɵlistener("ngModelChange", function ClrDatagridColumnToggle_div_2_li_12_Template_input_ngModelChange_2_listener($event) {
      const columnState_r3 = ɵɵrestoreView(_r2).$implicit;
      const ctx_r3 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r3.toggleColumnState(columnState_r3, !$event));
    });
    ɵɵelementEnd();
    ɵɵelementStart(3, "label");
    ɵɵtemplate(4, ClrDatagridColumnToggle_div_2_li_12_ng_template_4_Template, 0, 0, "ng-template", 14);
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const columnState_r3 = ctx.$implicit;
    const ctx_r3 = ɵɵnextContext(2);
    ɵɵadvance(2);
    ɵɵproperty("disabled", ctx_r3.hasOnlyOneVisibleColumn && !columnState_r3.hidden)("ngModel", !columnState_r3.hidden);
    ɵɵadvance(2);
    ɵɵproperty("ngTemplateOutlet", columnState_r3.titleTemplateRef);
  }
}
function ClrDatagridColumnToggle_div_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 3)(1, "div", 4)(2, "div", 5, 0);
    ɵɵtext(4);
    ɵɵelementEnd();
    ɵɵelementStart(5, "h2");
    ɵɵtext(6);
    ɵɵelementEnd();
    ɵɵelementStart(7, "button", 6);
    ɵɵelement(8, "cds-icon", 7);
    ɵɵelementStart(9, "span", 8);
    ɵɵtext(10);
    ɵɵelementEnd()()();
    ɵɵelementStart(11, "ul", 9);
    ɵɵtemplate(12, ClrDatagridColumnToggle_div_2_li_12_Template, 5, 3, "li", 10);
    ɵɵelementEnd();
    ɵɵelementStart(13, "div", 11)(14, "clr-dg-column-toggle-button", 12);
    ɵɵlistener("clrAllSelected", function ClrDatagridColumnToggle_div_2_Template_clr_dg_column_toggle_button_clrAllSelected_14_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r3 = ɵɵnextContext();
      return ɵɵresetView(ctx_r3.allColumnsSelected());
    });
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const ctx_r3 = ɵɵnextContext();
    ɵɵproperty("id", ctx_r3.popoverId);
    ɵɵattribute("aria-label", ctx_r3.commonStrings.keys.showColumnsMenuDescription);
    ɵɵadvance(4);
    ɵɵtextInterpolate(ctx_r3.commonStrings.keys.allColumnsSelected);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r3.commonStrings.keys.showColumns);
    ɵɵadvance();
    ɵɵattribute("aria-label", ctx_r3.commonStrings.keys.close);
    ɵɵadvance();
    ɵɵattribute("title", ctx_r3.commonStrings.keys.close);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r3.commonStrings.keys.close);
    ɵɵadvance(2);
    ɵɵproperty("ngForOf", ctx_r3.hideableColumnStates)("ngForTrackBy", ctx_r3.trackByFn);
  }
}
var _c73 = ["title"];
function ClrDatagridDetail_div_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 1)(1, "div", 2);
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵprojection(3);
    ɵɵelementStart(4, "div", 2);
    ɵɵtext(5);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("cdkTrapFocusAutoCapture", !ctx_r0.header)("id", ctx_r0.detailService.id);
    ɵɵattribute("aria-labelledby", ctx_r0.labelledBy)("aria-label", ctx_r0.label);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r0.commonStrings.keys.detailPaneStart);
    ɵɵadvance(3);
    ɵɵtextInterpolate(ctx_r0.commonStrings.keys.detailPaneEnd);
  }
}
var _c74 = [[["clr-dg-pagination"]], "*"];
var _c75 = ["clr-dg-pagination", "*"];
function ClrDatagridFooter_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "div", 1)(2, "clr-checkbox-wrapper", 2);
    ɵɵelement(3, "input", 3);
    ɵɵelementStart(4, "label");
    ɵɵtext(5);
    ɵɵelementEnd();
    ɵɵelementStart(6, "span", 4);
    ɵɵtext(7);
    ɵɵelementEnd()()();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance(5);
    ɵɵtextInterpolate(ctx_r0.selection.current.length);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r0.commonStrings.keys.selectedRows);
  }
}
function ClrDatagridFooter_ng_container_1_clr_dg_column_toggle_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "clr-dg-column-toggle");
  }
}
function ClrDatagridFooter_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, ClrDatagridFooter_ng_container_1_clr_dg_column_toggle_1_Template, 1, 0, "clr-dg-column-toggle", 0);
    ɵɵelementStart(2, "div", 5);
    ɵɵprojection(3, 1);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.hasHideableColumns);
  }
}
function ClrDatagridPageSize_option_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "option", 4);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const option_r1 = ctx.$implicit;
    ɵɵproperty("ngValue", option_r1);
    ɵɵadvance();
    ɵɵtextInterpolate(option_r1);
  }
}
var _c76 = ["currentPageInput"];
var _c77 = ["*", [["clr-dg-page-size"]]];
var _c78 = ["*", "clr-dg-page-size"];
function ClrDatagridPagination_ng_container_0_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 6);
    ɵɵprojection(1, 1);
    ɵɵelementEnd();
  }
}
function ClrDatagridPagination_ng_container_0_div_4_input_9_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "input", 18, 1);
    ɵɵlistener("keydown.enter", function ClrDatagridPagination_ng_container_0_div_4_input_9_Template_input_keydown_enter_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r1.updateCurrentPage($event));
    })("blur", function ClrDatagridPagination_ng_container_0_div_4_input_9_Template_input_blur_0_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext(3);
      return ɵɵresetView(ctx_r1.verifyCurrentPage($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵproperty("size", ctx_r1.page.last.toString().length)("value", ctx_r1.page.current);
    ɵɵattribute("aria-label", ctx_r1.commonStrings.keys.currentPage);
  }
}
function ClrDatagridPagination_ng_container_0_div_4_ng_template_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.page.current);
  }
}
function ClrDatagridPagination_ng_container_0_div_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 7)(1, "button", 8);
    ɵɵlistener("click", function ClrDatagridPagination_ng_container_0_div_4_Template_button_click_1_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.page.current = 1);
    });
    ɵɵelementStart(2, "span", 9);
    ɵɵtext(3);
    ɵɵelementEnd();
    ɵɵelement(4, "cds-icon", 10);
    ɵɵelementEnd();
    ɵɵelementStart(5, "button", 11);
    ɵɵlistener("click", function ClrDatagridPagination_ng_container_0_div_4_Template_button_click_5_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.page.current = ctx_r1.page.current - 1);
    });
    ɵɵelementStart(6, "span", 9);
    ɵɵtext(7);
    ɵɵelementEnd();
    ɵɵelement(8, "cds-icon", 12);
    ɵɵelementEnd();
    ɵɵtemplate(9, ClrDatagridPagination_ng_container_0_div_4_input_9_Template, 2, 3, "input", 13)(10, ClrDatagridPagination_ng_container_0_div_4_ng_template_10_Template, 2, 1, "ng-template", null, 0, ɵɵtemplateRefExtractor);
    ɵɵtext(12, "  / ");
    ɵɵelementStart(13, "span");
    ɵɵtext(14);
    ɵɵelementEnd();
    ɵɵelementStart(15, "button", 14);
    ɵɵlistener("click", function ClrDatagridPagination_ng_container_0_div_4_Template_button_click_15_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.page.current = ctx_r1.page.current + 1);
    });
    ɵɵelementStart(16, "span", 9);
    ɵɵtext(17);
    ɵɵelementEnd();
    ɵɵelement(18, "cds-icon", 15);
    ɵɵelementEnd();
    ɵɵelementStart(19, "button", 16);
    ɵɵlistener("click", function ClrDatagridPagination_ng_container_0_div_4_Template_button_click_19_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.page.current = ctx_r1.page.last);
    });
    ɵɵelementStart(20, "span", 9);
    ɵɵtext(21);
    ɵɵelementEnd();
    ɵɵelement(22, "cds-icon", 17);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const readOnly_r4 = ɵɵreference(11);
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("disabled", ctx_r1.page.current <= 1);
    ɵɵattribute("aria-label", ctx_r1.commonStrings.keys.firstPage);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r1.commonStrings.keys.firstPage);
    ɵɵadvance(2);
    ɵɵproperty("disabled", ctx_r1.page.current <= 1);
    ɵɵattribute("aria-label", ctx_r1.commonStrings.keys.previousPage);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r1.commonStrings.keys.previousPage);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", !ctx_r1.disableCurrentPageInput)("ngIfElse", readOnly_r4);
    ɵɵadvance(4);
    ɵɵattribute("aria-label", ctx_r1.commonStrings.keys.totalPages);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.page.last);
    ɵɵadvance();
    ɵɵproperty("disabled", ctx_r1.page.current >= ctx_r1.page.last);
    ɵɵattribute("aria-label", ctx_r1.commonStrings.keys.nextPage);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r1.commonStrings.keys.nextPage);
    ɵɵadvance(2);
    ɵɵproperty("disabled", ctx_r1.page.current >= ctx_r1.page.last);
    ɵɵattribute("aria-label", ctx_r1.commonStrings.keys.lastPage);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r1.commonStrings.keys.lastPage);
  }
}
function ClrDatagridPagination_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, ClrDatagridPagination_ng_container_0_div_1_Template, 2, 0, "div", 3);
    ɵɵelementStart(2, "div", 4);
    ɵɵprojection(3);
    ɵɵelementEnd();
    ɵɵtemplate(4, ClrDatagridPagination_ng_container_0_div_4_Template, 23, 16, "div", 5);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1._pageSizeComponent);
    ɵɵadvance(3);
    ɵɵproperty("ngIf", ctx_r1.page.last > 1);
  }
}
function ClrDatagridPagination_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "div", 19);
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵelementStart(3, "div", 7)(4, "button", 11);
    ɵɵlistener("click", function ClrDatagridPagination_ng_container_1_Template_button_click_4_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.page.current = ctx_r1.page.current - 1);
    });
    ɵɵelementStart(5, "span", 9);
    ɵɵtext(6);
    ɵɵelementEnd();
    ɵɵelement(7, "cds-icon", 12);
    ɵɵelementEnd();
    ɵɵelementStart(8, "span");
    ɵɵtext(9);
    ɵɵelementEnd();
    ɵɵelementStart(10, "button", 14);
    ɵɵlistener("click", function ClrDatagridPagination_ng_container_1_Template_button_click_10_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.page.current = ctx_r1.page.current + 1);
    });
    ɵɵelementStart(11, "span", 9);
    ɵɵtext(12);
    ɵɵelementEnd();
    ɵɵelement(13, "cds-icon", 15);
    ɵɵelementEnd()();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵtextInterpolate3(" ", ctx_r1.page.firstItem + 1, "-", ctx_r1.page.lastItem + 1, " / ", ctx_r1.page.totalItems, " ");
    ɵɵadvance(2);
    ɵɵproperty("disabled", ctx_r1.page.current <= 1);
    ɵɵattribute("aria-label", ctx_r1.commonStrings.keys.previousPage);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r1.commonStrings.keys.previousPage);
    ɵɵadvance(3);
    ɵɵtextInterpolate(ctx_r1.page.current);
    ɵɵadvance();
    ɵɵproperty("disabled", ctx_r1.page.current >= ctx_r1.page.last);
    ɵɵattribute("aria-label", ctx_r1.commonStrings.keys.nextPage);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r1.commonStrings.keys.nextPage);
  }
}
var _c79 = [[["clr-stack-label"]], "*", [["clr-stack-block"]]];
var _c80 = ["clr-stack-label", "*", "clr-stack-block"];
function ClrStackBlock_cds_icon_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "cds-icon", 7);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵattribute("direction", ctx_r0.caretDirection);
  }
}
function ClrStackBlock_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 8);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.commonStrings.keys.stackViewChanged);
  }
}
function ClrStackBlock_div_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 9);
    ɵɵprojection(1, 2);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵstyleProp("height", ctx_r0.expanded ? "auto" : 0);
    ɵɵattribute("id", ctx_r0.getStackChildrenId())("aria-labelledby", ctx_r0.labelledById);
  }
}
var _c81 = [[["clr-stack-header"]], "*"];
var _c82 = ["clr-stack-header", "*"];
var _c83 = ["*", [["", 8, "stack-action"]]];
var _c84 = ["*", ".stack-action"];
function RecursiveChildren_ng_container_0_ng_container_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0);
  }
}
function RecursiveChildren_ng_container_0_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, RecursiveChildren_ng_container_0_ng_container_1_ng_container_1_Template, 1, 0, "ng-container", 2);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const child_r1 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.featuresService.recursion.template)("ngTemplateOutletContext", ctx_r1.getContext(child_r1));
  }
}
function RecursiveChildren_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, RecursiveChildren_ng_container_0_ng_container_1_Template, 2, 2, "ng-container", 1);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", (ctx_r1.parent == null ? null : ctx_r1.parent.children) || ctx_r1.children);
  }
}
var _c85 = ["contentContainer"];
var _c86 = [[["clr-tree-node"]], [["", "clrIfExpanded", ""]], "*"];
var _c87 = ["clr-tree-node", "[clrIfExpanded]", "*"];
function ClrTreeNode_button_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 9);
    ɵɵlistener("click", function ClrTreeNode_button_2_Template_button_click_0_listener() {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.expandService.toggle());
    })("focus", function ClrTreeNode_button_2_Template_button_focus_0_listener() {
      ɵɵrestoreView(_r2);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.focusTreeNode());
    });
    ɵɵelement(1, "cds-icon", 10);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵproperty("disabled", ctx_r2.disabled);
    ɵɵadvance();
    ɵɵattribute("direction", ctx_r2.expandService.expanded ? "down" : "right");
  }
}
function ClrTreeNode_div_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 11);
    ɵɵelement(1, "span", 12);
    ɵɵelementEnd();
  }
}
function ClrTreeNode_div_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 13)(1, "input", 14);
    ɵɵlistener("change", function ClrTreeNode_div_4_Template_input_change_1_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2._model.toggleSelection(ctx_r2.featuresService.eager));
    })("focus", function ClrTreeNode_div_4_Template_input_focus_1_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.focusTreeNode());
    });
    ɵɵelementEnd();
    ɵɵelementStart(2, "label", 15);
    ɵɵelementContainer(3, 16);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    const treenodeContent_r5 = ɵɵreference(7);
    ɵɵadvance();
    ɵɵpropertyInterpolate1("id", "", ctx_r2.nodeId, "-check");
    ɵɵproperty("disabled", ctx_r2.disabled)("checked", ctx_r2._model.selected.value === ctx_r2.STATES.SELECTED)("indeterminate", ctx_r2._model.selected.value === ctx_r2.STATES.INDETERMINATE);
    ɵɵadvance();
    ɵɵpropertyInterpolate1("for", "", ctx_r2.nodeId, "-check");
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", treenodeContent_r5);
  }
}
function ClrTreeNode_div_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 17);
    ɵɵlistener("mouseup", function ClrTreeNode_div_5_Template_div_mouseup_0_listener() {
      ɵɵrestoreView(_r6);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.focusTreeNode());
    });
    ɵɵelementContainer(1, 16);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    const treenodeContent_r5 = ɵɵreference(7);
    ɵɵclassProp("clr-treenode-text-only", ctx_r2.treeNodeContentTextOnly);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", treenodeContent_r5);
  }
}
function ClrTreeNode_ng_template_6_div_1_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1, " selected");
    ɵɵelementEnd();
  }
}
function ClrTreeNode_ng_template_6_div_1_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1, " unselected");
    ɵɵelementEnd();
  }
}
function ClrTreeNode_ng_template_6_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 19);
    ɵɵtemplate(1, ClrTreeNode_ng_template_6_div_1_span_1_Template, 2, 0, "span", 20)(2, ClrTreeNode_ng_template_6_div_1_span_2_Template, 2, 0, "span", 20);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.ariaSelected);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r2.ariaSelected);
  }
}
function ClrTreeNode_ng_template_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 2);
    ɵɵtemplate(1, ClrTreeNode_ng_template_6_div_1_Template, 3, 2, "div", 18);
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.featuresService.selectable || ctx_r2.ariaSelected);
  }
}
function ClrTree_clr_recursive_children_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "clr-recursive-children", 1);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("children", ctx_r0.featuresService.recursion.root);
  }
}
function ClrAlert_div_0_button_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 4);
    ɵɵlistener("click", function ClrAlert_div_0_button_3_Template_button_click_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.close());
    });
    ɵɵelement(1, "cds-icon", 5);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵattribute("aria-label", ctx_r1.clrCloseButtonAriaLabel);
  }
}
function ClrAlert_div_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 1)(1, "div", 2);
    ɵɵprojection(2);
    ɵɵelementEnd();
    ɵɵtemplate(3, ClrAlert_div_0_button_3_Template, 2, 1, "button", 3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassProp("alert-sm", ctx_r1.isSmall)("alert-lightweight", ctx_r1.isLightweight)("alert-app-level", ctx_r1.isAppLevel);
    ɵɵproperty("ngClass", ctx_r1.alertClass);
    ɵɵadvance(3);
    ɵɵproperty("ngIf", ctx_r1.closable);
  }
}
function ClrAlertItem_clr_spinner_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "clr-spinner", 3);
  }
}
function ClrAlertItem_cds_icon_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "cds-icon", 4);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵattribute("shape", ctx_r0.iconService.alertIconShape)("aria-label", ctx_r0.iconService.alertIconTitle);
  }
}
var _c88 = [[["clr-alert"]]];
var _c89 = ["clr-alert"];
function ClrAlerts_clr_alerts_pager_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "clr-alerts-pager", 2);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("clrCurrentAlertIndex", ctx_r0.currentAlertIndex);
  }
}
function ClrHeader_button_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 3);
    ɵɵlistener("click", function ClrHeader_button_0_Template_button_click_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.openNav(ctx_r1.responsiveNavCodes.NAV_LEVEL_1));
    });
    ɵɵelement(1, "span");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵattribute("aria-label", ctx_r1.responsiveNavCommonString);
  }
}
function ClrHeader_button_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 4);
    ɵɵlistener("click", function ClrHeader_button_2_Template_button_click_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.openNav(ctx_r1.responsiveNavCodes.NAV_LEVEL_2));
    });
    ɵɵelement(1, "span");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵattribute("aria-label", ctx_r1.responsiveOverflowCommonString);
  }
}
function TemplateRefContainer_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0);
  }
}
var _c90 = ["tabContentProjectedRef"];
function ClrTabContent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "section", 1);
    ɵɵprojection(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵclassProp("active", ctx_r0.active);
    ɵɵproperty("id", ctx_r0.tabContentId)("hidden", !ctx_r0.active);
    ɵɵattribute("aria-labelledby", ctx_r0.ariaLabelledBy)("aria-hidden", !ctx_r0.active);
  }
}
var _c91 = ["tabContentViewContainer"];
function ClrTabs_ng_container_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "li", 5);
    ɵɵelementContainer(2, 6);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const link_r2 = ɵɵnextContext().$implicit;
    ɵɵadvance(2);
    ɵɵproperty("ngTemplateOutlet", link_r2.templateRefContainer.template);
  }
}
function ClrTabs_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, ClrTabs_ng_container_1_ng_container_1_Template, 3, 1, "ng-container", 4);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const link_r2 = ctx.$implicit;
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", link_r2.tabsId === ctx_r2.tabsId && !link_r2.inOverflow);
  }
}
function ClrTabs_ng_container_2_clr_tab_overflow_content_6_ng_container_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 6);
  }
  if (rf & 2) {
    const link_r7 = ɵɵnextContext().$implicit;
    ɵɵproperty("ngTemplateOutlet", link_r7.templateRefContainer.template);
  }
}
function ClrTabs_ng_container_2_clr_tab_overflow_content_6_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, ClrTabs_ng_container_2_clr_tab_overflow_content_6_ng_container_1_ng_container_1_Template, 1, 1, "ng-container", 13);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const link_r7 = ctx.$implicit;
    const ctx_r2 = ɵɵnextContext(3);
    ɵɵadvance();
    ɵɵproperty("ngIf", link_r7.tabsId === ctx_r2.tabsId && link_r7.inOverflow);
  }
}
function ClrTabs_ng_container_2_clr_tab_overflow_content_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "clr-tab-overflow-content", 12);
    ɵɵlistener("keydown.escape", function ClrTabs_ng_container_2_clr_tab_overflow_content_6_Template_clr_tab_overflow_content_keydown_escape_0_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.closeOnEscapeKey());
    }, false, ɵɵresolveDocument)("click", function ClrTabs_ng_container_2_clr_tab_overflow_content_6_Template_clr_tab_overflow_content_click_0_listener($event) {
      ɵɵrestoreView(_r5);
      ɵɵnextContext();
      const tabOverflowTrigger_r6 = ɵɵreference(4);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.closeOnOutsideClick($event, tabOverflowTrigger_r6));
    }, false, ɵɵresolveDocument)("focusout", function ClrTabs_ng_container_2_clr_tab_overflow_content_6_Template_clr_tab_overflow_content_focusout_0_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r2 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r2.closeOnFocusOut($event));
    });
    ɵɵtemplate(1, ClrTabs_ng_container_2_clr_tab_overflow_content_6_ng_container_1_Template, 2, 1, "ng-container", 3);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r2.tabLinkDirectives);
  }
}
function ClrTabs_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "div", 7)(2, "li", 8)(3, "button", 9, 1);
    ɵɵlistener("mousedown", function ClrTabs_ng_container_2_Template_button_mousedown_3_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2._mousedown = true);
    })("focus", function ClrTabs_ng_container_2_Template_button_focus_3_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.openOverflowOnFocus());
    })("click", function ClrTabs_ng_container_2_Template_button_click_3_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r2 = ɵɵnextContext();
      return ɵɵresetView(ctx_r2.toggleOverflowOnClick());
    });
    ɵɵelement(5, "cds-icon", 10);
    ɵɵelementEnd()();
    ɵɵtemplate(6, ClrTabs_ng_container_2_clr_tab_overflow_content_6_Template, 2, 1, "clr-tab-overflow-content", 11);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵclassProp("open", ctx_r2.toggleService.open);
    ɵɵadvance(2);
    ɵɵclassProp("active", ctx_r2.activeTabInOverflow)("open", ctx_r2.toggleService.open);
    ɵɵattribute("tabindex", ctx_r2.activeTabInOverflow && !ctx_r2.toggleService.open ? 0 : -1)("title", ctx_r2.commonStrings.keys.more);
    ɵɵadvance(2);
    ɵɵattribute("status", ctx_r2.toggleService.open ? "info" : null)("title", ctx_r2.commonStrings.keys.more);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r2.toggleService.open);
  }
}
function ClrVerticalNav_button_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 3);
    ɵɵlistener("click", function ClrVerticalNav_button_0_Template_button_click_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.toggleByButton());
    });
    ɵɵelement(1, "cds-icon", 4);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassProp("on-collapse", ctx_r1.collapsed);
    ɵɵattribute("aria-expanded", ctx_r1.ariaExpanded)("aria-label", ctx_r1.commonStrings.keys.verticalNavToggle);
    ɵɵadvance();
    ɵɵattribute("direction", ctx_r1.collapsed ? "right" : "left");
  }
}
function ClrVerticalNav_button_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 5);
    ɵɵlistener("click", function ClrVerticalNav_button_3_Template_button_click_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.collapsed = false);
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵattribute("aria-label", ctx_r1.commonStrings.keys.verticalNavToggle);
  }
}
var _c92 = [[["", "clrVerticalNavLink", ""]], [["", "clrVerticalNavIcon", ""]], "*", [["", "clrIfExpanded", ""], ["clr-vertical-nav-group-children"]]];
var _c93 = ["[clrVerticalNavLink]", "[clrVerticalNavIcon]", "*", "[clrIfExpanded], clr-vertical-nav-group-children"];
var _c94 = ["clrVerticalNavLink", ""];
var _c95 = [[["", "clrVerticalNavIcon", ""]], "*"];
var _c96 = ["[clrVerticalNavIcon]", "*"];
var _c97 = [[["", 8, "modal-nav"]], [["", 8, "modal-title"]], [["", 8, "modal-body"]], [["", 8, "modal-footer"]]];
var _c98 = [".modal-nav", ".modal-title", ".modal-body", ".modal-footer"];
function ClrModal_div_0_button_10_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 11);
    ɵɵlistener("click", function ClrModal_div_0_button_10_Template_button_click_0_listener() {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.close());
    });
    ɵɵelement(1, "cds-icon", 12);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵattribute("aria-label", ctx_r1.closeButtonAriaLabel || ctx_r1.commonStrings.keys.close);
  }
}
function ClrModal_div_0_div_16_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 13);
    ɵɵlistener("click", function ClrModal_div_0_div_16_Template_div_click_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.staticBackdrop || ctx_r1.close());
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    ɵɵproperty("@fade", void 0);
  }
}
function ClrModal_div_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 1)(1, "div", 2);
    ɵɵlistener("@fadeMove.done", function ClrModal_div_0_Template_div_animation_fadeMove_done_1_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.fadeDone($event));
    });
    ɵɵelementStart(2, "div", 3);
    ɵɵtext(3);
    ɵɵelementEnd();
    ɵɵelementStart(4, "div", 4);
    ɵɵprojection(5);
    ɵɵelementStart(6, "div", 5)(7, "div", 6)(8, "div", 7);
    ɵɵprojection(9, 1);
    ɵɵelementEnd();
    ɵɵtemplate(10, ClrModal_div_0_button_10_Template, 2, 1, "button", 8);
    ɵɵelementEnd();
    ɵɵelementStart(11, "div", 9);
    ɵɵprojection(12, 2);
    ɵɵelementEnd();
    ɵɵprojection(13, 3);
    ɵɵelementEnd()();
    ɵɵelementStart(14, "div", 3);
    ɵɵtext(15);
    ɵɵelementEnd()();
    ɵɵtemplate(16, ClrModal_div_0_div_16_Template, 1, 1, "div", 10);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassProp("modal-full-screen", ctx_r1.size == "full-screen");
    ɵɵadvance();
    ɵɵclassProp("modal-sm", ctx_r1.size == "sm")("modal-lg", ctx_r1.size == "lg")("modal-xl", ctx_r1.size == "xl");
    ɵɵproperty("cdkTrapFocusAutoCapture", true)("@fadeMove", ctx_r1.fadeMove);
    ɵɵattribute("aria-hidden", !ctx_r1._open)("aria-labelledby", ctx_r1.labelledBy || ctx_r1.modalId);
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r1.commonStrings.keys.modalContentStart);
    ɵɵadvance(5);
    ɵɵpropertyInterpolate("id", ctx_r1.modalId);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r1.closable);
    ɵɵadvance(5);
    ɵɵtextInterpolate(ctx_r1.commonStrings.keys.modalContentEnd);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.backdrop);
  }
}
var _c99 = [[["", 8, "side-panel-title"]], [["", 8, "side-panel-body"]], [["", 8, "side-panel-footer"]]];
var _c100 = [".side-panel-title", ".side-panel-body", ".side-panel-footer"];
function ClrProgressBar_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.displayValue);
  }
}
var _c101 = [[["clr-timeline-step-header"]], [["clr-timeline-step-title"]], [["clr-timeline-step-description"]]];
var _c102 = ["clr-timeline-step-header", "clr-timeline-step-title", "clr-timeline-step-description"];
function ClrTimelineStep_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelement(1, "cds-icon", 4);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵattribute("status", ctx_r0.iconStatus)("shape", ctx_r0.iconShape)("aria-label", ctx_r0.iconAriaLabel);
  }
}
function ClrTimelineStep_ng_template_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "clr-spinner", 5);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵattribute("aria-label", ctx_r0.iconAriaLabel);
  }
}
var _c103 = ["clr-wizard-stepnav-item", ""];
function ClrWizardStepnavItem_cds_icon_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "cds-icon", 7);
  }
}
function ClrWizardStepnavItem_ng_content_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0, 0, ["*ngIf", "!hasError"]);
  }
}
function ClrWizardStepnavItem_ng_template_5_Template(rf, ctx) {
}
function ClrWizardStepnavItem_span_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 8);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.commonStrings.keys.wizardStepError);
  }
}
function ClrWizardStepnavItem_span_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 8);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.commonStrings.keys.wizardStepSuccess);
  }
}
function ClrWizardStepnav_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 2);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const page_r1 = ctx.$implicit;
    const i_r2 = ctx.index;
    ɵɵproperty("page", page_r1);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", i_r2 + 1, " ");
  }
}
var _c104 = ["pageTitle"];
var _c105 = [[["clr-wizard-title"]], "*", [["clr-wizard-header-action"]], [["clr-wizard-button"]]];
var _c106 = ["clr-wizard-title", "*", "clr-wizard-header-action", "clr-wizard-button"];
function ClrWizard_ng_template_8_Template(rf, ctx) {
}
function ClrWizard_div_9_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵprojection(1, 2);
    ɵɵelementEnd();
  }
}
function ClrWizard_div_9_div_2_ng_template_1_Template(rf, ctx) {
}
function ClrWizard_div_9_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtemplate(1, ClrWizard_div_9_div_2_ng_template_1_Template, 0, 0, "ng-template", 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.navService.currentPage.headerActions);
  }
}
function ClrWizard_div_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 13);
    ɵɵtemplate(1, ClrWizard_div_9_div_1_Template, 2, 0, "div", 14)(2, ClrWizard_div_9_div_2_Template, 2, 1, "div", 14);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.headerActionService.showWizardHeaderActions);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.headerActionService.currentPageHasHeaderActions);
  }
}
function ClrWizard_div_15_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 15);
    ɵɵprojection(1, 3);
    ɵɵelementEnd();
  }
}
function ClrWizard_div_16_ng_template_1_Template(rf, ctx) {
}
function ClrWizard_div_16_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 15);
    ɵɵtemplate(1, ClrWizard_div_16_ng_template_1_Template, 0, 0, "ng-template", 6);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r1.navService.currentPage.buttons);
  }
}
var ClrIconCustomTag = class {
};
ClrIconCustomTag.ɵfac = function ClrIconCustomTag_Factory(t3) {
  return new (t3 || ClrIconCustomTag)();
};
ClrIconCustomTag.ɵdir = ɵɵdefineDirective({
  type: ClrIconCustomTag,
  selectors: [["clr-icon"]]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrIconCustomTag, [{
    type: Directive,
    args: [{
      selector: "clr-icon"
    }]
  }], null, null);
})();
var CdsIconCustomTag = class {
};
CdsIconCustomTag.ɵfac = function CdsIconCustomTag_Factory(t3) {
  return new (t3 || CdsIconCustomTag)();
};
CdsIconCustomTag.ɵdir = ɵɵdefineDirective({
  type: CdsIconCustomTag,
  selectors: [["cds-icon"]]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdsIconCustomTag, [{
    type: Directive,
    args: [{
      selector: "cds-icon"
    }]
  }], null, null);
})();
var CLR_ICON_DIRECTIVES = [ClrIconCustomTag, CdsIconCustomTag];
var ClrIconModule = class {
};
ClrIconModule.ɵfac = function ClrIconModule_Factory(t3) {
  return new (t3 || ClrIconModule)();
};
ClrIconModule.ɵmod = ɵɵdefineNgModule({
  type: ClrIconModule,
  declarations: [ClrIconCustomTag, CdsIconCustomTag],
  imports: [CommonModule],
  exports: [ClrIconCustomTag, CdsIconCustomTag]
});
ClrIconModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrIconModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      declarations: [CLR_ICON_DIRECTIVES],
      exports: [CLR_ICON_DIRECTIVES]
    }]
  }], null, null);
})();
var LoadingListener = class {
};
var ClrLoadingState;
(function(ClrLoadingState2) {
  ClrLoadingState2[ClrLoadingState2["DEFAULT"] = 0] = "DEFAULT";
  ClrLoadingState2[ClrLoadingState2["LOADING"] = 1] = "LOADING";
  ClrLoadingState2[ClrLoadingState2["SUCCESS"] = 2] = "SUCCESS";
  ClrLoadingState2[ClrLoadingState2["ERROR"] = 3] = "ERROR";
})(ClrLoadingState || (ClrLoadingState = {}));
var ClrLoading = class {
  // We find the first parent that handles something loading
  constructor(listener) {
    this.listener = listener;
    this._loadingState = ClrLoadingState.DEFAULT;
  }
  get loadingState() {
    return this._loadingState;
  }
  set loadingState(value) {
    if (value === true) {
      value = ClrLoadingState.LOADING;
    } else if (!value) {
      value = ClrLoadingState.DEFAULT;
    }
    if (value === this._loadingState) {
      return;
    }
    this._loadingState = value;
    if (this.listener) {
      this.listener.loadingStateChange(value);
    }
  }
  ngOnDestroy() {
    this.loadingState = ClrLoadingState.DEFAULT;
  }
};
ClrLoading.ɵfac = function ClrLoading_Factory(t3) {
  return new (t3 || ClrLoading)(ɵɵdirectiveInject(LoadingListener, 8));
};
ClrLoading.ɵdir = ɵɵdefineDirective({
  type: ClrLoading,
  selectors: [["", "clrLoading", ""]],
  inputs: {
    loadingState: [InputFlags.None, "clrLoading", "loadingState"]
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrLoading, [{
    type: Directive,
    args: [{
      selector: "[clrLoading]"
    }]
  }], function() {
    return [{
      type: LoadingListener,
      decorators: [{
        type: Optional
      }]
    }];
  }, {
    loadingState: [{
      type: Input,
      args: ["clrLoading"]
    }]
  });
})();
var IfExpandService = class {
  constructor() {
    this.expandable = 0;
    this._loading = false;
    this._expanded = false;
    this._expandChange = new Subject();
  }
  get loading() {
    return this._loading;
  }
  set loading(value) {
    value = !!value;
    if (value !== this._loading) {
      this._loading = value;
    }
  }
  get expanded() {
    return this._expanded;
  }
  set expanded(value) {
    value = !!value;
    if (value !== this._expanded) {
      this._expanded = value;
      this._expandChange.next(value);
    }
  }
  get expandChange() {
    return this._expandChange.asObservable();
  }
  toggle() {
    this.expanded = !this._expanded;
  }
  loadingStateChange(state2) {
    switch (state2) {
      case ClrLoadingState.LOADING:
        this.loading = true;
        break;
      default:
        this.loading = false;
        break;
    }
  }
};
IfExpandService.ɵfac = function IfExpandService_Factory(t3) {
  return new (t3 || IfExpandService)();
};
IfExpandService.ɵprov = ɵɵdefineInjectable({
  token: IfExpandService,
  factory: IfExpandService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(IfExpandService, [{
    type: Injectable
  }], null, null);
})();
var NB_INSTANCES = 0;
function uniqueIdFactory() {
  return "clr-id-" + NB_INSTANCES++;
}
var ClrAccordionDescription = class {
};
ClrAccordionDescription.ɵfac = function ClrAccordionDescription_Factory(t3) {
  return new (t3 || ClrAccordionDescription)();
};
ClrAccordionDescription.ɵcmp = ɵɵdefineComponent({
  type: ClrAccordionDescription,
  selectors: [["clr-accordion-description"], ["clr-step-description"]],
  hostVars: 2,
  hostBindings: function ClrAccordionDescription_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("clr-accordion-description", true);
    }
  },
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function ClrAccordionDescription_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrAccordionDescription, [{
    type: Component,
    args: [{
      selector: "clr-accordion-description, clr-step-description",
      template: `<ng-content></ng-content>`,
      host: {
        "[class.clr-accordion-description]": "true"
      },
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], null, null);
})();
var AccordionStatus;
(function(AccordionStatus2) {
  AccordionStatus2["Inactive"] = "inactive";
  AccordionStatus2["Error"] = "error";
  AccordionStatus2["Complete"] = "complete";
})(AccordionStatus || (AccordionStatus = {}));
var defaultAnimationTiming = "0.2s ease-in-out";
var panelAnimation = [trigger("skipInitialRender", [transition(":enter", [])]), trigger("toggle", [transition("void => *", [style({
  display: "block",
  height: 0
}), animate(defaultAnimationTiming, style({
  height: "*"
}))])])];
var stepAnimation = [trigger("skipInitialRender", [transition(":enter", [])]), trigger("toggle", [transition("void => *", [style({
  display: "block",
  height: 0
}), animate(defaultAnimationTiming, style({
  height: "*"
}))]), transition("* => void", [style({
  display: "block"
}), animate(defaultAnimationTiming, style({
  height: 0,
  display: "none"
}))])])];
var commonStringsDefault = {
  open: "Open",
  close: "Close",
  show: "Show",
  hide: "Hide",
  expand: "Expand",
  collapse: "Collapse",
  more: "More",
  select: "Select",
  selectAll: "Select All",
  previous: "Previous",
  next: "Next",
  current: "Jump to current",
  info: "Info",
  success: "Success",
  warning: "Warning",
  danger: "Error",
  neutral: "Neutral",
  unknown: "Unknown",
  rowActions: "Available actions",
  pickColumns: "Manage Columns",
  showColumns: "Show Columns",
  sortColumn: "Sort Column",
  firstPage: "First Page",
  lastPage: "Last Page",
  nextPage: "Next Page",
  previousPage: "Previous Page",
  currentPage: "Current Page",
  totalPages: "Total Pages",
  filterItems: "Filter items",
  minValue: "Min value",
  maxValue: "Max value",
  modalContentStart: "Beginning of Modal Content",
  modalContentEnd: "End of Modal Content",
  showColumnsMenuDescription: "Show or hide columns menu",
  allColumnsSelected: "All columns selected",
  signpostToggle: "Signpost Toggle",
  signpostClose: "Signpost Close",
  loading: "Loading",
  // Datagrid
  detailPaneStart: "Start of row details",
  detailPaneEnd: "End of row details",
  singleSelectionAriaLabel: "Single selection header",
  singleActionableAriaLabel: "Single actionable header",
  detailExpandableAriaLabel: "Toggle more row content",
  datagridFilterAriaLabel: "{COLUMN} filter",
  datagridFilterDialogAriaLabel: "Filter dialog",
  columnSeparatorAriaLabel: "Column resize handle",
  columnSeparatorDescription: "Use left or right key to resize the column",
  // Alert
  alertCloseButtonAriaLabel: "Close alert",
  alertNextAlertAriaLabel: "Next alert message, {CURRENT} of {COUNT}",
  alertPreviousAlertAriaLabel: "Previous alert message, {CURRENT} of {COUNT}",
  // Date Picker
  datepickerDialogLabel: "Choose date",
  datepickerToggleChooseDateLabel: "Choose date",
  datepickerToggleChangeDateLabel: "Change date, {SELECTED_DATE}",
  datepickerPreviousMonth: "Previous month",
  datepickerCurrentMonth: "Current month",
  datepickerNextMonth: "Next month",
  datepickerPreviousDecade: "Previous decade",
  datepickerNextDecade: "Next decade",
  datepickerCurrentDecade: "Current decade",
  datepickerSelectMonthText: "Select month, the current month is {CALENDAR_MONTH}",
  datepickerSelectYearText: "Select year, the current year is {CALENDAR_YEAR}",
  datepickerSelectedLabel: "{FULL_DATE} - Selected",
  // Stack View
  stackViewChanged: "Value changed.",
  // Responsive Nav
  responsiveNavToggleOpen: "Open navigation menu",
  responsiveNavToggleClose: "Close navigation menu",
  responsiveNavOverflowOpen: "Open navigation overflow menu",
  responsiveNavOverflowClose: "Close navigation overflow menu",
  //Vertical Nav
  verticalNavToggle: "Toggle vertical navigation",
  // Timeline steps
  timelineStepNotStarted: "Not started",
  timelineStepCurrent: "Current",
  timelineStepSuccess: "Completed",
  timelineStepError: "Error",
  timelineStepProcessing: "In progress",
  // Combobox
  comboboxDelete: "Delete selected option",
  comboboxSearching: 'Searching for matches for "{INPUT}"',
  comboboxSelection: "Selection",
  comboboxSelected: "Selected",
  comboboxNoResults: "No results",
  comboboxOpen: "Show options",
  // Datagrid expandable rows
  datagridExpandableBeginningOf: "Beginning of",
  datagridExpandableEndOf: "End of",
  datagridExpandableRowContent: "Expandable row content",
  datagridExpandableRowsHelperText: `Screen reader table commands may not work for viewing expanded content, please use your screen reader's browse mode to read the content exposed by this button`,
  // Wizard
  wizardStepSuccess: "Completed",
  wizardStepError: "Error",
  wizardStepnavAriaLabel: "Step navigation",
  /**
   * Password Input
   * Screen-reader text for the hide/show password field button
   */
  passwordHide: "Hide password for {LABEL}",
  passwordShow: "Show password for {LABEL}",
  /**
   * Datagrid footer; sr-only text after the number of selected rows.
   */
  selectedRows: "Selected rows",
  // Accordion/Stepper
  stepComplete: "Step {STEP} complete",
  stepError: "Error in step {STEP}",
  // File input
  browse: "Browse",
  fileCount: "{COUNT} files",
  clearFile: "Clear {FILE}",
  clearFiles: "Clear {COUNT} files"
};
var ClrCommonStringsService = class {
  constructor() {
    this._strings = commonStringsDefault;
  }
  /**
   * Access to all of the keys as strings
   */
  get keys() {
    return this._strings;
  }
  /**
   * Allows you to pass in new overrides for localization
   */
  localize(overrides) {
    this._strings = __spreadValues(__spreadValues({}, this._strings), overrides);
  }
  /**
   * Parse a string with a set of tokens to replace
   */
  parse(source, tokens = {}) {
    const names = Object.keys(tokens);
    let output = source;
    if (names.length) {
      names.forEach((name) => {
        output = output.replace(`{${name}}`, tokens[name]);
      });
    }
    return output;
  }
};
ClrCommonStringsService.ɵfac = function ClrCommonStringsService_Factory(t3) {
  return new (t3 || ClrCommonStringsService)();
};
ClrCommonStringsService.ɵprov = ɵɵdefineInjectable({
  token: ClrCommonStringsService,
  factory: ClrCommonStringsService.ɵfac,
  providedIn: "root"
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrCommonStringsService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var AccordionStrategy;
(function(AccordionStrategy2) {
  AccordionStrategy2["Default"] = "default";
  AccordionStrategy2["Multi"] = "multi";
})(AccordionStrategy || (AccordionStrategy = {}));
var accordionCount = 0;
var AccordionPanelModel = class {
  constructor(id, accordionId) {
    this.id = id;
    this.accordionId = accordionId;
    this.status = AccordionStatus.Inactive;
    this.index = null;
    this.disabled = false;
    this.open = false;
    this.templateId = `${this.id}-${this.accordionId}`;
  }
};
var AccordionModel = class {
  constructor() {
    this.strategy = AccordionStrategy.Default;
    this.accordionCount = accordionCount++;
    this._panels = {};
  }
  get panels() {
    return Object.keys(this._panels).map((id) => this._panels[id]);
  }
  setStrategy(strategy) {
    this.strategy = strategy;
  }
  updatePanelOrder(ids) {
    ids.forEach((id, index) => this._panels[id].index = index);
    this.removeOldPanels(ids);
  }
  addPanel(id, open = false) {
    this._panels[id] = new AccordionPanelModel(id, this.accordionCount);
    this._panels[id].open = open;
  }
  togglePanel(panelId, open) {
    const panelIsOpen = this._panels[panelId].open;
    const newOpenState = open !== void 0 ? open : !panelIsOpen;
    if (newOpenState && this.strategy === AccordionStrategy.Default) {
      this.closeAllPanels();
    }
    this._panels[panelId].open = newOpenState;
  }
  disablePanel(panelId, disabled) {
    this._panels[panelId].disabled = disabled;
  }
  closeAllPanels() {
    this.panels.forEach((panel) => this._panels[panel.id].open = false);
  }
  removeOldPanels(ids) {
    this.panels.filter((panel) => ids.find((id) => id === panel.id) === void 0).forEach((panel) => delete this._panels[panel.id]);
  }
};
var AccordionService = class {
  constructor() {
    this.accordion = new AccordionModel();
    this._panelsChanges = new BehaviorSubject(this.accordion.panels);
  }
  getPanelChanges(panelId) {
    return this._panelsChanges.pipe(map((panels) => panels.find((s2) => s2.id === panelId)));
  }
  setStrategy(strategy) {
    this.accordion.setStrategy(strategy);
  }
  addPanel(panelId, open = false) {
    this.accordion.addPanel(panelId, open);
    this.emitUpdatedPanels();
  }
  togglePanel(panelId, open) {
    this.accordion.togglePanel(panelId, open);
    this.emitUpdatedPanels();
  }
  disablePanel(panelId, disabled) {
    this.accordion.disablePanel(panelId, disabled);
    this.emitUpdatedPanels();
  }
  updatePanelOrder(ids) {
    this.accordion.updatePanelOrder(ids);
    this.emitUpdatedPanels();
  }
  emitUpdatedPanels() {
    this._panelsChanges.next(this.accordion.panels);
  }
};
AccordionService.ɵfac = function AccordionService_Factory(t3) {
  return new (t3 || AccordionService)();
};
AccordionService.ɵprov = ɵɵdefineInjectable({
  token: AccordionService,
  factory: AccordionService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AccordionService, [{
    type: Injectable
  }], null, null);
})();
var ClrAccordionPanel = class {
  constructor(commonStrings, accordionService, ifExpandService, cdr) {
    this.commonStrings = commonStrings;
    this.accordionService = accordionService;
    this.ifExpandService = ifExpandService;
    this.cdr = cdr;
    this.disabled = false;
    this.panelOpen = false;
    this.panelOpenChange = new EventEmitter();
    this.AccordionStatus = AccordionStatus;
    this.isAccordion = true;
    this._id = uniqueIdFactory();
  }
  get id() {
    return this._id;
  }
  set id(value) {
    this._id = value;
  }
  get panelNumber() {
    return this._panelIndex + 1;
  }
  ngOnInit() {
    this.panel = this.accordionService.getPanelChanges(this.id).pipe(tap((panel) => this.emitPanelChange(panel)));
    this.accordionService.addPanel(this.id, this.panelOpen);
    this.accordionService.togglePanel(this.id, this.panelOpen);
    this.accordionService.disablePanel(this.id, this.disabled);
  }
  ngOnChanges(changes) {
    if (this.panel && changes.panelOpen && changes.panelOpen.currentValue !== changes.panelOpen.previousValue) {
      this.accordionService.togglePanel(this.id, changes.panelOpen.currentValue);
    }
    if (this.panel && changes.disabled && changes.disabled.currentValue !== changes.disabled.previousValue) {
      this.accordionService.disablePanel(this.id, changes.disabled.currentValue);
    }
  }
  togglePanel() {
    this.accordionService.togglePanel(this.id);
  }
  collapsePanelOnAnimationDone(panel) {
    if (!panel.open) {
      this.ifExpandService.expanded = false;
    }
  }
  getPanelStateClasses(panel) {
    return `clr-accordion-panel-${panel.status} ${panel.open ? "clr-accordion-panel-open" : ""}`;
  }
  getAccordionContentId(id) {
    return `clr-accordion-content-${id}'`;
  }
  getAccordionHeaderId(id) {
    return `clr-accordion-header-${id}`;
  }
  stepCompleteText(panelNumber) {
    return this.commonStrings.parse(this.commonStrings.keys.stepComplete, {
      STEP: panelNumber.toString()
    });
  }
  stepErrorText(panelNumber) {
    return this.commonStrings.parse(this.commonStrings.keys.stepError, {
      STEP: panelNumber.toString()
    });
  }
  emitPanelChange(panel) {
    if (panel.index !== this._panelIndex) {
      this._panelIndex = panel.index;
      this.cdr.detectChanges();
    }
    if (panel.open !== this.panelOpen) {
      this.panelOpenChange.emit(panel.open);
      this.panelOpen = panel.open;
    }
    if (panel.open) {
      this.ifExpandService.expanded = true;
    }
  }
};
ClrAccordionPanel.ɵfac = function ClrAccordionPanel_Factory(t3) {
  return new (t3 || ClrAccordionPanel)(ɵɵdirectiveInject(ClrCommonStringsService), ɵɵdirectiveInject(AccordionService), ɵɵdirectiveInject(IfExpandService), ɵɵdirectiveInject(ChangeDetectorRef));
};
ClrAccordionPanel.ɵcmp = ɵɵdefineComponent({
  type: ClrAccordionPanel,
  selectors: [["clr-accordion-panel"]],
  contentQueries: function ClrAccordionPanel_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ClrAccordionDescription, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.accordionDescription = _t);
    }
  },
  hostVars: 4,
  hostBindings: function ClrAccordionPanel_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("clr-accordion-panel", true)("clr-accordion-panel-disabled", ctx.disabled);
    }
  },
  inputs: {
    disabled: [InputFlags.None, "clrAccordionPanelDisabled", "disabled"],
    panelOpen: [InputFlags.None, "clrAccordionPanelOpen", "panelOpen"]
  },
  outputs: {
    panelOpenChange: "clrAccordionPanelOpenChange"
  },
  features: [ɵɵProvidersFeature([IfExpandService]), ɵɵNgOnChangesFeature],
  ngContentSelectors: _c2,
  decls: 2,
  vars: 3,
  consts: [["headerButton", ""], [4, "ngIf"], [3, "ngClass"], [1, "clr-accordion-header"], ["type", "button", 1, "clr-accordion-header-button", 3, "click", "id", "disabled"], [1, "clr-accordion-status"], ["shape", "angle", "direction", "right", 1, "clr-accordion-angle"], [1, "clr-accordion-number"], ["status", "danger", "shape", "exclamation-circle", 1, "clr-accordion-error-icon"], ["status", "success", "shape", "check-circle", 1, "clr-accordion-complete-icon"], ["role", "status", 1, "clr-sr-only"], ["role", "region", 1, "clr-accordion-content-region", 3, "id"], ["class", "clr-accordion-content", 4, "ngIf"], [1, "clr-accordion-content"], [1, "clr-accordion-inner-content"]],
  template: function ClrAccordionPanel_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c12);
      ɵɵtemplate(0, ClrAccordionPanel_ng_container_0_Template, 19, 18, "ng-container", 1);
      ɵɵpipe(1, "async");
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ɵɵpipeBind1(1, 1, ctx.panel));
    }
  },
  dependencies: [NgClass, NgIf, CdsIconCustomTag, AsyncPipe],
  encapsulation: 2,
  data: {
    animation: panelAnimation
  },
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrAccordionPanel, [{
    type: Component,
    args: [{
      selector: "clr-accordion-panel",
      host: {
        "[class.clr-accordion-panel]": "true"
      },
      changeDetection: ChangeDetectionStrategy.OnPush,
      animations: panelAnimation,
      providers: [IfExpandService],
      template: '<ng-container *ngIf="panel | async; let panel">\n  <div [ngClass]="getPanelStateClasses(panel)">\n    <div class="clr-accordion-header">\n      <button\n        type="button"\n        class="clr-accordion-header-button"\n        (click)="togglePanel()"\n        [id]="getAccordionHeaderId(panel.templateId)"\n        [disabled]="isAccordion && panel.disabled"\n        [attr.aria-disabled]="!isAccordion && panel.disabled"\n        [attr.aria-controls]="getAccordionContentId(panel.templateId)"\n        [attr.aria-expanded]="panel.open"\n        [class.clr-accordion-header-has-description]="(accordionDescription.changes | async)?.length || accordionDescription.length"\n        #headerButton\n      >\n        <span class="clr-accordion-status">\n          <cds-icon shape="angle" direction="right" class="clr-accordion-angle"></cds-icon>\n          <span class="clr-accordion-number">{{panelNumber}}.</span>\n          <cds-icon status="danger" shape="exclamation-circle" class="clr-accordion-error-icon"></cds-icon>\n          <cds-icon status="success" shape="check-circle" class="clr-accordion-complete-icon"></cds-icon>\n        </span>\n        <ng-content select="clr-accordion-title, clr-step-title"></ng-content>\n        <ng-content select="clr-accordion-description, clr-step-description"></ng-content>\n      </button>\n      <div class="clr-sr-only" role="status">\n        <ng-container *ngIf="panel.status === AccordionStatus.Error"> {{ stepErrorText(panelNumber)}} </ng-container>\n        <ng-container *ngIf="panel.status === AccordionStatus.Complete">\n          {{ stepCompleteText(panelNumber)}}\n        </ng-container>\n      </div>\n    </div>\n    <div\n      @skipInitialRender\n      role="region"\n      class="clr-accordion-content-region"\n      [id]="getAccordionContentId(panel.templateId)"\n      [attr.aria-hidden]="!panel.open"\n      [attr.aria-labelledby]="getAccordionHeaderId(panel.templateId)"\n    >\n      <div\n        *ngIf="panel.open"\n        @toggle\n        (@toggle.done)="collapsePanelOnAnimationDone(panel)"\n        class="clr-accordion-content"\n      >\n        <div class="clr-accordion-inner-content">\n          <ng-content></ng-content>\n        </div>\n      </div>\n    </div>\n  </div>\n</ng-container>\n'
    }]
  }], function() {
    return [{
      type: ClrCommonStringsService
    }, {
      type: AccordionService
    }, {
      type: IfExpandService
    }, {
      type: ChangeDetectorRef
    }];
  }, {
    disabled: [{
      type: Input,
      args: ["clrAccordionPanelDisabled"]
    }, {
      type: HostBinding,
      args: ["class.clr-accordion-panel-disabled"]
    }],
    panelOpen: [{
      type: Input,
      args: ["clrAccordionPanelOpen"]
    }],
    panelOpenChange: [{
      type: Output,
      args: ["clrAccordionPanelOpenChange"]
    }],
    accordionDescription: [{
      type: ContentChildren,
      args: [ClrAccordionDescription]
    }]
  });
})();
var ClrAccordion = class {
  constructor(accordionService) {
    this.accordionService = accordionService;
    this.multiPanel = false;
    this.subscriptions = [];
  }
  ngOnInit() {
    this.setAccordionStrategy();
  }
  ngOnChanges(changes) {
    if (changes.multiPanel.currentValue !== changes.multiPanel.previousValue) {
      this.setAccordionStrategy();
    }
  }
  ngAfterViewInit() {
    this.subscriptions.push(this.listenForDOMChanges());
  }
  ngOnDestroy() {
    this.subscriptions.forEach((s2) => s2.unsubscribe());
  }
  setAccordionStrategy() {
    const strategy = this.multiPanel ? AccordionStrategy.Multi : AccordionStrategy.Default;
    this.accordionService.setStrategy(strategy);
  }
  listenForDOMChanges() {
    return this.panels.changes.pipe(startWith(this.panels)).subscribe((panels) => this.accordionService.updatePanelOrder(panels.toArray().map((p2) => p2.id)));
  }
};
ClrAccordion.ɵfac = function ClrAccordion_Factory(t3) {
  return new (t3 || ClrAccordion)(ɵɵdirectiveInject(AccordionService));
};
ClrAccordion.ɵcmp = ɵɵdefineComponent({
  type: ClrAccordion,
  selectors: [["clr-accordion"]],
  contentQueries: function ClrAccordion_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ClrAccordionPanel, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.panels = _t);
    }
  },
  hostVars: 2,
  hostBindings: function ClrAccordion_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("clr-accordion", true);
    }
  },
  inputs: {
    multiPanel: [InputFlags.None, "clrAccordionMultiPanel", "multiPanel"]
  },
  features: [ɵɵProvidersFeature([AccordionService]), ɵɵNgOnChangesFeature],
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function ClrAccordion_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrAccordion, [{
    type: Component,
    args: [{
      selector: "clr-accordion",
      template: `<ng-content></ng-content>`,
      host: {
        "[class.clr-accordion]": "true"
      },
      providers: [AccordionService],
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], function() {
    return [{
      type: AccordionService
    }];
  }, {
    multiPanel: [{
      type: Input,
      args: ["clrAccordionMultiPanel"]
    }],
    panels: [{
      type: ContentChildren,
      args: [ClrAccordionPanel]
    }]
  });
})();
var ClrAccordionContent = class {
};
ClrAccordionContent.ɵfac = function ClrAccordionContent_Factory(t3) {
  return new (t3 || ClrAccordionContent)();
};
ClrAccordionContent.ɵcmp = ɵɵdefineComponent({
  type: ClrAccordionContent,
  selectors: [["clr-accordion-content"], ["clr-step-content"]],
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function ClrAccordionContent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrAccordionContent, [{
    type: Component,
    args: [{
      selector: "clr-accordion-content, clr-step-content",
      template: `<ng-content></ng-content>`,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], null, null);
})();
var ClrAccordionTitle = class {
};
ClrAccordionTitle.ɵfac = function ClrAccordionTitle_Factory(t3) {
  return new (t3 || ClrAccordionTitle)();
};
ClrAccordionTitle.ɵcmp = ɵɵdefineComponent({
  type: ClrAccordionTitle,
  selectors: [["clr-accordion-title"], ["clr-step-title"]],
  hostVars: 2,
  hostBindings: function ClrAccordionTitle_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("clr-accordion-title", true);
    }
  },
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function ClrAccordionTitle_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrAccordionTitle, [{
    type: Component,
    args: [{
      selector: "clr-accordion-title, clr-step-title",
      template: `<ng-content></ng-content>`,
      host: {
        "[class.clr-accordion-title]": "true"
      },
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], null, null);
})();
var WillyWonka = class {
  constructor() {
    this.disableChocolateCheck = false;
    this._chocolate = new Subject();
  }
  get chocolate() {
    return this._chocolate.asObservable();
  }
  ngAfterViewChecked() {
    if (!this.disableChocolateCheck) {
      this._chocolate.next();
    }
  }
};
WillyWonka.ɵfac = function WillyWonka_Factory(t3) {
  return new (t3 || WillyWonka)();
};
WillyWonka.ɵdir = ɵɵdefineDirective({
  type: WillyWonka
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(WillyWonka, [{
    type: Directive
  }], null, null);
})();
var OompaLoompa = class {
  // FIXME: Request Injector once we move to Angular 4.2+, it'll allow easier refactors
  constructor(cdr, willyWonka) {
    this.subscription = willyWonka.chocolate.subscribe(() => {
      if (this.latestFlavor !== this.flavor) {
        willyWonka.disableChocolateCheck = true;
        cdr.detectChanges();
        willyWonka.disableChocolateCheck = false;
      }
    });
  }
  ngAfterContentChecked() {
    this.latestFlavor = this.flavor;
  }
  ngOnDestroy() {
    this.subscription.unsubscribe();
  }
};
OompaLoompa.ɵfac = function OompaLoompa_Factory(t3) {
  return new (t3 || OompaLoompa)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(WillyWonka));
};
OompaLoompa.ɵdir = ɵɵdefineDirective({
  type: OompaLoompa
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(OompaLoompa, [{
    type: Directive
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: WillyWonka
    }];
  }, null);
})();
var AccordionWillyWonka = class extends WillyWonka {
};
AccordionWillyWonka.ɵfac = /* @__PURE__ */ (() => {
  let ɵAccordionWillyWonka_BaseFactory;
  return function AccordionWillyWonka_Factory(t3) {
    return (ɵAccordionWillyWonka_BaseFactory || (ɵAccordionWillyWonka_BaseFactory = ɵɵgetInheritedFactory(AccordionWillyWonka)))(t3 || AccordionWillyWonka);
  };
})();
AccordionWillyWonka.ɵdir = ɵɵdefineDirective({
  type: AccordionWillyWonka,
  selectors: [["clr-accordion"]],
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AccordionWillyWonka, [{
    type: Directive,
    args: [{
      selector: "clr-accordion"
    }]
  }], null, null);
})();
var AccordionOompaLoompa = class extends OompaLoompa {
  constructor(cdr, willyWonka, ifExpandService) {
    if (!willyWonka) {
      throw new Error("clr-accordion-panel should only be used inside of clr-accordion");
    }
    super(cdr, willyWonka);
    this.expand = ifExpandService;
  }
  get flavor() {
    return this.expand.expanded;
  }
};
AccordionOompaLoompa.ɵfac = function AccordionOompaLoompa_Factory(t3) {
  return new (t3 || AccordionOompaLoompa)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(AccordionWillyWonka, 8), ɵɵdirectiveInject(IfExpandService));
};
AccordionOompaLoompa.ɵdir = ɵɵdefineDirective({
  type: AccordionOompaLoompa,
  selectors: [["clr-accordion-panel"]],
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AccordionOompaLoompa, [{
    type: Directive,
    args: [{
      selector: "clr-accordion-panel"
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: AccordionWillyWonka,
      decorators: [{
        type: Optional
      }]
    }, {
      type: IfExpandService
    }];
  }, null);
})();
var declarations$1 = [ClrAccordion, ClrAccordionPanel, ClrAccordionTitle, ClrAccordionDescription, ClrAccordionContent, AccordionOompaLoompa, AccordionWillyWonka];
var ClrAccordionModule = class {
  constructor() {
    r.addIcons(o3, e3, l);
  }
};
ClrAccordionModule.ɵfac = function ClrAccordionModule_Factory(t3) {
  return new (t3 || ClrAccordionModule)();
};
ClrAccordionModule.ɵmod = ɵɵdefineNgModule({
  type: ClrAccordionModule,
  declarations: [ClrAccordion, ClrAccordionPanel, ClrAccordionTitle, ClrAccordionDescription, ClrAccordionContent, AccordionOompaLoompa, AccordionWillyWonka],
  imports: [CommonModule, ClrIconModule],
  exports: [ClrAccordion, ClrAccordionPanel, ClrAccordionTitle, ClrAccordionDescription, ClrAccordionContent, AccordionOompaLoompa, AccordionWillyWonka]
});
ClrAccordionModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, ClrIconModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrAccordionModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, ClrIconModule],
      declarations: [...declarations$1],
      exports: [...declarations$1]
    }]
  }], function() {
    return [];
  }, null);
})();
function triggerAllFormControlValidation(formGroup) {
  Object.keys(formGroup.controls).forEach((field) => {
    const control = formGroup.get(field);
    if (control instanceof FormControl) {
      control.markAsTouched();
      control.markAsDirty();
      control.updateValueAndValidity();
    } else if (control instanceof FormGroup) {
      triggerAllFormControlValidation(control);
    }
  });
}
var StepperModel = class extends AccordionModel {
  constructor() {
    super(...arguments);
    this.stepperModelInitialize = false;
  }
  get allPanelsCompleted() {
    return this.panels.length && this.getNumberOfIncompletePanels() === 0 && this.getNumberOfOpenPanels() === 0;
  }
  get shouldOpenFirstPanel() {
    return !this.initialPanel || this._panels && Object.keys(this._panels).length && !this._panels[this.initialPanel];
  }
  addPanel(id, open = false) {
    super.addPanel(id, open);
    this._panels[id].disabled = true;
  }
  updatePanelOrder(ids) {
    super.updatePanelOrder(ids);
    if (this.stepperModelInitialize === false) {
      this.openFirstPanel();
    }
  }
  togglePanel(panelId) {
    if (this._panels[panelId].status === AccordionStatus.Complete) {
      this._panels[panelId].open = !this._panels[panelId].open;
    }
  }
  navigateToNextPanel(currentPanelId, currentPanelValid = true) {
    if (currentPanelValid) {
      this.completePanel(currentPanelId);
      this.openNextPanel(this._panels[currentPanelId].id);
    } else {
      this.setPanelError(currentPanelId);
    }
  }
  overrideInitialPanel(panelId) {
    this.initialPanel = panelId;
    this.panels.filter(() => this._panels[panelId] !== void 0).forEach((panel) => {
      if (panel.index < this._panels[panelId].index) {
        this.completePanel(panel.id);
      } else if (panel.id === panelId) {
        this._panels[panel.id].open = true;
      } else {
        this._panels[panel.id].open = false;
      }
    });
  }
  setPanelValid(panelId) {
    this._panels[panelId].status = AccordionStatus.Complete;
  }
  setPanelInvalid(panelId) {
    this._panels[panelId].status = AccordionStatus.Error;
  }
  setPanelsWithErrors(ids) {
    ids.forEach((id) => this.setPanelError(id));
  }
  resetPanels() {
    this.stepperModelInitialize = false;
    this.panels.forEach((p2) => this.resetPanel(p2.id));
    this.openFirstPanel();
  }
  getNextPanel(currentPanelId) {
    return this.panels.find((s2) => s2.index === this._panels[currentPanelId].index + 1);
  }
  resetAllFuturePanels(panelId) {
    this.panels.filter((panel) => panel.index >= this._panels[panelId].index).forEach((panel) => this.resetPanel(panel.id));
  }
  resetPanel(panelId) {
    this._panels[panelId].status = AccordionStatus.Inactive;
    this._panels[panelId].open = false;
    this._panels[panelId].disabled = true;
  }
  openFirstPanel() {
    if (!this.shouldOpenFirstPanel) {
      return;
    }
    const firstPanel = this.getFirstPanel();
    if (!firstPanel) {
      return;
    }
    this._panels[firstPanel.id].open = true;
    this._panels[firstPanel.id].disabled = true;
    this.stepperModelInitialize = true;
  }
  completePanel(panelId) {
    this._panels[panelId].status = AccordionStatus.Complete;
    this._panels[panelId].disabled = false;
    this._panels[panelId].open = false;
  }
  openNextPanel(currentPanelId) {
    const nextPanel = this.getNextPanel(currentPanelId);
    if (nextPanel) {
      this.resetAllFuturePanels(nextPanel.id);
      this._panels[nextPanel.id].open = true;
      this._panels[nextPanel.id].disabled = true;
    }
  }
  setPanelError(panelId) {
    this.resetAllFuturePanels(panelId);
    this._panels[panelId].open = true;
    this._panels[panelId].status = AccordionStatus.Error;
  }
  getFirstPanel() {
    return this.panels.find((panel) => panel.index === 0);
  }
  getNumberOfIncompletePanels() {
    return this.panels.reduce((prev, next) => next.status !== AccordionStatus.Complete ? prev + 1 : prev, 0);
  }
  getNumberOfOpenPanels() {
    return this.panels.reduce((prev, next) => next.open !== false ? prev + 1 : prev, 0);
  }
};
var StepperService = class extends AccordionService {
  constructor() {
    super();
    this.panelsCompleted = this.getAllCompletedPanelChanges();
    this.accordion = new StepperModel();
    this._activeStepChanges = new Subject();
    this.activeStep = this._activeStepChanges.asObservable();
  }
  resetPanels() {
    this.accordion.resetPanels();
    this.emitUpdatedPanels();
  }
  setPanelValid(panelId) {
    this.accordion.setPanelValid(panelId);
    this.emitUpdatedPanels();
  }
  setPanelInvalid(panelId) {
    this.accordion.setPanelInvalid(panelId);
    this.emitUpdatedPanels();
  }
  setPanelsWithErrors(ids) {
    this.accordion.setPanelsWithErrors(ids);
    this.emitUpdatedPanels();
  }
  navigateToNextPanel(currentPanelId, currentPanelValid = true) {
    this.accordion.navigateToNextPanel(currentPanelId, currentPanelValid);
    this.updateNextStep(currentPanelId, currentPanelValid);
    this.emitUpdatedPanels();
  }
  overrideInitialPanel(panelId) {
    this.accordion.overrideInitialPanel(panelId);
    this.emitUpdatedPanels();
  }
  updateNextStep(currentPanelId, currentPanelValid) {
    const nextPanel = this.accordion.getNextPanel(currentPanelId);
    if (currentPanelValid && nextPanel) {
      this._activeStepChanges.next(nextPanel.id);
    } else if (currentPanelValid) {
      this._activeStepChanges.next(currentPanelId);
    }
  }
  getAllCompletedPanelChanges() {
    return this._panelsChanges.pipe(map(() => this.accordion.allPanelsCompleted), distinctUntilChanged());
  }
};
StepperService.ɵfac = function StepperService_Factory(t3) {
  return new (t3 || StepperService)();
};
StepperService.ɵprov = ɵɵdefineInjectable({
  token: StepperService,
  factory: StepperService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StepperService, [{
    type: Injectable
  }], function() {
    return [];
  }, null);
})();
var ClrStepperPanel = class extends ClrAccordionPanel {
  constructor(platformId, commonStrings, formGroupName, ngModelGroup, stepperService, ifExpandService, cdr) {
    super(commonStrings, stepperService, ifExpandService, cdr);
    this.platformId = platformId;
    this.commonStrings = commonStrings;
    this.formGroupName = formGroupName;
    this.ngModelGroup = ngModelGroup;
    this.stepperService = stepperService;
    this.isAccordion = false;
    this.subscriptions = [];
  }
  get id() {
    return this.formGroupName ? this.formGroupName.name.toString() : this.ngModelGroup.name;
  }
  set id(_value) {
  }
  get formGroup() {
    return this.formGroupName ? this.formGroupName.control : this.ngModelGroup.control;
  }
  ngOnInit() {
    super.ngOnInit();
    this.panel = this.panel.pipe(tap((panel) => this.triggerAllFormControlValidationIfError(panel)));
    this.stepperService.disablePanel(this.id, true);
    this.listenToFocusChanges();
    if (this.formGroup) {
      const invalidStatusTrigger = this.formGroup.statusChanges.pipe(filter((status) => status === "INVALID"));
      this.subscriptions.push(this.formGroup.statusChanges.pipe(skipUntil(invalidStatusTrigger), distinctUntilChanged()).subscribe((status) => {
        if (status === "VALID") {
          this.stepperService.setPanelValid(this.id);
        } else if (status === "INVALID") {
          this.stepperService.setPanelInvalid(this.id);
        }
      }));
    }
  }
  ngOnDestroy() {
    this.subscriptions.forEach((s2) => s2.unsubscribe());
  }
  listenToFocusChanges() {
    this.subscriptions.push(this.stepperService.activeStep.pipe(filter((panelId) => isPlatformBrowser(this.platformId) && panelId === this.id)).subscribe(() => {
      setTimeout(() => this.headerButton.nativeElement.focus(), 1500);
    }));
  }
  triggerAllFormControlValidationIfError(panel) {
    if (panel.status === AccordionStatus.Error) {
      triggerAllFormControlValidation(this.formGroup);
    }
  }
};
ClrStepperPanel.ɵfac = function ClrStepperPanel_Factory(t3) {
  return new (t3 || ClrStepperPanel)(ɵɵdirectiveInject(PLATFORM_ID), ɵɵdirectiveInject(ClrCommonStringsService), ɵɵdirectiveInject(FormGroupName, 8), ɵɵdirectiveInject(NgModelGroup, 8), ɵɵdirectiveInject(StepperService), ɵɵdirectiveInject(IfExpandService), ɵɵdirectiveInject(ChangeDetectorRef));
};
ClrStepperPanel.ɵcmp = ɵɵdefineComponent({
  type: ClrStepperPanel,
  selectors: [["clr-stepper-panel"]],
  viewQuery: function ClrStepperPanel_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c3, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerButton = _t.first);
    }
  },
  hostVars: 2,
  hostBindings: function ClrStepperPanel_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("clr-accordion-panel", true);
    }
  },
  features: [ɵɵProvidersFeature([IfExpandService]), ɵɵInheritDefinitionFeature],
  ngContentSelectors: _c2,
  decls: 2,
  vars: 3,
  consts: [["headerButton", ""], [4, "ngIf"], [3, "ngClass"], [1, "clr-accordion-header"], ["type", "button", 1, "clr-accordion-header-button", 3, "click", "id", "disabled"], [1, "clr-accordion-status"], ["shape", "angle", "direction", "right", 1, "clr-accordion-angle"], [1, "clr-accordion-number"], ["status", "danger", "shape", "exclamation-circle", 1, "clr-accordion-error-icon"], ["status", "success", "shape", "check-circle", 1, "clr-accordion-complete-icon"], ["role", "status", 1, "clr-sr-only"], ["role", "region", 1, "clr-accordion-content-region", 3, "id"], ["class", "clr-accordion-content", 4, "ngIf"], [1, "clr-accordion-content"], [1, "clr-accordion-inner-content"]],
  template: function ClrStepperPanel_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c12);
      ɵɵtemplate(0, ClrStepperPanel_ng_container_0_Template, 19, 18, "ng-container", 1);
      ɵɵpipe(1, "async");
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ɵɵpipeBind1(1, 1, ctx.panel));
    }
  },
  dependencies: [NgClass, NgIf, CdsIconCustomTag, AsyncPipe],
  encapsulation: 2,
  data: {
    animation: stepAnimation
  },
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrStepperPanel, [{
    type: Component,
    args: [{
      selector: "clr-stepper-panel",
      host: {
        "[class.clr-accordion-panel]": "true"
      },
      changeDetection: ChangeDetectionStrategy.OnPush,
      animations: stepAnimation,
      providers: [IfExpandService],
      template: '<ng-container *ngIf="panel | async; let panel">\n  <div [ngClass]="getPanelStateClasses(panel)">\n    <div class="clr-accordion-header">\n      <button\n        type="button"\n        class="clr-accordion-header-button"\n        (click)="togglePanel()"\n        [id]="getAccordionHeaderId(panel.templateId)"\n        [disabled]="isAccordion && panel.disabled"\n        [attr.aria-disabled]="!isAccordion && panel.disabled"\n        [attr.aria-controls]="getAccordionContentId(panel.templateId)"\n        [attr.aria-expanded]="panel.open"\n        [class.clr-accordion-header-has-description]="(accordionDescription.changes | async)?.length || accordionDescription.length"\n        #headerButton\n      >\n        <span class="clr-accordion-status">\n          <cds-icon shape="angle" direction="right" class="clr-accordion-angle"></cds-icon>\n          <span class="clr-accordion-number">{{panelNumber}}.</span>\n          <cds-icon status="danger" shape="exclamation-circle" class="clr-accordion-error-icon"></cds-icon>\n          <cds-icon status="success" shape="check-circle" class="clr-accordion-complete-icon"></cds-icon>\n        </span>\n        <ng-content select="clr-accordion-title, clr-step-title"></ng-content>\n        <ng-content select="clr-accordion-description, clr-step-description"></ng-content>\n      </button>\n      <div class="clr-sr-only" role="status">\n        <ng-container *ngIf="panel.status === AccordionStatus.Error"> {{ stepErrorText(panelNumber)}} </ng-container>\n        <ng-container *ngIf="panel.status === AccordionStatus.Complete">\n          {{ stepCompleteText(panelNumber)}}\n        </ng-container>\n      </div>\n    </div>\n    <div\n      @skipInitialRender\n      role="region"\n      class="clr-accordion-content-region"\n      [id]="getAccordionContentId(panel.templateId)"\n      [attr.aria-hidden]="!panel.open"\n      [attr.aria-labelledby]="getAccordionHeaderId(panel.templateId)"\n    >\n      <div\n        *ngIf="panel.open"\n        @toggle\n        (@toggle.done)="collapsePanelOnAnimationDone(panel)"\n        class="clr-accordion-content"\n      >\n        <div class="clr-accordion-inner-content">\n          <ng-content></ng-content>\n        </div>\n      </div>\n    </div>\n  </div>\n</ng-container>\n'
    }]
  }], function() {
    return [{
      type: void 0,
      decorators: [{
        type: Inject,
        args: [PLATFORM_ID]
      }]
    }, {
      type: ClrCommonStringsService
    }, {
      type: FormGroupName,
      decorators: [{
        type: Optional
      }]
    }, {
      type: NgModelGroup,
      decorators: [{
        type: Optional
      }]
    }, {
      type: StepperService
    }, {
      type: IfExpandService
    }, {
      type: ChangeDetectorRef
    }];
  }, {
    headerButton: [{
      type: ViewChild,
      args: ["headerButton"]
    }]
  });
})();
var ClrStepButtonType;
(function(ClrStepButtonType2) {
  ClrStepButtonType2["Next"] = "next";
  ClrStepButtonType2["Submit"] = "submit";
})(ClrStepButtonType || (ClrStepButtonType = {}));
var ClrStepButton = class {
  constructor(clrStep, stepperService) {
    this.clrStep = clrStep;
    this.stepperService = stepperService;
    this.type = ClrStepButtonType.Next;
    this.submitButton = false;
  }
  ngOnInit() {
    this.submitButton = this.type === ClrStepButtonType.Submit;
  }
  navigateToNextPanel() {
    this.stepperService.navigateToNextPanel(this.clrStep.id, this.clrStep.formGroup.valid);
  }
};
ClrStepButton.ɵfac = function ClrStepButton_Factory(t3) {
  return new (t3 || ClrStepButton)(ɵɵdirectiveInject(ClrStepperPanel), ɵɵdirectiveInject(StepperService));
};
ClrStepButton.ɵdir = ɵɵdefineDirective({
  type: ClrStepButton,
  selectors: [["", "clrStepButton", ""]],
  hostVars: 7,
  hostBindings: function ClrStepButton_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function ClrStepButton_click_HostBindingHandler() {
        return ctx.navigateToNextPanel();
      });
    }
    if (rf & 2) {
      ɵɵhostProperty("type", "button");
      ɵɵclassProp("clr-step-button", true)("btn", true)("btn-primary", ctx.submitButton);
    }
  },
  inputs: {
    type: [InputFlags.None, "clrStepButton", "type"]
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrStepButton, [{
    type: Directive,
    args: [{
      selector: "[clrStepButton]",
      host: {
        "[class.clr-step-button]": "true",
        "[class.btn]": "true",
        "[type]": "'button'"
      }
    }]
  }], function() {
    return [{
      type: ClrStepperPanel
    }, {
      type: StepperService
    }];
  }, {
    type: [{
      type: Input,
      args: ["clrStepButton"]
    }],
    submitButton: [{
      type: HostBinding,
      args: ["class.btn-primary"]
    }],
    navigateToNextPanel: [{
      type: HostListener,
      args: ["click"]
    }]
  });
})();
var ClrStepper = class {
  constructor(formGroup, ngForm, stepperService) {
    this.formGroup = formGroup;
    this.ngForm = ngForm;
    this.stepperService = stepperService;
    this.subscriptions = [];
  }
  ngOnInit() {
    if (!this.formGroup && !this.ngForm) {
      throw new Error("To use stepper a Reactive or Template Form is required.");
    }
    this.form = this.formGroup ? this.formGroup : this.ngForm;
    this.subscriptions.push(this.listenForPanelsCompleted());
    this.subscriptions.push(this.listenForFormResetChanges());
  }
  ngOnChanges(changes) {
    if (changes.initialPanel.currentValue !== changes.initialPanel.previousValue) {
      this.stepperService.overrideInitialPanel(this.initialPanel);
    }
  }
  ngAfterViewInit() {
    this.subscriptions.push(this.listenForDOMChanges());
  }
  ngOnDestroy() {
    this.subscriptions.forEach((s2) => s2.unsubscribe());
  }
  listenForFormResetChanges() {
    return fromControlReset(this.form.form).subscribe(() => this.stepperService.resetPanels());
  }
  listenForPanelsCompleted() {
    return this.stepperService.panelsCompleted.subscribe((panelsCompleted) => {
      if (panelsCompleted && this.form.valid) {
        this.form.ngSubmit.emit();
      } else if (!this.form.valid && this.form.touched) {
        this.setPanelsWithFormErrors();
      }
    });
  }
  setPanelsWithFormErrors() {
    const panelsWithErrors = this.panels.reduce((panels, p2) => p2.formGroup.invalid ? [...panels, p2.id] : panels, []);
    this.stepperService.setPanelsWithErrors(panelsWithErrors);
  }
  listenForDOMChanges() {
    return this.panels.changes.pipe(startWith(this.panels)).subscribe((panels) => {
      this.stepperService.updatePanelOrder(panels.toArray().map((p2) => p2.id));
      if (this.initialPanel) {
        this.stepperService.overrideInitialPanel(this.initialPanel);
      }
    });
  }
};
ClrStepper.ɵfac = function ClrStepper_Factory(t3) {
  return new (t3 || ClrStepper)(ɵɵdirectiveInject(FormGroupDirective, 8), ɵɵdirectiveInject(NgForm, 8), ɵɵdirectiveInject(StepperService));
};
ClrStepper.ɵcmp = ɵɵdefineComponent({
  type: ClrStepper,
  selectors: [["form", "clrStepper", ""]],
  contentQueries: function ClrStepper_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ClrStepperPanel, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.panels = _t);
    }
  },
  hostVars: 4,
  hostBindings: function ClrStepper_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("clr-accordion", true)("clr-stepper-forms", true);
    }
  },
  inputs: {
    initialPanel: [InputFlags.None, "clrInitialStep", "initialPanel"]
  },
  features: [ɵɵProvidersFeature([StepperService, {
    provide: AccordionService,
    useExisting: StepperService
  }]), ɵɵNgOnChangesFeature],
  attrs: _c4,
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function ClrStepper_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrStepper, [{
    type: Component,
    args: [{
      selector: "form[clrStepper]",
      template: `<ng-content></ng-content>`,
      host: {
        "[class.clr-accordion]": "true",
        "[class.clr-stepper-forms]": "true"
      },
      providers: [StepperService, {
        provide: AccordionService,
        useExisting: StepperService
      }],
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], function() {
    return [{
      type: FormGroupDirective,
      decorators: [{
        type: Optional
      }]
    }, {
      type: NgForm,
      decorators: [{
        type: Optional
      }]
    }, {
      type: StepperService
    }];
  }, {
    initialPanel: [{
      type: Input,
      args: ["clrInitialStep"]
    }],
    panels: [{
      type: ContentChildren,
      args: [ClrStepperPanel, {
        descendants: true
      }]
    }]
  });
})();
function fromControlReset(control) {
  return new Observable((observer) => {
    const unpatchedControlReset = control.reset;
    control.reset = () => {
      observer.next();
      unpatchedControlReset.apply(control);
    };
    return () => {
      control.reset = unpatchedControlReset;
    };
  });
}
var StepperWillyWonka = class extends WillyWonka {
};
StepperWillyWonka.ɵfac = /* @__PURE__ */ (() => {
  let ɵStepperWillyWonka_BaseFactory;
  return function StepperWillyWonka_Factory(t3) {
    return (ɵStepperWillyWonka_BaseFactory || (ɵStepperWillyWonka_BaseFactory = ɵɵgetInheritedFactory(StepperWillyWonka)))(t3 || StepperWillyWonka);
  };
})();
StepperWillyWonka.ɵdir = ɵɵdefineDirective({
  type: StepperWillyWonka,
  selectors: [["form", "clrStepper", ""]],
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StepperWillyWonka, [{
    type: Directive,
    args: [{
      selector: "form[clrStepper]"
    }]
  }], null, null);
})();
var StepperOompaLoompa = class extends OompaLoompa {
  constructor(cdr, willyWonka, ifExpandService) {
    if (!willyWonka) {
      throw new Error("clr-stepper-panel should only be used inside of clrStepper");
    }
    super(cdr, willyWonka);
    this.expand = ifExpandService;
  }
  get flavor() {
    return this.expand.expanded;
  }
};
StepperOompaLoompa.ɵfac = function StepperOompaLoompa_Factory(t3) {
  return new (t3 || StepperOompaLoompa)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(StepperWillyWonka, 8), ɵɵdirectiveInject(IfExpandService));
};
StepperOompaLoompa.ɵdir = ɵɵdefineDirective({
  type: StepperOompaLoompa,
  selectors: [["clr-stepper-panel"], ["", "clrStepButton", ""]],
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StepperOompaLoompa, [{
    type: Directive,
    args: [{
      selector: "clr-stepper-panel, [clrStepButton]"
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: StepperWillyWonka,
      decorators: [{
        type: Optional
      }]
    }, {
      type: IfExpandService
    }];
  }, null);
})();
var declarations = [ClrStepper, ClrStepButton, ClrStepperPanel, StepperOompaLoompa, StepperWillyWonka];
var ClrStepperModule = class {
};
ClrStepperModule.ɵfac = function ClrStepperModule_Factory(t3) {
  return new (t3 || ClrStepperModule)();
};
ClrStepperModule.ɵmod = ɵɵdefineNgModule({
  type: ClrStepperModule,
  declarations: [ClrStepper, ClrStepButton, ClrStepperPanel, StepperOompaLoompa, StepperWillyWonka],
  imports: [CommonModule, ClrIconModule, ClrAccordionModule],
  exports: [ClrStepper, ClrStepButton, ClrStepperPanel, StepperOompaLoompa, StepperWillyWonka, ClrAccordionModule]
});
ClrStepperModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, ClrIconModule, ClrAccordionModule, ClrAccordionModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrStepperModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, ClrIconModule, ClrAccordionModule],
      declarations: [...declarations],
      exports: [...declarations, ClrAccordionModule]
    }]
  }], null, null);
})();
var Keys;
(function(Keys2) {
  Keys2["ArrowLeft"] = "ArrowLeft";
  Keys2["ArrowUp"] = "ArrowUp";
  Keys2["ArrowRight"] = "ArrowRight";
  Keys2["ArrowDown"] = "ArrowDown";
  Keys2["Backspace"] = "Backspace";
  Keys2["Tab"] = "Tab";
  Keys2["Enter"] = "Enter";
  Keys2["Escape"] = "Escape";
  Keys2["Space"] = "Space";
  Keys2["Spacebar"] = " ";
  Keys2["Home"] = "Home";
  Keys2["End"] = "End";
})(Keys || (Keys = {}));
var IEKeys;
(function(IEKeys2) {
  IEKeys2["ArrowUp"] = "Up";
  IEKeys2["ArrowDown"] = "Down";
  IEKeys2["ArrowRight"] = "Right";
  IEKeys2["ArrowLeft"] = "Left";
  IEKeys2["Space"] = "Spacebar";
  IEKeys2["Escape"] = "Esc";
})(IEKeys || (IEKeys = {}));
function normalizeKey(key) {
  if (key === Keys.ArrowUp || key === IEKeys.ArrowUp) {
    return Keys.ArrowUp;
  } else if (key === Keys.ArrowDown || key === IEKeys.ArrowDown) {
    return Keys.ArrowDown;
  } else if (key === Keys.ArrowRight || key === IEKeys.ArrowRight) {
    return Keys.ArrowRight;
  } else if (key === Keys.ArrowLeft || key === IEKeys.ArrowLeft) {
    return Keys.ArrowLeft;
  } else if (key === Keys.Space || key === IEKeys.Space) {
    return Keys.Space;
  } else if (key === Keys.Escape || key === IEKeys.Escape) {
    return Keys.Escape;
  } else {
    return key;
  }
}
function preventArrowKeyScroll(event) {
  const key = normalizeKey(event.key);
  if (key === Keys.ArrowUp || key === Keys.ArrowDown || key === Keys.ArrowLeft || key === Keys.ArrowRight) {
    event.preventDefault();
  }
}
function isKeyEitherLetterOrNumber(event) {
  const char = event.key;
  return char.toLowerCase() !== char.toUpperCase() || char >= "0" && char <= "9";
}
var ClrPopoverToggleService = class {
  constructor() {
    this._open = false;
    this._openChange = new Subject();
    this._openEventChange = new Subject();
    this._popoverAligned = new Subject();
    this._popoverVisible = new Subject();
  }
  get openChange() {
    return this._openChange.asObservable();
  }
  get popoverVisible() {
    return this._popoverVisible.asObservable();
  }
  get openEvent() {
    return this._openEvent;
  }
  set openEvent(event) {
    this._openEvent = event;
    this._openEventChange.next(event);
  }
  get open() {
    return this._open;
  }
  set open(value) {
    value = !!value;
    if (this._open !== value) {
      this._open = value;
      this._openChange.next(value);
    }
  }
  // For compatibility with legacy IfOpenService based implementations
  get originalEvent() {
    return this._openEvent;
  }
  get popoverAligned() {
    return this._popoverAligned.asObservable();
  }
  getEventChange() {
    return this._openEventChange.asObservable();
  }
  /**
   * Sometimes, we need to remember the event that triggered the toggling to avoid loops.
   * This is for instance the case of components that open on a click, but close on a click outside.
   */
  toggleWithEvent(event) {
    preventArrowKeyScroll(event);
    this.openEvent = event;
    this.open = !this.open;
  }
  popoverVisibleEmit(visible) {
    this._popoverVisible.next(visible);
  }
  popoverAlignedEmit(popoverNode) {
    this._popoverAligned.next(popoverNode);
  }
};
ClrPopoverToggleService.ɵfac = function ClrPopoverToggleService_Factory(t3) {
  return new (t3 || ClrPopoverToggleService)();
};
ClrPopoverToggleService.ɵprov = ɵɵdefineInjectable({
  token: ClrPopoverToggleService,
  factory: ClrPopoverToggleService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrPopoverToggleService, [{
    type: Injectable
  }], null, null);
})();
var ClrPopoverEventsService = class {
  constructor(renderer, smartOpenService, document2) {
    this.renderer = renderer;
    this.smartOpenService = smartOpenService;
    this.document = document2;
    this.outsideClickClose = true;
    this.scrollToClose = true;
    this.subscriptions = [];
    this.subscriptions.push(smartOpenService.openChange.subscribe((open) => {
      if (open) {
        this.addEscapeListener();
        this.addClickListener();
        this.addScrollListener();
      } else {
        this.removeAllEventListeners();
      }
    }), smartOpenService.getEventChange().subscribe((event) => {
      this.ignoredEvent = event;
    }));
  }
  ngOnDestroy() {
    this.subscriptions.forEach((sub) => sub.unsubscribe());
    this.removeAllEventListeners();
  }
  addScrollListener() {
    if (this.scrollToClose) {
      this.documentScroller = fromEvent(this.document, "scroll", {
        capture: true
      });
      this.scrollSubscription = this.documentScroller.pipe(filter(this.testForSmartPopoverContentContainer)).subscribe(() => {
        this.smartOpenService.open = false;
        this.setAnchorFocus();
      });
    } else {
      return;
    }
  }
  removeScrollListener() {
    if (this.documentScroller) {
      this.scrollSubscription.unsubscribe();
      delete this.documentScroller;
    }
  }
  addClickListener() {
    if (this.outsideClickClose) {
      this.documentClickListener = this.renderer.listen(this.document, "click", (event) => {
        if (event === this.ignoredEvent) {
          delete this.ignoredEvent;
        } else {
          this.smartOpenService.open = false;
          const clickedElement = event.target;
          clickedElement.focus();
        }
      });
    }
  }
  removeClickListener() {
    if (this.outsideClickClose) {
      delete this.ignoredEvent;
      if (this.documentClickListener) {
        this.documentClickListener();
        delete this.documentClickListener;
      }
    }
  }
  addEscapeListener() {
    this.escapeListener = this.renderer.listen(this.document, "keydown.escape", () => {
      this.smartOpenService.open = false;
      this.setAnchorFocus();
    });
  }
  removeEscapeListener() {
    if (this.escapeListener) {
      this.escapeListener();
      delete this.escapeListener;
    }
  }
  setCloseFocus() {
    this.closeButtonRef.nativeElement.focus();
  }
  setAnchorFocus() {
    this.anchorButtonRef.nativeElement.focus();
  }
  testForSmartPopoverContentContainer(event) {
    let target = event.target;
    while (target.classList && target.parentElement.localName !== "body") {
      target = target.parentElement;
    }
    if (target.classList) {
      return target.classList.contains("clr-popover-content") ? false : true;
    } else {
      return false;
    }
  }
  removeAllEventListeners() {
    this.removeScrollListener();
    this.removeClickListener();
    this.removeEscapeListener();
  }
};
ClrPopoverEventsService.ɵfac = function ClrPopoverEventsService_Factory(t3) {
  return new (t3 || ClrPopoverEventsService)(ɵɵinject(Renderer2), ɵɵinject(ClrPopoverToggleService), ɵɵinject(DOCUMENT));
};
ClrPopoverEventsService.ɵprov = ɵɵdefineInjectable({
  token: ClrPopoverEventsService,
  factory: ClrPopoverEventsService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrPopoverEventsService, [{
    type: Injectable
  }], function() {
    return [{
      type: Renderer2
    }, {
      type: ClrPopoverToggleService
    }, {
      type: HTMLDocument,
      decorators: [{
        type: Inject,
        args: [DOCUMENT]
      }]
    }];
  }, null);
})();
var ClrPopoverAnchor = class {
  constructor(smartEventService, element) {
    smartEventService.anchorButtonRef = element;
  }
};
ClrPopoverAnchor.ɵfac = function ClrPopoverAnchor_Factory(t3) {
  return new (t3 || ClrPopoverAnchor)(ɵɵdirectiveInject(ClrPopoverEventsService), ɵɵdirectiveInject(ElementRef));
};
ClrPopoverAnchor.ɵdir = ɵɵdefineDirective({
  type: ClrPopoverAnchor,
  selectors: [["", "clrPopoverAnchor", ""]],
  hostVars: 2,
  hostBindings: function ClrPopoverAnchor_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("clr-anchor", true);
    }
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrPopoverAnchor, [{
    type: Directive,
    args: [{
      selector: "[clrPopoverAnchor]",
      host: {
        "[class.clr-anchor]": "true"
      }
    }]
  }], function() {
    return [{
      type: ClrPopoverEventsService
    }, {
      type: ElementRef
    }];
  }, null);
})();
var ClrPopoverCloseButton = class {
  constructor(elementRef, smartEventsService, smartOpenService) {
    this.elementRef = elementRef;
    this.smartEventsService = smartEventsService;
    this.smartOpenService = smartOpenService;
    this.closeChange = new EventEmitter();
    this.subscriptions = [];
    this.subscriptions.push(smartOpenService.openChange.pipe(filter((value) => !value)).subscribe(() => {
      this.closeChange.next();
    }));
  }
  handleClick(event) {
    this.smartOpenService.toggleWithEvent(event);
    this.smartEventsService.setAnchorFocus();
  }
  ngAfterViewInit() {
    this.smartEventsService.closeButtonRef = this.elementRef;
    this.smartEventsService.setCloseFocus();
  }
  ngOnDestroy() {
    this.subscriptions.forEach((sub) => sub.unsubscribe());
  }
};
ClrPopoverCloseButton.ɵfac = function ClrPopoverCloseButton_Factory(t3) {
  return new (t3 || ClrPopoverCloseButton)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ClrPopoverEventsService), ɵɵdirectiveInject(ClrPopoverToggleService));
};
ClrPopoverCloseButton.ɵdir = ɵɵdefineDirective({
  type: ClrPopoverCloseButton,
  selectors: [["", "clrPopoverCloseButton", ""]],
  hostVars: 2,
  hostBindings: function ClrPopoverCloseButton_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function ClrPopoverCloseButton_click_HostBindingHandler($event) {
        return ctx.handleClick($event);
      });
    }
    if (rf & 2) {
      ɵɵclassProp("clr-smart-close-button", true);
    }
  },
  outputs: {
    closeChange: "clrPopoverOnCloseChange"
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrPopoverCloseButton, [{
    type: Directive,
    args: [{
      selector: "[clrPopoverCloseButton]",
      host: {
        "[class.clr-smart-close-button]": "true"
      }
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: ClrPopoverEventsService
    }, {
      type: ClrPopoverToggleService
    }];
  }, {
    closeChange: [{
      type: Output,
      args: ["clrPopoverOnCloseChange"]
    }],
    handleClick: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }]
  });
})();
var ClrAxis;
(function(ClrAxis2) {
  ClrAxis2[ClrAxis2["VERTICAL"] = 0] = "VERTICAL";
  ClrAxis2[ClrAxis2["HORIZONTAL"] = 1] = "HORIZONTAL";
})(ClrAxis || (ClrAxis = {}));
var ClrAlignment;
(function(ClrAlignment2) {
  ClrAlignment2[ClrAlignment2["START"] = 0] = "START";
  ClrAlignment2[ClrAlignment2["CENTER"] = 0.5] = "CENTER";
  ClrAlignment2[ClrAlignment2["END"] = 1] = "END";
})(ClrAlignment || (ClrAlignment = {}));
var ClrViewportViolation;
(function(ClrViewportViolation2) {
  ClrViewportViolation2[ClrViewportViolation2["BOTTOM"] = 0] = "BOTTOM";
  ClrViewportViolation2[ClrViewportViolation2["LEFT"] = 1] = "LEFT";
  ClrViewportViolation2[ClrViewportViolation2["RIGHT"] = 2] = "RIGHT";
  ClrViewportViolation2[ClrViewportViolation2["TOP"] = 3] = "TOP";
})(ClrViewportViolation || (ClrViewportViolation = {}));
var flipSides = (position) => {
  return __spreadProps(__spreadValues({}, position), {
    side: -1 * position.side
  });
};
var nudgeContent = (position, forward) => {
  const nextAlignment = position.content + (forward ? 0.5 : -0.5);
  if (nextAlignment < 0 || nextAlignment > 1) {
    return position;
  } else {
    return __spreadProps(__spreadValues({}, position), {
      content: nextAlignment
    });
  }
};
function flipSidesAndNudgeContent(flip, nudge, nudgeBack) {
  return (position) => nudge(flip(position), nudgeBack);
}
function align(position, anchor, content) {
  let xDiff = anchor.left;
  let yDiff = anchor.top;
  switch (position.axis + position.side) {
    case -1: {
      xDiff += alignHorizontal(position, anchor, content);
      yDiff -= content.height;
      break;
    }
    case 1: {
      xDiff += alignHorizontal(position, anchor, content);
      yDiff += anchor.height;
      break;
    }
    case 0: {
      xDiff -= content.width;
      yDiff += alignVertical(position, anchor, content);
      break;
    }
    case 2: {
      xDiff += anchor.width;
      yDiff += alignVertical(position, anchor, content);
      break;
    }
    default: {
      break;
    }
  }
  return {
    xOffset: xDiff,
    yOffset: yDiff
  };
}
function alignHorizontal(position, anchor, content) {
  let horizontalOffset = 0;
  switch (position.anchor) {
    case ClrAlignment.START: {
      break;
    }
    case ClrAlignment.CENTER: {
      horizontalOffset += anchor.width / 2;
      break;
    }
    case ClrAlignment.END: {
      horizontalOffset += anchor.width;
      break;
    }
    default: {
      break;
    }
  }
  switch (position.content) {
    case ClrAlignment.START: {
      break;
    }
    case ClrAlignment.CENTER: {
      horizontalOffset -= content.width / 2;
      break;
    }
    case ClrAlignment.END: {
      horizontalOffset -= content.width;
      break;
    }
    default: {
      break;
    }
  }
  return horizontalOffset;
}
function alignVertical(position, anchor, content) {
  let verticalOffset = 0;
  switch (position.anchor) {
    case ClrAlignment.START: {
      break;
    }
    case ClrAlignment.CENTER: {
      verticalOffset += anchor.height / 2;
      break;
    }
    case ClrAlignment.END: {
      verticalOffset += anchor.height;
      break;
    }
    default: {
      break;
    }
  }
  switch (position.content) {
    case ClrAlignment.START: {
      break;
    }
    case ClrAlignment.CENTER: {
      verticalOffset -= content.height / 2;
      break;
    }
    case ClrAlignment.END: {
      verticalOffset -= content.height;
      break;
    }
    default: {
      break;
    }
  }
  return verticalOffset;
}
function testVisibility(offset, content) {
  const violations = [];
  const mockCoords = {
    bottom: offset.yOffset + content.height,
    left: offset.xOffset,
    right: offset.xOffset + content.width,
    top: offset.yOffset
  };
  if (!(mockCoords.top >= 0)) {
    violations.push(ClrViewportViolation.TOP);
  }
  if (!(mockCoords.left >= 0)) {
    violations.push(ClrViewportViolation.LEFT);
  }
  if (!(mockCoords.bottom <= (window.innerHeight || document.documentElement.clientHeight))) {
    violations.push(ClrViewportViolation.BOTTOM);
  }
  if (!(mockCoords.right <= (window.innerWidth || document.documentElement.clientWidth))) {
    violations.push(ClrViewportViolation.RIGHT);
  }
  return violations;
}
var ClrPopoverPositionService = class {
  constructor(eventService, platformId) {
    this.eventService = eventService;
    this.platformId = platformId;
    this._shouldRealign = new Subject();
    this.shouldRealign = this._shouldRealign.asObservable();
  }
  realign() {
    this._shouldRealign.next();
  }
  alignContent(content) {
    if (!isPlatformBrowser(this.platformId)) {
      return {
        xOffset: 0,
        yOffset: 0
      };
    }
    this.currentAnchorCoords = this.eventService.anchorButtonRef.nativeElement.getBoundingClientRect();
    this.currentContentCoords = content.getBoundingClientRect();
    this.contentOffsets = align(this.position, this.currentAnchorCoords, this.currentContentCoords);
    const visibilityViolations = testVisibility(this.contentOffsets, this.currentContentCoords);
    const errorSum = visibilityViolations.reduce((count, current) => {
      return count + current;
    }, 0);
    if (visibilityViolations.length === 1 && this.position.axis === ClrAxis.VERTICAL) {
      this.handleVerticalAxisOneViolation(errorSum);
    } else if (visibilityViolations.length === 1 && this.position.axis === ClrAxis.HORIZONTAL) {
      this.handleHorizontalAxisOneViolation(errorSum);
    } else if (visibilityViolations.length === 2 && this.position.axis === ClrAxis.VERTICAL) {
      this.handleVerticalAxisTwoViolations(errorSum);
    } else if (visibilityViolations.length === 2 && this.position.axis === ClrAxis.HORIZONTAL) {
      this.handleHorizontalAxisTwoViolations(errorSum);
    }
    if (this.currentContentCoords.top < 0) {
      this.contentOffsets.yOffset += Math.abs(this.currentContentCoords.top);
    }
    if (this.contentOffsets.yOffset + this.currentAnchorCoords.y < 0) {
      this.contentOffsets.yOffset = 0 - this.currentContentCoords.top;
    }
    return this.contentOffsets;
  }
  handleVerticalAxisOneViolation(errorSum) {
    switch (errorSum) {
      case 0:
      case 3: {
        this.contentOffsets = align(flipSides(this.position), this.currentAnchorCoords, this.currentContentCoords);
        break;
      }
      case 1: {
        this.contentOffsets = align(this.position, this.currentAnchorCoords, this.currentContentCoords);
        if (this.contentOffsets.xOffset < 0) {
          this.contentOffsets.xOffset = 10;
        }
        break;
      }
      case 2: {
        this.contentOffsets = align(nudgeContent(this.position, true), this.currentAnchorCoords, this.currentContentCoords);
        break;
      }
      default: {
        break;
      }
    }
  }
  handleVerticalAxisTwoViolations(errorSum) {
    switch (errorSum) {
      case 5: {
        const flipAndNudgeLeft = flipSidesAndNudgeContent(flipSides, nudgeContent, true);
        this.contentOffsets = align(flipAndNudgeLeft(this.position), this.currentAnchorCoords, this.currentContentCoords);
        break;
      }
      case 4: {
        const flipAndNudgeRight = flipSidesAndNudgeContent(flipSides, nudgeContent, false);
        this.contentOffsets = align(flipAndNudgeRight(this.position), this.currentAnchorCoords, this.currentContentCoords);
        break;
      }
      case 3: {
        break;
      }
      case 2: {
        const flipAndNudgeLeft = flipSidesAndNudgeContent(flipSides, nudgeContent, true);
        this.contentOffsets = align(flipAndNudgeLeft(this.position), this.currentAnchorCoords, this.currentContentCoords);
        break;
      }
      case 1: {
        const flipAndNudgeRight = flipSidesAndNudgeContent(flipSides, nudgeContent, false);
        this.contentOffsets = align(flipAndNudgeRight(this.position), this.currentAnchorCoords, this.currentContentCoords);
        break;
      }
      default: {
        break;
      }
    }
  }
  handleHorizontalAxisOneViolation(errorSum) {
    switch (errorSum) {
      case 1:
      case 2: {
        this.contentOffsets = align(flipSides(this.position), this.currentAnchorCoords, this.currentContentCoords);
        break;
      }
      case 0: {
        this.contentOffsets = align(nudgeContent(this.position, true), this.currentAnchorCoords, this.currentContentCoords);
        break;
      }
      case 3: {
        this.contentOffsets = align(nudgeContent(this.position), this.currentAnchorCoords, this.currentContentCoords);
        break;
      }
      default: {
        break;
      }
    }
  }
  handleHorizontalAxisTwoViolations(errorSum) {
    switch (errorSum) {
      case 5:
      case 4: {
        const flipAndNudgeDown = flipSidesAndNudgeContent(flipSides, nudgeContent, false);
        this.contentOffsets = align(flipAndNudgeDown(this.position), this.currentAnchorCoords, this.currentContentCoords);
        break;
      }
      case 3: {
        break;
      }
      case 2:
      case 1: {
        const flipAndNudgeUp = flipSidesAndNudgeContent(flipSides, nudgeContent, true);
        this.contentOffsets = align(flipAndNudgeUp(this.position), this.currentAnchorCoords, this.currentContentCoords);
        break;
      }
      default: {
        break;
      }
    }
  }
};
ClrPopoverPositionService.ɵfac = function ClrPopoverPositionService_Factory(t3) {
  return new (t3 || ClrPopoverPositionService)(ɵɵinject(ClrPopoverEventsService), ɵɵinject(PLATFORM_ID));
};
ClrPopoverPositionService.ɵprov = ɵɵdefineInjectable({
  token: ClrPopoverPositionService,
  factory: ClrPopoverPositionService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrPopoverPositionService, [{
    type: Injectable
  }], function() {
    return [{
      type: ClrPopoverEventsService
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [PLATFORM_ID]
      }]
    }];
  }, null);
})();
var ClrPopoverContent = class {
  constructor(document2, container, template, renderer, smartPositionService, smartEventsService, smartOpenService) {
    this.document = document2;
    this.container = container;
    this.template = template;
    this.renderer = renderer;
    this.smartPositionService = smartPositionService;
    this.smartEventsService = smartEventsService;
    this.smartOpenService = smartOpenService;
    this.subscriptions = [];
    this.removeClickListenerFn = null;
    this.shouldRealign = false;
    this.checkCollector = new EventEmitter();
  }
  set open(value) {
    this.smartOpenService.open = !!value;
  }
  set contentAt(position) {
    this.smartPositionService.position = position;
  }
  set outsideClickClose(clickToClose) {
    this.smartEventsService.outsideClickClose = !!clickToClose;
  }
  set scrollToClose(scrollToClose) {
    this.smartEventsService.scrollToClose = !!scrollToClose;
  }
  ngAfterContentChecked() {
    if (this.smartOpenService.open && this.view && this.shouldRealign) {
      this.checkCollector.emit();
    }
  }
  ngAfterViewInit() {
    this.subscriptions.push(
      this.smartOpenService.openChange.subscribe((change) => {
        if (change) {
          this.addContent();
        } else {
          this.removeContent();
        }
      }),
      this.smartPositionService.shouldRealign.subscribe(() => {
        this.shouldRealign = true;
      }),
      // Here we collect subsequent synchronously received content-check events and only take action
      // at the end of the cycle. See below for details on the check-collector pattern.
      this.checkCollector.pipe(debounceTime(0)).subscribe(() => {
        this.alignContent();
        this.shouldRealign = false;
        if (this.view) {
          this.renderer.setStyle(this.view.rootNodes[0], "opacity", "1");
          this.smartOpenService.popoverVisibleEmit(true);
        }
      })
    );
  }
  ngOnDestroy() {
    this.removeContent();
    this.subscriptions.forEach((sub) => sub.unsubscribe());
  }
  /**
   * TODO(matt): investigate why DebugElement retains a reference to the nodes and causes a memory leak.
   * A note about the use of appendChild/removeChild
   * The DebugElement is keeping a reference to the detached node and its unclear why.
   * This does warrant further investigation. But, since it doesn't happen in production mode
   * it is a low priority issue for now.
   */
  addContent() {
    this.view = this.container.createEmbeddedView(this.template);
    const [rootNode] = this.view.rootNodes;
    this.smartEventsService.contentRef = rootNode;
    this.renderer.addClass(rootNode, "clr-popover-content");
    this.renderer.setStyle(rootNode, "top", "0px");
    this.renderer.setStyle(rootNode, "left", "0px");
    this.renderer.setStyle(rootNode, "opacity", "0");
    this.removeClickListenerFn = this.renderer.listen(rootNode, "click", (event) => {
      this.smartOpenService.openEvent = event;
    });
    this.view.rootNodes.forEach((node) => {
      this.renderer.appendChild(this.document.body, node);
    });
    this.shouldRealign = true;
  }
  removeContent() {
    if (!this.view) {
      return;
    }
    if (this.removeClickListenerFn) {
      this.removeClickListenerFn();
      this.removeClickListenerFn = null;
    }
    this.view.rootNodes.forEach((node) => this.renderer.removeChild(this.document.body, node));
    this.container.clear();
    delete this.view;
    this.smartOpenService.popoverVisibleEmit(false);
  }
  alignContent() {
    if (!this.view) {
      return;
    }
    const positionCoords = this.smartPositionService.alignContent(this.view.rootNodes[0]);
    this.renderer.setStyle(this.view.rootNodes[0], "top", `${positionCoords.yOffset}px`);
    this.renderer.setStyle(this.view.rootNodes[0], "left", `${positionCoords.xOffset}px`);
    this.smartOpenService.popoverAlignedEmit(this.view.rootNodes[0]);
  }
};
ClrPopoverContent.ɵfac = function ClrPopoverContent_Factory(t3) {
  return new (t3 || ClrPopoverContent)(ɵɵdirectiveInject(DOCUMENT), ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(TemplateRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ClrPopoverPositionService), ɵɵdirectiveInject(ClrPopoverEventsService), ɵɵdirectiveInject(ClrPopoverToggleService));
};
ClrPopoverContent.ɵdir = ɵɵdefineDirective({
  type: ClrPopoverContent,
  selectors: [["", "clrPopoverContent", ""]],
  inputs: {
    open: [InputFlags.None, "clrPopoverContent", "open"],
    contentAt: [InputFlags.None, "clrPopoverContentAt", "contentAt"],
    outsideClickClose: [InputFlags.None, "clrPopoverContentOutsideClickToClose", "outsideClickClose"],
    scrollToClose: [InputFlags.None, "clrPopoverContentScrollToClose", "scrollToClose"]
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrPopoverContent, [{
    type: Directive,
    args: [{
      selector: "[clrPopoverContent]"
    }]
  }], function() {
    return [{
      type: Document,
      decorators: [{
        type: Inject,
        args: [DOCUMENT]
      }]
    }, {
      type: ViewContainerRef
    }, {
      type: TemplateRef
    }, {
      type: Renderer2
    }, {
      type: ClrPopoverPositionService
    }, {
      type: ClrPopoverEventsService
    }, {
      type: ClrPopoverToggleService
    }];
  }, {
    open: [{
      type: Input,
      args: ["clrPopoverContent"]
    }],
    contentAt: [{
      type: Input,
      args: ["clrPopoverContentAt"]
    }],
    outsideClickClose: [{
      type: Input,
      args: ["clrPopoverContentOutsideClickToClose"]
    }],
    scrollToClose: [{
      type: Input,
      args: ["clrPopoverContentScrollToClose"]
    }]
  });
})();
var ClrPopoverOpenCloseButton = class {
  constructor(smartOpenService) {
    this.smartOpenService = smartOpenService;
    this.openCloseChange = new EventEmitter();
    this.subscriptions = [];
    this.subscriptions.push(this.smartOpenService.openChange.subscribe((change) => {
      this.openCloseChange.next(change);
    }));
  }
  handleClick(event) {
    this.smartOpenService.toggleWithEvent(event);
  }
  ngOnDestroy() {
    this.subscriptions.forEach((sub) => sub.unsubscribe());
  }
};
ClrPopoverOpenCloseButton.ɵfac = function ClrPopoverOpenCloseButton_Factory(t3) {
  return new (t3 || ClrPopoverOpenCloseButton)(ɵɵdirectiveInject(ClrPopoverToggleService));
};
ClrPopoverOpenCloseButton.ɵdir = ɵɵdefineDirective({
  type: ClrPopoverOpenCloseButton,
  selectors: [["", "clrPopoverOpenCloseButton", ""]],
  hostVars: 2,
  hostBindings: function ClrPopoverOpenCloseButton_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function ClrPopoverOpenCloseButton_click_HostBindingHandler($event) {
        return ctx.handleClick($event);
      });
    }
    if (rf & 2) {
      ɵɵclassProp("clr-smart-open-close", true);
    }
  },
  outputs: {
    openCloseChange: "clrPopoverOpenCloseChange"
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrPopoverOpenCloseButton, [{
    type: Directive,
    args: [{
      selector: "[clrPopoverOpenCloseButton]",
      host: {
        "[class.clr-smart-open-close]": "true"
      }
    }]
  }], function() {
    return [{
      type: ClrPopoverToggleService
    }];
  }, {
    openCloseChange: [{
      type: Output,
      args: ["clrPopoverOpenCloseChange"]
    }],
    handleClick: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }]
  });
})();
var ClrPopoverModuleNext = class {
};
ClrPopoverModuleNext.ɵfac = function ClrPopoverModuleNext_Factory(t3) {
  return new (t3 || ClrPopoverModuleNext)();
};
ClrPopoverModuleNext.ɵmod = ɵɵdefineNgModule({
  type: ClrPopoverModuleNext,
  declarations: [ClrPopoverAnchor, ClrPopoverCloseButton, ClrPopoverOpenCloseButton, ClrPopoverContent],
  exports: [ClrPopoverAnchor, ClrPopoverCloseButton, ClrPopoverOpenCloseButton, ClrPopoverContent]
});
ClrPopoverModuleNext.ɵinj = ɵɵdefineInjector({});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrPopoverModuleNext, [{
    type: NgModule,
    args: [{
      imports: [],
      declarations: [ClrPopoverAnchor, ClrPopoverCloseButton, ClrPopoverOpenCloseButton, ClrPopoverContent],
      exports: [ClrPopoverAnchor, ClrPopoverCloseButton, ClrPopoverOpenCloseButton, ClrPopoverContent]
    }]
  }], null, null);
})();
var ButtonInGroupService = class {
  constructor() {
    this._changes = new Subject();
  }
  get changes() {
    return this._changes.asObservable();
  }
  updateButtonGroup(button) {
    this._changes.next(button);
  }
};
ButtonInGroupService.ɵfac = function ButtonInGroupService_Factory(t3) {
  return new (t3 || ButtonInGroupService)();
};
ButtonInGroupService.ɵprov = ɵɵdefineInjectable({
  token: ButtonInGroupService,
  factory: ButtonInGroupService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ButtonInGroupService, [{
    type: Injectable
  }], null, null);
})();
var ClrButton = class {
  constructor(buttonInGroupService) {
    this.buttonInGroupService = buttonInGroupService;
    this._click = new EventEmitter(false);
    this._inMenu = false;
    this._enableService = false;
    this._classNames = "btn";
    this._name = null;
    this._type = null;
    this._disabled = null;
    this._id = uniqueIdFactory();
  }
  get inMenu() {
    return this._inMenu;
  }
  set inMenu(value) {
    value = !!value;
    if (this._inMenu !== value) {
      this._inMenu = value;
      if (this._enableService && this.buttonInGroupService) {
        this.buttonInGroupService.updateButtonGroup(this);
      }
    }
  }
  get classNames() {
    return this._classNames;
  }
  set classNames(value) {
    if (typeof value === "string") {
      const classNames = value.split(" ");
      if (classNames.indexOf("btn") === -1) {
        classNames.push("btn");
      }
      this._classNames = classNames.join(" ");
    }
  }
  get name() {
    return this._name;
  }
  set name(value) {
    if (typeof value === "string") {
      this._name = value;
    }
  }
  get type() {
    return this._type;
  }
  set type(value) {
    if (typeof value === "string") {
      this._type = value;
    }
  }
  get id() {
    return this._id;
  }
  set id(value) {
    if (typeof value === "string") {
      this._id = value;
    }
  }
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    if (value !== null && value !== false) {
      this._disabled = "";
    } else {
      this._disabled = null;
    }
  }
  get role() {
    return this.inMenu ? "menuitem" : null;
  }
  ngAfterViewInit() {
    this._enableService = true;
  }
  loadingStateChange(state2) {
    this.loading = state2 === ClrLoadingState.LOADING;
  }
  emitClick() {
    this._click.emit(true);
  }
};
ClrButton.ɵfac = function ClrButton_Factory(t3) {
  return new (t3 || ClrButton)(ɵɵdirectiveInject(ButtonInGroupService, 12));
};
ClrButton.ɵcmp = ɵɵdefineComponent({
  type: ClrButton,
  selectors: [["clr-button"]],
  viewQuery: function ClrButton_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c5, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.templateRef = _t.first);
    }
  },
  inputs: {
    inMenu: [InputFlags.None, "clrInMenu", "inMenu"],
    classNames: [InputFlags.None, "class", "classNames"],
    name: "name",
    type: "type",
    id: "id",
    disabled: "disabled"
  },
  outputs: {
    _click: "click"
  },
  features: [ɵɵProvidersFeature([{
    provide: LoadingListener,
    useExisting: ClrButton
  }])],
  ngContentSelectors: _c02,
  decls: 2,
  vars: 0,
  consts: [["buttonProjectedRef", ""], [3, "click"], ["class", "spinner spinner-inline", 4, "ngIf"], [1, "spinner", "spinner-inline"]],
  template: function ClrButton_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵtemplate(0, ClrButton_ng_template_0_Template, 3, 8, "ng-template", null, 0, ɵɵtemplateRefExtractor);
    }
  },
  dependencies: [NgIf],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrButton, [{
    type: Component,
    args: [{
      selector: "clr-button",
      template: `
    <ng-template #buttonProjectedRef>
      <button
        [class]="classNames"
        (click)="emitClick()"
        [attr.type]="type"
        [attr.name]="name"
        [attr.disabled]="disabled"
        [attr.role]="role"
        [attr.id]="id"
      >
        <span class="spinner spinner-inline" *ngIf="loading"></span>
        <ng-content></ng-content>
      </button>
    </ng-template>
  `,
      providers: [{
        provide: LoadingListener,
        useExisting: ClrButton
      }]
    }]
  }], function() {
    return [{
      type: ButtonInGroupService,
      decorators: [{
        type: SkipSelf
      }, {
        type: Optional
      }]
    }];
  }, {
    _click: [{
      type: Output,
      args: ["click"]
    }],
    templateRef: [{
      type: ViewChild,
      args: ["buttonProjectedRef", {
        static: true
      }]
    }],
    inMenu: [{
      type: Input,
      args: ["clrInMenu"]
    }],
    classNames: [{
      type: Input,
      args: ["class"]
    }],
    name: [{
      type: Input,
      args: ["name"]
    }],
    type: [{
      type: Input,
      args: ["type"]
    }],
    id: [{
      type: Input,
      args: ["id"]
    }],
    disabled: [{
      type: Input,
      args: ["disabled"]
    }]
  });
})();
var ClrDestroyService = class extends Subject {
  ngOnDestroy() {
    this.next();
    this.complete();
  }
};
ClrDestroyService.ɵfac = /* @__PURE__ */ (() => {
  let ɵClrDestroyService_BaseFactory;
  return function ClrDestroyService_Factory(t3) {
    return (ɵClrDestroyService_BaseFactory || (ɵClrDestroyService_BaseFactory = ɵɵgetInheritedFactory(ClrDestroyService)))(t3 || ClrDestroyService);
  };
})();
ClrDestroyService.ɵprov = ɵɵdefineInjectable({
  token: ClrDestroyService,
  factory: ClrDestroyService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDestroyService, [{
    type: Injectable
  }], null, null);
})();
var ArrowKeyDirection;
(function(ArrowKeyDirection2) {
  ArrowKeyDirection2["UP"] = "up";
  ArrowKeyDirection2["DOWN"] = "down";
  ArrowKeyDirection2["LEFT"] = "left";
  ArrowKeyDirection2["RIGHT"] = "right";
})(ArrowKeyDirection || (ArrowKeyDirection = {}));
var FocusService$1 = class FocusService {
  constructor(renderer) {
    this.renderer = renderer;
    this._unlistenFuncs = [];
  }
  get current() {
    return this._current;
  }
  reset(first2) {
    this._current = first2;
  }
  listenToArrowKeys(el) {
    this._unlistenFuncs.push(this.renderer.listen(el, "keydown.arrowup", () => !this.move(ArrowKeyDirection.UP)));
    this._unlistenFuncs.push(this.renderer.listen(el, "keydown.arrowdown", () => !this.move(ArrowKeyDirection.DOWN)));
    this._unlistenFuncs.push(this.renderer.listen(el, "keydown.arrowleft", () => !this.move(ArrowKeyDirection.LEFT)));
    this._unlistenFuncs.push(this.renderer.listen(el, "keydown.arrowright", () => !this.move(ArrowKeyDirection.RIGHT)));
  }
  registerContainer(el, tabIndex = "0") {
    this.renderer.setAttribute(el, "tabindex", tabIndex);
    this.listenToArrowKeys(el);
    this._unlistenFuncs.push(this.renderer.listen(el, "keydown.space", () => !this.activateCurrent()));
    this._unlistenFuncs.push(this.renderer.listen(el, "keydown.enter", () => !this.activateCurrent()));
  }
  moveTo(item) {
    if (item === void 0) {
      return;
    }
    if (this.current) {
      this.current.blur();
    }
    item.focus();
    this._current = item;
  }
  move(direction) {
    let moved = false;
    if (this.current) {
      const next = this.current[direction];
      if (next) {
        const nextObs = isObservable(next) ? next : of(next);
        nextObs.subscribe((item) => {
          if (item) {
            this.moveTo(item);
            moved = true;
          }
        });
      }
    }
    return moved;
  }
  activateCurrent() {
    if (this.current && this.current.activate) {
      this.current.activate();
      return true;
    }
    return false;
  }
  detachListeners() {
    this._unlistenFuncs.forEach((unlisten) => unlisten());
  }
};
FocusService$1.ɵfac = function FocusService$1_Factory(t3) {
  return new (t3 || FocusService$1)(ɵɵinject(Renderer2));
};
FocusService$1.ɵprov = ɵɵdefineInjectable({
  token: FocusService$1,
  factory: FocusService$1.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FocusService$1, [{
    type: Injectable
  }], function() {
    return [{
      type: Renderer2
    }];
  }, null);
})();
function clrFocusServiceFactory(existing, renderer) {
  return existing || new FocusService$1(renderer);
}
var FOCUS_SERVICE_PROVIDER = {
  provide: FocusService$1,
  useFactory: clrFocusServiceFactory,
  deps: [[new Optional(), new SkipSelf(), FocusService$1], Renderer2]
};
var ClrSide;
(function(ClrSide2) {
  ClrSide2[ClrSide2["BEFORE"] = -1] = "BEFORE";
  ClrSide2[ClrSide2["AFTER"] = 1] = "AFTER";
})(ClrSide || (ClrSide = {}));
var ClrPopoverPositions = class {
};
ClrPopoverPositions["top-right"] = {
  axis: ClrAxis.VERTICAL,
  side: ClrSide.BEFORE,
  anchor: ClrAlignment.END,
  content: ClrAlignment.END
};
ClrPopoverPositions["top-left"] = {
  axis: ClrAxis.VERTICAL,
  side: ClrSide.BEFORE,
  anchor: ClrAlignment.START,
  content: ClrAlignment.START
};
ClrPopoverPositions["bottom-right"] = {
  axis: ClrAxis.VERTICAL,
  side: ClrSide.AFTER,
  anchor: ClrAlignment.END,
  content: ClrAlignment.END
};
ClrPopoverPositions["bottom-left"] = {
  axis: ClrAxis.VERTICAL,
  side: ClrSide.AFTER,
  anchor: ClrAlignment.START,
  content: ClrAlignment.START
};
ClrPopoverPositions["right-top"] = {
  axis: ClrAxis.HORIZONTAL,
  side: ClrSide.AFTER,
  anchor: ClrAlignment.CENTER,
  content: ClrAlignment.END
};
ClrPopoverPositions["right-bottom"] = {
  axis: ClrAxis.HORIZONTAL,
  side: ClrSide.AFTER,
  anchor: ClrAlignment.START,
  content: ClrAlignment.START
};
ClrPopoverPositions["left-top"] = {
  axis: ClrAxis.HORIZONTAL,
  side: ClrSide.BEFORE,
  anchor: ClrAlignment.CENTER,
  content: ClrAlignment.END
};
ClrPopoverPositions["left-bottom"] = {
  axis: ClrAxis.HORIZONTAL,
  side: ClrSide.BEFORE,
  anchor: ClrAlignment.START,
  content: ClrAlignment.START
};
var POPOVER_HOST_ANCHOR = new InjectionToken("POPOVER_HOST_ANCHOR");
var ClrStopEscapePropagationDirective = class {
  constructor(toggleService) {
    this.toggleService = toggleService;
    this.lastOpenChange = null;
  }
  ngOnInit() {
    this.subscription = this.toggleService.openChange.subscribe((open) => {
      this.lastOpenChange = open;
    });
  }
  ngOnDestroy() {
    this.subscription?.unsubscribe();
  }
  onEscapeKey(event) {
    if (this.lastOpenChange !== null) {
      if (this.lastOpenChange === false) {
        event.stopPropagation();
      }
      this.lastOpenChange = null;
    }
  }
};
ClrStopEscapePropagationDirective.ɵfac = function ClrStopEscapePropagationDirective_Factory(t3) {
  return new (t3 || ClrStopEscapePropagationDirective)(ɵɵdirectiveInject(ClrPopoverToggleService));
};
ClrStopEscapePropagationDirective.ɵdir = ɵɵdefineDirective({
  type: ClrStopEscapePropagationDirective,
  hostBindings: function ClrStopEscapePropagationDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("keyup.escape", function ClrStopEscapePropagationDirective_keyup_escape_HostBindingHandler($event) {
        return ctx.onEscapeKey($event);
      });
    }
  },
  standalone: true
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrStopEscapePropagationDirective, [{
    type: Directive,
    args: [{
      standalone: true
    }]
  }], function() {
    return [{
      type: ClrPopoverToggleService
    }];
  }, {
    onEscapeKey: [{
      type: HostListener,
      args: ["keyup.escape", ["$event"]]
    }]
  });
})();
var ClrPopoverHostDirective = class {
};
ClrPopoverHostDirective.ɵfac = function ClrPopoverHostDirective_Factory(t3) {
  return new (t3 || ClrPopoverHostDirective)();
};
ClrPopoverHostDirective.ɵdir = ɵɵdefineDirective({
  type: ClrPopoverHostDirective,
  standalone: true,
  features: [ɵɵProvidersFeature([ClrPopoverToggleService, ClrPopoverEventsService, ClrPopoverPositionService, {
    provide: POPOVER_HOST_ANCHOR,
    useExisting: ElementRef
  }]), ɵɵHostDirectivesFeature([ClrStopEscapePropagationDirective])]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrPopoverHostDirective, [{
    type: Directive,
    args: [{
      standalone: true,
      providers: [ClrPopoverToggleService, ClrPopoverEventsService, ClrPopoverPositionService, {
        provide: POPOVER_HOST_ANCHOR,
        useExisting: ElementRef
      }],
      hostDirectives: [ClrStopEscapePropagationDirective]
    }]
  }], null, null);
})();
var Linkers = class {
  /**
   * Links a set of focusable items to a parent along one direction
   */
  static linkParent(items, parent, direction) {
    items.forEach((item) => item[direction] = parent);
  }
  /**
   * Double-links a set of focusable items vertically, possibly looping
   */
  static linkVertical(items, loop = true) {
    items.forEach((item, index) => {
      if (index > 0) {
        item.up = items[index - 1];
      }
      if (index < items.length - 1) {
        item.down = items[index + 1];
      }
    });
    if (loop && items.length > 1) {
      items[0].up = items[items.length - 1];
      items[items.length - 1].down = items[0];
    }
  }
};
var InitialFocus;
(function(InitialFocus2) {
  InitialFocus2["FIRST_ITEM"] = "first";
  InitialFocus2["LAST_ITEM"] = "last";
})(InitialFocus || (InitialFocus = {}));
function collapse() {
  "use strict";
  return [state("true", style({
    height: 0,
    "overflow-y": "hidden"
  })), transition("true => false", [animate(defaultAnimationTiming, style({
    height: "*",
    "overflow-y": "hidden"
  }))]), transition("false => true", [style({
    height: "*",
    "overflow-y": "hidden"
  }), animate(defaultAnimationTiming)])];
}
var DomAdapter = class {
  /*
    We clone the element and take its measurements from outside the grid
    so we don't trigger reflow for the whole datagrid.
  */
  userDefinedWidth(element) {
    const clonedElement = element.cloneNode(true);
    if (clonedElement.id) {
      clonedElement.id = clonedElement.id + "-clone";
    }
    clonedElement.classList.add("datagrid-cell-width-zero");
    document.body.appendChild(clonedElement);
    const userDefinedWidth = this.clientRect(clonedElement).width;
    clonedElement.remove();
    return userDefinedWidth;
  }
  scrollBarWidth(element) {
    return element.offsetWidth - element.clientWidth;
  }
  scrollWidth(element) {
    return element.scrollWidth || 0;
  }
  computedHeight(element) {
    return parseInt(getComputedStyle(element).getPropertyValue("height"), 10);
  }
  clientRect(element) {
    const elementClientRect = element.getBoundingClientRect();
    return {
      top: parseInt(elementClientRect.top, 10),
      bottom: parseInt(elementClientRect.bottom, 10),
      left: parseInt(elementClientRect.left, 10),
      right: parseInt(elementClientRect.right, 10),
      width: parseInt(elementClientRect.width, 10),
      height: parseInt(elementClientRect.height, 10)
    };
  }
  minWidth(element) {
    return parseInt(getComputedStyle(element).getPropertyValue("min-width"), 10);
  }
  focus(element) {
    element.focus();
  }
};
DomAdapter.ɵfac = function DomAdapter_Factory(t3) {
  return new (t3 || DomAdapter)();
};
DomAdapter.ɵprov = ɵɵdefineInjectable({
  token: DomAdapter,
  factory: DomAdapter.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DomAdapter, [{
    type: Injectable
  }], null, null);
})();
var ClrExpandableAnimation = class {
  constructor(element, domAdapter, renderer) {
    this.element = element;
    this.domAdapter = domAdapter;
    this.renderer = renderer;
    this.clrExpandTrigger = false;
    this.startHeight = 0;
  }
  get expandAnimation() {
    return {
      value: this.clrExpandTrigger,
      params: {
        startHeight: this.startHeight
      }
    };
  }
  animationStart(event) {
    if (event.fromState !== "void") {
      this.renderer.setStyle(this.element.nativeElement, "overflow", "hidden");
    }
  }
  animationDone(event) {
    if (event.fromState !== "void") {
      this.renderer.removeStyle(this.element.nativeElement, "overflow");
      this.updateStartHeight();
    }
  }
  updateStartHeight() {
    this.startHeight = this.domAdapter.computedHeight(this.element.nativeElement) || 0;
  }
};
ClrExpandableAnimation.ɵfac = function ClrExpandableAnimation_Factory(t3) {
  return new (t3 || ClrExpandableAnimation)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(DomAdapter), ɵɵdirectiveInject(Renderer2));
};
ClrExpandableAnimation.ɵcmp = ɵɵdefineComponent({
  type: ClrExpandableAnimation,
  selectors: [["clr-expandable-animation"]],
  hostVars: 1,
  hostBindings: function ClrExpandableAnimation_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵsyntheticHostListener("@expandAnimation.start", function ClrExpandableAnimation_animation_expandAnimation_start_HostBindingHandler($event) {
        return ctx.animationStart($event);
      })("@expandAnimation.done", function ClrExpandableAnimation_animation_expandAnimation_done_HostBindingHandler($event) {
        return ctx.animationDone($event);
      });
    }
    if (rf & 2) {
      ɵɵsyntheticHostProperty("@expandAnimation", ctx.expandAnimation);
    }
  },
  inputs: {
    clrExpandTrigger: "clrExpandTrigger"
  },
  features: [ɵɵProvidersFeature([DomAdapter])],
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function ClrExpandableAnimation_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  styles: ["[_nghost-%COMP%]{display:block}"],
  data: {
    animation: [trigger("expandAnimation", [transition("true <=> false", [style({
      height: "{{startHeight}}px"
    }), animate("0.2s ease-in-out", style({
      height: "*"
    }))])])]
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrExpandableAnimation, [{
    type: Component,
    args: [{
      selector: "clr-expandable-animation",
      template: `<ng-content></ng-content>`,
      animations: [trigger("expandAnimation", [transition("true <=> false", [style({
        height: "{{startHeight}}px"
      }), animate("0.2s ease-in-out", style({
        height: "*"
      }))])])],
      providers: [DomAdapter],
      styles: [":host{display:block}\n"]
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: DomAdapter
    }, {
      type: Renderer2
    }];
  }, {
    clrExpandTrigger: [{
      type: Input
    }],
    expandAnimation: [{
      type: HostBinding,
      args: ["@expandAnimation"]
    }],
    animationStart: [{
      type: HostListener,
      args: ["@expandAnimation.start", ["$event"]]
    }],
    animationDone: [{
      type: HostListener,
      args: ["@expandAnimation.done", ["$event"]]
    }]
  });
})();
var EXPANDABLE_ANIMATION_DIRECTIVES = [ClrExpandableAnimation];
function fade(opacity = 1) {
  return [transition("void => *", [style({
    opacity: 0
  }), animate(defaultAnimationTiming, style({
    opacity
  }))]), transition("* => void", [animate(defaultAnimationTiming, style({
    opacity: 0
  }))])];
}
function fadeSlide(direction) {
  let transform = null;
  if (direction === "up") {
    transform = "translate(0, 25%)";
  } else if (direction === "down") {
    transform = "translate(0, -25%)";
  } else if (direction === "left") {
    transform = "translate(25%, 0)";
  } else if (direction === "right") {
    transform = "translate(-25%, 0)";
  } else {
    throw new Error("Unknown direction " + direction + " for slide animation.");
  }
  return [transition("void => *", [style({
    opacity: 0,
    transform
  }), animate(defaultAnimationTiming)]), transition("* => void", [animate(defaultAnimationTiming, style({
    opacity: 0,
    transform
  }))])];
}
function slide(direction) {
  let transform = null;
  if (direction === "up") {
    transform = "translate(0, 25%)";
  } else if (direction === "down") {
    transform = "translate(0, -25%)";
  } else if (direction === "left") {
    transform = "translate(25%, 0)";
  } else if (direction === "right") {
    transform = "translate(-25%, 0)";
  } else {
    throw new Error("Unknown direction " + direction + " for slide animation.");
  }
  return [transition("void => *", [style({
    transform
  }), animate(defaultAnimationTiming)]), transition("* => void", [animate(defaultAnimationTiming, style({
    transform
  }))])];
}
var CLR_LOADING_DIRECTIVES = [ClrLoading];
var ClrLoadingModule = class {
};
ClrLoadingModule.ɵfac = function ClrLoadingModule_Factory(t3) {
  return new (t3 || ClrLoadingModule)();
};
ClrLoadingModule.ɵmod = ɵɵdefineNgModule({
  type: ClrLoadingModule,
  declarations: [ClrLoading],
  imports: [CommonModule],
  exports: [ClrLoading]
});
ClrLoadingModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrLoadingModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      declarations: [CLR_LOADING_DIRECTIVES],
      exports: [CLR_LOADING_DIRECTIVES]
    }]
  }], null, null);
})();
var activeCounter = 0;
var IF_ACTIVE_ID = new InjectionToken("IF_ACTIVE_ID");
function tokenFactory$1() {
  return ++activeCounter;
}
var IF_ACTIVE_ID_PROVIDER = {
  provide: IF_ACTIVE_ID,
  useFactory: tokenFactory$1
};
var IfActiveService = class {
  constructor() {
    this._currentChange = new Subject();
  }
  /*********
   *
   * @description
   * A getter function that provides an observable for the _current Subject.
   *
   */
  get currentChange() {
    return this._currentChange.asObservable();
  }
  /*********
   *
   * @description
   * A property that gets/sets the current state of _current for this instance of IfActive structural directive.
   * And, broadcasts the new value to all subscribers.
   *
   */
  get current() {
    return this._current;
  }
  set current(value) {
    if (this._current !== value) {
      this._current = value;
      this._currentChange.next(value);
    }
  }
};
IfActiveService.ɵfac = function IfActiveService_Factory(t3) {
  return new (t3 || IfActiveService)();
};
IfActiveService.ɵprov = ɵɵdefineInjectable({
  token: IfActiveService,
  factory: IfActiveService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(IfActiveService, [{
    type: Injectable
  }], null, null);
})();
var ClrIfActive = class {
  constructor(ifActiveService, id, template, container) {
    this.ifActiveService = ifActiveService;
    this.id = id;
    this.template = template;
    this.container = container;
    this.activeChange = new EventEmitter(false);
    this.wasActive = false;
    this.checkAndUpdateView(ifActiveService.current);
    this.subscription = this.ifActiveService.currentChange.subscribe((newCurrentId) => {
      this.checkAndUpdateView(newCurrentId);
    });
  }
  /**
   * @description
   * A property that gets/sets IfActiveService.active with value.
   *
   */
  get active() {
    return this.ifActiveService.current === this.id;
  }
  set active(value) {
    if (value) {
      this.ifActiveService.current = this.id;
    }
  }
  ngOnDestroy() {
    this.subscription.unsubscribe();
  }
  /**
   * @description
   * Function that takes a any value and either created an embedded view for the associated ViewContainerRef or,
   * Clears all views from the ViewContainerRef
   */
  updateView(value) {
    if (value) {
      this.container.createEmbeddedView(this.template);
    } else {
      this.container.clear();
    }
  }
  checkAndUpdateView(currentId) {
    const isNowActive = currentId === this.id;
    if (isNowActive !== this.wasActive) {
      this.updateView(isNowActive);
      this.activeChange.emit(isNowActive);
      this.wasActive = isNowActive;
    }
  }
};
ClrIfActive.ɵfac = function ClrIfActive_Factory(t3) {
  return new (t3 || ClrIfActive)(ɵɵdirectiveInject(IfActiveService), ɵɵdirectiveInject(IF_ACTIVE_ID), ɵɵdirectiveInject(TemplateRef), ɵɵdirectiveInject(ViewContainerRef));
};
ClrIfActive.ɵdir = ɵɵdefineDirective({
  type: ClrIfActive,
  selectors: [["", "clrIfActive", ""]],
  inputs: {
    active: [InputFlags.None, "clrIfActive", "active"]
  },
  outputs: {
    activeChange: "clrIfActiveChange"
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrIfActive, [{
    type: Directive,
    args: [{
      selector: "[clrIfActive]"
    }]
  }], function() {
    return [{
      type: IfActiveService
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [IF_ACTIVE_ID]
      }]
    }, {
      type: TemplateRef
    }, {
      type: ViewContainerRef
    }];
  }, {
    activeChange: [{
      type: Output,
      args: ["clrIfActiveChange"]
    }],
    active: [{
      type: Input,
      args: ["clrIfActive"]
    }]
  });
})();
var ClrIfOpen = class {
  constructor(toggleService, template, container) {
    this.toggleService = toggleService;
    this.template = template;
    this.container = container;
    this.openChange = new EventEmitter(false);
    this.subscription = this.toggleService.openChange.subscribe((change) => {
      this.updateView(change);
      this.openChange.emit(change);
    });
  }
  /**
   * @description
   * A property that gets/sets ClrPopoverToggleService.open with value.
   */
  get open() {
    return this.toggleService.open;
  }
  set open(value) {
    this.toggleService.open = value;
  }
  ngOnDestroy() {
    this.subscription.unsubscribe();
  }
  /**
   * @description
   * Function that takes a boolean value and either created an embedded view for the associated ViewContainerRef or,
   * Clears all views from the ViewContainerRef
   *
   * @param value
   */
  updateView(value) {
    if (value) {
      this.container.createEmbeddedView(this.template);
    } else {
      this.container.clear();
    }
  }
};
ClrIfOpen.ɵfac = function ClrIfOpen_Factory(t3) {
  return new (t3 || ClrIfOpen)(ɵɵdirectiveInject(ClrPopoverToggleService), ɵɵdirectiveInject(TemplateRef), ɵɵdirectiveInject(ViewContainerRef));
};
ClrIfOpen.ɵdir = ɵɵdefineDirective({
  type: ClrIfOpen,
  selectors: [["", "clrIfOpen", ""]],
  inputs: {
    open: [InputFlags.None, "clrIfOpen", "open"]
  },
  outputs: {
    openChange: "clrIfOpenChange"
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrIfOpen, [{
    type: Directive,
    args: [{
      selector: "[clrIfOpen]"
    }]
  }], function() {
    return [{
      type: ClrPopoverToggleService
    }, {
      type: TemplateRef
    }, {
      type: ViewContainerRef
    }];
  }, {
    openChange: [{
      type: Output,
      args: ["clrIfOpenChange"]
    }],
    open: [{
      type: Input,
      args: ["clrIfOpen"]
    }]
  });
})();
var ClrIfExpanded = class {
  constructor(template, container, el, renderer, expand) {
    this.template = template;
    this.container = container;
    this.el = el;
    this.renderer = renderer;
    this.expand = expand;
    this.expandedChange = new EventEmitter(true);
    this._expanded = false;
    this._subscriptions = [];
    this._subscriptions.push(expand.expandChange.subscribe(() => {
      this.updateView();
      this.expandedChange.emit(this.expand.expanded);
    }));
  }
  get expanded() {
    return this._expanded;
  }
  set expanded(value) {
    if (typeof value === "boolean") {
      this.expand.expanded = value;
      this._expanded = value;
    }
  }
  ngOnInit() {
    this.expand.expandable++;
    this.updateView();
  }
  ngOnDestroy() {
    this.expand.expandable--;
    this._subscriptions.forEach((sub) => sub.unsubscribe());
  }
  updateView() {
    if (this.expand.expanded && this.container.length !== 0) {
      return;
    }
    if (this.template) {
      if (this.expand.expanded) {
        this.container.createEmbeddedView(this.template);
      } else {
        this.container.clear();
      }
    } else {
      try {
        if (this.expand.expanded) {
          this.renderer.setStyle(this.el.nativeElement, "display", null);
        } else {
          this.renderer.setStyle(this.el.nativeElement, "display", "none");
        }
      } catch (e5) {
      }
    }
  }
};
ClrIfExpanded.ɵfac = function ClrIfExpanded_Factory(t3) {
  return new (t3 || ClrIfExpanded)(ɵɵdirectiveInject(TemplateRef, 8), ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(IfExpandService));
};
ClrIfExpanded.ɵdir = ɵɵdefineDirective({
  type: ClrIfExpanded,
  selectors: [["", "clrIfExpanded", ""]],
  inputs: {
    expanded: [InputFlags.None, "clrIfExpanded", "expanded"]
  },
  outputs: {
    expandedChange: "clrIfExpandedChange"
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrIfExpanded, [{
    type: Directive,
    args: [{
      selector: "[clrIfExpanded]"
    }]
  }], function() {
    return [{
      type: TemplateRef,
      decorators: [{
        type: Optional
      }]
    }, {
      type: ViewContainerRef
    }, {
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: IfExpandService
    }];
  }, {
    expandedChange: [{
      type: Output,
      args: ["clrIfExpandedChange"]
    }],
    expanded: [{
      type: Input,
      args: ["clrIfExpanded"]
    }]
  });
})();
var CONDITIONAL_DIRECTIVES = [ClrIfActive, ClrIfOpen, ClrIfExpanded];
var ClrConditionalModule = class {
};
ClrConditionalModule.ɵfac = function ClrConditionalModule_Factory(t3) {
  return new (t3 || ClrConditionalModule)();
};
ClrConditionalModule.ɵmod = ɵɵdefineNgModule({
  type: ClrConditionalModule,
  declarations: [ClrIfActive, ClrIfOpen, ClrIfExpanded],
  imports: [CommonModule],
  exports: [ClrIfActive, ClrIfOpen, ClrIfExpanded]
});
ClrConditionalModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrConditionalModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      declarations: [CONDITIONAL_DIRECTIVES],
      exports: [CONDITIONAL_DIRECTIVES]
    }]
  }], null, null);
})();
var FOCUS_ON_VIEW_INIT = new InjectionToken("FOCUS_ON_VIEW_INIT");
var FOCUS_ON_VIEW_INIT_PROVIDER = {
  provide: FOCUS_ON_VIEW_INIT,
  useValue: true
};
var ClrFocusOnViewInit = class {
  constructor(el, platformId, focusOnViewInit, document2, renderer, ngZone) {
    this.el = el;
    this.platformId = platformId;
    this.focusOnViewInit = focusOnViewInit;
    this.renderer = renderer;
    this.directFocus = true;
    this.destroy$ = new Subject();
    this._isEnabled = this.focusOnViewInit;
    this.document = document2;
    ngZone.runOutsideAngular(() => fromEvent(el.nativeElement, "focusout").pipe(takeUntil(this.destroy$)).subscribe(() => {
      if (!this.directFocus) {
        this.renderer.removeAttribute(this.el.nativeElement, "tabindex");
        this.renderer.setStyle(this.el.nativeElement, "outline", null);
      }
    }));
  }
  set isEnabled(value) {
    if (this.focusOnViewInit && typeof value === "boolean") {
      this._isEnabled = value;
    }
  }
  ngAfterViewInit() {
    this.focus();
  }
  ngOnDestroy() {
    this.destroy$.next();
  }
  focus() {
    if (!isPlatformBrowser(this.platformId)) {
      return;
    }
    if (!this._isEnabled) {
      return;
    }
    if (this.document && this.document.activeElement !== this.el.nativeElement) {
      this.el.nativeElement.focus();
      if (this.document.activeElement !== this.el.nativeElement) {
        this.directFocus = false;
        this.renderer.setAttribute(this.el.nativeElement, "tabindex", "-1");
        this.renderer.setStyle(this.el.nativeElement, "outline", "none");
        this.el.nativeElement.focus();
      }
    }
  }
};
ClrFocusOnViewInit.ɵfac = function ClrFocusOnViewInit_Factory(t3) {
  return new (t3 || ClrFocusOnViewInit)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(PLATFORM_ID), ɵɵdirectiveInject(FOCUS_ON_VIEW_INIT), ɵɵdirectiveInject(DOCUMENT), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone));
};
ClrFocusOnViewInit.ɵdir = ɵɵdefineDirective({
  type: ClrFocusOnViewInit,
  selectors: [["", "clrFocusOnViewInit", ""]],
  inputs: {
    isEnabled: [InputFlags.None, "clrFocusOnViewInit", "isEnabled"]
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrFocusOnViewInit, [{
    type: Directive,
    args: [{
      selector: "[clrFocusOnViewInit]"
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [PLATFORM_ID]
      }]
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [FOCUS_ON_VIEW_INIT]
      }]
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [DOCUMENT]
      }]
    }, {
      type: Renderer2
    }, {
      type: NgZone
    }];
  }, {
    isEnabled: [{
      type: Input,
      args: ["clrFocusOnViewInit"]
    }]
  });
})();
var FOCUS_ON_VIEW_INIT_DIRECTIVES = [ClrFocusOnViewInit];
var ClrFocusOnViewInitModule = class {
};
ClrFocusOnViewInitModule.ɵfac = function ClrFocusOnViewInitModule_Factory(t3) {
  return new (t3 || ClrFocusOnViewInitModule)();
};
ClrFocusOnViewInitModule.ɵmod = ɵɵdefineNgModule({
  type: ClrFocusOnViewInitModule,
  declarations: [ClrFocusOnViewInit],
  imports: [CommonModule],
  exports: [ClrFocusOnViewInit]
});
ClrFocusOnViewInitModule.ɵinj = ɵɵdefineInjector({
  providers: [FOCUS_ON_VIEW_INIT_PROVIDER],
  imports: [CommonModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrFocusOnViewInitModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      declarations: [FOCUS_ON_VIEW_INIT_DIRECTIVES],
      providers: [FOCUS_ON_VIEW_INIT_PROVIDER],
      exports: [FOCUS_ON_VIEW_INIT_DIRECTIVES]
    }]
  }], null, null);
})();
var ClrStandaloneCdkTrapFocus = class extends CdkTrapFocus {
  /**
   * Include the constructor to forward all the dependencies to the base class
   * as a workaround to fix Angular "ɵɵinvalidFactoryDep" error after upgrading storybook
   * https://github.com/storybookjs/storybook/issues/23534
   */
  constructor(elementRef, focusTrapFactory, document2) {
    super(elementRef, focusTrapFactory, document2);
  }
};
ClrStandaloneCdkTrapFocus.ɵfac = function ClrStandaloneCdkTrapFocus_Factory(t3) {
  return new (t3 || ClrStandaloneCdkTrapFocus)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(FocusTrapFactory), ɵɵdirectiveInject(DOCUMENT, 8));
};
ClrStandaloneCdkTrapFocus.ɵdir = ɵɵdefineDirective({
  type: ClrStandaloneCdkTrapFocus,
  standalone: true,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrStandaloneCdkTrapFocus, [{
    type: Directive,
    args: [{
      standalone: true
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: FocusTrapFactory
    }, {
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [DOCUMENT]
      }]
    }];
  }, null);
})();
var ButtonGroupFocusHandler = class {
  constructor(focusService, toggleService, renderer) {
    this.focusService = focusService;
    this.toggleService = toggleService;
    this.renderer = renderer;
    this.initialFocus = InitialFocus.FIRST_ITEM;
    this._unlistenFuncs = [];
  }
  ngOnDestroy() {
    this._unlistenFuncs.forEach((unlisten) => unlisten());
    this.focusService.detachListeners();
  }
  initialize({
    menu,
    menuToggle
  }) {
    this.menu = menu;
    this.menuToggle = menuToggle;
    this.focusService.registerContainer(this.menu, "-1");
    this.listenToKeys();
    this.linkButtons();
    switch (this.initialFocus) {
      case InitialFocus.LAST_ITEM:
        this.focusLastItem();
        break;
      default:
        this.focusFirstItem();
        break;
    }
  }
  resetButtonsFocus() {
    this.buttons.forEach((button) => {
      button.blur();
    });
  }
  listenToKeys() {
    this._unlistenFuncs.push(this.renderer.listen(this.menu, "keydown.shift.tab", (event) => this.closeMenu(event, false)));
    this._unlistenFuncs.push(this.renderer.listen(this.menu, "keydown.tab", (event) => this.closeMenu(event, true)));
  }
  closeMenu(event, focusBackOnToggle) {
    this.toggleService.toggleWithEvent(event);
    if (focusBackOnToggle) {
      this.menuToggle.focus();
    }
    this.resetButtonsFocus();
  }
  linkButtons() {
    const buttonElements = Array.from(this.menu.children);
    this.buttons = buttonElements.map((buttonElement) => {
      this._unlistenFuncs.push(this.renderer.listen(buttonElement, "click", (event) => this.closeMenu(event, true)));
      return {
        id: buttonElement.id,
        value: buttonElement,
        focus: () => {
          buttonElement.setAttribute("tabindex", "0");
          buttonElement.focus();
        },
        blur: () => {
          buttonElement.setAttribute("tabindex", "-1");
          buttonElement.blur();
        }
      };
    });
    this.resetButtonsFocus();
    Linkers.linkVertical(this.buttons);
  }
  focusFirstItem() {
    if (this.buttons.length) {
      this.focusService.moveTo(this.buttons[0]);
    }
    this.initialFocus = InitialFocus.FIRST_ITEM;
  }
  focusLastItem() {
    if (this.buttons.length) {
      this.focusService.moveTo(this.buttons[this.buttons.length - 1]);
    }
    this.initialFocus = InitialFocus.FIRST_ITEM;
  }
};
ButtonGroupFocusHandler.ɵfac = function ButtonGroupFocusHandler_Factory(t3) {
  return new (t3 || ButtonGroupFocusHandler)(ɵɵinject(FocusService$1), ɵɵinject(ClrPopoverToggleService), ɵɵinject(Renderer2));
};
ButtonGroupFocusHandler.ɵprov = ɵɵdefineInjectable({
  token: ButtonGroupFocusHandler,
  factory: ButtonGroupFocusHandler.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ButtonGroupFocusHandler, [{
    type: Injectable
  }], function() {
    return [{
      type: FocusService$1
    }, {
      type: ClrPopoverToggleService
    }, {
      type: Renderer2
    }];
  }, null);
})();
var BUTTON_GROUP_FOCUS_HANDLER_PROVIDER = {
  provide: ButtonGroupFocusHandler
};
var ClrButtonGroup = class {
  constructor(buttonGroupNewService, toggleService, commonStrings, destroy$, focusHandler) {
    this.buttonGroupNewService = buttonGroupNewService;
    this.toggleService = toggleService;
    this.commonStrings = commonStrings;
    this.destroy$ = destroy$;
    this.focusHandler = focusHandler;
    this.clrToggleButtonAriaLabel = this.commonStrings.keys.rowActions;
    this.popoverId = uniqueIdFactory();
    this.InitialFocus = InitialFocus;
    this.popoverPosition = ClrPopoverPositions["bottom-left"];
    this.inlineButtons = [];
    this.menuButtons = [];
  }
  get menuPosition() {
    return this._menuPosition;
  }
  set menuPosition(pos) {
    if (pos && ClrPopoverPositions[pos]) {
      this._menuPosition = pos;
    } else {
      this._menuPosition = "bottom-left";
    }
    this.popoverPosition = ClrPopoverPositions[this._menuPosition];
  }
  get open() {
    return this.toggleService.open;
  }
  /**
   * 1. Initializes the initial Button Group View
   * 2. Subscribes to changes on the ContentChildren
   *    in case the user content projection changes
   */
  ngAfterContentInit() {
    this.initializeButtons();
    this.buttonGroupNewService.changes.pipe(takeUntil(this.destroy$)).subscribe((button) => this.rearrangeButton(button));
    this.buttons.changes.subscribe(() => {
      this.initializeButtons();
    });
  }
  ngAfterViewInit() {
    this.handleFocusOnMenuOpen();
  }
  /**
   * Moves the button into the other ViewContainer
   * when an update is received.
   *
   * @param button
   */
  rearrangeButton(button) {
    let fromView;
    let toView;
    if (button.inMenu) {
      fromView = this.inlineButtons;
      toView = this.menuButtons;
    } else {
      fromView = this.menuButtons;
      toView = this.inlineButtons;
    }
    const index = fromView.indexOf(button);
    if (index > -1) {
      fromView.splice(index, 1);
      const moveIndex = this.getMoveIndex(button);
      if (moveIndex <= toView.length) {
        toView.splice(moveIndex, 0, button);
      }
    }
  }
  openMenu(event, initialFocus) {
    this.focusHandler.initialFocus = initialFocus;
    if (!this.toggleService.open) {
      this.toggleService.toggleWithEvent(event);
    }
  }
  /**
   * Author: Eudes
   *
   * Finds the order of a button w.r.t other buttons
   *
   * @param buttonToMove
   * @returns
   */
  getMoveIndex(buttonToMove) {
    const tempArr = this.buttons.filter((button) => button.inMenu === buttonToMove.inMenu);
    return tempArr.indexOf(buttonToMove);
  }
  initializeButtons() {
    const tempInlineButtons = [];
    const tempInMenuButtons = [];
    this.buttons.forEach((button) => {
      if (button.inMenu) {
        tempInMenuButtons.push(button);
      } else {
        tempInlineButtons.push(button);
      }
    });
    this.inlineButtons = tempInlineButtons;
    this.menuButtons = tempInMenuButtons;
  }
  handleFocusOnMenuOpen() {
    this.toggleService.popoverVisible.pipe(takeUntil(this.destroy$)).subscribe((visible) => {
      if (visible) {
        this.focusHandler.initialize({
          menu: this.menu.nativeElement,
          menuToggle: this.menuToggle.nativeElement
        });
      }
    });
  }
};
ClrButtonGroup.ɵfac = function ClrButtonGroup_Factory(t3) {
  return new (t3 || ClrButtonGroup)(ɵɵdirectiveInject(ButtonInGroupService), ɵɵdirectiveInject(ClrPopoverToggleService), ɵɵdirectiveInject(ClrCommonStringsService), ɵɵdirectiveInject(ClrDestroyService), ɵɵdirectiveInject(ButtonGroupFocusHandler));
};
ClrButtonGroup.ɵcmp = ɵɵdefineComponent({
  type: ClrButtonGroup,
  selectors: [["clr-button-group"]],
  contentQueries: function ClrButtonGroup_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ClrButton, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.buttons = _t);
    }
  },
  viewQuery: function ClrButtonGroup_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c6, 5);
      ɵɵviewQuery(_c7, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.menuToggle = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.menu = _t.first);
    }
  },
  hostVars: 2,
  hostBindings: function ClrButtonGroup_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("btn-group", true);
    }
  },
  inputs: {
    clrToggleButtonAriaLabel: "clrToggleButtonAriaLabel",
    menuPosition: [InputFlags.None, "clrMenuPosition", "menuPosition"]
  },
  features: [ɵɵProvidersFeature([ButtonInGroupService, ClrDestroyService, BUTTON_GROUP_FOCUS_HANDLER_PROVIDER, FOCUS_SERVICE_PROVIDER]), ɵɵHostDirectivesFeature([ClrPopoverHostDirective])],
  decls: 2,
  vars: 2,
  consts: [["menuToggle", ""], ["menu", ""], [4, "ngFor", "ngForOf"], ["class", "btn-group-overflow open", 3, "ngClass", 4, "ngIf"], [3, "ngTemplateOutlet"], [1, "btn-group-overflow", "open", 3, "ngClass"], ["clrPopoverAnchor", "", "clrPopoverOpenCloseButton", "", 1, "btn", "dropdown-toggle", 3, "keydown.arrowup", "keydown.arrowdown"], ["shape", "ellipsis-horizontal"], ["role", "menu", "class", "dropdown-menu clr-button-group-menu", 3, "id", 4, "clrPopoverContent", "clrPopoverContentAt", "clrPopoverContentOutsideClickToClose", "clrPopoverContentScrollToClose"], ["role", "menu", 1, "dropdown-menu", "clr-button-group-menu", 3, "id"]],
  template: function ClrButtonGroup_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, ClrButtonGroup_0_Template, 1, 1, null, 2)(1, ClrButtonGroup_div_1_Template, 5, 9, "div", 3);
    }
    if (rf & 2) {
      ɵɵproperty("ngForOf", ctx.inlineButtons);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.menuButtons.length > 0);
    }
  },
  dependencies: [NgClass, NgForOf, NgIf, NgTemplateOutlet, CdsIconCustomTag, ClrPopoverAnchor, ClrPopoverOpenCloseButton, ClrPopoverContent],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrButtonGroup, [{
    type: Component,
    args: [{
      selector: "clr-button-group",
      providers: [ButtonInGroupService, ClrDestroyService, BUTTON_GROUP_FOCUS_HANDLER_PROVIDER, FOCUS_SERVICE_PROVIDER],
      hostDirectives: [ClrPopoverHostDirective],
      host: {
        "[class.btn-group]": "true"
      },
      template: '<!--\n  ~ Copyright (c) 2016-2024 Broadcom. All Rights Reserved.\n  ~ The term "Broadcom" refers to Broadcom Inc. and/or its subsidiaries.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n  -->\n\n<ng-template *ngFor="let inlineButton of inlineButtons" [ngTemplateOutlet]="inlineButton.templateRef"></ng-template>\n\n<div *ngIf="menuButtons.length > 0" class="btn-group-overflow open" [ngClass]="menuPosition">\n  <button\n    #menuToggle\n    class="btn dropdown-toggle"\n    clrPopoverAnchor\n    clrPopoverOpenCloseButton\n    (keydown.arrowup)="openMenu($event, InitialFocus.LAST_ITEM)"\n    (keydown.arrowdown)="openMenu($event, InitialFocus.FIRST_ITEM)"\n    [attr.aria-controls]="popoverId"\n    [attr.aria-expanded]="open"\n    [attr.aria-label]="clrToggleButtonAriaLabel"\n  >\n    <cds-icon shape="ellipsis-horizontal" [attr.title]="commonStrings.keys.more"></cds-icon>\n  </button>\n  <div\n    #menu\n    role="menu"\n    class="dropdown-menu clr-button-group-menu"\n    [id]="popoverId"\n    [attr.id]="popoverId"\n    [attr.aria-hidden]="!open"\n    *clrPopoverContent="open at popoverPosition; outsideClickToClose: true; scrollToClose: true"\n  >\n    <ng-template *ngFor="let menuButton of menuButtons" [ngTemplateOutlet]="menuButton.templateRef"></ng-template>\n  </div>\n</div>\n'
    }]
  }], function() {
    return [{
      type: ButtonInGroupService
    }, {
      type: ClrPopoverToggleService
    }, {
      type: ClrCommonStringsService
    }, {
      type: ClrDestroyService
    }, {
      type: ButtonGroupFocusHandler
    }];
  }, {
    clrToggleButtonAriaLabel: [{
      type: Input,
      args: ["clrToggleButtonAriaLabel"]
    }],
    menuToggle: [{
      type: ViewChild,
      args: ["menuToggle"]
    }],
    menu: [{
      type: ViewChild,
      args: ["menu"]
    }],
    buttons: [{
      type: ContentChildren,
      args: [ClrButton]
    }],
    menuPosition: [{
      type: Input,
      args: ["clrMenuPosition"]
    }]
  });
})();
var CLR_BUTTON_GROUP_DIRECTIVES = [ClrButton, ClrButtonGroup];
var ClrButtonGroupModule = class {
};
ClrButtonGroupModule.ɵfac = function ClrButtonGroupModule_Factory(t3) {
  return new (t3 || ClrButtonGroupModule)();
};
ClrButtonGroupModule.ɵmod = ɵɵdefineNgModule({
  type: ClrButtonGroupModule,
  declarations: [ClrButton, ClrButtonGroup],
  imports: [CommonModule, ClrIconModule, ClrPopoverModuleNext],
  exports: [ClrButton, ClrButtonGroup]
});
ClrButtonGroupModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, ClrIconModule, ClrPopoverModuleNext]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrButtonGroupModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, ClrIconModule, ClrPopoverModuleNext],
      declarations: [CLR_BUTTON_GROUP_DIRECTIVES],
      exports: [CLR_BUTTON_GROUP_DIRECTIVES]
    }]
  }], null, null);
})();
var MIN_BUTTON_WIDTH = 42;
var ClrLoadingButton = class {
  constructor(el, renderer) {
    this.el = el;
    this.renderer = renderer;
    this.clrLoadingChange = new EventEmitter(false);
    this.buttonState = ClrLoadingState;
    this.state = ClrLoadingState.DEFAULT;
  }
  loadingStateChange(state2) {
    if (state2 === this.state) {
      return;
    }
    this.state = state2;
    switch (state2) {
      case ClrLoadingState.DEFAULT:
        this.renderer.removeStyle(this.el.nativeElement, "width");
        this.renderer.removeStyle(this.el.nativeElement, "transform");
        if (!this.disabled) {
          this.renderer.removeAttribute(this.el.nativeElement, "disabled");
        }
        break;
      case ClrLoadingState.LOADING:
        this.setExplicitButtonWidth();
        this.renderer.setStyle(this.el.nativeElement, "transform", "translatez(0)");
        this.renderer.setAttribute(this.el.nativeElement, "disabled", "");
        break;
      case ClrLoadingState.SUCCESS:
        this.setExplicitButtonWidth();
        break;
      case ClrLoadingState.ERROR:
        this.loadingStateChange(ClrLoadingState.DEFAULT);
        break;
      default:
        break;
    }
    this.clrLoadingChange.emit(state2);
  }
  setExplicitButtonWidth() {
    if (this.el.nativeElement && this.el.nativeElement.getBoundingClientRect) {
      const boundingClientRect = this.el.nativeElement.getBoundingClientRect();
      const width = Math.max(MIN_BUTTON_WIDTH, boundingClientRect.width);
      this.renderer.setStyle(this.el.nativeElement, "width", `${width}px`);
    }
  }
};
ClrLoadingButton.ɵfac = function ClrLoadingButton_Factory(t3) {
  return new (t3 || ClrLoadingButton)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2));
};
ClrLoadingButton.ɵcmp = ɵɵdefineComponent({
  type: ClrLoadingButton,
  selectors: [["button", "clrLoading", ""]],
  hostVars: 1,
  hostBindings: function ClrLoadingButton_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("disabled", ctx.disabled ? "" : null);
    }
  },
  inputs: {
    disabled: "disabled"
  },
  outputs: {
    clrLoadingChange: "clrLoadingChange"
  },
  features: [ɵɵProvidersFeature([{
    provide: LoadingListener,
    useExisting: ClrLoadingButton
  }])],
  attrs: _c8,
  ngContentSelectors: _c02,
  decls: 4,
  vars: 5,
  consts: [[3, "ngSwitch"], [4, "ngSwitchCase"], ["class", "clr-loading-btn-content", 4, "ngSwitchCase"], [1, "spinner", "spinner-inline"], [1, "spinner", "spinner-inline", "spinner-check"], [1, "clr-loading-btn-content"]],
  template: function ClrLoadingButton_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "span", 0);
      ɵɵtemplate(1, ClrLoadingButton_ng_container_1_Template, 2, 1, "ng-container", 1)(2, ClrLoadingButton_ng_container_2_Template, 2, 1, "ng-container", 1)(3, ClrLoadingButton_span_3_Template, 2, 1, "span", 2);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("@parent", void 0)("ngSwitch", ctx.state);
      ɵɵadvance();
      ɵɵproperty("ngSwitchCase", ctx.buttonState.LOADING);
      ɵɵadvance();
      ɵɵproperty("ngSwitchCase", ctx.buttonState.SUCCESS);
      ɵɵadvance();
      ɵɵproperty("ngSwitchCase", ctx.buttonState.DEFAULT);
    }
  },
  dependencies: [NgSwitch, NgSwitchCase],
  encapsulation: 2,
  data: {
    animation: [trigger("parent", [
      // Skip :enter animation on first render.
      // The button text/content should only be faded when transitioning to or from a non-default state.
      transition(":enter", [])
    ]), trigger("defaultButton", [
      transition(":enter", [style({
        opacity: 0
      }), animate("200ms 100ms ease-in", style({
        opacity: 1
      }))]),
      // TODO: see if we can get leave animation to work before spinner's enter animation
      transition(":leave", [style({
        opacity: 0
      })])
    ]), trigger("spinner", [transition(":enter", [style({
      opacity: 0
    }), animate("200ms 100ms ease-in", style({
      opacity: 1
    }))]), transition(":leave", [style({
      opacity: 1
    }), animate("100ms ease-out", style({
      opacity: 0
    }))])]), trigger("validated", [transition(":enter", [animate("600ms", keyframes([style({
      transform: "scale(0,0)",
      offset: 0
    }), style({
      opacity: 1,
      offset: 0.2
    }), style({
      transform: "scale(1.2,1.2)",
      offset: 0.4
    }), style({
      transform: "scale(.9,.9)",
      offset: 0.6
    }), style({
      transform: "scale(1,1)",
      offset: 1
    })]))]), transition(":leave", [style({
      opacity: 1
    }), animate("100ms ease-out", style({
      opacity: 0
    }))])])]
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrLoadingButton, [{
    type: Component,
    args: [{
      selector: "button[clrLoading]",
      template: `
    <span @parent [ngSwitch]="state">
      <ng-container *ngSwitchCase="buttonState.LOADING">
        <span @spinner class="spinner spinner-inline"></span>
      </ng-container>
      <ng-container *ngSwitchCase="buttonState.SUCCESS">
        <span
          @validated
          (@validated.done)="this.loadingStateChange(this.buttonState.DEFAULT)"
          class="spinner spinner-inline spinner-check"
        ></span>
      </ng-container>
      <span *ngSwitchCase="buttonState.DEFAULT" @defaultButton class="clr-loading-btn-content">
        <ng-content></ng-content>
      </span>
    </span>
  `,
      providers: [{
        provide: LoadingListener,
        useExisting: ClrLoadingButton
      }],
      animations: [trigger("parent", [
        // Skip :enter animation on first render.
        // The button text/content should only be faded when transitioning to or from a non-default state.
        transition(":enter", [])
      ]), trigger("defaultButton", [
        transition(":enter", [style({
          opacity: 0
        }), animate("200ms 100ms ease-in", style({
          opacity: 1
        }))]),
        // TODO: see if we can get leave animation to work before spinner's enter animation
        transition(":leave", [style({
          opacity: 0
        })])
      ]), trigger("spinner", [transition(":enter", [style({
        opacity: 0
      }), animate("200ms 100ms ease-in", style({
        opacity: 1
      }))]), transition(":leave", [style({
        opacity: 1
      }), animate("100ms ease-out", style({
        opacity: 0
      }))])]), trigger("validated", [transition(":enter", [animate("600ms", keyframes([style({
        transform: "scale(0,0)",
        offset: 0
      }), style({
        opacity: 1,
        offset: 0.2
      }), style({
        transform: "scale(1.2,1.2)",
        offset: 0.4
      }), style({
        transform: "scale(.9,.9)",
        offset: 0.6
      }), style({
        transform: "scale(1,1)",
        offset: 1
      })]))]), transition(":leave", [style({
        opacity: 1
      }), animate("100ms ease-out", style({
        opacity: 0
      }))])])],
      host: {
        "[attr.disabled]": "disabled? '' : null"
      }
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: Renderer2
    }];
  }, {
    disabled: [{
      type: Input,
      args: ["disabled"]
    }],
    clrLoadingChange: [{
      type: Output,
      args: ["clrLoadingChange"]
    }]
  });
})();
var CLR_LOADING_BUTTON_DIRECTIVES = [ClrLoadingButton];
var ClrLoadingButtonModule = class {
};
ClrLoadingButtonModule.ɵfac = function ClrLoadingButtonModule_Factory(t3) {
  return new (t3 || ClrLoadingButtonModule)();
};
ClrLoadingButtonModule.ɵmod = ɵɵdefineNgModule({
  type: ClrLoadingButtonModule,
  declarations: [ClrLoadingButton],
  imports: [CommonModule],
  exports: [ClrLoadingButton]
});
ClrLoadingButtonModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrLoadingButtonModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      declarations: [CLR_LOADING_BUTTON_DIRECTIVES],
      exports: [CLR_LOADING_BUTTON_DIRECTIVES]
    }]
  }], null, null);
})();
var ClrButtonModule = class {
  constructor() {
    r.addIcons(i);
  }
};
ClrButtonModule.ɵfac = function ClrButtonModule_Factory(t3) {
  return new (t3 || ClrButtonModule)();
};
ClrButtonModule.ɵmod = ɵɵdefineNgModule({
  type: ClrButtonModule,
  exports: [ClrLoadingButtonModule, ClrButtonGroupModule]
});
ClrButtonModule.ɵinj = ɵɵdefineInjector({
  imports: [ClrLoadingButtonModule, ClrButtonGroupModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrButtonModule, [{
    type: NgModule,
    args: [{
      exports: [ClrLoadingButtonModule, ClrButtonGroupModule]
    }]
  }], function() {
    return [];
  }, null);
})();
var EmptyAnchor = class {
};
EmptyAnchor.ɵfac = function EmptyAnchor_Factory(t3) {
  return new (t3 || EmptyAnchor)();
};
EmptyAnchor.ɵcmp = ɵɵdefineComponent({
  type: EmptyAnchor,
  selectors: [["ng-component"]],
  decls: 0,
  vars: 0,
  template: function EmptyAnchor_Template(rf, ctx) {
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(EmptyAnchor, [{
    type: Component,
    args: [{
      template: ""
    }]
  }], null, null);
})();
var ClrHostWrappingModule = class {
};
ClrHostWrappingModule.ɵfac = function ClrHostWrappingModule_Factory(t3) {
  return new (t3 || ClrHostWrappingModule)();
};
ClrHostWrappingModule.ɵmod = ɵɵdefineNgModule({
  type: ClrHostWrappingModule,
  declarations: [EmptyAnchor],
  exports: [EmptyAnchor]
});
ClrHostWrappingModule.ɵinj = ɵɵdefineInjector({});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrHostWrappingModule, [{
    type: NgModule,
    args: [{
      declarations: [EmptyAnchor],
      exports: [EmptyAnchor]
    }]
  }], null, null);
})();
var counter$2 = 0;
var ControlIdService = class {
  constructor() {
    this._id = "clr-form-control-" + ++counter$2;
    this._idChange = new BehaviorSubject(this._id);
  }
  get id() {
    return this._id;
  }
  set id(value) {
    this._id = value;
    this._idChange.next(value);
  }
  get idChange() {
    return this._idChange.asObservable();
  }
};
ControlIdService.ɵfac = function ControlIdService_Factory(t3) {
  return new (t3 || ControlIdService)();
};
ControlIdService.ɵprov = ɵɵdefineInjectable({
  token: ControlIdService,
  factory: ControlIdService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ControlIdService, [{
    type: Injectable
  }], null, null);
})();
var counter$1 = 0;
var ContainerIdService = class {
  constructor() {
    this._id = `clr-form-container-${++counter$1}`;
    this._idChange = new BehaviorSubject(this._id);
  }
  get id() {
    return this._id;
  }
  set id(value) {
    this._id = value;
    this._idChange.next(value);
  }
  get idChange() {
    return this._idChange.asObservable();
  }
};
ContainerIdService.ɵfac = function ContainerIdService_Factory(t3) {
  return new (t3 || ContainerIdService)();
};
ContainerIdService.ɵprov = ɵɵdefineInjectable({
  token: ContainerIdService,
  factory: ContainerIdService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ContainerIdService, [{
    type: Injectable
  }], null, null);
})();
var CONTROL_SUFFIX = {
  HELPER: "helper",
  ERROR: "error",
  SUCCESS: "success",
  NONE: null
};
var ClrAbstractControl = class {
  constructor(controlIdService, containerIdService) {
    this.controlIdService = controlIdService;
    this.containerIdService = containerIdService;
    this.controlIdSuffix = "abstract";
  }
  get id() {
    if (this.containerIdService) {
      return `${this.containerIdService.id}-${this.controlIdSuffix}`;
    }
    if (this.controlIdService) {
      return `${this.controlIdService.id}-${this.controlIdSuffix}`;
    }
    return null;
  }
};
ClrAbstractControl.ɵfac = function ClrAbstractControl_Factory(t3) {
  return new (t3 || ClrAbstractControl)(ɵɵdirectiveInject(ControlIdService, 8), ɵɵdirectiveInject(ContainerIdService, 8));
};
ClrAbstractControl.ɵdir = ɵɵdefineDirective({
  type: ClrAbstractControl
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrAbstractControl, [{
    type: Directive
  }], function() {
    return [{
      type: ControlIdService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: ContainerIdService,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var ClrControlError = class extends ClrAbstractControl {
  constructor(controlIdService, containerIdService) {
    super(controlIdService, containerIdService);
    this.controlIdService = controlIdService;
    this.containerIdService = containerIdService;
    this.controlIdSuffix = CONTROL_SUFFIX.ERROR;
  }
};
ClrControlError.ɵfac = function ClrControlError_Factory(t3) {
  return new (t3 || ClrControlError)(ɵɵdirectiveInject(ControlIdService, 8), ɵɵdirectiveInject(ContainerIdService, 8));
};
ClrControlError.ɵcmp = ɵɵdefineComponent({
  type: ClrControlError,
  selectors: [["clr-control-error"]],
  hostVars: 5,
  hostBindings: function ClrControlError_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("id", ctx.id);
      ɵɵclassProp("clr-subtext", true)("error", true);
    }
  },
  features: [ɵɵInheritDefinitionFeature],
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function ClrControlError_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrControlError, [{
    type: Component,
    args: [{
      selector: "clr-control-error",
      template: `<ng-content></ng-content>`,
      host: {
        "[class.clr-subtext]": "true",
        "[class.error]": "true",
        "[attr.id]": "id"
      }
    }]
  }], function() {
    return [{
      type: ControlIdService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: ContainerIdService,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var ClrControlHelper = class extends ClrAbstractControl {
  constructor(controlIdService, containerIdService) {
    super(controlIdService, containerIdService);
    this.controlIdService = controlIdService;
    this.containerIdService = containerIdService;
    this.controlIdSuffix = CONTROL_SUFFIX.HELPER;
  }
};
ClrControlHelper.ɵfac = function ClrControlHelper_Factory(t3) {
  return new (t3 || ClrControlHelper)(ɵɵdirectiveInject(ControlIdService, 8), ɵɵdirectiveInject(ContainerIdService, 8));
};
ClrControlHelper.ɵcmp = ɵɵdefineComponent({
  type: ClrControlHelper,
  selectors: [["clr-control-helper"]],
  hostVars: 3,
  hostBindings: function ClrControlHelper_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("id", ctx.id);
      ɵɵclassProp("clr-subtext", true);
    }
  },
  features: [ɵɵInheritDefinitionFeature],
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function ClrControlHelper_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrControlHelper, [{
    type: Component,
    args: [{
      selector: "clr-control-helper",
      template: `<ng-content></ng-content>`,
      host: {
        "[class.clr-subtext]": "true",
        "[attr.id]": "id"
      }
    }]
  }], function() {
    return [{
      type: ControlIdService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: ContainerIdService,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var NgControlService = class {
  constructor() {
    this._controlChanges = new Subject();
    this._helpers = new Subject();
  }
  get controlChanges() {
    return this._controlChanges.asObservable();
  }
  get helpersChange() {
    return this._helpers.asObservable();
  }
  setControl(control) {
    this._controlChanges.next(control);
  }
  setHelpers(state2) {
    this._helpers.next(state2);
  }
};
NgControlService.ɵfac = function NgControlService_Factory(t3) {
  return new (t3 || NgControlService)();
};
NgControlService.ɵprov = ɵɵdefineInjectable({
  token: NgControlService,
  factory: NgControlService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgControlService, [{
    type: Injectable
  }], null, null);
})();
var CONTROL_STATE;
(function(CONTROL_STATE2) {
  CONTROL_STATE2["NONE"] = "NONE";
  CONTROL_STATE2["VALID"] = "VALID";
  CONTROL_STATE2["INVALID"] = "INVALID";
})(CONTROL_STATE || (CONTROL_STATE = {}));
var IfControlStateService = class {
  constructor(ngControlService) {
    this.ngControlService = ngControlService;
    this.subscriptions = [];
    this._statusChanges = new BehaviorSubject(CONTROL_STATE.NONE);
    this.subscriptions.push(this.ngControlService.controlChanges.subscribe((control) => {
      if (control) {
        this.control = control;
        this.subscriptions.push(this.control.statusChanges.subscribe(() => {
          this.triggerStatusChange();
        }));
      }
    }));
  }
  get statusChanges() {
    return this._statusChanges.asObservable();
  }
  ngOnDestroy() {
    this.subscriptions.forEach((subscription) => subscription.unsubscribe());
  }
  triggerStatusChange() {
    if (this.control) {
      const status = CONTROL_STATE[this.control.status];
      this._statusChanges.next(["VALID", "INVALID"].includes(status) ? status : CONTROL_STATE.NONE);
    }
  }
};
IfControlStateService.ɵfac = function IfControlStateService_Factory(t3) {
  return new (t3 || IfControlStateService)(ɵɵinject(NgControlService));
};
IfControlStateService.ɵprov = ɵɵdefineInjectable({
  token: IfControlStateService,
  factory: IfControlStateService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(IfControlStateService, [{
    type: Injectable
  }], function() {
    return [{
      type: NgControlService
    }];
  }, null);
})();
var ClrFormLayout;
(function(ClrFormLayout2) {
  ClrFormLayout2["VERTICAL"] = "vertical";
  ClrFormLayout2["HORIZONTAL"] = "horizontal";
  ClrFormLayout2["COMPACT"] = "compact";
})(ClrFormLayout || (ClrFormLayout = {}));
var LayoutService = class {
  constructor() {
    this.minLabelSize = 1;
    this.maxLabelSize = 12;
    this.layout = ClrFormLayout.HORIZONTAL;
    this.layoutValues = Object.keys(ClrFormLayout).map((key) => ClrFormLayout[key]);
    this._labelSize = 2;
  }
  get labelSize() {
    return this._labelSize;
  }
  set labelSize(size) {
    if (this.labelSizeIsValid(size)) {
      this._labelSize = size;
    }
  }
  get layoutClass() {
    return `clr-form-${this.layout}`;
  }
  isVertical() {
    return this.layout === ClrFormLayout.VERTICAL;
  }
  isHorizontal() {
    return this.layout === ClrFormLayout.HORIZONTAL;
  }
  isCompact() {
    return this.layout === ClrFormLayout.COMPACT;
  }
  isValid(layout) {
    return this.layoutValues.indexOf(layout) > -1;
  }
  labelSizeIsValid(labelSize) {
    return Number.isInteger(labelSize) && labelSize >= this.minLabelSize && labelSize <= this.maxLabelSize;
  }
};
LayoutService.ɵfac = function LayoutService_Factory(t3) {
  return new (t3 || LayoutService)();
};
LayoutService.ɵprov = ɵɵdefineInjectable({
  token: LayoutService,
  factory: LayoutService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LayoutService, [{
    type: Injectable
  }], null, null);
})();
var ClrLabel = class {
  constructor(controlIdService, layoutService, ngControlService, renderer, el) {
    this.controlIdService = controlIdService;
    this.layoutService = layoutService;
    this.ngControlService = ngControlService;
    this.renderer = renderer;
    this.el = el;
    this.enableGrid = true;
    this.subscriptions = [];
  }
  get labelText() {
    return this.el.nativeElement && this.el.nativeElement.textContent;
  }
  ngOnInit() {
    if (this.controlIdService || this.ngControlService) {
      this.renderer.addClass(this.el.nativeElement, "clr-control-label");
    }
    if (this.enableGrid && this.layoutService && !this.layoutService.isVertical() && this.el.nativeElement && this.el.nativeElement.className.indexOf("clr-col") < 0) {
      this.renderer.addClass(this.el.nativeElement, "clr-col-12");
      this.renderer.addClass(this.el.nativeElement, `clr-col-md-${this.layoutService.labelSize}`);
    }
    if (this.controlIdService && !this.forAttr) {
      this.subscriptions.push(this.controlIdService.idChange.subscribe((id) => this.forAttr = id));
    }
  }
  ngOnDestroy() {
    this.subscriptions.forEach((sub) => sub.unsubscribe());
  }
  disableGrid() {
    this.enableGrid = false;
  }
};
ClrLabel.ɵfac = function ClrLabel_Factory(t3) {
  return new (t3 || ClrLabel)(ɵɵdirectiveInject(ControlIdService, 8), ɵɵdirectiveInject(LayoutService, 8), ɵɵdirectiveInject(NgControlService, 8), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef));
};
ClrLabel.ɵdir = ɵɵdefineDirective({
  type: ClrLabel,
  selectors: [["label"]],
  hostVars: 1,
  hostBindings: function ClrLabel_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("for", ctx.forAttr);
    }
  },
  inputs: {
    forAttr: [InputFlags.None, "for", "forAttr"]
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrLabel, [{
    type: Directive,
    args: [{
      selector: "label"
    }]
  }], function() {
    return [{
      type: ControlIdService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: LayoutService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: NgControlService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: Renderer2
    }, {
      type: ElementRef
    }];
  }, {
    forAttr: [{
      type: Input,
      args: ["for"]
    }, {
      type: HostBinding,
      args: ["attr.for"]
    }]
  });
})();
var ClrControlSuccess = class extends ClrAbstractControl {
  constructor(controlIdService, containerIdService) {
    super(controlIdService, containerIdService);
    this.controlIdService = controlIdService;
    this.containerIdService = containerIdService;
    this.controlIdSuffix = CONTROL_SUFFIX.SUCCESS;
  }
};
ClrControlSuccess.ɵfac = function ClrControlSuccess_Factory(t3) {
  return new (t3 || ClrControlSuccess)(ɵɵdirectiveInject(ControlIdService, 8), ɵɵdirectiveInject(ContainerIdService, 8));
};
ClrControlSuccess.ɵcmp = ɵɵdefineComponent({
  type: ClrControlSuccess,
  selectors: [["clr-control-success"]],
  hostVars: 5,
  hostBindings: function ClrControlSuccess_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("id", ctx.id);
      ɵɵclassProp("clr-subtext", true)("success", true);
    }
  },
  features: [ɵɵInheritDefinitionFeature],
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function ClrControlSuccess_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrControlSuccess, [{
    type: Component,
    args: [{
      selector: "clr-control-success",
      template: `<ng-content></ng-content>`,
      host: {
        "[class.clr-subtext]": "true",
        "[class.success]": "true",
        "[attr.id]": "id"
      }
    }]
  }], function() {
    return [{
      type: ControlIdService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: ContainerIdService,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var CLASS_ERROR = "clr-error";
var CLASS_SUCCESS = "clr-success";
var ControlClassService = class {
  constructor(layoutService) {
    this.layoutService = layoutService;
    this.className = "";
  }
  controlClass(state2 = CONTROL_STATE.NONE, grid = false, additional = "") {
    const controlClasses = [this.className, additional];
    switch (state2) {
      case CONTROL_STATE.VALID:
        controlClasses.push(CLASS_SUCCESS);
        break;
      case CONTROL_STATE.INVALID:
        controlClasses.push(CLASS_ERROR);
        break;
    }
    if (grid && this.layoutService && this.className.indexOf("clr-col") === -1) {
      controlClasses.push(`clr-col-md-${this.layoutService.maxLabelSize - this.layoutService.labelSize} clr-col-12`);
    }
    return controlClasses.join(" ").trim();
  }
  // We want to remove the column classes from the input up to the container
  initControlClass(renderer, element) {
    if (element && element.className) {
      this.className = element.className;
      const klasses = element.className.split(" ");
      klasses.forEach((klass) => {
        if (klass.startsWith("clr-col")) {
          renderer.removeClass(element, klass);
        }
      });
    }
  }
};
ControlClassService.ɵfac = function ControlClassService_Factory(t3) {
  return new (t3 || ControlClassService)(ɵɵinject(LayoutService, 8));
};
ControlClassService.ɵprov = ɵɵdefineInjectable({
  token: ControlClassService,
  factory: ControlClassService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ControlClassService, [{
    type: Injectable
  }], function() {
    return [{
      type: LayoutService,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var ClrAbstractContainer = class {
  constructor(ifControlStateService, layoutService, controlClassService, ngControlService) {
    this.ifControlStateService = ifControlStateService;
    this.layoutService = layoutService;
    this.controlClassService = controlClassService;
    this.ngControlService = ngControlService;
    this._dynamic = false;
    this.subscriptions = [];
    this.subscriptions.push(this.ifControlStateService.statusChanges.subscribe((state2) => {
      this.state = state2;
      setTimeout(() => {
        this.updateHelpers();
      });
    }));
    this.subscriptions.push(this.ngControlService.controlChanges.subscribe((control) => {
      this.control = control;
    }));
  }
  /**
   * @NOTE
   * Helper control is a bit different than the others, it must be always visible:
   *   -  Labels and instructions must always accompany forms and are persistent.
   *   -  The recommendation here is to always have helper text or anything instructions visible.
   *   -  The expectation is to have error text + helper text in the errored state. this way all users will have the helper text information always available.
   */
  get showHelper() {
    return Boolean(this.controlHelperComponent);
  }
  get showValid() {
    return this.touched && this.state === CONTROL_STATE.VALID && !!this.controlSuccessComponent;
  }
  get showInvalid() {
    return this.touched && this.state === CONTROL_STATE.INVALID && !!this.controlErrorComponent;
  }
  get touched() {
    return this.control?.touched;
  }
  ngAfterContentInit() {
    this.updateHelpers();
  }
  ngOnDestroy() {
    this.subscriptions.forEach((subscription) => subscription.unsubscribe());
  }
  controlClass() {
    if (!this.controlSuccessComponent && this.state === CONTROL_STATE.VALID || !this.touched) {
      return this.controlClassService.controlClass(CONTROL_STATE.NONE, this.addGrid());
    }
    return this.controlClassService.controlClass(this.state, this.addGrid());
  }
  addGrid() {
    return this.layoutService && !this.layoutService.isVertical();
  }
  updateHelpers() {
    if (this.ngControlService) {
      this.ngControlService.setHelpers({
        show: this.showInvalid || this.showHelper || this.showValid,
        showInvalid: this.showInvalid,
        showHelper: this.showHelper,
        showValid: this.showValid
      });
    }
  }
};
ClrAbstractContainer.ɵfac = function ClrAbstractContainer_Factory(t3) {
  return new (t3 || ClrAbstractContainer)(ɵɵdirectiveInject(IfControlStateService), ɵɵdirectiveInject(LayoutService, 8), ɵɵdirectiveInject(ControlClassService), ɵɵdirectiveInject(NgControlService));
};
ClrAbstractContainer.ɵdir = ɵɵdefineDirective({
  type: ClrAbstractContainer,
  contentQueries: function ClrAbstractContainer_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ClrLabel, 5);
      ɵɵcontentQuery(dirIndex, ClrControlSuccess, 5);
      ɵɵcontentQuery(dirIndex, ClrControlError, 5);
      ɵɵcontentQuery(dirIndex, ClrControlHelper, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.label = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.controlSuccessComponent = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.controlErrorComponent = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.controlHelperComponent = _t.first);
    }
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrAbstractContainer, [{
    type: Directive
  }], function() {
    return [{
      type: IfControlStateService
    }, {
      type: LayoutService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: ControlClassService
    }, {
      type: NgControlService
    }];
  }, {
    label: [{
      type: ContentChild,
      args: [ClrLabel, {
        static: false
      }]
    }],
    controlSuccessComponent: [{
      type: ContentChild,
      args: [ClrControlSuccess]
    }],
    controlErrorComponent: [{
      type: ContentChild,
      args: [ClrControlError]
    }],
    controlHelperComponent: [{
      type: ContentChild,
      args: [ClrControlHelper]
    }]
  });
})();
var ClrControlContainer = class extends ClrAbstractContainer {
};
ClrControlContainer.ɵfac = /* @__PURE__ */ (() => {
  let ɵClrControlContainer_BaseFactory;
  return function ClrControlContainer_Factory(t3) {
    return (ɵClrControlContainer_BaseFactory || (ɵClrControlContainer_BaseFactory = ɵɵgetInheritedFactory(ClrControlContainer)))(t3 || ClrControlContainer);
  };
})();
ClrControlContainer.ɵcmp = ɵɵdefineComponent({
  type: ClrControlContainer,
  selectors: [["clr-control-container"]],
  hostVars: 6,
  hostBindings: function ClrControlContainer_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("clr-form-control", true)("clr-form-control-disabled", ctx.control == null ? null : ctx.control.disabled)("clr-row", ctx.addGrid());
    }
  },
  features: [ɵɵProvidersFeature([IfControlStateService, NgControlService, ControlIdService, ControlClassService]), ɵɵInheritDefinitionFeature],
  ngContentSelectors: _c10,
  decls: 10,
  vars: 7,
  consts: [[4, "ngIf"], [1, "clr-control-container", 3, "ngClass"], [1, "clr-input-wrapper"], ["class", "clr-validate-icon", "shape", "exclamation-circle", "status", "danger", "aria-hidden", "true", 4, "ngIf"], ["class", "clr-validate-icon", "shape", "check-circle", "status", "success", "aria-hidden", "true", 4, "ngIf"], ["shape", "exclamation-circle", "status", "danger", "aria-hidden", "true", 1, "clr-validate-icon"], ["shape", "check-circle", "status", "success", "aria-hidden", "true", 1, "clr-validate-icon"]],
  template: function ClrControlContainer_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c9);
      ɵɵprojection(0);
      ɵɵtemplate(1, ClrControlContainer_label_1_Template, 1, 0, "label", 0);
      ɵɵelementStart(2, "div", 1)(3, "div", 2);
      ɵɵprojection(4, 1);
      ɵɵtemplate(5, ClrControlContainer_cds_icon_5_Template, 1, 0, "cds-icon", 3)(6, ClrControlContainer_cds_icon_6_Template, 1, 0, "cds-icon", 4);
      ɵɵelementEnd();
      ɵɵtemplate(7, ClrControlContainer_ng_content_7_Template, 1, 0, "ng-content", 0)(8, ClrControlContainer_ng_content_8_Template, 1, 0, "ng-content", 0)(9, ClrControlContainer_ng_content_9_Template, 1, 0, "ng-content", 0);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.label && ctx.addGrid());
      ɵɵadvance();
      ɵɵproperty("ngClass", ctx.controlClass());
      ɵɵadvance(3);
      ɵɵproperty("ngIf", ctx.showInvalid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showValid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showHelper);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showInvalid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showValid);
    }
  },
  dependencies: [NgClass, NgIf, CdsIconCustomTag, ClrLabel],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrControlContainer, [{
    type: Component,
    args: [{
      selector: "clr-control-container",
      template: `
    <ng-content select="label"></ng-content>
    <label *ngIf="!label && addGrid()"></label>
    <div class="clr-control-container" [ngClass]="controlClass()">
      <div class="clr-input-wrapper">
        <ng-content></ng-content>
        <cds-icon
          *ngIf="showInvalid"
          class="clr-validate-icon"
          shape="exclamation-circle"
          status="danger"
          aria-hidden="true"
        ></cds-icon>
        <cds-icon
          *ngIf="showValid"
          class="clr-validate-icon"
          shape="check-circle"
          status="success"
          aria-hidden="true"
        ></cds-icon>
      </div>
      <ng-content select="clr-control-helper" *ngIf="showHelper"></ng-content>
      <ng-content select="clr-control-error" *ngIf="showInvalid"></ng-content>
      <ng-content select="clr-control-success" *ngIf="showValid"></ng-content>
    </div>
  `,
      host: {
        "[class.clr-form-control]": "true",
        "[class.clr-form-control-disabled]": "control?.disabled",
        "[class.clr-row]": "addGrid()"
      },
      providers: [IfControlStateService, NgControlService, ControlIdService, ControlClassService]
    }]
  }], null, null);
})();
var HostWrapper = class {
  constructor(containerType, vcr, index = 0) {
    this.injector = vcr.injector;
    if (!this.injector.get(containerType, null)) {
      const cfr = this.injector.get(ComponentFactoryResolver$1);
      const el = this.injector.get(ElementRef);
      vcr.createComponent(cfr.resolveComponentFactory(EmptyAnchor));
      const factory = cfr.resolveComponentFactory(containerType);
      const element = [];
      element[index] = [el.nativeElement];
      const containerRef = vcr.createComponent(factory, void 0, void 0, element);
      vcr.remove(0);
      containerRef.instance._dynamic = true;
      this.injector = containerRef.injector;
    }
  }
  get(token, notFoundValue) {
    return this.injector.get(token, notFoundValue);
  }
};
var MarkControlService = class {
  constructor() {
    this._touched = new Subject();
  }
  get touchedChange() {
    return this._touched.asObservable();
  }
  markAsTouched() {
    this._touched.next();
  }
};
MarkControlService.ɵfac = function MarkControlService_Factory(t3) {
  return new (t3 || MarkControlService)();
};
MarkControlService.ɵprov = ɵɵdefineInjectable({
  token: MarkControlService,
  factory: MarkControlService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MarkControlService, [{
    type: Injectable
  }], null, null);
})();
var CHANGE_KEYS;
(function(CHANGE_KEYS2) {
  CHANGE_KEYS2["FORM"] = "form";
  CHANGE_KEYS2["MODEL"] = "model";
})(CHANGE_KEYS || (CHANGE_KEYS = {}));
var WrappedFormControl = class {
  // I lost way too much time trying to make this work without injecting the ViewContainerRef and the Injector,
  // I'm giving up. So we have to inject these two manually for now.
  constructor(vcr, wrapperType, injector, ngControl, renderer, el) {
    this.vcr = vcr;
    this.wrapperType = wrapperType;
    this.ngControl = ngControl;
    this.index = 0;
    this.subscriptions = [];
    this.renderer = renderer;
    this.el = el;
    if (injector) {
      this.ngControlService = injector.get(NgControlService, null);
      this.ifControlStateService = injector.get(IfControlStateService, null);
      this.controlClassService = injector.get(ControlClassService, null);
      this.markControlService = injector.get(MarkControlService, null);
      this.differs = injector.get(KeyValueDiffers, null);
    }
    if (this.controlClassService) {
      this.controlClassService.initControlClass(renderer, el.nativeElement);
    }
    if (this.markControlService) {
      this.subscriptions.push(this.markControlService.touchedChange.subscribe(() => {
        this.markAsTouched();
      }));
    }
    if (this.ngControlService) {
      this.subscriptions.push(this.ngControlService.helpersChange.subscribe((state2) => {
        this.setAriaDescribedBy(state2);
      }));
    }
    if (ngControl) {
      this.differ = this.differs.find(ngControl).create();
    }
  }
  get id() {
    return this._id;
  }
  set id(value) {
    this._id = value;
    if (this.controlIdService) {
      this.controlIdService.id = value;
    }
  }
  ngOnInit() {
    this._containerInjector = new HostWrapper(this.wrapperType, this.vcr, this.index);
    this.controlIdService = this._containerInjector.get(ControlIdService);
    this.containerIdService = this._containerInjector.get(ContainerIdService, null);
    if (this._id) {
      this.controlIdService.id = this._id;
    } else {
      this._id = this.controlIdService.id;
    }
    if (this.ngControlService && this.ngControl) {
      this.ngControlService.setControl(this.ngControl);
    }
  }
  ngDoCheck() {
    if (this.differ) {
      const changes = this.differ.diff(this.ngControl);
      if (changes) {
        changes.forEachChangedItem((change) => {
          if ((change.key === CHANGE_KEYS.FORM || change.key === CHANGE_KEYS.MODEL) && change.currentValue !== change.previousValue) {
            this.triggerValidation();
          }
        });
      }
    }
  }
  ngOnDestroy() {
    this.subscriptions.forEach((sub) => sub.unsubscribe());
  }
  triggerValidation() {
    if (this.ifControlStateService) {
      this.ifControlStateService.triggerStatusChange();
    }
  }
  // @TODO This method has a try/catch due to an unknown issue that came when building the clrToggle feature
  // We need to figure out why this fails for the ClrToggle scenario but works for Date picker...
  // To see the error, remove the try/catch here and run the ClrToggle suite to see issues getting the container
  // injector in time, and this ONLY HAPPENS in tests and not in dev/prod mode.
  getProviderFromContainer(token, notFoundValue) {
    try {
      return this._containerInjector.get(token, notFoundValue);
    } catch (e5) {
      return notFoundValue;
    }
  }
  markAsTouched() {
    if (this.ngControl) {
      this.ngControl.control.markAsTouched();
      this.ngControl.control.updateValueAndValidity();
    }
  }
  setAriaDescribedBy(helpers) {
    if (helpers.show) {
      const ariaDescribedBy = this.getAriaDescribedById(helpers);
      if (ariaDescribedBy !== null) {
        this.renderer.setAttribute(this.el.nativeElement, "aria-describedby", ariaDescribedBy);
        return;
      }
    }
    this.renderer.removeAttribute(this.el.nativeElement, "aria-describedby");
  }
  getAriaDescribedById(helpers) {
    const elementId = this.containerIdService?.id || this.controlIdService?.id;
    if (!elementId) {
      return null;
    }
    const describedByIds = [`${elementId}-${CONTROL_SUFFIX.HELPER}`];
    if (helpers.showInvalid) {
      describedByIds.push(`${elementId}-${CONTROL_SUFFIX.ERROR}`);
    } else if (helpers.showValid) {
      describedByIds.push(`${elementId}-${CONTROL_SUFFIX.SUCCESS}`);
    }
    return describedByIds.join(" ");
  }
};
WrappedFormControl.ɵfac = function WrappedFormControl_Factory(t3) {
  return new (t3 || WrappedFormControl)(ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(Type), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(NgControl), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef));
};
WrappedFormControl.ɵdir = ɵɵdefineDirective({
  type: WrappedFormControl,
  hostVars: 1,
  hostBindings: function WrappedFormControl_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("blur", function WrappedFormControl_blur_HostBindingHandler() {
        return ctx.triggerValidation();
      });
    }
    if (rf & 2) {
      ɵɵhostProperty("id", ctx.id);
    }
  },
  inputs: {
    id: "id"
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(WrappedFormControl, [{
    type: Directive
  }], function() {
    return [{
      type: ViewContainerRef
    }, {
      type: Type
    }, {
      type: Injector
    }, {
      type: NgControl
    }, {
      type: Renderer2
    }, {
      type: ElementRef
    }];
  }, {
    id: [{
      type: Input
    }, {
      type: HostBinding
    }],
    triggerValidation: [{
      type: HostListener,
      args: ["blur"]
    }]
  });
})();
var ClrControl = class extends WrappedFormControl {
  constructor(vcr, injector, control, renderer, el) {
    super(vcr, ClrControlContainer, injector, control, renderer, el);
    this.index = 1;
  }
};
ClrControl.ɵfac = function ClrControl_Factory(t3) {
  return new (t3 || ClrControl)(ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(NgControl, 10), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef));
};
ClrControl.ɵdir = ɵɵdefineDirective({
  type: ClrControl,
  selectors: [["", "clrControl", ""]],
  hostVars: 2,
  hostBindings: function ClrControl_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("clr-input", true);
    }
  },
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrControl, [{
    type: Directive,
    args: [{
      selector: "[clrControl]",
      host: {
        "[class.clr-input]": "true"
      }
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }, {
      type: Injector
    }, {
      type: NgControl,
      decorators: [{
        type: Self
      }, {
        type: Optional
      }]
    }, {
      type: Renderer2
    }, {
      type: ElementRef
    }];
  }, null);
})();
var ClrForm = class {
  constructor(layoutService, markControlService) {
    this.layoutService = layoutService;
    this.markControlService = markControlService;
  }
  set labelSize(size) {
    const sizeNumber = parseInt(size, 10) || 2;
    this.layoutService.labelSize = sizeNumber;
  }
  onFormSubmit() {
    this.markAsTouched();
  }
  // Trying to avoid adding an input and keep this backwards compatible at the same time
  markAsTouched() {
    this.markControlService.markAsTouched();
  }
};
ClrForm.ɵfac = function ClrForm_Factory(t3) {
  return new (t3 || ClrForm)(ɵɵdirectiveInject(LayoutService), ɵɵdirectiveInject(MarkControlService));
};
ClrForm.ɵdir = ɵɵdefineDirective({
  type: ClrForm,
  selectors: [["", "clrForm", ""]],
  contentQueries: function ClrForm_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ClrLabel, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.labels = _t);
    }
  },
  hostVars: 6,
  hostBindings: function ClrForm_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("submit", function ClrForm_submit_HostBindingHandler() {
        return ctx.onFormSubmit();
      });
    }
    if (rf & 2) {
      ɵɵclassProp("clr-form", true)("clr-form-horizontal", ctx.layoutService.isHorizontal())("clr-form-compact", ctx.layoutService.isCompact());
    }
  },
  inputs: {
    labelSize: [InputFlags.None, "clrLabelSize", "labelSize"]
  },
  features: [ɵɵProvidersFeature([LayoutService, MarkControlService])]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrForm, [{
    type: Directive,
    args: [{
      selector: "[clrForm]",
      providers: [LayoutService, MarkControlService],
      host: {
        "[class.clr-form]": "true",
        "[class.clr-form-horizontal]": "layoutService.isHorizontal()",
        "[class.clr-form-compact]": "layoutService.isCompact()"
      }
    }]
  }], function() {
    return [{
      type: LayoutService
    }, {
      type: MarkControlService
    }];
  }, {
    labels: [{
      type: ContentChildren,
      args: [ClrLabel, {
        descendants: true
      }]
    }],
    labelSize: [{
      type: Input,
      args: ["clrLabelSize"]
    }],
    onFormSubmit: [{
      type: HostListener,
      args: ["submit"]
    }]
  });
})();
var AbstractIfState = class {
  constructor(ifControlStateService, ngControlService) {
    this.ifControlStateService = ifControlStateService;
    this.ngControlService = ngControlService;
    this.subscriptions = [];
    this.displayedContent = false;
    if (ngControlService) {
      this.subscriptions.push(this.ngControlService.controlChanges.subscribe((control) => {
        this.control = control;
      }));
    }
    if (ifControlStateService) {
      this.subscriptions.push(this.ifControlStateService.statusChanges.subscribe((state2) => {
        this.handleState(state2);
      }));
    }
  }
  ngOnDestroy() {
    this.subscriptions.forEach((sub) => sub.unsubscribe());
  }
  handleState(_state) {
  }
};
AbstractIfState.ɵfac = function AbstractIfState_Factory(t3) {
  return new (t3 || AbstractIfState)(ɵɵdirectiveInject(IfControlStateService, 8), ɵɵdirectiveInject(NgControlService, 8));
};
AbstractIfState.ɵdir = ɵɵdefineDirective({
  type: AbstractIfState
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AbstractIfState, [{
    type: Directive
  }], function() {
    return [{
      type: IfControlStateService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: NgControlService,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var ClrIfError = class extends AbstractIfState {
  constructor(ifControlStateService, ngControlService, template, container) {
    super(ifControlStateService, ngControlService);
    this.template = template;
    this.container = container;
    if (!this.ifControlStateService) {
      throw new Error("clrIfError can only be used within a form control container element like clr-input-container");
    }
  }
  /**
   * @param state CONTROL_STATE
   */
  handleState(state2) {
    if (this.error && this.control) {
      this.displayError(this.control.hasError(this.error));
    } else {
      this.displayError(CONTROL_STATE.INVALID === state2);
    }
  }
  displayError(invalid) {
    if (!this.container) {
      return;
    }
    if (invalid) {
      if (this.displayedContent === false) {
        this.embeddedViewRef = this.container.createEmbeddedView(this.template, {
          error: this.control.getError(this.error)
        });
        this.displayedContent = true;
      } else if (this.embeddedViewRef && this.embeddedViewRef.context) {
        this.embeddedViewRef.context.error = this.control.getError(this.error);
      }
    } else {
      this.container.clear();
      this.displayedContent = false;
    }
  }
};
ClrIfError.ɵfac = function ClrIfError_Factory(t3) {
  return new (t3 || ClrIfError)(ɵɵdirectiveInject(IfControlStateService, 8), ɵɵdirectiveInject(NgControlService, 8), ɵɵdirectiveInject(TemplateRef), ɵɵdirectiveInject(ViewContainerRef));
};
ClrIfError.ɵdir = ɵɵdefineDirective({
  type: ClrIfError,
  selectors: [["", "clrIfError", ""]],
  inputs: {
    error: [InputFlags.None, "clrIfError", "error"]
  },
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrIfError, [{
    type: Directive,
    args: [{
      selector: "[clrIfError]"
    }]
  }], function() {
    return [{
      type: IfControlStateService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: NgControlService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: TemplateRef
    }, {
      type: ViewContainerRef
    }];
  }, {
    error: [{
      type: Input,
      args: ["clrIfError"]
    }]
  });
})();
var ClrIfSuccess = class extends AbstractIfState {
  constructor(ifControlStateService, ngControlService, template, container) {
    super(ifControlStateService, ngControlService);
    this.template = template;
    this.container = container;
    if (!ifControlStateService) {
      throw new Error("ClrIfSuccess can only be used within a form control container element like clr-input-container");
    }
  }
  /**
   * @param state CONTROL_STATE
   */
  handleState(state2) {
    const isValid = CONTROL_STATE.VALID === state2;
    if (isValid && !this.displayedContent) {
      this.container.createEmbeddedView(this.template);
    } else if (!isValid && this.container) {
      this.container.clear();
    }
    this.displayedContent = isValid;
  }
};
ClrIfSuccess.ɵfac = function ClrIfSuccess_Factory(t3) {
  return new (t3 || ClrIfSuccess)(ɵɵdirectiveInject(IfControlStateService, 8), ɵɵdirectiveInject(NgControlService, 8), ɵɵdirectiveInject(TemplateRef), ɵɵdirectiveInject(ViewContainerRef));
};
ClrIfSuccess.ɵdir = ɵɵdefineDirective({
  type: ClrIfSuccess,
  selectors: [["", "clrIfSuccess", ""]],
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrIfSuccess, [{
    type: Directive,
    args: [{
      selector: "[clrIfSuccess]"
    }]
  }], function() {
    return [{
      type: IfControlStateService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: NgControlService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: TemplateRef
    }, {
      type: ViewContainerRef
    }];
  }, null);
})();
var ClrLayout = class {
  constructor(layoutService) {
    this.layoutService = layoutService;
  }
  ngOnInit() {
    if (this.layout && this.layoutService.isValid(this.layout)) {
      this.layoutService.layout = this.layout;
    }
  }
};
ClrLayout.ɵfac = function ClrLayout_Factory(t3) {
  return new (t3 || ClrLayout)(ɵɵdirectiveInject(LayoutService));
};
ClrLayout.ɵdir = ɵɵdefineDirective({
  type: ClrLayout,
  selectors: [["", "clrForm", "", "clrLayout", ""]],
  inputs: {
    layout: [InputFlags.None, "clrLayout", "layout"]
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrLayout, [{
    type: Directive,
    args: [{
      selector: "[clrForm][clrLayout]"
    }]
  }], function() {
    return [{
      type: LayoutService
    }];
  }, {
    layout: [{
      type: Input,
      args: ["clrLayout"]
    }]
  });
})();
var ClrCommonFormsModule = class {
  constructor() {
    r.addIcons(e3, l);
  }
};
ClrCommonFormsModule.ɵfac = function ClrCommonFormsModule_Factory(t3) {
  return new (t3 || ClrCommonFormsModule)();
};
ClrCommonFormsModule.ɵmod = ɵɵdefineNgModule({
  type: ClrCommonFormsModule,
  declarations: [ClrLabel, ClrControlError, ClrControlSuccess, ClrControlHelper, ClrIfError, ClrIfSuccess, ClrForm, ClrLayout, ClrControlContainer, ClrControl],
  imports: [CommonModule, ClrIconModule],
  exports: [ClrLabel, ClrControlError, ClrControlSuccess, ClrControlHelper, ClrIfError, ClrIfSuccess, ClrForm, ClrLayout, ClrControlContainer, ClrControl]
});
ClrCommonFormsModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, ClrIconModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrCommonFormsModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, ClrIconModule],
      declarations: [ClrLabel, ClrControlError, ClrControlSuccess, ClrControlHelper, ClrIfError, ClrIfSuccess, ClrForm, ClrLayout, ClrControlContainer, ClrControl],
      exports: [ClrLabel, ClrControlError, ClrControlSuccess, ClrControlHelper, ClrIfError, ClrIfSuccess, ClrForm, ClrLayout, ClrControlContainer, ClrControl]
    }]
  }], function() {
    return [];
  }, null);
})();
var IS_TOGGLE = new InjectionToken("IS_TOGGLE");
function isToggleFactory() {
  return new BehaviorSubject(false);
}
var IS_TOGGLE_PROVIDER = {
  provide: IS_TOGGLE,
  useFactory: isToggleFactory
};
var ClrCheckboxWrapper = class {
  constructor(toggleService) {
    this._dynamic = false;
    this.toggle = false;
    this.subscriptions = [];
    this.subscriptions.push(toggleService.subscribe((state2) => {
      this.toggle = state2;
    }));
  }
  ngOnInit() {
    if (this.label) {
      this.label.disableGrid();
    }
  }
  ngOnDestroy() {
    this.subscriptions.forEach((sub) => sub.unsubscribe());
  }
};
ClrCheckboxWrapper.ɵfac = function ClrCheckboxWrapper_Factory(t3) {
  return new (t3 || ClrCheckboxWrapper)(ɵɵdirectiveInject(IS_TOGGLE));
};
ClrCheckboxWrapper.ɵcmp = ɵɵdefineComponent({
  type: ClrCheckboxWrapper,
  selectors: [["clr-checkbox-wrapper"], ["clr-toggle-wrapper"]],
  contentQueries: function ClrCheckboxWrapper_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ClrLabel, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.label = _t.first);
    }
  },
  hostVars: 4,
  hostBindings: function ClrCheckboxWrapper_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("clr-checkbox-wrapper", !ctx.toggle)("clr-toggle-wrapper", ctx.toggle);
    }
  },
  features: [ɵɵProvidersFeature([ControlIdService, IS_TOGGLE_PROVIDER])],
  ngContentSelectors: _c122,
  decls: 3,
  vars: 1,
  consts: [[4, "ngIf"]],
  template: function ClrCheckboxWrapper_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c11);
      ɵɵprojection(0);
      ɵɵprojection(1, 1);
      ɵɵtemplate(2, ClrCheckboxWrapper_label_2_Template, 1, 0, "label", 0);
    }
    if (rf & 2) {
      ɵɵadvance(2);
      ɵɵproperty("ngIf", !ctx.label);
    }
  },
  dependencies: [NgIf, ClrLabel],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrCheckboxWrapper, [{
    type: Component,
    args: [{
      selector: "clr-checkbox-wrapper,clr-toggle-wrapper",
      template: `
    <ng-content select="[clrCheckbox],[clrToggle]"></ng-content>
    <ng-content select="label"></ng-content>
    <label *ngIf="!label"></label>
  `,
      host: {
        "[class.clr-checkbox-wrapper]": "!toggle",
        "[class.clr-toggle-wrapper]": "toggle"
      },
      providers: [ControlIdService, IS_TOGGLE_PROVIDER]
    }]
  }], function() {
    return [{
      type: BehaviorSubject,
      decorators: [{
        type: Inject,
        args: [IS_TOGGLE]
      }]
    }];
  }, {
    label: [{
      type: ContentChild,
      args: [ClrLabel, {
        static: true
      }]
    }]
  });
})();
var ClrCheckbox = class extends WrappedFormControl {
  constructor(vcr, injector, control, renderer, el, toggle) {
    super(vcr, ClrCheckboxWrapper, injector, control, renderer, el);
    this.toggle = toggle;
  }
  ngOnInit() {
    super.ngOnInit();
    const toggleService = this.getProviderFromContainer(IS_TOGGLE, null);
    if (toggleService && this.toggle !== null) {
      toggleService.next(true);
    }
  }
};
ClrCheckbox.ɵfac = function ClrCheckbox_Factory(t3) {
  return new (t3 || ClrCheckbox)(ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(NgControl, 10), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵinjectAttribute("clrToggle"));
};
ClrCheckbox.ɵdir = ɵɵdefineDirective({
  type: ClrCheckbox,
  selectors: [["", "clrCheckbox", ""], ["", "clrToggle", ""]],
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrCheckbox, [{
    type: Directive,
    args: [{
      selector: "[clrCheckbox],[clrToggle]"
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }, {
      type: Injector
    }, {
      type: NgControl,
      decorators: [{
        type: Self
      }, {
        type: Optional
      }]
    }, {
      type: Renderer2
    }, {
      type: ElementRef
    }, {
      type: void 0,
      decorators: [{
        type: Attribute,
        args: ["clrToggle"]
      }]
    }];
  }, null);
})();
var ClrCheckboxContainer = class extends ClrAbstractContainer {
  constructor(layoutService, controlClassService, ngControlService, ifControlStateService) {
    super(ifControlStateService, layoutService, controlClassService, ngControlService);
    this.layoutService = layoutService;
    this.controlClassService = controlClassService;
    this.ngControlService = ngControlService;
    this.ifControlStateService = ifControlStateService;
    this.inline = false;
  }
  /*
   * Here we want to support the following cases
   * clrInline - true by presence
   * clrInline="true|false" - unless it is explicitly false, strings are considered true
   * [clrInline]="true|false" - expect a boolean
   */
  get clrInline() {
    return this.inline;
  }
  set clrInline(value) {
    if (typeof value === "string") {
      this.inline = value === "false" ? false : true;
    } else {
      this.inline = !!value;
    }
  }
  ngAfterContentInit() {
    this.setAriaRoles();
  }
  setAriaRoles() {
    this.role = this.checkboxes.length ? "group" : null;
  }
};
ClrCheckboxContainer.ɵfac = function ClrCheckboxContainer_Factory(t3) {
  return new (t3 || ClrCheckboxContainer)(ɵɵdirectiveInject(LayoutService, 8), ɵɵdirectiveInject(ControlClassService), ɵɵdirectiveInject(NgControlService), ɵɵdirectiveInject(IfControlStateService));
};
ClrCheckboxContainer.ɵcmp = ɵɵdefineComponent({
  type: ClrCheckboxContainer,
  selectors: [["clr-checkbox-container"], ["clr-toggle-container"]],
  contentQueries: function ClrCheckboxContainer_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ClrCheckbox, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.checkboxes = _t);
    }
  },
  hostVars: 7,
  hostBindings: function ClrCheckboxContainer_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("role", ctx.role);
      ɵɵclassProp("clr-form-control", true)("clr-form-control-disabled", ctx.control == null ? null : ctx.control.disabled)("clr-row", ctx.addGrid());
    }
  },
  inputs: {
    clrInline: "clrInline"
  },
  features: [ɵɵProvidersFeature([IfControlStateService, NgControlService, ControlClassService, ContainerIdService]), ɵɵInheritDefinitionFeature],
  ngContentSelectors: _c14,
  decls: 10,
  vars: 9,
  consts: [[4, "ngIf"], [1, "clr-control-container", 3, "ngClass"], [1, "clr-subtext-wrapper"], ["class", "clr-validate-icon", "shape", "exclamation-circle", "status", "danger", "aria-hidden", "true", 4, "ngIf"], ["class", "clr-validate-icon", "shape", "check-circle", "status", "success", "aria-hidden", "true", 4, "ngIf"], ["shape", "exclamation-circle", "status", "danger", "aria-hidden", "true", 1, "clr-validate-icon"], ["shape", "check-circle", "status", "success", "aria-hidden", "true", 1, "clr-validate-icon"]],
  template: function ClrCheckboxContainer_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c13);
      ɵɵprojection(0);
      ɵɵtemplate(1, ClrCheckboxContainer_label_1_Template, 1, 0, "label", 0);
      ɵɵelementStart(2, "div", 1);
      ɵɵprojection(3, 1);
      ɵɵelementStart(4, "div", 2);
      ɵɵtemplate(5, ClrCheckboxContainer_ng_content_5_Template, 1, 0, "ng-content", 0)(6, ClrCheckboxContainer_cds_icon_6_Template, 1, 0, "cds-icon", 3)(7, ClrCheckboxContainer_cds_icon_7_Template, 1, 0, "cds-icon", 4)(8, ClrCheckboxContainer_ng_content_8_Template, 1, 0, "ng-content", 0)(9, ClrCheckboxContainer_ng_content_9_Template, 1, 0, "ng-content", 0);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.label && ctx.addGrid());
      ɵɵadvance();
      ɵɵclassProp("clr-control-inline", ctx.clrInline);
      ɵɵproperty("ngClass", ctx.controlClass());
      ɵɵadvance(3);
      ɵɵproperty("ngIf", ctx.showHelper);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showInvalid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showValid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showInvalid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showValid);
    }
  },
  dependencies: [NgClass, NgIf, CdsIconCustomTag, ClrLabel],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrCheckboxContainer, [{
    type: Component,
    args: [{
      selector: "clr-checkbox-container,clr-toggle-container",
      template: `
    <ng-content select="label"></ng-content>
    <label *ngIf="!label && addGrid()"></label>
    <div class="clr-control-container" [class.clr-control-inline]="clrInline" [ngClass]="controlClass()">
      <ng-content select="clr-checkbox-wrapper,clr-toggle-wrapper"></ng-content>
      <div class="clr-subtext-wrapper">
        <ng-content select="clr-control-helper" *ngIf="showHelper"></ng-content>
        <cds-icon
          *ngIf="showInvalid"
          class="clr-validate-icon"
          shape="exclamation-circle"
          status="danger"
          aria-hidden="true"
        ></cds-icon>
        <cds-icon
          *ngIf="showValid"
          class="clr-validate-icon"
          shape="check-circle"
          status="success"
          aria-hidden="true"
        ></cds-icon>
        <ng-content select="clr-control-error" *ngIf="showInvalid"></ng-content>
        <ng-content select="clr-control-success" *ngIf="showValid"></ng-content>
      </div>
    </div>
  `,
      host: {
        "[class.clr-form-control]": "true",
        "[class.clr-form-control-disabled]": "control?.disabled",
        "[class.clr-row]": "addGrid()",
        "[attr.role]": "role"
      },
      providers: [IfControlStateService, NgControlService, ControlClassService, ContainerIdService]
    }]
  }], function() {
    return [{
      type: LayoutService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: ControlClassService
    }, {
      type: NgControlService
    }, {
      type: IfControlStateService
    }];
  }, {
    checkboxes: [{
      type: ContentChildren,
      args: [ClrCheckbox, {
        descendants: true
      }]
    }],
    clrInline: [{
      type: Input
    }]
  });
})();
var ClrCheckboxModule = class {
  constructor() {
    r.addIcons(e3, l);
  }
};
ClrCheckboxModule.ɵfac = function ClrCheckboxModule_Factory(t3) {
  return new (t3 || ClrCheckboxModule)();
};
ClrCheckboxModule.ɵmod = ɵɵdefineNgModule({
  type: ClrCheckboxModule,
  declarations: [ClrCheckbox, ClrCheckboxContainer, ClrCheckboxWrapper],
  imports: [CommonModule, ClrIconModule, ClrCommonFormsModule, ClrHostWrappingModule],
  exports: [ClrCommonFormsModule, ClrCheckbox, ClrCheckboxContainer, ClrCheckboxWrapper]
});
ClrCheckboxModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, ClrIconModule, ClrCommonFormsModule, ClrHostWrappingModule, ClrCommonFormsModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrCheckboxModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, ClrIconModule, ClrCommonFormsModule, ClrHostWrappingModule],
      declarations: [ClrCheckbox, ClrCheckboxContainer, ClrCheckboxWrapper],
      exports: [ClrCommonFormsModule, ClrCheckbox, ClrCheckboxContainer, ClrCheckboxWrapper]
    }]
  }], function() {
    return [];
  }, null);
})();
function isBooleanAttributeSet(value) {
  if (value === null) {
    return false;
  }
  if (typeof value === "string") {
    return value.length >= 0;
  }
  return typeof value === "boolean" ? value : false;
}
var ClrSpinner = class {
  /**
   * Default class for all spinners. This class is always true
   */
  get spinnerClass() {
    return true;
  }
  get inlineClass() {
    return this._inline;
  }
  set clrInline(value) {
    this._inline = isBooleanAttributeSet(value);
  }
  get inverseClass() {
    return this._inverse;
  }
  set clrInverse(value) {
    this._inverse = isBooleanAttributeSet(value);
  }
  get smallClass() {
    return this._small;
  }
  set clrSmall(value) {
    this._small = isBooleanAttributeSet(value);
  }
  /**
   * When clrSmall & clrMedium are set both to true.
   * The CSS with high priority will be small - so medium size will be ignored.
   *
   * For this reason if clrSmall is set we won't add clrMedium class.
   *
   * NOTE: This is dictated by the CSS rules.
   * DON'T USE clrSmall & clrMedium to toggle classes. This could change without notice.
   *
   * Also there is no logical need to have both of them set to TRUE or FALSE.
   */
  get mediumClass() {
    if (this._small) {
      return false;
    }
    return this._medium;
  }
  set clrMedium(value) {
    this._medium = isBooleanAttributeSet(value);
  }
};
ClrSpinner.ɵfac = function ClrSpinner_Factory(t3) {
  return new (t3 || ClrSpinner)();
};
ClrSpinner.ɵcmp = ɵɵdefineComponent({
  type: ClrSpinner,
  selectors: [["clr-spinner"]],
  hostVars: 11,
  hostBindings: function ClrSpinner_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("aria-busy", true);
      ɵɵclassProp("spinner", ctx.spinnerClass)("spinner-inline", ctx.inlineClass)("spinner-inverse", ctx.inverseClass)("spinner-sm", ctx.smallClass)("spinner-md", ctx.mediumClass);
    }
  },
  inputs: {
    clrInline: "clrInline",
    clrInverse: "clrInverse",
    clrSmall: "clrSmall",
    clrMedium: "clrMedium"
  },
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function ClrSpinner_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrSpinner, [{
    type: Component,
    args: [{
      selector: "clr-spinner",
      template: `<ng-content></ng-content>`,
      host: {
        "[attr.aria-busy]": "true"
      }
    }]
  }], null, {
    spinnerClass: [{
      type: HostBinding,
      args: ["class.spinner"]
    }],
    inlineClass: [{
      type: HostBinding,
      args: ["class.spinner-inline"]
    }],
    clrInline: [{
      type: Input,
      args: ["clrInline"]
    }],
    inverseClass: [{
      type: HostBinding,
      args: ["class.spinner-inverse"]
    }],
    clrInverse: [{
      type: Input,
      args: ["clrInverse"]
    }],
    smallClass: [{
      type: HostBinding,
      args: ["class.spinner-sm"]
    }],
    clrSmall: [{
      type: Input,
      args: ["clrSmall"]
    }],
    mediumClass: [{
      type: HostBinding,
      args: ["class.spinner-md"]
    }],
    clrMedium: [{
      type: Input,
      args: ["clrMedium"]
    }]
  });
})();
var CLR_SPINNER_DIRECTIVES = [ClrSpinner];
var ClrSpinnerModule = class {
};
ClrSpinnerModule.ɵfac = function ClrSpinnerModule_Factory(t3) {
  return new (t3 || ClrSpinnerModule)();
};
ClrSpinnerModule.ɵmod = ɵɵdefineNgModule({
  type: ClrSpinnerModule,
  declarations: [ClrSpinner],
  imports: [CommonModule],
  exports: [ClrSpinner]
});
ClrSpinnerModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrSpinnerModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      declarations: [CLR_SPINNER_DIRECTIVES],
      exports: [CLR_SPINNER_DIRECTIVES]
    }]
  }], null, null);
})();
var ClrFocusDirection;
(function(ClrFocusDirection2) {
  ClrFocusDirection2["VERTICAL"] = "vertical";
  ClrFocusDirection2["HORIZONTAL"] = "horizontal";
  ClrFocusDirection2["BOTH"] = "both";
})(ClrFocusDirection || (ClrFocusDirection = {}));
var ClrKeyFocusItem = class {
  constructor(elementRef, platformId) {
    this.elementRef = elementRef;
    this.platformId = platformId;
  }
  get nativeElement() {
    return this.elementRef.nativeElement;
  }
  focus() {
    if (isPlatformBrowser(this.platformId)) {
      this.elementRef.nativeElement.focus();
    }
  }
};
ClrKeyFocusItem.ɵfac = function ClrKeyFocusItem_Factory(t3) {
  return new (t3 || ClrKeyFocusItem)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(PLATFORM_ID));
};
ClrKeyFocusItem.ɵdir = ɵɵdefineDirective({
  type: ClrKeyFocusItem,
  selectors: [["", "clrKeyFocusItem", ""]]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrKeyFocusItem, [{
    type: Directive,
    args: [{
      selector: "[clrKeyFocusItem]"
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [PLATFORM_ID]
      }]
    }];
  }, null);
})();
var ClrKeyFocus = class {
  constructor(elementRef) {
    this.elementRef = elementRef;
    this.direction = ClrFocusDirection.VERTICAL;
    this.focusOnLoad = false;
    this.subscriptions = [];
    this.focusChange = new EventEmitter();
    this._current = 0;
  }
  /**
   * Here we use `any` cause any other type require reworking all methods below and a lot of more ifs.
   * this method will only work with array with FocusableItems anyway so any other value will be ignored.
   */
  get focusableItems() {
    if (this._focusableItems) {
      return this._focusableItems;
    } else if (this.clrKeyFocusItems) {
      return this.clrKeyFocusItems.toArray();
    }
    return [];
  }
  set focusableItems(elements) {
    if (Array.isArray(elements) && elements.length) {
      this._focusableItems = elements;
      this.initializeFocus();
    }
  }
  get nativeElement() {
    return this.elementRef.nativeElement;
  }
  get current() {
    return this._current;
  }
  set current(value) {
    if (this._current !== value) {
      this._current = value;
    }
  }
  get currentItem() {
    return this.focusableItems[this._current];
  }
  get currentItemElement() {
    return this.currentItem.nativeElement ? this.currentItem.nativeElement : this.currentItem;
  }
  ngAfterContentInit() {
    this.subscriptions.push(this.listenForItemUpdates());
    this.initializeFocus();
  }
  ngOnDestroy() {
    this.subscriptions.forEach((s2) => s2.unsubscribe());
  }
  handleKeyboardEvent(event) {
    if (this.currentItemElement !== event.target) {
      const position = this.getItemPosition(event.target);
      if (this.positionInRange(position)) {
        this.current = position;
      }
    }
    if (this.prevKeyPressed(event) && this.currentFocusIsNotFirstItem()) {
      this.moveTo(this.current - 1);
    } else if (this.nextKeyPressed(event) && this.currentFocusIsNotLastItem()) {
      this.moveTo(this.current + 1);
    } else if (event.code === Keys.Home) {
      this.moveTo(0);
    } else if (event.code === Keys.End) {
      this.moveTo(this.focusableItems.length - 1);
    }
    preventArrowKeyScroll(event);
  }
  setClickedItemCurrent(event) {
    const position = this.getItemPosition(event.target);
    if (position > -1) {
      this.moveTo(position);
    }
  }
  focusCurrent() {
    this.currentItem.focus();
    this.focusChange.next(this._current);
  }
  moveTo(position) {
    if (this.positionInRange(position)) {
      this.current = position;
      this.focusCurrent();
    }
  }
  positionInRange(position) {
    return position >= 0 && position < this.focusableItems.length;
  }
  currentFocusIsNotFirstItem() {
    return this._current - 1 >= 0;
  }
  currentFocusIsNotLastItem() {
    return this._current + 1 < this.focusableItems.length;
  }
  initializeFocus() {
    if (this.focusableItems && this.focusableItems.length) {
      if (this._current >= this.focusableItems.length) {
        this._current = this.focusableItems.length - 1;
      }
      if (this.focusOnLoad) {
        this.currentItem.focus();
        this.focusChange.emit();
      }
    }
  }
  nextKeyPressed(event) {
    const key = normalizeKey(event.key);
    switch (this.direction) {
      case ClrFocusDirection.VERTICAL:
        return key === Keys.ArrowDown;
      case ClrFocusDirection.HORIZONTAL:
        return key === Keys.ArrowRight;
      case ClrFocusDirection.BOTH:
        return key === Keys.ArrowDown || key === Keys.ArrowRight;
      default:
        return false;
    }
  }
  prevKeyPressed(event) {
    const key = normalizeKey(event.key);
    switch (this.direction) {
      case ClrFocusDirection.VERTICAL:
        return key === Keys.ArrowUp;
      case ClrFocusDirection.HORIZONTAL:
        return key === Keys.ArrowLeft;
      case ClrFocusDirection.BOTH:
        return key === Keys.ArrowUp || key === Keys.ArrowLeft;
      default:
        return false;
    }
  }
  getItemPosition(item) {
    if (this._focusableItems) {
      return this.focusableItems.indexOf(item);
    } else {
      return this.focusableItems.map((_item) => _item.nativeElement).indexOf(item);
    }
  }
  listenForItemUpdates() {
    return this.clrKeyFocusItems.changes.subscribe(() => {
      this.initializeFocus();
    });
  }
};
ClrKeyFocus.ɵfac = function ClrKeyFocus_Factory(t3) {
  return new (t3 || ClrKeyFocus)(ɵɵdirectiveInject(ElementRef));
};
ClrKeyFocus.ɵcmp = ɵɵdefineComponent({
  type: ClrKeyFocus,
  selectors: [["", "clrKeyFocus", ""]],
  contentQueries: function ClrKeyFocus_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ClrKeyFocusItem, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.clrKeyFocusItems = _t);
    }
  },
  hostBindings: function ClrKeyFocus_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("keydown", function ClrKeyFocus_keydown_HostBindingHandler($event) {
        return ctx.handleKeyboardEvent($event);
      })("click", function ClrKeyFocus_click_HostBindingHandler($event) {
        return ctx.setClickedItemCurrent($event);
      });
    }
  },
  inputs: {
    direction: [InputFlags.None, "clrDirection", "direction"],
    focusOnLoad: [InputFlags.None, "clrFocusOnLoad", "focusOnLoad"],
    focusableItems: [InputFlags.None, "clrKeyFocus", "focusableItems"]
  },
  outputs: {
    focusChange: "clrFocusChange"
  },
  attrs: _c15,
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function ClrKeyFocus_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrKeyFocus, [{
    type: Component,
    args: [{
      selector: "[clrKeyFocus]",
      template: "<ng-content></ng-content>"
    }]
  }], function() {
    return [{
      type: ElementRef
    }];
  }, {
    direction: [{
      type: Input,
      args: ["clrDirection"]
    }],
    focusOnLoad: [{
      type: Input,
      args: ["clrFocusOnLoad"]
    }],
    clrKeyFocusItems: [{
      type: ContentChildren,
      args: [ClrKeyFocusItem, {
        descendants: true
      }]
    }],
    focusChange: [{
      type: Output,
      args: ["clrFocusChange"]
    }],
    focusableItems: [{
      type: Input,
      args: ["clrKeyFocus"]
    }],
    handleKeyboardEvent: [{
      type: HostListener,
      args: ["keydown", ["$event"]]
    }],
    setClickedItemCurrent: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }]
  });
})();
var ClrRovingTabindex = class extends ClrKeyFocus {
  constructor(elementRef, renderer) {
    super(elementRef);
    this.renderer = renderer;
    this.disabled = false;
  }
  // Proxy the input, as the selector name from parent class will still be "clrKeyFocus".
  get rovingIndexItems() {
    return this.focusableItems;
  }
  set rovingIndexItems(elements) {
    this.focusableItems = elements;
  }
  set rovingTabindexDisabled(disabled) {
    this.disabled = disabled;
    if (this.currentItem) {
      this.setTabindex(this.currentItem, disabled ? -1 : 0);
    }
  }
  handleKeyboardEvent(event) {
    if (this.prevKeyPressed(event) && this.currentFocusIsNotFirstItem()) {
      this.updateTabindex(this.current - 1);
    } else if (this.nextKeyPressed(event) && this.currentFocusIsNotLastItem()) {
      this.updateTabindex(this.current + 1);
    } else if (event.code === Keys.Home) {
      this.updateTabindex(0);
    } else if (event.code === Keys.End) {
      this.updateTabindex(this.focusableItems.length - 1);
    }
    super.handleKeyboardEvent(event);
  }
  setClickedItemCurrent(event) {
    let position;
    if (this.focusableItems[0].nativeElement) {
      position = this.focusableItems.map((item) => item.nativeElement).indexOf(event.target);
    } else {
      position = this.focusableItems.indexOf(event.target);
    }
    if (position > -1) {
      this.updateTabindex(position);
    }
    super.setClickedItemCurrent(event);
  }
  initializeFocus() {
    if (this.focusableItems && this.focusableItems.length) {
      this.focusableItems.forEach((item) => {
        this.setTabindex(item, -1);
      });
      if (this.current >= this.focusableItems.length) {
        this.current = this.focusableItems.length - 1;
      }
      if (!this.disabled && this.currentItem) {
        this.setTabindex(this.currentItem, 0);
      }
    }
    super.initializeFocus();
  }
  updateTabindex(newIndex) {
    this.setTabindex(this.currentItem, -1);
    this.setTabindex(this.focusableItems[newIndex], 0);
  }
  setTabindex(item, value) {
    if (item instanceof HTMLElement) {
      this.renderer.setAttribute(item, "tabindex", value.toString());
    } else {
      this.renderer.setAttribute(item.nativeElement, "tabindex", value.toString());
    }
  }
};
ClrRovingTabindex.ɵfac = function ClrRovingTabindex_Factory(t3) {
  return new (t3 || ClrRovingTabindex)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2));
};
ClrRovingTabindex.ɵcmp = ɵɵdefineComponent({
  type: ClrRovingTabindex,
  selectors: [["", "clrRovingTabindex", ""]],
  inputs: {
    rovingIndexItems: [InputFlags.None, "clrRovingTabindex", "rovingIndexItems"],
    rovingTabindexDisabled: [InputFlags.None, "clrRovingTabindexDisabled", "rovingTabindexDisabled"]
  },
  features: [ɵɵInheritDefinitionFeature],
  attrs: _c16,
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function ClrRovingTabindex_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrRovingTabindex, [{
    type: Component,
    args: [{
      selector: "[clrRovingTabindex]",
      template: "<ng-content></ng-content>"
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: Renderer2
    }];
  }, {
    rovingIndexItems: [{
      type: Input,
      args: ["clrRovingTabindex"]
    }],
    rovingTabindexDisabled: [{
      type: Input,
      args: ["clrRovingTabindexDisabled"]
    }]
  });
})();
var KEY_FOCUS_DIRECTIVES = [ClrKeyFocus, ClrRovingTabindex, ClrKeyFocusItem];
var ClrKeyFocusModule = class {
};
ClrKeyFocusModule.ɵfac = function ClrKeyFocusModule_Factory(t3) {
  return new (t3 || ClrKeyFocusModule)();
};
ClrKeyFocusModule.ɵmod = ɵɵdefineNgModule({
  type: ClrKeyFocusModule,
  declarations: [ClrKeyFocus, ClrRovingTabindex, ClrKeyFocusItem],
  imports: [CommonModule],
  exports: [ClrKeyFocus, ClrRovingTabindex, ClrKeyFocusItem]
});
ClrKeyFocusModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrKeyFocusModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      declarations: [KEY_FOCUS_DIRECTIVES],
      exports: [KEY_FOCUS_DIRECTIVES]
    }]
  }], null, null);
})();
var ComboboxContainerService = class {
  constructor() {
    this.labelOffset = 0;
  }
};
ComboboxContainerService.ɵfac = function ComboboxContainerService_Factory(t3) {
  return new (t3 || ComboboxContainerService)();
};
ComboboxContainerService.ɵprov = ɵɵdefineInjectable({
  token: ComboboxContainerService,
  factory: ComboboxContainerService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ComboboxContainerService, [{
    type: Injectable
  }], null, null);
})();
var ClrComboboxContainer = class extends ClrAbstractContainer {
  constructor(ifControlStateService, layoutService, controlClassService, ngControlService, containerService, el) {
    super(ifControlStateService, layoutService, controlClassService, ngControlService);
    this.containerService = containerService;
    this.el = el;
  }
  ngAfterContentInit() {
    if (this.label) {
      this.containerService.labelText = this.label.labelText;
    }
  }
  ngAfterViewInit() {
    this.containerService.labelOffset = this.controlContainer.nativeElement.offsetHeight - this.el.nativeElement.offsetHeight;
  }
};
ClrComboboxContainer.ɵfac = function ClrComboboxContainer_Factory(t3) {
  return new (t3 || ClrComboboxContainer)(ɵɵdirectiveInject(IfControlStateService), ɵɵdirectiveInject(LayoutService, 8), ɵɵdirectiveInject(ControlClassService), ɵɵdirectiveInject(NgControlService), ɵɵdirectiveInject(ComboboxContainerService), ɵɵdirectiveInject(ElementRef));
};
ClrComboboxContainer.ɵcmp = ɵɵdefineComponent({
  type: ClrComboboxContainer,
  selectors: [["clr-combobox-container"]],
  viewQuery: function ClrComboboxContainer_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c17, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.controlContainer = _t.first);
    }
  },
  hostVars: 8,
  hostBindings: function ClrComboboxContainer_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("clr-form-control", true)("clr-combobox-form-control", true)("clr-form-control-disabled", ctx.control == null ? null : ctx.control.disabled)("clr-row", ctx.addGrid());
    }
  },
  features: [ɵɵProvidersFeature([IfControlStateService, NgControlService, ControlIdService, ControlClassService, ComboboxContainerService]), ɵɵInheritDefinitionFeature],
  ngContentSelectors: _c19,
  decls: 10,
  vars: 7,
  consts: [["controlContainer", ""], [4, "ngIf"], [1, "clr-control-container", 3, "ngClass"], ["class", "clr-validate-icon", "shape", "exclamation-circle", "status", "danger", "aria-hidden", "true", 4, "ngIf"], ["class", "clr-validate-icon", "shape", "check-circle", "status", "success", "aria-hidden", "true", 4, "ngIf"], ["shape", "exclamation-circle", "status", "danger", "aria-hidden", "true", 1, "clr-validate-icon"], ["shape", "check-circle", "status", "success", "aria-hidden", "true", 1, "clr-validate-icon"]],
  template: function ClrComboboxContainer_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c18);
      ɵɵprojection(0);
      ɵɵtemplate(1, ClrComboboxContainer_label_1_Template, 1, 0, "label", 1);
      ɵɵelementStart(2, "div", 2, 0);
      ɵɵprojection(4, 1);
      ɵɵtemplate(5, ClrComboboxContainer_cds_icon_5_Template, 1, 0, "cds-icon", 3)(6, ClrComboboxContainer_cds_icon_6_Template, 1, 0, "cds-icon", 4)(7, ClrComboboxContainer_ng_content_7_Template, 1, 0, "ng-content", 1)(8, ClrComboboxContainer_ng_content_8_Template, 1, 0, "ng-content", 1)(9, ClrComboboxContainer_ng_content_9_Template, 1, 0, "ng-content", 1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.label && ctx.addGrid());
      ɵɵadvance();
      ɵɵproperty("ngClass", ctx.controlClass());
      ɵɵadvance(3);
      ɵɵproperty("ngIf", ctx.showInvalid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showValid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showHelper);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showInvalid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showValid);
    }
  },
  dependencies: [NgClass, NgIf, CdsIconCustomTag, ClrLabel],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrComboboxContainer, [{
    type: Component,
    args: [{
      selector: "clr-combobox-container",
      template: `
    <ng-content select="label"></ng-content>
    <label *ngIf="!label && addGrid()"></label>
    <div class="clr-control-container" [ngClass]="controlClass()" #controlContainer>
      <ng-content select="clr-combobox"></ng-content>
      <cds-icon
        *ngIf="showInvalid"
        class="clr-validate-icon"
        shape="exclamation-circle"
        status="danger"
        aria-hidden="true"
      ></cds-icon>
      <cds-icon
        *ngIf="showValid"
        class="clr-validate-icon"
        shape="check-circle"
        status="success"
        aria-hidden="true"
      ></cds-icon>
      <ng-content select="clr-control-helper" *ngIf="showHelper"></ng-content>
      <ng-content select="clr-control-error" *ngIf="showInvalid"></ng-content>
      <ng-content select="clr-control-success" *ngIf="showValid"></ng-content>
    </div>
  `,
      host: {
        "[class.clr-form-control]": "true",
        "[class.clr-combobox-form-control]": "true",
        "[class.clr-form-control-disabled]": "control?.disabled",
        "[class.clr-row]": "addGrid()"
      },
      providers: [IfControlStateService, NgControlService, ControlIdService, ControlClassService, ComboboxContainerService]
    }]
  }], function() {
    return [{
      type: IfControlStateService
    }, {
      type: LayoutService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: ControlClassService
    }, {
      type: NgControlService
    }, {
      type: ComboboxContainerService
    }, {
      type: ElementRef
    }];
  }, {
    controlContainer: [{
      type: ViewChild,
      args: ["controlContainer"]
    }]
  });
})();
var MultiSelectComboboxModel = class {
  containsItem(item) {
    return this.model ? this.model.includes(item) : false;
  }
  select(item) {
    this.addItem(item);
  }
  unselect(item) {
    this.removeItem(item);
  }
  isEmpty() {
    return !(this.model && this.model.length > 0);
  }
  pop() {
    let item;
    if (this.model && this.model.length > 0) {
      item = this.model[this.model.length - 1];
      this.removeItem(item);
    }
    return item;
  }
  toString(displayField, index = -1) {
    let displayString = "";
    if (this.model) {
      if (index > -1) {
        if (this.model[index]) {
          if (displayField && this.model[index][displayField]) {
            displayString += this.model[index][displayField];
          } else {
            displayString += this.model[index].toString();
          }
        }
      } else {
        this.model.forEach((model) => {
          if (displayField && model[displayField]) {
            displayString += model[displayField];
          } else {
            displayString += model.toString();
          }
          displayString += " ";
        });
      }
    }
    return displayString.trim();
  }
  addItem(item) {
    if (!this.containsItem(item)) {
      this.model = this.model || [];
      this.model.push(item);
    }
  }
  removeItem(item) {
    if (this.model === null || this.model === void 0) {
      return;
    }
    const index = this.model.indexOf(item);
    if (index > -1) {
      this.model.splice(index, 1);
    }
    if (this.model.length === 0) {
      this.model = null;
    }
  }
};
var SingleSelectComboboxModel = class {
  containsItem(item) {
    return this.model === item;
  }
  select(item) {
    this.model = item;
  }
  unselect(item) {
    if (this.containsItem(item)) {
      this.model = null;
    }
  }
  isEmpty() {
    return !this.model;
  }
  pop() {
    const item = this.model;
    this.model = null;
    return item;
  }
  toString(displayField) {
    if (!this.model) {
      return "";
    }
    if (displayField && this.model[displayField]) {
      return this.model[displayField];
    } else {
      return this.model.toString();
    }
  }
};
var ClrOptionSelected = class {
  constructor(template) {
    this.template = template;
  }
};
ClrOptionSelected.ɵfac = function ClrOptionSelected_Factory(t3) {
  return new (t3 || ClrOptionSelected)(ɵɵdirectiveInject(TemplateRef));
};
ClrOptionSelected.ɵdir = ɵɵdefineDirective({
  type: ClrOptionSelected,
  selectors: [["", "clrOptionSelected", ""]],
  inputs: {
    selected: [InputFlags.None, "clrOptionSelected", "selected"]
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrOptionSelected, [{
    type: Directive,
    args: [{
      selector: "[clrOptionSelected]"
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, {
    selected: [{
      type: Input,
      args: ["clrOptionSelected"]
    }]
  });
})();
var FocusableItem = class {
};
function customFocusableItemProvider(implementation) {
  return [implementation, {
    provide: FocusableItem,
    useExisting: implementation
  }];
}
var PseudoFocusModel = class extends SingleSelectComboboxModel {
  constructor() {
    super(...arguments);
    this._focusChanged = new BehaviorSubject(null);
  }
  get focusChanged() {
    return this._focusChanged.asObservable();
  }
  select(item) {
    if (this.model !== item) {
      this.model = item;
      this._focusChanged.next(item);
    }
  }
};
var OptionSelectionService = class {
  constructor() {
    this.loading = false;
    this.showAllOptions = true;
    this._currentInput = "";
    this._inputChanged = new BehaviorSubject("");
    this._selectionChanged = new ReplaySubject(1);
    this.inputChanged = this._inputChanged.asObservable();
  }
  get currentInput() {
    return this._currentInput;
  }
  set currentInput(input) {
    if (input === "" && !this.multiselectable) {
      this.setSelectionValue(null);
    }
    this._currentInput = input;
    this._inputChanged.next(input);
  }
  // This observable is for notifying the ClrOption to update its
  // selection by comparing the value
  get selectionChanged() {
    return this._selectionChanged.asObservable();
  }
  get multiselectable() {
    return this.selectionModel instanceof MultiSelectComboboxModel;
  }
  select(item) {
    if (item === null || item === void 0 || this.selectionModel.containsItem(item)) {
      return;
    }
    this.selectionModel.select(item);
    this._selectionChanged.next(this.selectionModel);
  }
  toggle(item) {
    if (item === null || item === void 0) {
      return;
    }
    if (this.selectionModel.containsItem(item)) {
      this.selectionModel.unselect(item);
    } else {
      this.selectionModel.select(item);
    }
    this._selectionChanged.next(this.selectionModel);
  }
  unselect(item) {
    if (item === null || item === void 0 || !this.selectionModel.containsItem(item)) {
      return;
    }
    this.selectionModel.unselect(item);
    this._selectionChanged.next(this.selectionModel);
  }
  // TODO: Add support for trackBy and compareFn
  setSelectionValue(value) {
    if (!this.selectionModel || this.selectionModel.model === value || !this.selectionModel.model && !value) {
      return;
    }
    this.selectionModel.model = value;
    this._selectionChanged.next(this.selectionModel);
  }
};
OptionSelectionService.ɵfac = function OptionSelectionService_Factory(t3) {
  return new (t3 || OptionSelectionService)();
};
OptionSelectionService.ɵprov = ɵɵdefineInjectable({
  token: OptionSelectionService,
  factory: OptionSelectionService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(OptionSelectionService, [{
    type: Injectable
  }], function() {
    return [];
  }, null);
})();
var ComboboxFocusHandler = class {
  constructor(rendererFactory, toggleService, selectionService, platformId) {
    this.toggleService = toggleService;
    this.selectionService = selectionService;
    this.platformId = platformId;
    this.pseudoFocus = new PseudoFocusModel();
    this.optionData = [];
    this.handleFocusSubscription();
    this.renderer = rendererFactory.createRenderer(null, null);
  }
  get trigger() {
    return this._trigger;
  }
  set trigger(el) {
    this._trigger = el;
    this.addFocusOnBlurListener(el);
  }
  get listbox() {
    return this._listbox;
  }
  set listbox(el) {
    this._listbox = el;
    this.addFocusOnBlurListener(el);
  }
  get textInput() {
    return this._textInput;
  }
  set textInput(el) {
    this._textInput = el;
    this.renderer.listen(el, "keydown", (event) => !this.handleTextInput(event));
    this.addFocusOnBlurListener(el);
  }
  focusInput() {
    if (this.textInput && isPlatformBrowser(this.platformId)) {
      this.textInput.focus();
    }
  }
  focusFirstActive() {
    if (this.optionData.length > 0) {
      if (this.selectionService.selectionModel.isEmpty()) {
        this.pseudoFocus.select(this.optionData[0]);
      } else {
        let firstActive;
        if (this.selectionService.multiselectable) {
          firstActive = this.selectionService.selectionModel.model[0];
        } else {
          firstActive = this.selectionService.selectionModel.model;
        }
        const activeProxy = this.optionData.find((option) => option.value === firstActive);
        if (activeProxy) {
          this.pseudoFocus.select(activeProxy);
        } else {
          this.pseudoFocus.select(this.optionData[0]);
        }
        this.scrollIntoSelectedModel("auto");
      }
    }
  }
  addOptionValues(options) {
    this.optionData = options;
  }
  handleFocusSubscription() {
    this.toggleService.openChange.subscribe((open) => {
      if (!open) {
        this.pseudoFocus.model = null;
      }
    });
  }
  moveFocusTo(direction) {
    let index = this.optionData.findIndex((option) => option.equals(this.pseudoFocus.model));
    if (direction === ArrowKeyDirection.UP) {
      if (index === -1 || index === 0) {
        index = this.optionData.length - 1;
      } else {
        index--;
      }
    } else if (direction === ArrowKeyDirection.DOWN) {
      if (index === -1 || index === this.optionData.length - 1) {
        index = 0;
      } else {
        index++;
      }
    }
    this.pseudoFocus.select(this.optionData[index]);
    this.scrollIntoSelectedModel();
  }
  openAndMoveTo(direction) {
    if (!this.toggleService.open) {
      this.toggleService.openChange.pipe(take(1)).subscribe((open) => {
        if (open) {
          this.moveFocusTo(direction);
        }
      });
      this.toggleService.open = true;
    } else {
      this.moveFocusTo(direction);
    }
  }
  // this service is only interested in keys that may move the focus
  handleTextInput(event) {
    let preventDefault = false;
    const key = normalizeKey(event.key);
    if (event) {
      switch (key) {
        case Keys.Enter:
          if (this.toggleService.open && this.pseudoFocus.model) {
            if (this.selectionService.multiselectable) {
              this.selectionService.toggle(this.pseudoFocus.model.value);
            } else {
              this.selectionService.select(this.pseudoFocus.model.value);
            }
            preventDefault = true;
          }
          break;
        case Keys.Space:
          if (!this.toggleService.open) {
            this.toggleService.open = true;
            preventDefault = true;
          }
          break;
        case Keys.ArrowUp:
          this.preventViewportScrolling(event);
          this.openAndMoveTo(ArrowKeyDirection.UP);
          preventDefault = true;
          break;
        case Keys.ArrowDown:
          this.preventViewportScrolling(event);
          this.openAndMoveTo(ArrowKeyDirection.DOWN);
          preventDefault = true;
          break;
        default:
          if (event.key !== Keys.Tab && !(this.selectionService.multiselectable && event.key === Keys.Backspace) && !(event.key === Keys.Escape) && !this.toggleService.open) {
            this.toggleService.open = true;
          }
          break;
      }
    }
    return preventDefault;
  }
  scrollIntoSelectedModel(behavior = "smooth") {
    if (this.pseudoFocus.model && this.pseudoFocus.model.el) {
      this.pseudoFocus.model.el.scrollIntoView({
        behavior,
        block: "center",
        inline: "nearest"
      });
    }
  }
  preventViewportScrolling(event) {
    event.preventDefault();
    event.stopImmediatePropagation();
  }
  addFocusOnBlurListener(el) {
    if (isPlatformBrowser(this.platformId)) {
      this.renderer.listen(el, "blur", (event) => {
        if (this.focusOutOfComponent(event)) {
          this.toggleService.open = false;
          if (this.componentCdRef) {
            this.componentCdRef.detectChanges();
          }
        }
      });
    }
  }
  focusOutOfComponent(event) {
    const target = event.relatedTarget || document.activeElement;
    return !(this.textInput.contains(target) || this.trigger.contains(target) || this.listbox.contains(target));
  }
};
ComboboxFocusHandler.ɵfac = function ComboboxFocusHandler_Factory(t3) {
  return new (t3 || ComboboxFocusHandler)(ɵɵinject(RendererFactory2), ɵɵinject(ClrPopoverToggleService), ɵɵinject(OptionSelectionService), ɵɵinject(PLATFORM_ID));
};
ComboboxFocusHandler.ɵprov = ɵɵdefineInjectable({
  token: ComboboxFocusHandler,
  factory: ComboboxFocusHandler.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ComboboxFocusHandler, [{
    type: Injectable
  }], function() {
    return [{
      type: RendererFactory2
    }, {
      type: ClrPopoverToggleService
    }, {
      type: OptionSelectionService
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [PLATFORM_ID]
      }]
    }];
  }, null);
})();
var COMBOBOX_FOCUS_HANDLER_PROVIDER = customFocusableItemProvider(ComboboxFocusHandler);
var OptionData = class {
  constructor(id, value) {
    this.id = id;
    this.value = value;
  }
  equals(other) {
    if (!other) {
      return false;
    }
    return this.id === other.id && this.value === other.value;
  }
};
var ClrOption = class {
  constructor(elRef, commonStrings, focusHandler, optionSelectionService) {
    this.elRef = elRef;
    this.commonStrings = commonStrings;
    this.focusHandler = focusHandler;
    this.optionSelectionService = optionSelectionService;
    this.optionProxy = new OptionData(null, null);
    this.optionProxy.el = this.elRef.nativeElement;
  }
  get optionId() {
    return this._id;
  }
  set optionId(id) {
    this._id = id;
    this.optionProxy.id = this._id;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.optionProxy.value = value;
  }
  get selected() {
    return this.optionSelectionService.selectionModel && this.optionSelectionService.selectionModel.containsItem(this.value);
  }
  get focusClass() {
    return this.focusHandler.pseudoFocus.containsItem(this.optionProxy);
  }
  ngOnInit() {
    if (!this._id) {
      this._id = "clr-option-" + uniqueIdFactory();
      this.optionProxy.id = this._id;
    }
  }
  onClick() {
    if (this.optionSelectionService.multiselectable) {
      this.optionSelectionService.toggle(this.value);
    } else {
      this.optionSelectionService.select(this.value);
    }
    this.focusHandler.focusInput();
  }
};
ClrOption.ɵfac = function ClrOption_Factory(t3) {
  return new (t3 || ClrOption)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ClrCommonStringsService), ɵɵdirectiveInject(ComboboxFocusHandler), ɵɵdirectiveInject(OptionSelectionService));
};
ClrOption.ɵcmp = ɵɵdefineComponent({
  type: ClrOption,
  selectors: [["clr-option"]],
  hostVars: 9,
  hostBindings: function ClrOption_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function ClrOption_click_HostBindingHandler() {
        return ctx.onClick();
      });
    }
    if (rf & 2) {
      ɵɵattribute("role", "option")("tabindex", -1)("id", ctx.optionId);
      ɵɵclassProp("clr-combobox-option", true)("active", ctx.selected)("clr-focus", ctx.focusClass);
    }
  },
  inputs: {
    optionId: [InputFlags.None, "id", "optionId"],
    value: [InputFlags.None, "clrValue", "value"]
  },
  ngContentSelectors: _c02,
  decls: 2,
  vars: 1,
  consts: [["class", "clr-sr-only", 4, "ngIf"], [1, "clr-sr-only"]],
  template: function ClrOption_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
      ɵɵtemplate(1, ClrOption_span_1_Template, 2, 1, "span", 0);
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.selected);
    }
  },
  dependencies: [NgIf],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrOption, [{
    type: Component,
    args: [{
      selector: "clr-option",
      template: `
    <ng-content></ng-content>
    <span *ngIf="selected" class="clr-sr-only">{{ commonStrings.keys.comboboxSelected }}</span>
  `,
      host: {
        "[class.clr-combobox-option]": "true",
        "[attr.role]": '"option"',
        // Do not remove. Or click-selection will not work.
        "[attr.tabindex]": "-1",
        "[attr.id]": "optionId"
      }
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: ClrCommonStringsService
    }, {
      type: ComboboxFocusHandler
    }, {
      type: OptionSelectionService
    }];
  }, {
    optionId: [{
      type: Input,
      args: ["id"]
    }],
    value: [{
      type: Input,
      args: ["clrValue"]
    }],
    selected: [{
      type: HostBinding,
      args: ["class.active"]
    }],
    focusClass: [{
      type: HostBinding,
      args: ["class.clr-focus"]
    }],
    onClick: [{
      type: HostListener,
      args: ["click"]
    }]
  });
})();
var nbOptionsComponents = 0;
var ClrOptions = class {
  constructor(optionSelectionService, id, el, commonStrings, focusHandler, toggleService, parentHost, document2) {
    this.optionSelectionService = optionSelectionService;
    this.id = id;
    this.el = el;
    this.commonStrings = commonStrings;
    this.focusHandler = focusHandler;
    this.toggleService = toggleService;
    this.document = document2;
    this.loading = false;
    this.subscriptions = [];
    if (!parentHost) {
      throw new Error("clr-options should only be used inside of a clr-combobox");
    }
    if (!this.optionsId) {
      this.optionsId = "clr-options-" + nbOptionsComponents++;
    }
  }
  get items() {
    return this._items;
  }
  set items(items) {
    this._items = items;
    this.focusHandler.addOptionValues(this._items.map((option) => option.optionProxy));
  }
  /**
   * Tests if the list of options is empty, meaning it doesn't contain any items
   */
  get emptyOptions() {
    return !this.optionSelectionService.loading && this.items.length === 0;
  }
  get noResultsElementId() {
    return `${this.optionsId}-no-results`;
  }
  ngAfterViewInit() {
    this.focusHandler.listbox = this.el.nativeElement;
    this.subscriptions.push(fromEvent(this.document, "scroll", {
      capture: true
    }).subscribe((event) => {
      if (this.toggleService.open && event.target !== this.el.nativeElement && event.target !== this.focusHandler.textInput) {
        this.toggleService.open = false;
      }
    }), this.items.changes.subscribe((items) => {
      if (items.length) {
        setTimeout(() => {
          this.focusHandler.focusFirstActive();
        });
      } else {
        this.focusHandler.pseudoFocus.pop();
      }
    }));
  }
  ngOnDestroy() {
    this.subscriptions.forEach((sub) => sub.unsubscribe());
  }
  searchText(input) {
    return this.commonStrings.parse(this.commonStrings.keys.comboboxSearching, {
      INPUT: input
    });
  }
  loadingStateChange(state2) {
    this.loading = state2 === ClrLoadingState.LOADING;
  }
};
ClrOptions.ɵfac = function ClrOptions_Factory(t3) {
  return new (t3 || ClrOptions)(ɵɵdirectiveInject(OptionSelectionService), ɵɵdirectiveInject(IF_ACTIVE_ID), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ClrCommonStringsService), ɵɵdirectiveInject(ComboboxFocusHandler), ɵɵdirectiveInject(ClrPopoverToggleService), ɵɵdirectiveInject(POPOVER_HOST_ANCHOR, 8), ɵɵdirectiveInject(DOCUMENT));
};
ClrOptions.ɵcmp = ɵɵdefineComponent({
  type: ClrOptions,
  selectors: [["clr-options"]],
  contentQueries: function ClrOptions_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ClrOption, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.items = _t);
    }
  },
  hostVars: 4,
  hostBindings: function ClrOptions_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵhostProperty("id", ctx.optionsId);
      ɵɵattribute("role", "listbox");
      ɵɵclassProp("clr-combobox-options", true);
    }
  },
  inputs: {
    optionsId: [InputFlags.None, "id", "optionsId"]
  },
  features: [ɵɵProvidersFeature([{
    provide: LoadingListener,
    useExisting: ClrOptions
  }])],
  ngContentSelectors: _c02,
  decls: 3,
  vars: 2,
  consts: [["class", "clr-combobox-options-loading", 4, "ngIf"], ["role", "option", 3, "id", 4, "ngIf"], [1, "clr-combobox-options-loading"], ["clrInline", ""], [1, "clr-combobox-options-text"], ["role", "option", 3, "id"], [1, "clr-combobox-options-empty-text"]],
  template: function ClrOptions_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵtemplate(0, ClrOptions_div_0_Template, 5, 2, "div", 0)(1, ClrOptions_div_1_Template, 3, 2, "div", 1);
      ɵɵprojection(2);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.optionSelectionService.loading);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.emptyOptions);
    }
  },
  dependencies: [NgIf, ClrSpinner],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrOptions, [{
    type: Component,
    args: [{
      selector: "clr-options",
      template: `
    <div *ngIf="optionSelectionService.loading" class="clr-combobox-options-loading">
      <clr-spinner clrInline>
        {{ commonStrings.keys.loading }}
      </clr-spinner>
      <span class="clr-combobox-options-text">
        {{ searchText(optionSelectionService.currentInput) }}
      </span>
    </div>

    <!-- Rendered if data set is empty -->
    <div *ngIf="emptyOptions" [id]="noResultsElementId" role="option">
      <span class="clr-combobox-options-empty-text">
        {{ commonStrings.keys.comboboxNoResults }}
      </span>
    </div>

    <!--Option Groups and Options will be projected here-->
    <ng-content></ng-content>
  `,
      providers: [{
        provide: LoadingListener,
        useExisting: ClrOptions
      }],
      host: {
        "[class.clr-combobox-options]": "true",
        "[attr.role]": '"listbox"',
        "[id]": "optionsId"
      }
    }]
  }], function() {
    return [{
      type: OptionSelectionService
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [IF_ACTIVE_ID]
      }]
    }, {
      type: ElementRef
    }, {
      type: ClrCommonStringsService
    }, {
      type: ComboboxFocusHandler
    }, {
      type: ClrPopoverToggleService
    }, {
      type: ElementRef,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [POPOVER_HOST_ANCHOR]
      }]
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [DOCUMENT]
      }]
    }];
  }, {
    optionsId: [{
      type: Input,
      args: ["id"]
    }],
    items: [{
      type: ContentChildren,
      args: [ClrOption]
    }]
  });
})();
var ClrCombobox = class extends WrappedFormControl {
  constructor(vcr, injector, control, renderer, el, optionSelectionService, commonStrings, toggleService, positionService, controlStateService, containerService, platformId, focusHandler, cdr) {
    super(vcr, ClrComboboxContainer, injector, control, renderer, el);
    this.control = control;
    this.renderer = renderer;
    this.el = el;
    this.optionSelectionService = optionSelectionService;
    this.commonStrings = commonStrings;
    this.toggleService = toggleService;
    this.positionService = positionService;
    this.controlStateService = controlStateService;
    this.containerService = containerService;
    this.platformId = platformId;
    this.focusHandler = focusHandler;
    this.cdr = cdr;
    this.placeholder = "";
    this.clrInputChange = new EventEmitter(false);
    this.clrOpenChange = this.toggleService.openChange;
    this.clrSelectionChange = this.optionSelectionService.selectionChanged;
    this.invalid = false;
    this.focused = false;
    this.smartPosition = {
      axis: ClrAxis.VERTICAL,
      side: ClrSide.AFTER,
      anchor: ClrAlignment.START,
      content: ClrAlignment.START
    };
    this.index = 1;
    this._searchText = "";
    if (control) {
      control.valueAccessor = this;
    }
    this.optionSelectionService.selectionModel = new SingleSelectComboboxModel();
    this.updateControlValue();
  }
  get multiSelect() {
    return this.optionSelectionService.multiselectable;
  }
  set multiSelect(value) {
    if (value) {
      this.optionSelectionService.selectionModel = new MultiSelectComboboxModel();
    } else {
      this.optionSelectionService.selectionModel = new SingleSelectComboboxModel();
    }
    this.updateControlValue();
  }
  // Override the id of WrappedFormControl, as we want to move it to the embedded input.
  // Otherwise the label/component connection does not work and screen readers do not read the label.
  get id() {
    return this.controlIdService.id + "-combobox";
  }
  set id(id) {
    super.id = id;
  }
  get searchText() {
    return this._searchText;
  }
  set searchText(text) {
    if (text !== this._searchText) {
      if (this.toggleService.open) {
        this.optionSelectionService.showAllOptions = false;
      }
      this._searchText = text;
      this.clrInputChange.emit(this.searchText);
    }
    this.optionSelectionService.currentInput = this.searchText;
  }
  get openState() {
    return this.toggleService.open;
  }
  get multiSelectModel() {
    if (!this.multiSelect) {
      throw Error("multiSelectModel is not available in single selection context");
    }
    return this.optionSelectionService.selectionModel.model;
  }
  get ariaControls() {
    return this.options?.optionsId;
  }
  get ariaOwns() {
    return this.options?.optionsId;
  }
  get ariaDescribedBySelection() {
    return "selection-" + this.id;
  }
  get displayField() {
    return this.optionSelectionService.displayField;
  }
  get disabled() {
    return this.control && this.control.disabled;
  }
  ngAfterContentInit() {
    this.initializeSubscriptions();
    if (!this.optionSelectionService.selectionModel.isEmpty()) {
      this.updateInputValue(this.optionSelectionService.selectionModel);
    }
  }
  ngAfterViewInit() {
    this.focusHandler.componentCdRef = this.cdr;
    this.focusHandler.textInput = this.textbox.nativeElement;
    this.focusHandler.trigger = this.trigger.nativeElement;
    this.el = this.textbox;
  }
  onKeyUp(event) {
    if (event.key === Keys.Backspace && this.multiSelect && this._searchText.length === 0) {
      const multiModel = this.optionSelectionService.selectionModel.model;
      if (multiModel && multiModel.length > 0) {
        const lastItem = multiModel[multiModel.length - 1];
        this.control.control.markAsTouched();
        this.optionSelectionService.unselect(lastItem);
      }
    }
  }
  inputId() {
    return this.controlIdService.id;
  }
  loadingStateChange(state2) {
    this.optionSelectionService.loading = state2 === ClrLoadingState.LOADING;
    this.positionService.realign();
    if (state2 !== ClrLoadingState.LOADING && isPlatformBrowser(this.platformId)) {
      this.focusFirstActive();
    }
  }
  unselect(item) {
    if (!this.disabled) {
      this.optionSelectionService.unselect(item);
    }
  }
  onBlur() {
    this.onTouchedCallback();
    if (this.control.control.updateOn === "change" && this.control.control?.errors?.required) {
      this.updateControlValue();
    }
    if (this.control.control.updateOn === "blur") {
      this.control.control.updateValueAndValidity();
    }
    this.focused = false;
  }
  onFocus() {
    this.focused = true;
    this.cdr.detectChanges();
  }
  getSelectionAriaLabel() {
    if (this.containerService && this.containerService.labelText) {
      return `${this.containerService.labelText} ${this.commonStrings.keys.comboboxSelection}`;
    }
    return this.commonStrings.keys.comboboxSelection;
  }
  focusFirstActive() {
    setTimeout(() => {
      this.focusHandler.focusFirstActive();
    });
  }
  writeValue(value) {
    this.optionSelectionService.selectionModel.model = value;
    this.updateInputValue(this.optionSelectionService.selectionModel);
  }
  registerOnTouched(onTouched) {
    this.onTouchedCallback = onTouched;
  }
  registerOnChange(onChange) {
    this.onChangeCallback = onChange;
  }
  getActiveDescendant() {
    const model = this.focusHandler.pseudoFocus.model;
    return model ? model.id : this.options?.noResultsElementId;
  }
  setDisabledState() {
  }
  focusInput() {
    this.focusHandler.focusInput();
  }
  initializeSubscriptions() {
    this.subscriptions.push(this.optionSelectionService.selectionChanged.subscribe((newSelection) => {
      this.updateInputValue(newSelection);
      if (this.multiSelect) {
        this.positionService.realign();
      }
      if (!this.multiSelect && newSelection && !newSelection.isEmpty()) {
        this.toggleService.open = false;
      }
      this.updateControlValue();
    }));
    this.subscriptions.push(this.toggleService.openChange.subscribe((open) => {
      if (open) {
        this.focusFirstActive();
      } else {
        this.optionSelectionService.showAllOptions = true;
      }
      if (this.multiSelect) {
        this.searchText = "";
      } else {
        this.searchText = this.getDisplayNames(this.optionSelectionService.selectionModel.model)[0] || "";
      }
    }));
    this.subscriptions.push(this.toggleService.popoverAligned.subscribe((popoverNode) => {
      if (!this.containerService) {
        return;
      }
      const popover = popoverNode;
      if (popover.getBoundingClientRect().top < this.el.nativeElement.getBoundingClientRect().top) {
        this.renderer.setStyle(popoverNode, "top", `${popover.offsetTop + this.containerService.labelOffset}px`);
      }
    }));
    if (this.controlStateService) {
      this.subscriptions.push(this.controlStateService.statusChanges.subscribe((invalid) => {
        this.invalid = this.control.control.touched && invalid === CONTROL_STATE.INVALID;
      }));
    }
  }
  updateInputValue(model) {
    if (!this.multiSelect) {
      this.searchText = model.model ? this.getDisplayNames(model.model)[0] : "";
      if (this.searchText) {
        this.optionSelectionService.currentInput = this.searchText;
      }
    }
  }
  updateControlValue() {
    if (this.onChangeCallback) {
      this.onChangeCallback(this.optionSelectionService.selectionModel.model);
    }
  }
  getDisplayNames(model) {
    if (this.displayField) {
      if (!Array.isArray(model)) {
        model = [model];
      }
      return model.map((item) => item ? item[this.displayField] : null);
    }
    return [this.optionSelectionService.selectionModel.model];
  }
};
ClrCombobox.ɵfac = function ClrCombobox_Factory(t3) {
  return new (t3 || ClrCombobox)(ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(NgControl, 10), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(OptionSelectionService), ɵɵdirectiveInject(ClrCommonStringsService), ɵɵdirectiveInject(ClrPopoverToggleService), ɵɵdirectiveInject(ClrPopoverPositionService), ɵɵdirectiveInject(IfControlStateService, 8), ɵɵdirectiveInject(ComboboxContainerService, 8), ɵɵdirectiveInject(PLATFORM_ID), ɵɵdirectiveInject(ComboboxFocusHandler), ɵɵdirectiveInject(ChangeDetectorRef));
};
ClrCombobox.ɵcmp = ɵɵdefineComponent({
  type: ClrCombobox,
  selectors: [["clr-combobox"]],
  contentQueries: function ClrCombobox_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ClrOptionSelected, 5);
      ɵɵcontentQuery(dirIndex, ClrOptions, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.optionSelected = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.options = _t.first);
    }
  },
  viewQuery: function ClrCombobox_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c20, 5);
      ɵɵviewQuery(_c21, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.textbox = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.trigger = _t.first);
    }
  },
  hostVars: 6,
  hostBindings: function ClrCombobox_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("keydown", function ClrCombobox_keydown_HostBindingHandler($event) {
        return ctx.onKeyUp($event);
      });
    }
    if (rf & 2) {
      ɵɵclassProp("aria-required", true)("clr-combobox", true)("clr-combobox-disabled", ctx.control == null ? null : ctx.control.disabled);
    }
  },
  inputs: {
    placeholder: "placeholder",
    multiSelect: [InputFlags.None, "clrMulti", "multiSelect"]
  },
  outputs: {
    clrInputChange: "clrInputChange",
    clrOpenChange: "clrOpenChange",
    clrSelectionChange: "clrSelectionChange"
  },
  features: [ɵɵProvidersFeature([OptionSelectionService, {
    provide: LoadingListener,
    useExisting: ClrCombobox
  }, IF_ACTIVE_ID_PROVIDER, FOCUS_SERVICE_PROVIDER, COMBOBOX_FOCUS_HANDLER_PROVIDER]), ɵɵHostDirectivesFeature([ClrPopoverHostDirective]), ɵɵInheritDefinitionFeature],
  ngContentSelectors: _c02,
  decls: 10,
  vars: 23,
  consts: [["textboxInput", ""], ["trigger", ""], ["clrPopoverAnchor", "", 1, "clr-combobox-wrapper", 3, "click"], ["role", "grid", "clrRovingTabindex", "", "clrDirection", "both", 3, "clrRovingTabindexDisabled", 4, "ngIf"], [1, "clr-combobox-input-wrapper"], ["type", "text", "role", "combobox", "aria-haspopup", "listbox", "aria-autocomplete", "list", "autocomplete", "off", 1, "clr-input", "clr-combobox-input", 3, "ngModelChange", "blur", "focus", "id", "ngModel", "disabled"], ["clrPopoverOpenCloseButton", "", "type", "button", "tabindex", "-1", 1, "clr-combobox-trigger", 3, "disabled"], ["shape", "angle", "direction", "down"], [1, "clr-focus-indicator"], ["role", "dialog", 4, "clrPopoverContent", "clrPopoverContentAt", "clrPopoverContentOutsideClickToClose", "clrPopoverContentScrollToClose"], ["role", "grid", "clrRovingTabindex", "", "clrDirection", "both", 3, "clrRovingTabindexDisabled"], ["class", "label label-combobox-pill", "role", "row", 4, "ngFor", "ngForOf"], ["role", "row", 1, "label", "label-combobox-pill"], ["role", "gridcell"], ["clrKeyFocusItem", "", 1, "clr-combobox-pill-content"], [3, "ngTemplateOutlet", "ngTemplateOutletContext", 4, "ngIf"], ["clrKeyFocusItem", "", "type", "button", 1, "clr-combobox-remove-btn", 3, "click", "disabled"], ["shape", "window-close", "size", "12"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["role", "dialog"]],
  template: function ClrCombobox_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵprojectionDef();
      ɵɵelementStart(0, "div", 2);
      ɵɵlistener("click", function ClrCombobox_Template_div_click_0_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.focusInput());
      });
      ɵɵtemplate(1, ClrCombobox_span_1_Template, 2, 4, "span", 3);
      ɵɵelementStart(2, "span", 4)(3, "input", 5, 0);
      ɵɵtwoWayListener("ngModelChange", function ClrCombobox_Template_input_ngModelChange_3_listener($event) {
        ɵɵrestoreView(_r1);
        ɵɵtwoWayBindingSet(ctx.searchText, $event) || (ctx.searchText = $event);
        return ɵɵresetView($event);
      });
      ɵɵlistener("blur", function ClrCombobox_Template_input_blur_3_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.onBlur());
      })("focus", function ClrCombobox_Template_input_focus_3_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.onFocus());
      });
      ɵɵelementEnd()();
      ɵɵelementStart(5, "button", 6, 1);
      ɵɵelement(7, "cds-icon", 7);
      ɵɵelementEnd();
      ɵɵelement(8, "div", 8);
      ɵɵelementEnd();
      ɵɵtemplate(9, ClrCombobox_div_9_Template, 2, 0, "div", 9);
    }
    if (rf & 2) {
      ɵɵclassProp("multi", ctx.multiSelect)("invalid", ctx.invalid)("disabled", (ctx.control == null ? null : ctx.control.disabled) ? true : null);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.multiSelect && ctx.optionSelectionService.selectionModel.model);
      ɵɵadvance(2);
      ɵɵproperty("id", ctx.inputId());
      ɵɵtwoWayProperty("ngModel", ctx.searchText);
      ɵɵproperty("disabled", (ctx.control == null ? null : ctx.control.disabled) ? true : null);
      ɵɵattribute("aria-expanded", ctx.openState)("aria-owns", ctx.ariaOwns)("aria-invalid", (ctx.control == null ? null : ctx.control.invalid) ? true : null)("aria-activedescendant", ctx.getActiveDescendant())("placeholder", ctx.placeholder);
      ɵɵadvance(2);
      ɵɵproperty("disabled", (ctx.control == null ? null : ctx.control.disabled) || null);
      ɵɵattribute("aria-label", ctx.commonStrings.keys.comboboxOpen);
      ɵɵadvance(3);
      ɵɵclassProp("clr-focus", ctx.focused);
      ɵɵadvance();
      ɵɵproperty("clrPopoverContent", ctx.openState)("clrPopoverContentAt", ctx.smartPosition)("clrPopoverContentOutsideClickToClose", false)("clrPopoverContentScrollToClose", false);
    }
  },
  dependencies: [NgForOf, NgIf, NgTemplateOutlet, DefaultValueAccessor, NgControlStatus, NgModel, CdsIconCustomTag, ClrRovingTabindex, ClrKeyFocusItem, ClrPopoverAnchor, ClrPopoverOpenCloseButton, ClrPopoverContent],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrCombobox, [{
    type: Component,
    args: [{
      selector: "clr-combobox",
      providers: [OptionSelectionService, {
        provide: LoadingListener,
        useExisting: ClrCombobox
      }, IF_ACTIVE_ID_PROVIDER, FOCUS_SERVICE_PROVIDER, COMBOBOX_FOCUS_HANDLER_PROVIDER],
      hostDirectives: [ClrPopoverHostDirective],
      host: {
        "[class.aria-required]": "true",
        "[class.clr-combobox]": "true",
        "[class.clr-combobox-disabled]": "control?.disabled"
      },
      template: `<!--
  ~ Copyright (c) 2016-2024 Broadcom. All Rights Reserved.
  ~ The term "Broadcom" refers to Broadcom Inc. and/or its subsidiaries.
  ~ This software is released under MIT license.
  ~ The full license information can be found in LICENSE in the root directory of this project.
-->

<!-- The (click) handler is needed to auto-focus on input field which can not currently occupy the whole
     width of the component, after being wrapped to a new line -->
<div
  class="clr-combobox-wrapper"
  clrPopoverAnchor
  (click)="focusInput()"
  [class.multi]="multiSelect"
  [class.invalid]="invalid"
  [class.disabled]="control?.disabled? true: null"
>
  <span
    *ngIf="multiSelect && optionSelectionService.selectionModel.model"
    role="grid"
    clrRovingTabindex
    [clrRovingTabindexDisabled]="control?.disabled"
    clrDirection="both"
    [attr.aria-label]="getSelectionAriaLabel()"
    [attr.aria-disabled]="control?.disabled? true: null"
  >
    <span *ngFor="let item of multiSelectModel; let i = index" class="label label-combobox-pill" role="row">
      <span role="gridcell">
        <span class="clr-combobox-pill-content" clrKeyFocusItem>
          <ng-container
            *ngIf="optionSelected"
            [ngTemplateOutlet]="optionSelected.template"
            [ngTemplateOutletContext]="{$implicit: optionSelectionService.selectionModel.model[i]}"
          ></ng-container>
        </span>
      </span>
      <span role="gridcell">
        <button
          clrKeyFocusItem
          type="button"
          class="clr-combobox-remove-btn"
          [disabled]="control?.disabled? true: null"
          [attr.aria-label]="commonStrings.keys.comboboxDelete + ' ' + optionSelectionService.selectionModel.toString(displayField, i)"
          (click)="unselect(item)"
        >
          <cds-icon shape="window-close" size="12"></cds-icon>
        </button>
      </span>
    </span>
  </span>

  <span class="clr-combobox-input-wrapper">
    <input
      #textboxInput
      type="text"
      role="combobox"
      [id]="inputId()"
      class="clr-input clr-combobox-input"
      [(ngModel)]="searchText"
      (blur)="onBlur()"
      (focus)="onFocus()"
      [attr.aria-expanded]="openState"
      [attr.aria-owns]="ariaOwns"
      aria-haspopup="listbox"
      aria-autocomplete="list"
      autocomplete="off"
      [attr.aria-invalid]="control?.invalid? true: null"
      [disabled]="control?.disabled? true: null"
      [attr.aria-activedescendant]="getActiveDescendant()"
      [attr.placeholder]="placeholder"
    />
  </span>

  <!-- No click handler, as it uses the handler on the .clr-combobox-wrapper -->
  <button
    clrPopoverOpenCloseButton
    #trigger
    type="button"
    class="clr-combobox-trigger"
    tabindex="-1"
    [disabled]="control?.disabled || null"
    [attr.aria-label]="commonStrings.keys.comboboxOpen"
  >
    <cds-icon shape="angle" direction="down"></cds-icon>
  </button>

  <div class="clr-focus-indicator" [class.clr-focus]="focused"></div>
</div>

<!-- Both close handlers are handled manually due to issues in Edge browser.
     Additionally 'outsideClickToClose' has complex handling that's necessary
     to be manual due to the component architecture -->
<div role="dialog" *clrPopoverContent="openState at smartPosition; outsideClickToClose: false; scrollToClose: false">
  <ng-content></ng-content>
</div>
`
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }, {
      type: Injector
    }, {
      type: NgControl,
      decorators: [{
        type: Self
      }, {
        type: Optional
      }]
    }, {
      type: Renderer2
    }, {
      type: ElementRef
    }, {
      type: OptionSelectionService
    }, {
      type: ClrCommonStringsService
    }, {
      type: ClrPopoverToggleService
    }, {
      type: ClrPopoverPositionService
    }, {
      type: IfControlStateService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: ComboboxContainerService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [PLATFORM_ID]
      }]
    }, {
      type: ComboboxFocusHandler
    }, {
      type: ChangeDetectorRef
    }];
  }, {
    placeholder: [{
      type: Input,
      args: ["placeholder"]
    }],
    clrInputChange: [{
      type: Output,
      args: ["clrInputChange"]
    }],
    clrOpenChange: [{
      type: Output,
      args: ["clrOpenChange"]
    }],
    clrSelectionChange: [{
      type: Output,
      args: ["clrSelectionChange"]
    }],
    textbox: [{
      type: ViewChild,
      args: ["textboxInput"]
    }],
    trigger: [{
      type: ViewChild,
      args: ["trigger"]
    }],
    optionSelected: [{
      type: ContentChild,
      args: [ClrOptionSelected]
    }],
    options: [{
      type: ContentChild,
      args: [ClrOptions]
    }],
    multiSelect: [{
      type: Input,
      args: ["clrMulti"]
    }],
    onKeyUp: [{
      type: HostListener,
      args: ["keydown", ["$event"]]
    }]
  });
})();
var ClrOptionItems = class {
  constructor(template, differs, optionService, positionService, vcr) {
    this.template = template;
    this.differs = differs;
    this.optionService = optionService;
    this.positionService = positionService;
    this.vcr = vcr;
    this.subscriptions = [];
    this.filter = "";
    this.differ = null;
    this.iterableProxy = new NgForOf(this.vcr, this.template, this.differs);
    this.subscriptions.push(optionService.inputChanged.subscribe((filter2) => {
      this.filter = filter2;
      this.updateItems();
    }));
  }
  set rawItems(items) {
    this._rawItems = items ? items : [];
    this.updateItems();
  }
  set trackBy(value) {
    this.iterableProxy.ngForTrackBy = value;
  }
  set field(field) {
    this._filterField = field;
    this.optionService.displayField = field;
  }
  ngDoCheck() {
    if (!this.differ) {
      this.differ = this.differs.find(this.filteredItems).create(this.iterableProxy.ngForTrackBy);
    }
    if (this.differ) {
      const changes = this.differ.diff(this.filteredItems);
      if (changes) {
        this.iterableProxy.ngDoCheck();
        this.positionService.realign();
      }
    }
  }
  ngOnDestroy() {
    this.subscriptions.forEach((sub) => sub.unsubscribe());
  }
  updateItems() {
    if (!this._rawItems || this.filter === void 0 || this.filter === null) {
      return;
    }
    const normalizedFilterValue = normalizeValue(this.filter);
    if (this.optionService.showAllOptions) {
      this.filteredItems = this._rawItems;
    } else if (this._filterField) {
      this.filteredItems = this._rawItems.filter((item) => {
        const objValue = item[this._filterField];
        return objValue ? normalizeValue(objValue).includes(normalizedFilterValue) : false;
      });
    } else {
      this.filteredItems = this._rawItems.filter((item) => {
        if (typeof item !== "object") {
          return normalizeValue(item).includes(normalizedFilterValue);
        }
        const objValues = Object.values(item).filter((value) => {
          return value !== null && value !== void 0 ? normalizeValue(value).includes(normalizedFilterValue) : false;
        });
        return objValues.length > 0;
      });
    }
    this.iterableProxy.ngForOf = this.filteredItems;
  }
};
ClrOptionItems.ɵfac = function ClrOptionItems_Factory(t3) {
  return new (t3 || ClrOptionItems)(ɵɵdirectiveInject(TemplateRef), ɵɵdirectiveInject(IterableDiffers), ɵɵdirectiveInject(OptionSelectionService), ɵɵdirectiveInject(ClrPopoverPositionService), ɵɵdirectiveInject(ViewContainerRef));
};
ClrOptionItems.ɵdir = ɵɵdefineDirective({
  type: ClrOptionItems,
  selectors: [["", "clrOptionItems", "", "clrOptionItemsOf", ""]],
  inputs: {
    rawItems: [InputFlags.None, "clrOptionItemsOf", "rawItems"],
    trackBy: [InputFlags.None, "clrOptionItemsTrackBy", "trackBy"],
    field: [InputFlags.None, "clrOptionItemsField", "field"]
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrOptionItems, [{
    type: Directive,
    args: [{
      selector: "[clrOptionItems][clrOptionItemsOf]"
    }]
  }], function() {
    return [{
      type: TemplateRef
    }, {
      type: IterableDiffers
    }, {
      type: OptionSelectionService
    }, {
      type: ClrPopoverPositionService
    }, {
      type: ViewContainerRef
    }];
  }, {
    rawItems: [{
      type: Input,
      args: ["clrOptionItemsOf"]
    }],
    trackBy: [{
      type: Input,
      args: ["clrOptionItemsTrackBy"]
    }],
    field: [{
      type: Input,
      args: ["clrOptionItemsField"]
    }]
  });
})();
function normalizeValue(value) {
  return value.toString().normalize("NFD").replace(new RegExp("\\p{Diacritic}", "gu"), "").toLowerCase();
}
var ClrComboboxModule = class {
  constructor() {
    r.addIcons(e3, l, o3, n3);
  }
};
ClrComboboxModule.ɵfac = function ClrComboboxModule_Factory(t3) {
  return new (t3 || ClrComboboxModule)();
};
ClrComboboxModule.ɵmod = ɵɵdefineNgModule({
  type: ClrComboboxModule,
  declarations: [ClrCombobox, ClrComboboxContainer, ClrOptions, ClrOption, ClrOptionSelected, ClrOptionItems],
  imports: [CommonModule, FormsModule, ClrIconModule, ClrKeyFocusModule, ClrCommonFormsModule, ClrConditionalModule, ClrPopoverModuleNext, ClrSpinnerModule],
  exports: [ClrCommonFormsModule, ClrCombobox, ClrComboboxContainer, ClrOptions, ClrOption, ClrOptionSelected, ClrConditionalModule, ClrOptionItems]
});
ClrComboboxModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, FormsModule, ClrIconModule, ClrKeyFocusModule, ClrCommonFormsModule, ClrConditionalModule, ClrPopoverModuleNext, ClrSpinnerModule, ClrCommonFormsModule, ClrConditionalModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrComboboxModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, FormsModule, ClrIconModule, ClrKeyFocusModule, ClrCommonFormsModule, ClrConditionalModule, ClrPopoverModuleNext, ClrSpinnerModule],
      declarations: [ClrCombobox, ClrComboboxContainer, ClrOptions, ClrOption, ClrOptionSelected, ClrOptionItems],
      exports: [ClrCommonFormsModule, ClrCombobox, ClrComboboxContainer, ClrOptions, ClrOption, ClrOptionSelected, ClrConditionalModule, ClrOptionItems]
    }]
  }], function() {
    return [];
  }, null);
})();
var ClrInputContainer = class extends ClrAbstractContainer {
};
ClrInputContainer.ɵfac = /* @__PURE__ */ (() => {
  let ɵClrInputContainer_BaseFactory;
  return function ClrInputContainer_Factory(t3) {
    return (ɵClrInputContainer_BaseFactory || (ɵClrInputContainer_BaseFactory = ɵɵgetInheritedFactory(ClrInputContainer)))(t3 || ClrInputContainer);
  };
})();
ClrInputContainer.ɵcmp = ɵɵdefineComponent({
  type: ClrInputContainer,
  selectors: [["clr-input-container"]],
  hostVars: 6,
  hostBindings: function ClrInputContainer_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("clr-form-control", true)("clr-form-control-disabled", ctx.control == null ? null : ctx.control.disabled)("clr-row", ctx.addGrid());
    }
  },
  features: [ɵɵProvidersFeature([IfControlStateService, NgControlService, ControlIdService, ControlClassService]), ɵɵInheritDefinitionFeature],
  ngContentSelectors: _c24,
  decls: 10,
  vars: 7,
  consts: [[4, "ngIf"], [1, "clr-control-container", 3, "ngClass"], [1, "clr-input-wrapper"], ["class", "clr-validate-icon", "shape", "exclamation-circle", "status", "danger", "aria-hidden", "true", 4, "ngIf"], ["class", "clr-validate-icon", "shape", "check-circle", "status", "success", "aria-hidden", "true", 4, "ngIf"], ["shape", "exclamation-circle", "status", "danger", "aria-hidden", "true", 1, "clr-validate-icon"], ["shape", "check-circle", "status", "success", "aria-hidden", "true", 1, "clr-validate-icon"]],
  template: function ClrInputContainer_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c23);
      ɵɵprojection(0);
      ɵɵtemplate(1, ClrInputContainer_label_1_Template, 1, 0, "label", 0);
      ɵɵelementStart(2, "div", 1)(3, "div", 2);
      ɵɵprojection(4, 1);
      ɵɵtemplate(5, ClrInputContainer_cds_icon_5_Template, 1, 0, "cds-icon", 3)(6, ClrInputContainer_cds_icon_6_Template, 1, 0, "cds-icon", 4);
      ɵɵelementEnd();
      ɵɵtemplate(7, ClrInputContainer_ng_content_7_Template, 1, 0, "ng-content", 0)(8, ClrInputContainer_ng_content_8_Template, 1, 0, "ng-content", 0)(9, ClrInputContainer_ng_content_9_Template, 1, 0, "ng-content", 0);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.label && ctx.addGrid());
      ɵɵadvance();
      ɵɵproperty("ngClass", ctx.controlClass());
      ɵɵadvance(3);
      ɵɵproperty("ngIf", ctx.showInvalid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showValid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showHelper);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showInvalid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showValid);
    }
  },
  dependencies: [NgClass, NgIf, CdsIconCustomTag, ClrLabel],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrInputContainer, [{
    type: Component,
    args: [{
      selector: "clr-input-container",
      template: `
    <ng-content select="label"></ng-content>
    <label *ngIf="!label && addGrid()"></label>
    <div class="clr-control-container" [ngClass]="controlClass()">
      <div class="clr-input-wrapper">
        <ng-content select="[clrInput]"></ng-content>
        <cds-icon
          *ngIf="showInvalid"
          class="clr-validate-icon"
          shape="exclamation-circle"
          status="danger"
          aria-hidden="true"
        ></cds-icon>
        <cds-icon
          *ngIf="showValid"
          class="clr-validate-icon"
          shape="check-circle"
          status="success"
          aria-hidden="true"
        ></cds-icon>
      </div>
      <ng-content select="clr-control-helper" *ngIf="showHelper"></ng-content>
      <ng-content select="clr-control-error" *ngIf="showInvalid"></ng-content>
      <ng-content select="clr-control-success" *ngIf="showValid"></ng-content>
    </div>
  `,
      host: {
        "[class.clr-form-control]": "true",
        "[class.clr-form-control-disabled]": "control?.disabled",
        "[class.clr-row]": "addGrid()"
      },
      providers: [IfControlStateService, NgControlService, ControlIdService, ControlClassService]
    }]
  }], null, null);
})();
var ClrInput = class extends WrappedFormControl {
  constructor(vcr, injector, control, renderer, el) {
    super(vcr, ClrInputContainer, injector, control, renderer, el);
    this.index = 1;
  }
};
ClrInput.ɵfac = function ClrInput_Factory(t3) {
  return new (t3 || ClrInput)(ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(NgControl, 10), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef));
};
ClrInput.ɵdir = ɵɵdefineDirective({
  type: ClrInput,
  selectors: [["", "clrInput", ""]],
  hostVars: 2,
  hostBindings: function ClrInput_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("clr-input", true);
    }
  },
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrInput, [{
    type: Directive,
    args: [{
      selector: "[clrInput]",
      host: {
        "[class.clr-input]": "true"
      }
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }, {
      type: Injector
    }, {
      type: NgControl,
      decorators: [{
        type: Self
      }, {
        type: Optional
      }]
    }, {
      type: Renderer2
    }, {
      type: ElementRef
    }];
  }, null);
})();
var ClrInputModule = class {
  constructor() {
    r.addIcons(
      e3,
      l
      // caret
    );
  }
};
ClrInputModule.ɵfac = function ClrInputModule_Factory(t3) {
  return new (t3 || ClrInputModule)();
};
ClrInputModule.ɵmod = ɵɵdefineNgModule({
  type: ClrInputModule,
  declarations: [ClrInput, ClrInputContainer],
  imports: [CommonModule, FormsModule, ClrIconModule, ClrCommonFormsModule],
  exports: [ClrCommonFormsModule, ClrInput, ClrInputContainer]
});
ClrInputModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, FormsModule, ClrIconModule, ClrCommonFormsModule, ClrCommonFormsModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrInputModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, FormsModule, ClrIconModule, ClrCommonFormsModule],
      declarations: [ClrInput, ClrInputContainer],
      exports: [ClrCommonFormsModule, ClrInput, ClrInputContainer]
    }]
  }], function() {
    return [];
  }, null);
})();
var counter = 0;
var DatalistIdService = class {
  constructor() {
    this._id = "clr-datalist-" + ++counter;
    this._idChange = new BehaviorSubject(this._id);
  }
  get id() {
    return this._id;
  }
  set id(value) {
    this._id = value;
    this._idChange.next(value);
  }
  get idChange() {
    return this._idChange.asObservable();
  }
};
DatalistIdService.ɵfac = function DatalistIdService_Factory(t3) {
  return new (t3 || DatalistIdService)();
};
DatalistIdService.ɵprov = ɵɵdefineInjectable({
  token: DatalistIdService,
  factory: DatalistIdService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DatalistIdService, [{
    type: Injectable
  }], null, null);
})();
var ClrDatalist = class {
  constructor(datalistIdService) {
    this.datalistIdService = datalistIdService;
    this.subscriptions = [];
  }
  set id(idValue) {
    if (!!idValue && this.datalistIdService) {
      this.datalistId = idValue;
      this.datalistIdService.id = idValue;
    } else if (idValue) {
      this.datalistId = idValue;
    }
  }
  ngAfterContentInit() {
    if (!this.datalistIdService) {
      return;
    }
    this.subscriptions.push(this.datalistIdService.idChange.subscribe((id) => this.datalistId = id));
  }
  ngOnDestroy() {
    this.subscriptions.forEach((sub) => sub.unsubscribe());
  }
};
ClrDatalist.ɵfac = function ClrDatalist_Factory(t3) {
  return new (t3 || ClrDatalist)(ɵɵdirectiveInject(DatalistIdService, 8));
};
ClrDatalist.ɵdir = ɵɵdefineDirective({
  type: ClrDatalist,
  selectors: [["datalist"]],
  hostVars: 1,
  hostBindings: function ClrDatalist_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵhostProperty("id", ctx.datalistId);
    }
  },
  inputs: {
    id: "id"
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDatalist, [{
    type: Directive,
    args: [{
      selector: "datalist",
      host: {
        "[id]": "datalistId"
      }
    }]
  }], function() {
    return [{
      type: DatalistIdService,
      decorators: [{
        type: Optional
      }]
    }];
  }, {
    id: [{
      type: Input
    }]
  });
})();
var FocusService2 = class {
  constructor() {
    this._focused = new BehaviorSubject(false);
  }
  get focusChange() {
    return this._focused.asObservable();
  }
  set focused(state2) {
    this._focused.next(state2);
  }
};
FocusService2.ɵfac = function FocusService_Factory(t3) {
  return new (t3 || FocusService2)();
};
FocusService2.ɵprov = ɵɵdefineInjectable({
  token: FocusService2,
  factory: FocusService2.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FocusService2, [{
    type: Injectable
  }], null, null);
})();
var ClrDatalistContainer = class extends ClrAbstractContainer {
  constructor(controlClassService, layoutService, ngControlService, focusService, ifControlStateService) {
    super(ifControlStateService, layoutService, controlClassService, ngControlService);
    this.focusService = focusService;
    this.ifControlStateService = ifControlStateService;
    this.focus = false;
    this.subscriptions.push(this.focusService.focusChange.subscribe((state2) => this.focus = state2));
  }
};
ClrDatalistContainer.ɵfac = function ClrDatalistContainer_Factory(t3) {
  return new (t3 || ClrDatalistContainer)(ɵɵdirectiveInject(ControlClassService), ɵɵdirectiveInject(LayoutService, 8), ɵɵdirectiveInject(NgControlService), ɵɵdirectiveInject(FocusService2), ɵɵdirectiveInject(IfControlStateService));
};
ClrDatalistContainer.ɵcmp = ɵɵdefineComponent({
  type: ClrDatalistContainer,
  selectors: [["clr-datalist-container"]],
  hostVars: 6,
  hostBindings: function ClrDatalistContainer_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("clr-form-control", true)("clr-form-control-disabled", ctx.control == null ? null : ctx.control.disabled)("clr-row", ctx.addGrid());
    }
  },
  features: [ɵɵProvidersFeature([ControlClassService, ControlIdService, FocusService2, NgControlService, DatalistIdService, IfControlStateService]), ɵɵInheritDefinitionFeature],
  ngContentSelectors: _c26,
  decls: 13,
  vars: 9,
  consts: [[4, "ngIf"], [1, "clr-control-container", 3, "ngClass"], [1, "clr-input-wrapper"], [1, "clr-input-group"], ["shape", "angle", "direction", "down", 1, "clr-datalist-caret"], ["class", "clr-validate-icon", "shape", "exclamation-circle", "status", "danger", "aria-hidden", "true", 4, "ngIf"], ["class", "clr-validate-icon", "shape", "check-circle", "status", "success", "aria-hidden", "true", 4, "ngIf"], ["shape", "exclamation-circle", "status", "danger", "aria-hidden", "true", 1, "clr-validate-icon"], ["shape", "check-circle", "status", "success", "aria-hidden", "true", 1, "clr-validate-icon"]],
  template: function ClrDatalistContainer_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c25);
      ɵɵprojection(0);
      ɵɵtemplate(1, ClrDatalistContainer_label_1_Template, 1, 0, "label", 0);
      ɵɵelementStart(2, "div", 1)(3, "div", 2)(4, "div", 3);
      ɵɵprojection(5, 1);
      ɵɵprojection(6, 2);
      ɵɵelement(7, "cds-icon", 4);
      ɵɵelementEnd();
      ɵɵtemplate(8, ClrDatalistContainer_cds_icon_8_Template, 1, 0, "cds-icon", 5)(9, ClrDatalistContainer_cds_icon_9_Template, 1, 0, "cds-icon", 6);
      ɵɵelementEnd();
      ɵɵtemplate(10, ClrDatalistContainer_ng_content_10_Template, 1, 0, "ng-content", 0)(11, ClrDatalistContainer_ng_content_11_Template, 1, 0, "ng-content", 0)(12, ClrDatalistContainer_ng_content_12_Template, 1, 0, "ng-content", 0);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.label && ctx.addGrid());
      ɵɵadvance();
      ɵɵproperty("ngClass", ctx.controlClass());
      ɵɵadvance(2);
      ɵɵclassProp("clr-focus", ctx.focus);
      ɵɵadvance(4);
      ɵɵproperty("ngIf", ctx.showInvalid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showValid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showHelper);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showInvalid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showValid);
    }
  },
  dependencies: [NgClass, NgIf, ClrLabel, CdsIconCustomTag],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDatalistContainer, [{
    type: Component,
    args: [{
      selector: "clr-datalist-container",
      template: `
    <ng-content select="label"></ng-content>
    <label *ngIf="!label && addGrid()"></label>
    <div class="clr-control-container" [ngClass]="controlClass()">
      <div class="clr-input-wrapper">
        <div class="clr-input-group" [class.clr-focus]="focus">
          <ng-content select="[clrDatalistInput]"></ng-content>
          <ng-content select="datalist"></ng-content>
          <cds-icon shape="angle" class="clr-datalist-caret" direction="down"></cds-icon>
        </div>
        <cds-icon
          *ngIf="showInvalid"
          class="clr-validate-icon"
          shape="exclamation-circle"
          status="danger"
          aria-hidden="true"
        ></cds-icon>
        <cds-icon
          *ngIf="showValid"
          class="clr-validate-icon"
          shape="check-circle"
          status="success"
          aria-hidden="true"
        ></cds-icon>
      </div>
      <ng-content select="clr-control-helper" *ngIf="showHelper"></ng-content>
      <ng-content select="clr-control-error" *ngIf="showInvalid"></ng-content>
      <ng-content select="clr-control-success" *ngIf="showValid"></ng-content>
    </div>
  `,
      host: {
        "[class.clr-form-control]": "true",
        "[class.clr-form-control-disabled]": "control?.disabled",
        "[class.clr-row]": "addGrid()"
      },
      providers: [ControlClassService, ControlIdService, FocusService2, NgControlService, DatalistIdService, IfControlStateService]
    }]
  }], function() {
    return [{
      type: ControlClassService
    }, {
      type: LayoutService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: NgControlService
    }, {
      type: FocusService2
    }, {
      type: IfControlStateService
    }];
  }, null);
})();
var ClrDatalistInput = class extends WrappedFormControl {
  constructor(focusService, vcr, injector, control, renderer, el, datalistIdService) {
    super(vcr, ClrDatalistContainer, injector, control, renderer, el);
    this.focusService = focusService;
    this.datalistIdService = datalistIdService;
    if (!this.focusService) {
      throw new Error("clrDatalist requires being wrapped in <clr-datalist-container>");
    }
  }
  ngAfterContentInit() {
    this.subscriptions.push(this.datalistIdService.idChange.subscribe((id) => this.listValue = id));
  }
  triggerFocus() {
    if (this.focusService) {
      this.focusService.focused = true;
    }
  }
  triggerValidation() {
    super.triggerValidation();
    if (this.focusService) {
      this.focusService.focused = false;
    }
  }
};
ClrDatalistInput.ɵfac = function ClrDatalistInput_Factory(t3) {
  return new (t3 || ClrDatalistInput)(ɵɵdirectiveInject(FocusService2, 8), ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(NgControl, 10), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(DatalistIdService));
};
ClrDatalistInput.ɵdir = ɵɵdefineDirective({
  type: ClrDatalistInput,
  selectors: [["", "clrDatalistInput", ""]],
  hostVars: 3,
  hostBindings: function ClrDatalistInput_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("focus", function ClrDatalistInput_focus_HostBindingHandler() {
        return ctx.triggerFocus();
      })("blur", function ClrDatalistInput_blur_HostBindingHandler() {
        return ctx.triggerValidation();
      });
    }
    if (rf & 2) {
      ɵɵattribute("list", ctx.listValue);
      ɵɵclassProp("clr-input", true);
    }
  },
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDatalistInput, [{
    type: Directive,
    args: [{
      selector: "[clrDatalistInput]",
      host: {
        "[class.clr-input]": "true",
        "[attr.list]": "listValue"
      }
    }]
  }], function() {
    return [{
      type: FocusService2,
      decorators: [{
        type: Optional
      }]
    }, {
      type: ViewContainerRef
    }, {
      type: Injector
    }, {
      type: NgControl,
      decorators: [{
        type: Self
      }, {
        type: Optional
      }]
    }, {
      type: Renderer2
    }, {
      type: ElementRef
    }, {
      type: DatalistIdService
    }];
  }, {
    triggerFocus: [{
      type: HostListener,
      args: ["focus"]
    }],
    triggerValidation: [{
      type: HostListener,
      args: ["blur"]
    }]
  });
})();
var ClrDatalistModule = class {
  constructor() {
    r.addIcons(e3, l);
  }
};
ClrDatalistModule.ɵfac = function ClrDatalistModule_Factory(t3) {
  return new (t3 || ClrDatalistModule)();
};
ClrDatalistModule.ɵmod = ɵɵdefineNgModule({
  type: ClrDatalistModule,
  declarations: [ClrDatalist, ClrDatalistInput, ClrDatalistContainer],
  imports: [CommonModule, ClrInputModule, ClrIconModule],
  exports: [ClrDatalist, ClrDatalistInput, ClrDatalistContainer]
});
ClrDatalistModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, ClrInputModule, ClrIconModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDatalistModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, ClrInputModule, ClrIconModule],
      declarations: [ClrDatalist, ClrDatalistInput, ClrDatalistContainer],
      exports: [ClrDatalist, ClrDatalistInput, ClrDatalistContainer]
    }]
  }], function() {
    return [];
  }, null);
})();
var CdkTrapFocusModule_CdkTrapFocus = class extends CdkTrapFocus {
  /**
   * Include the constructor to forward all the dependencies to the base class
   * as a workaround to fix Angular "ɵɵinvalidFactoryDep" error after upgrading storybook
   * https://github.com/storybookjs/storybook/issues/23534
   */
  constructor(elementRef, focusTrapFactory, document2) {
    super(elementRef, focusTrapFactory, document2);
  }
};
CdkTrapFocusModule_CdkTrapFocus.ɵfac = function CdkTrapFocusModule_CdkTrapFocus_Factory(t3) {
  return new (t3 || CdkTrapFocusModule_CdkTrapFocus)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(FocusTrapFactory), ɵɵdirectiveInject(DOCUMENT, 8));
};
CdkTrapFocusModule_CdkTrapFocus.ɵdir = ɵɵdefineDirective({
  type: CdkTrapFocusModule_CdkTrapFocus,
  selectors: [["", "cdkTrapFocus", ""]],
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkTrapFocusModule_CdkTrapFocus, [{
    type: Directive,
    args: [{
      selector: "[cdkTrapFocus]"
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: FocusTrapFactory
    }, {
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [DOCUMENT]
      }]
    }];
  }, null);
})();
var CdkTrapFocusModule = class {
};
CdkTrapFocusModule.ɵfac = function CdkTrapFocusModule_Factory(t3) {
  return new (t3 || CdkTrapFocusModule)();
};
CdkTrapFocusModule.ɵmod = ɵɵdefineNgModule({
  type: CdkTrapFocusModule,
  declarations: [CdkTrapFocusModule_CdkTrapFocus],
  exports: [CdkTrapFocusModule_CdkTrapFocus]
});
CdkTrapFocusModule.ɵinj = ɵɵdefineInjector({});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkTrapFocusModule, [{
    type: NgModule,
    args: [{
      declarations: [CdkTrapFocusModule_CdkTrapFocus],
      exports: [CdkTrapFocusModule_CdkTrapFocus]
    }]
  }], null, null);
})();
var DEFAULT_LOCALE_FORMAT = "dd/MM/y";
var LITTLE_ENDIAN_REGEX = /d+.+m+.+y+/i;
var MIDDLE_ENDIAN_REGEX = /m+.+d+.+y+/i;
var DELIMITER_REGEX = /d+|m+|y+/i;
var USER_INPUT_REGEX = /\d+/g;
var MOBILE_USERAGENT_REGEX = /Mobi/i;
var RTL_REGEX = /\u200f/g;
var YEAR = "YYYY";
var MONTH = "MM";
var DATE = "DD";
var LITTLE_ENDIAN = {
  name: "LITTLE_ENDIAN",
  format: [DATE, MONTH, YEAR]
};
var MIDDLE_ENDIAN = {
  name: "MIDDLE_ENDIAN",
  format: [MONTH, DATE, YEAR]
};
var BIG_ENDIAN = {
  name: "BIG_ENDIAN",
  format: [YEAR, MONTH, DATE]
};
var NO_OF_DAYS_IN_A_WEEK = 7;
var NO_OF_ROWS_IN_CALENDAR_VIEW = 6;
var TOTAL_DAYS_IN_DAYS_VIEW = NO_OF_DAYS_IN_A_WEEK * NO_OF_ROWS_IN_CALENDAR_VIEW;
function getNumberOfDaysInTheMonth(year, month) {
  return new Date(year, month + 1, 0).getDate();
}
function getDay(year, month, date) {
  return new Date(year, month, date).getDay();
}
function parseToFourDigitYear(year) {
  if (year > 9999 || year > 100 && year < 999 || year < 10) {
    return -1;
  }
  if (year > 999) {
    return year;
  }
  const currYear = (/* @__PURE__ */ new Date()).getFullYear();
  const century = Math.floor(currYear / 100) * 100;
  let result = year + century;
  if (result > currYear + 20) {
    result = result - 100;
  }
  return result;
}
function datesAreEqual(date1, date2) {
  if (date1 instanceof Date && date2 instanceof Date) {
    return date1.getFullYear() === date2.getFullYear() && date1.getMonth() === date2.getMonth() && date1.getDate() === date2.getDate();
  } else {
    return false;
  }
}
var DayViewModel = class {
  constructor(dayModel, isTodaysDate = false, isExcluded = false, isDisabled = false, isSelected = false, isFocusable = false) {
    this.dayModel = dayModel;
    this.isTodaysDate = isTodaysDate;
    this.isExcluded = isExcluded;
    this.isDisabled = isDisabled;
    this.isSelected = isSelected;
    this.isFocusable = isFocusable;
  }
  /**
   * Gets the tab index based on the isFocusable flag.
   */
  get tabIndex() {
    return this.isFocusable ? 0 : -1;
  }
};
var DayModel = class _DayModel {
  constructor(year, month, date) {
    this.year = year;
    this.month = month;
    this.date = date;
  }
  /**
   * Checks if the passed CalendarDate is equal to itself.
   */
  isEqual(day) {
    if (day) {
      return this.year === day.year && this.month === day.month && this.date === day.date;
    }
    return false;
  }
  toDate() {
    return new Date(this.year, this.month, this.date);
  }
  /**
   * Returns a new DayModel which is incremented based on the value passed.
   */
  incrementBy(value) {
    const date = new Date(this.year, this.month, this.date + value);
    return new _DayModel(date.getFullYear(), date.getMonth(), date.getDate());
  }
  /**
   * Clones the current day model.
   */
  clone() {
    return new _DayModel(this.year, this.month, this.date);
  }
  toComparisonString() {
    return `${this.year}${this.pad(this.month)}${this.pad(this.date)}`;
  }
  toDateString() {
    return this.toDate().toLocaleDateString(void 0, {
      weekday: "long",
      month: "long",
      day: "numeric",
      year: "numeric"
    });
  }
  pad(num) {
    return num < 10 ? `0${num}` : `${num}`;
  }
};
var CalendarViewModel = class {
  constructor(calendar, selectedDay, focusableDay, today, firstDayOfWeek, excludedDates) {
    this.calendar = calendar;
    this.selectedDay = selectedDay;
    this.focusableDay = focusableDay;
    this.today = today;
    this.firstDayOfWeek = firstDayOfWeek;
    this.excludedDates = excludedDates;
    this.currMonthDayViews = [];
    this.initializeCalendarView();
  }
  /**
   * DayViewModel matrix. Size 6x7
   */
  get calendarView() {
    return this._calendarView;
  }
  /**
   * Updates the focusable day in the calendar.
   */
  updateFocusableDay(day) {
    this.setFocusableFlag(this.focusableDay, false);
    this.setFocusableFlag(day, true);
    this.focusableDay = day;
  }
  /**
   * Generates a 6x7 matrix of DayViewModel based on the Calendar.
   * The 6x7 matrix is structured according to the first day of the week.
   * 6 rows to accommodate months which might have dates spanning over 6 weeks.
   * 7 columns because there are 7 days in a week :P :D
   */
  initializeCalendarView() {
    const prevMonthCalendar = this.calendar.previousMonth();
    const nextMonthCalendar = this.calendar.nextMonth();
    const daysFromPrevMonthInCalView = this.numDaysFromPrevMonthInCalView(this.calendar.year, this.calendar.month);
    const daysFromNextMonthInCalView = TOTAL_DAYS_IN_DAYS_VIEW - (this.calendar.days.length + daysFromPrevMonthInCalView);
    let prevMonthDayViews = [];
    let nextMonthDayViews = [];
    if (daysFromPrevMonthInCalView > 0) {
      prevMonthDayViews = this.generateDayViewModels(prevMonthCalendar.days.slice(-1 * daysFromPrevMonthInCalView), true, false);
    }
    this.currMonthDayViews = this.generateDayViewModels(this.calendar.days, false, true);
    if (daysFromNextMonthInCalView > 0) {
      nextMonthDayViews = this.generateDayViewModels(nextMonthCalendar.days.slice(0, daysFromNextMonthInCalView), true, false);
    }
    this._calendarView = this.generateCalendarView(prevMonthDayViews, this.currMonthDayViews, nextMonthDayViews);
    this.initializeSelectedDay();
    this.initializeFocusableDay();
  }
  isDateExcluded(date) {
    const {
      minDate,
      maxDate
    } = this.excludedDates;
    const from = minDate.toComparisonString();
    const to = maxDate.toComparisonString();
    const today = date.toComparisonString();
    return !(today >= from && today <= to);
  }
  /**
   * Generates a DayViewModel array based on the DayModel passed
   */
  generateDayViewModels(days, isExcluded, isCurrentCalendar) {
    const dayViews = days.map((day) => {
      return new DayViewModel(day, false, isExcluded, this.isDateExcluded(day), false, false);
    });
    if (isCurrentCalendar && this.calendar.isDayInCalendar(this.today)) {
      dayViews[this.today.date - 1].isTodaysDate = true;
    }
    return dayViews;
  }
  /**
   * Gets the first day of the current month to figure out how many dates of previous month
   * are needed to complete the Calendar View based on the first day of the week.
   * eg: Assuming locale en-US, the first day of the week is Sunday,
   * if first day of the current month lands on Wednesday, then
   * (this.getDay function would return 3 since
   * first day of the week is 0), we need the 3 days from the previous month.
   */
  numDaysFromPrevMonthInCalView(currentYear, currentMonth) {
    const firstDayOfCurrMonth = getDay(currentYear, currentMonth, 1);
    if (firstDayOfCurrMonth >= this.firstDayOfWeek) {
      return firstDayOfCurrMonth - this.firstDayOfWeek;
    } else {
      return NO_OF_DAYS_IN_A_WEEK + firstDayOfCurrMonth - this.firstDayOfWeek;
    }
  }
  /**
   * Checks if the Day passed is in the CalendarView.
   */
  isDayInCalendarView(day) {
    if (!this.calendar.isDayInCalendar(day)) {
      return false;
    }
    return true;
  }
  /**
   * Using the DayViewModels from the previous, current and next month, this function
   * generates the CalendarView.
   */
  generateCalendarView(prev, curr, next) {
    const combinationArr = [...prev, ...curr, ...next];
    const calendarView = [];
    for (let i2 = 0; i2 < NO_OF_ROWS_IN_CALENDAR_VIEW; i2++) {
      calendarView[i2] = combinationArr.slice(i2 * NO_OF_DAYS_IN_A_WEEK, (i2 + 1) * NO_OF_DAYS_IN_A_WEEK);
    }
    return calendarView;
  }
  /**
   * Initialize the selected day if the day is in the calendar.
   */
  initializeSelectedDay() {
    if (this.selectedDay && this.isDayInCalendarView(this.selectedDay)) {
      this.currMonthDayViews[this.selectedDay.date - 1].isSelected = true;
    }
  }
  /**
   * Initializes the focusable day if the day is in the calendar. If focusable day is not set, then
   * we check for the selected day. If selected day is not set then check if today is in the current
   * calendar. If not then just set the 15th of the current calendar month.
   */
  initializeFocusableDay() {
    if (this.focusableDay && this.isDayInCalendarView(this.focusableDay)) {
      this.setFocusableFlag(this.focusableDay, true);
    } else if (this.selectedDay && this.isDayInCalendarView(this.selectedDay)) {
      this.setFocusableFlag(this.selectedDay, true);
      this.focusableDay = this.selectedDay.clone();
    } else if (this.isDayInCalendarView(this.today)) {
      this.setFocusableFlag(this.today, true);
      this.focusableDay = this.today.clone();
    } else {
      this.focusableDay = new DayModel(this.calendar.year, this.calendar.month, 15);
      this.setFocusableFlag(this.focusableDay, true);
    }
  }
  setFocusableFlag(day, flag) {
    if (day) {
      this.currMonthDayViews[day.date - 1].isFocusable = flag;
    }
  }
};
var LocaleHelperService = class {
  constructor(locale) {
    this.locale = locale;
    this._firstDayOfWeek = 0;
    this.initializeLocaleData();
  }
  get firstDayOfWeek() {
    return this._firstDayOfWeek;
  }
  get localeDays() {
    return this._localeDays;
  }
  // leave for backward compatibility
  get localeDaysNarrow() {
    return this._localeDays.map((day) => day.narrow);
  }
  get localeMonthsAbbreviated() {
    return this._localeMonthsAbbreviated;
  }
  get localeMonthsWide() {
    return this._localeMonthsWide;
  }
  get localeDateFormat() {
    return this._localeDateFormat;
  }
  /**
   * Initializes the locale data.
   */
  initializeLocaleData() {
    this.initializeFirstDayOfWeek();
    this.initializeLocaleDateFormat();
    this.initializeLocaleMonthsAbbreviated();
    this.initializeLocaleMonthsWide();
    this.initializeLocaleDays();
  }
  /**
   * Initialize day names based on the locale.
   * eg: [{day: Sunday, narrow: S}, {day: Monday, narrow: M}...] for en-US.
   */
  initializeLocaleDays() {
    const tempArr = [];
    const tempWideArr = getLocaleDayNames(this.locale, FormStyle.Standalone, TranslationWidth.Wide).slice();
    const tempNarrowArr = getLocaleDayNames(this.locale, FormStyle.Standalone, TranslationWidth.Narrow).slice();
    const firstDayOfWeek = this.firstDayOfWeek;
    for (let i2 = 0; i2 < 7; i2++) {
      tempArr.push({
        day: tempWideArr[i2],
        narrow: tempNarrowArr[i2]
      });
    }
    if (firstDayOfWeek > 0) {
      const prevDays = tempArr.splice(0, firstDayOfWeek);
      tempArr.push(...prevDays);
    }
    this._localeDays = tempArr;
  }
  /**
   * Initializes the array of month names in the TranslationWidth.Abbreviated format.
   * e.g. `[Jan, Feb, ...]` for en-US
   */
  initializeLocaleMonthsAbbreviated() {
    this._localeMonthsAbbreviated = getLocaleMonthNames(this.locale, FormStyle.Standalone, TranslationWidth.Abbreviated).slice();
  }
  /**
   * Initializes the array of month names in the TranslationWidth.Wide format.
   * e.g. `[January, February, ...]` for en-US
   */
  initializeLocaleMonthsWide() {
    this._localeMonthsWide = getLocaleMonthNames(this.locale, FormStyle.Standalone, TranslationWidth.Wide).slice();
  }
  /**
   * Initializes the first day of the week based on the locale.
   */
  initializeFirstDayOfWeek() {
    this._firstDayOfWeek = getLocaleFirstDayOfWeek(this.locale);
  }
  initializeLocaleDateFormat() {
    this._localeDateFormat = getLocaleDateFormat(this.locale, FormatWidth.Short);
  }
};
LocaleHelperService.ɵfac = function LocaleHelperService_Factory(t3) {
  return new (t3 || LocaleHelperService)(ɵɵinject(LOCALE_ID));
};
LocaleHelperService.ɵprov = ɵɵdefineInjectable({
  token: LocaleHelperService,
  factory: LocaleHelperService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LocaleHelperService, [{
    type: Injectable
  }], function() {
    return [{
      type: void 0,
      decorators: [{
        type: Inject,
        args: [LOCALE_ID]
      }]
    }];
  }, null);
})();
var CalendarModel = class _CalendarModel {
  constructor(year, month) {
    this.year = year;
    this.month = month;
    this.initializeDaysInCalendar();
  }
  /**
   * Checks if the calendar passed is equal to the current calendar.
   */
  isEqual(calendar) {
    if (calendar) {
      return this.year === calendar.year && this.month === calendar.month;
    }
    return false;
  }
  /**
   * Checks if a DayModel is in the Calendar
   */
  isDayInCalendar(day) {
    if (day) {
      return this.year === day.year && this.month === day.month;
    }
    return false;
  }
  /**
   * Returns CalendarModel of the previous month.
   */
  previousMonth() {
    if (this.month === 0) {
      return new _CalendarModel(this.year - 1, 11);
    } else {
      return new _CalendarModel(this.year, this.month - 1);
    }
  }
  /**
   * Returns CalendarModel of the next month.
   */
  nextMonth() {
    if (this.month === 11) {
      return new _CalendarModel(this.year + 1, 0);
    } else {
      return new _CalendarModel(this.year, this.month + 1);
    }
  }
  /**
   * Populates the days array with the DayModels in the current Calendar.
   */
  initializeDaysInCalendar() {
    const noOfDaysInCalendar = getNumberOfDaysInTheMonth(this.year, this.month);
    this.days = Array(noOfDaysInCalendar).fill(null).map((_date, index) => {
      return new DayModel(this.year, this.month, index + 1);
    });
  }
};
var DateNavigationService = class {
  constructor() {
    this._todaysFullDate = /* @__PURE__ */ new Date();
    this._selectedDayChange = new Subject();
    this._displayedCalendarChange = new Subject();
    this._focusOnCalendarChange = new Subject();
    this._focusedDayChange = new Subject();
  }
  get today() {
    return this._today;
  }
  get displayedCalendar() {
    return this._displayedCalendar;
  }
  get selectedDayChange() {
    return this._selectedDayChange.asObservable();
  }
  /**
   * This observable lets the subscriber know that the displayed calendar has changed.
   */
  get displayedCalendarChange() {
    return this._displayedCalendarChange.asObservable();
  }
  /**
   * This observable lets the subscriber know that the focus should be applied on the calendar.
   */
  get focusOnCalendarChange() {
    return this._focusOnCalendarChange.asObservable();
  }
  /**
   * This observable lets the subscriber know that the focused day in the displayed calendar has changed.
   */
  get focusedDayChange() {
    return this._focusedDayChange.asObservable();
  }
  /**
   * Notifies that the selected day has changed so that the date can be emitted to the user.
   * Note: Only to be called from day.ts
   */
  notifySelectedDayChanged(dayModel) {
    this.selectedDay = dayModel;
    this._selectedDayChange.next(dayModel);
  }
  /**
   * Initializes the calendar based on the selected day.
   */
  initializeCalendar() {
    this.focusedDay = null;
    this.initializeTodaysDate();
    if (this.selectedDay) {
      this._displayedCalendar = new CalendarModel(this.selectedDay.year, this.selectedDay.month);
    } else {
      this._displayedCalendar = new CalendarModel(this.today.year, this.today.month);
    }
  }
  changeMonth(month) {
    this.setDisplayedCalendar(new CalendarModel(this._displayedCalendar.year, month));
  }
  changeYear(year) {
    this.setDisplayedCalendar(new CalendarModel(year, this._displayedCalendar.month));
  }
  /**
   * Moves the displayed calendar to the next month.
   */
  moveToNextMonth() {
    this.setDisplayedCalendar(this._displayedCalendar.nextMonth());
  }
  /**
   * Moves the displayed calendar to the previous month.
   */
  moveToPreviousMonth() {
    this.setDisplayedCalendar(this._displayedCalendar.previousMonth());
  }
  /**
   * Moves the displayed calendar to the current month and year.
   */
  moveToCurrentMonth() {
    if (!this.displayedCalendar.isDayInCalendar(this.today)) {
      this.setDisplayedCalendar(new CalendarModel(this.today.year, this.today.month));
    }
    this._focusOnCalendarChange.next();
  }
  incrementFocusDay(value) {
    this.focusedDay = this.focusedDay.incrementBy(value);
    if (this._displayedCalendar.isDayInCalendar(this.focusedDay)) {
      this._focusedDayChange.next(this.focusedDay);
    } else {
      this.setDisplayedCalendar(new CalendarModel(this.focusedDay.year, this.focusedDay.month));
    }
    this._focusOnCalendarChange.next();
  }
  // not a setter because i want this to remain private
  setDisplayedCalendar(value) {
    if (!this._displayedCalendar.isEqual(value)) {
      this._displayedCalendar = value;
      this._displayedCalendarChange.next();
    }
  }
  initializeTodaysDate() {
    this._todaysFullDate = /* @__PURE__ */ new Date();
    this._today = new DayModel(this._todaysFullDate.getFullYear(), this._todaysFullDate.getMonth(), this._todaysFullDate.getDate());
  }
};
DateNavigationService.ɵfac = function DateNavigationService_Factory(t3) {
  return new (t3 || DateNavigationService)();
};
DateNavigationService.ɵprov = ɵɵdefineInjectable({
  token: DateNavigationService,
  factory: DateNavigationService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateNavigationService, [{
    type: Injectable
  }], null, null);
})();
var DatepickerFocusService = class {
  constructor(_ngZone, platformId) {
    this._ngZone = _ngZone;
    this.platformId = platformId;
  }
  focusCell(elRef) {
    this._ngZone.runOutsideAngular(() => {
      this.ngZoneIsStableInBrowser().subscribe(() => {
        const focusEl = elRef.nativeElement.querySelector('[tabindex="0"]');
        if (focusEl) {
          focusEl.focus();
        }
      });
    });
  }
  focusInput(element) {
    this._ngZone.runOutsideAngular(() => this.ngZoneIsStableInBrowser().subscribe(() => element.focus()));
  }
  elementIsFocused(element) {
    return isPlatformBrowser(this.platformId) && document.activeElement === element;
  }
  ngZoneIsStableInBrowser() {
    return this._ngZone.onStable.asObservable().pipe(first(), filter(() => isPlatformBrowser(this.platformId)));
  }
};
DatepickerFocusService.ɵfac = function DatepickerFocusService_Factory(t3) {
  return new (t3 || DatepickerFocusService)(ɵɵinject(NgZone), ɵɵinject(PLATFORM_ID));
};
DatepickerFocusService.ɵprov = ɵɵdefineInjectable({
  token: DatepickerFocusService,
  factory: DatepickerFocusService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DatepickerFocusService, [{
    type: Injectable
  }], function() {
    return [{
      type: NgZone
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [PLATFORM_ID]
      }]
    }];
  }, null);
})();
var DateIOService = class {
  constructor(_localeHelperService) {
    this._localeHelperService = _localeHelperService;
    this.disabledDates = {
      // This is the default range. It approximates the beginning of time to the end of time.
      // Unless a minDate or maxDate is set with the native HTML5 api the range is all dates
      // TODO: turn this into an Array of min/max ranges that allow configuration of multiple ranges.
      minDate: new DayModel(0, 0, 1),
      maxDate: new DayModel(9999, 11, 31)
    };
    this.cldrLocaleDateFormat = DEFAULT_LOCALE_FORMAT;
    this.localeDisplayFormat = LITTLE_ENDIAN;
    this.delimiters = ["/", "/"];
    this.cldrLocaleDateFormat = this._localeHelperService.localeDateFormat;
    this.initializeLocaleDisplayFormat();
  }
  get placeholderText() {
    const format = this.localeDisplayFormat.format;
    return format[0] + this.delimiters[0] + format[1] + this.delimiters[1] + format[2];
  }
  setMinDate(date) {
    if (!date) {
      this.disabledDates.minDate = new DayModel(0, 0, 1);
    } else {
      const [year, month, day] = date.split("-").map((n4) => parseInt(n4, 10));
      this.disabledDates.minDate = new DayModel(year, month - 1, day);
    }
  }
  setMaxDate(date) {
    if (!date) {
      this.disabledDates.maxDate = new DayModel(9999, 11, 31);
    } else {
      const [year, month, day] = date.split("-").map((n4) => parseInt(n4, 10));
      this.disabledDates.maxDate = new DayModel(year, month - 1, day);
    }
  }
  toLocaleDisplayFormatString(date) {
    if (date) {
      if (isNaN(date.getTime())) {
        return "";
      }
      const dateNo = date.getDate();
      const monthNo = date.getMonth() + 1;
      const dateStr = dateNo > 9 ? dateNo.toString() : "0" + dateNo;
      const monthStr = monthNo > 9 ? monthNo.toString() : "0" + monthNo;
      if (this.localeDisplayFormat === LITTLE_ENDIAN) {
        return dateStr + this.delimiters[0] + monthStr + this.delimiters[1] + date.getFullYear();
      } else if (this.localeDisplayFormat === MIDDLE_ENDIAN) {
        return monthStr + this.delimiters[0] + dateStr + this.delimiters[1] + date.getFullYear();
      } else {
        return date.getFullYear() + this.delimiters[0] + monthStr + this.delimiters[1] + dateStr;
      }
    }
    return "";
  }
  getDateValueFromDateString(date) {
    if (!date || typeof date !== "string") {
      return null;
    }
    const dateParts = date.match(USER_INPUT_REGEX);
    if (!dateParts || dateParts.length !== 3) {
      return null;
    }
    const [firstPart, secondPart, thirdPart] = dateParts;
    if (this.localeDisplayFormat === LITTLE_ENDIAN) {
      return this.validateAndGetDate(thirdPart, secondPart, firstPart);
    } else if (this.localeDisplayFormat === MIDDLE_ENDIAN) {
      return this.validateAndGetDate(thirdPart, firstPart, secondPart);
    } else {
      return this.validateAndGetDate(firstPart, secondPart, thirdPart);
    }
  }
  initializeLocaleDisplayFormat() {
    const format = this.cldrLocaleDateFormat.toLocaleLowerCase();
    if (LITTLE_ENDIAN_REGEX.test(format)) {
      this.localeDisplayFormat = LITTLE_ENDIAN;
    } else if (MIDDLE_ENDIAN_REGEX.test(format)) {
      this.localeDisplayFormat = MIDDLE_ENDIAN;
    } else {
      this.localeDisplayFormat = BIG_ENDIAN;
    }
    this.extractDelimiters();
  }
  extractDelimiters() {
    if (this.cldrLocaleDateFormat) {
      const localeFormat = this.cldrLocaleDateFormat.replace(RTL_REGEX, "");
      const delimiters = localeFormat.split(DELIMITER_REGEX);
      if (delimiters && delimiters.length === 4) {
        this.delimiters = [delimiters[1], delimiters[2]];
      } else {
        console.error("Unexpected date format received. Delimiters extracted: ", delimiters);
      }
    }
  }
  /**
   * Checks if the month entered by the user is valid or not.
   * Note: Month is 0 based.
   */
  isValidMonth(month) {
    return month > -1 && month < 12;
  }
  /**
   * Checks if the date is valid depending on the year and month provided.
   */
  isValidDate(year, month, date) {
    return date > 0 && date <= getNumberOfDaysInTheMonth(year, month);
  }
  /**
   * Validates the parameters provided and returns the date.
   * If the parameters are not
   * valid then return null.
   * NOTE: (Month here is 1 based since the user has provided that as an input)
   */
  validateAndGetDate(year, month, date) {
    const y = +year;
    const m3 = +month - 1;
    const d5 = +date;
    if (!this.isValidMonth(m3) || !this.isValidDate(y, m3, d5)) {
      return null;
    }
    const result = parseToFourDigitYear(y);
    return result !== -1 ? new Date(result, m3, d5) : null;
  }
};
DateIOService.ɵfac = function DateIOService_Factory(t3) {
  return new (t3 || DateIOService)(ɵɵinject(LocaleHelperService));
};
DateIOService.ɵprov = ɵɵdefineInjectable({
  token: DateIOService,
  factory: DateIOService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateIOService, [{
    type: Injectable
  }], function() {
    return [{
      type: LocaleHelperService
    }];
  }, null);
})();
var DateFormControlService = class {
  constructor() {
    this._touchedChange = new Subject();
    this._dirtyChange = new Subject();
  }
  get touchedChange() {
    return this._touchedChange.asObservable();
  }
  get dirtyChange() {
    return this._dirtyChange.asObservable();
  }
  markAsTouched() {
    this._touchedChange.next();
  }
  markAsDirty() {
    this._dirtyChange.next();
  }
  // friendly wrapper
  setDisabled(state2) {
    this.disabled = state2;
  }
};
DateFormControlService.ɵfac = function DateFormControlService_Factory(t3) {
  return new (t3 || DateFormControlService)();
};
DateFormControlService.ɵprov = ɵɵdefineInjectable({
  token: DateFormControlService,
  factory: DateFormControlService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateFormControlService, [{
    type: Injectable
  }], null, null);
})();
var ClrDay = class {
  constructor(_dateNavigationService, _toggleService, dateFormControlService, commonStrings) {
    this._dateNavigationService = _dateNavigationService;
    this._toggleService = _toggleService;
    this.dateFormControlService = dateFormControlService;
    this.commonStrings = commonStrings;
  }
  /**
   * DayViewModel input which is used to build the Day View.
   */
  get dayView() {
    return this._dayView;
  }
  set dayView(day) {
    this._dayView = day;
  }
  get dayString() {
    return this.dayView.isSelected ? this.commonStrings.parse(this.commonStrings.keys.datepickerSelectedLabel, {
      FULL_DATE: this._dayView.dayModel.toDateString()
    }) : this._dayView.dayModel.toDateString();
  }
  /**
   * Updates the focusedDay in the DateNavigationService when the ClrDay is focused.
   */
  onDayViewFocus() {
    this._dateNavigationService.focusedDay = this.dayView.dayModel;
  }
  /**
   * Updates the selectedDay when the ClrDay is selected and closes the datepicker popover.
   */
  selectDay() {
    const day = this.dayView.dayModel;
    this._dateNavigationService.notifySelectedDayChanged(day);
    this.dateFormControlService.markAsDirty();
    this._toggleService.open = false;
  }
};
ClrDay.ɵfac = function ClrDay_Factory(t3) {
  return new (t3 || ClrDay)(ɵɵdirectiveInject(DateNavigationService), ɵɵdirectiveInject(ClrPopoverToggleService), ɵɵdirectiveInject(DateFormControlService), ɵɵdirectiveInject(ClrCommonStringsService));
};
ClrDay.ɵcmp = ɵɵdefineComponent({
  type: ClrDay,
  selectors: [["clr-day"]],
  hostVars: 2,
  hostBindings: function ClrDay_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("day", true);
    }
  },
  inputs: {
    dayView: [InputFlags.None, "clrDayView", "dayView"]
  },
  decls: 2,
  vars: 13,
  consts: [["type", "button", 1, "day-btn", 3, "click", "focus"]],
  template: function ClrDay_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "button", 0);
      ɵɵlistener("click", function ClrDay_Template_button_click_0_listener() {
        return ctx.selectDay();
      })("focus", function ClrDay_Template_button_focus_0_listener() {
        return ctx.onDayViewFocus();
      });
      ɵɵtext(1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵclassProp("is-today", ctx.dayView.isTodaysDate)("is-excluded", ctx.dayView.isExcluded)("is-disabled", ctx.dayView.isDisabled)("is-selected", ctx.dayView.isSelected);
      ɵɵattribute("tabindex", ctx.dayView.tabIndex)("aria-current", ctx.dayView.isTodaysDate ? "date" : "false")("aria-label", ctx.dayString)("aria-selected", ctx.dayView.isSelected);
      ɵɵadvance();
      ɵɵtextInterpolate1(" ", ctx.dayView.dayModel.date, " ");
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDay, [{
    type: Component,
    args: [{
      selector: "clr-day",
      template: `
    <button
      class="day-btn"
      type="button"
      [class.is-today]="dayView.isTodaysDate"
      [class.is-excluded]="dayView.isExcluded"
      [class.is-disabled]="dayView.isDisabled"
      [class.is-selected]="dayView.isSelected"
      [attr.tabindex]="dayView.tabIndex"
      (click)="selectDay()"
      (focus)="onDayViewFocus()"
      [attr.aria-current]="dayView.isTodaysDate ? 'date' : 'false'"
      [attr.aria-label]="dayString"
      [attr.aria-selected]="dayView.isSelected"
    >
      {{ dayView.dayModel.date }}
    </button>
  `,
      host: {
        "[class.day]": "true"
      }
    }]
  }], function() {
    return [{
      type: DateNavigationService
    }, {
      type: ClrPopoverToggleService
    }, {
      type: DateFormControlService
    }, {
      type: ClrCommonStringsService
    }];
  }, {
    dayView: [{
      type: Input,
      args: ["clrDayView"]
    }]
  });
})();
var ClrCalendar = class {
  constructor(_localeHelperService, _dateNavigationService, _datepickerFocusService, _dateIOService, _elRef) {
    this._localeHelperService = _localeHelperService;
    this._dateNavigationService = _dateNavigationService;
    this._datepickerFocusService = _datepickerFocusService;
    this._dateIOService = _dateIOService;
    this._elRef = _elRef;
    this._subs = [];
    this.generateCalendarView();
    this.initializeSubscriptions();
  }
  /**
   * Gets the locale days according to the TranslationWidth.Narrow format.
   */
  get localeDays() {
    return this._localeHelperService.localeDays;
  }
  get calendar() {
    return this._dateNavigationService.displayedCalendar;
  }
  get selectedDay() {
    return this._dateNavigationService.selectedDay;
  }
  get focusedDay() {
    return this._dateNavigationService.focusedDay;
  }
  get today() {
    return this._dateNavigationService.today;
  }
  /**
   * Focuses on the focusable day when the Calendar View is initialized.
   */
  ngAfterViewInit() {
    this._datepickerFocusService.focusCell(this._elRef);
  }
  /**
   * Unsubscribe from subscriptions.
   */
  ngOnDestroy() {
    this._subs.forEach((sub) => sub.unsubscribe());
  }
  /**
   * Delegates Keyboard arrow navigation to the DateNavigationService.
   */
  onKeyDown(event) {
    if (event && this.focusedDay) {
      switch (normalizeKey(event.key)) {
        case Keys.ArrowUp:
          event.preventDefault();
          this._dateNavigationService.incrementFocusDay(-1 * NO_OF_DAYS_IN_A_WEEK);
          break;
        case Keys.ArrowDown:
          event.preventDefault();
          this._dateNavigationService.incrementFocusDay(NO_OF_DAYS_IN_A_WEEK);
          break;
        case Keys.ArrowLeft:
          event.preventDefault();
          this._dateNavigationService.incrementFocusDay(-1);
          break;
        case Keys.ArrowRight:
          event.preventDefault();
          this._dateNavigationService.incrementFocusDay(1);
          break;
        default:
          break;
      }
    }
  }
  /**
   * Initialize subscriptions to:
   * 1. update the calendar view model.
   * 2. update the focusable day in the calendar view model.
   * 3. focus on the focusable day in the calendar.
   */
  initializeSubscriptions() {
    this._subs.push(this._dateNavigationService.displayedCalendarChange.subscribe(() => {
      this.generateCalendarView();
    }));
    this._subs.push(this._dateNavigationService.focusedDayChange.subscribe((focusedDay) => {
      this.calendarViewModel.updateFocusableDay(focusedDay);
    }));
    this._subs.push(this._dateNavigationService.focusOnCalendarChange.subscribe(() => {
      this._datepickerFocusService.focusCell(this._elRef);
    }));
  }
  /**
   * Generates the Calendar View based on the calendar retrieved from the DateNavigationService.
   */
  generateCalendarView() {
    this.calendarViewModel = new CalendarViewModel(this.calendar, this.selectedDay, this.focusedDay, this.today, this._localeHelperService.firstDayOfWeek, this._dateIOService.disabledDates);
  }
};
ClrCalendar.ɵfac = function ClrCalendar_Factory(t3) {
  return new (t3 || ClrCalendar)(ɵɵdirectiveInject(LocaleHelperService), ɵɵdirectiveInject(DateNavigationService), ɵɵdirectiveInject(DatepickerFocusService), ɵɵdirectiveInject(DateIOService), ɵɵdirectiveInject(ElementRef));
};
ClrCalendar.ɵcmp = ɵɵdefineComponent({
  type: ClrCalendar,
  selectors: [["clr-calendar"]],
  hostBindings: function ClrCalendar_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("keydown", function ClrCalendar_keydown_HostBindingHandler($event) {
        return ctx.onKeyDown($event);
      });
    }
  },
  decls: 4,
  vars: 2,
  consts: [["role", "presentation", 1, "calendar-table"], [1, "calendar-row", "weekdays"], ["class", "calendar-cell weekday", 4, "ngFor", "ngForOf"], ["class", "calendar-row", 4, "ngFor", "ngForOf"], [1, "calendar-cell", "weekday"], [1, "calendar-row"], ["class", "calendar-cell", 4, "ngFor", "ngForOf"], [1, "calendar-cell"], ["aria-hidden", "true", 3, "clrDayView"]],
  template: function ClrCalendar_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "table", 0)(1, "tr", 1);
      ɵɵtemplate(2, ClrCalendar_th_2_Template, 3, 2, "th", 2);
      ɵɵelementEnd();
      ɵɵtemplate(3, ClrCalendar_tr_3_Template, 2, 1, "tr", 3);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance(2);
      ɵɵproperty("ngForOf", ctx.localeDays);
      ɵɵadvance();
      ɵɵproperty("ngForOf", ctx.calendarViewModel.calendarView);
    }
  },
  dependencies: [NgForOf, ClrDay],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrCalendar, [{
    type: Component,
    args: [{
      selector: "clr-calendar",
      template: '<table class="calendar-table" role="presentation">\n  <tr class="calendar-row weekdays">\n    <th *ngFor="let day of localeDays" class="calendar-cell weekday">\n      <span [attr.aria-label]="day.day">{{day.narrow}}</span>\n    </th>\n  </tr>\n  <tr class="calendar-row" *ngFor="let row of calendarViewModel.calendarView">\n    <td *ngFor="let dayView of row" class="calendar-cell">\n      <clr-day [clrDayView]="dayView" aria-hidden="true"></clr-day>\n    </td>\n  </tr>\n</table>\n'
    }]
  }], function() {
    return [{
      type: LocaleHelperService
    }, {
      type: DateNavigationService
    }, {
      type: DatepickerFocusService
    }, {
      type: DateIOService
    }, {
      type: ElementRef
    }];
  }, {
    onKeyDown: [{
      type: HostListener,
      args: ["keydown", ["$event"]]
    }]
  });
})();
var DATEPICKER_ENABLE_BREAKPOINT = 768;
var LARGE_BREAKPOINT = 992;
var DatepickerEnabledService = class {
  constructor(_document) {
    this._document = _document;
    this._isUserAgentMobile = false;
    if (this._document) {
      this._isUserAgentMobile = MOBILE_USERAGENT_REGEX.test(_document.defaultView.navigator.userAgent);
      this._innerWidth = _document.defaultView.innerWidth;
    }
  }
  /**
   * Returns if the calendar should be active or not.
   * If the user agent is mobile and the screen width is less than DATEPICKER_ACTIVE_BREAKPOINT
   * then the calendar is inactive.
   */
  get isEnabled() {
    if (this._document) {
      if (this._innerWidth < DATEPICKER_ENABLE_BREAKPOINT && this._isUserAgentMobile) {
        return false;
      }
    }
    return true;
  }
};
DatepickerEnabledService.ɵfac = function DatepickerEnabledService_Factory(t3) {
  return new (t3 || DatepickerEnabledService)(ɵɵinject(DOCUMENT));
};
DatepickerEnabledService.ɵprov = ɵɵdefineInjectable({
  token: DatepickerEnabledService,
  factory: DatepickerEnabledService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DatepickerEnabledService, [{
    type: Injectable
  }], function() {
    return [{
      type: void 0,
      decorators: [{
        type: Inject,
        args: [DOCUMENT]
      }]
    }];
  }, null);
})();
var ViewManagerService = class {
  constructor() {
    this.position = ClrPopoverPositions["bottom-left"];
    this._currentView = "DAYVIEW";
  }
  get isDayView() {
    return this._currentView === "DAYVIEW";
  }
  get isYearView() {
    return this._currentView === "YEARVIEW";
  }
  get isMonthView() {
    return this._currentView === "MONTHVIEW";
  }
  changeToMonthView() {
    this._currentView = "MONTHVIEW";
  }
  changeToYearView() {
    this._currentView = "YEARVIEW";
  }
  changeToDayView() {
    this._currentView = "DAYVIEW";
  }
};
ViewManagerService.ɵfac = function ViewManagerService_Factory(t3) {
  return new (t3 || ViewManagerService)();
};
ViewManagerService.ɵprov = ɵɵdefineInjectable({
  token: ViewManagerService,
  factory: ViewManagerService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ViewManagerService, [{
    type: Injectable
  }], null, null);
})();
var ClrMonthpicker = class {
  constructor(_viewManagerService, _localeHelperService, _dateNavigationService, _datepickerFocusService, _elRef) {
    this._viewManagerService = _viewManagerService;
    this._localeHelperService = _localeHelperService;
    this._dateNavigationService = _dateNavigationService;
    this._datepickerFocusService = _datepickerFocusService;
    this._elRef = _elRef;
    this._focusedMonthIndex = this.calendarMonthIndex;
  }
  /**
   * Gets the months array which is used to rendered the monthpicker view.
   * Months are in the TranslationWidth.Wide format.
   */
  get monthNames() {
    return this._localeHelperService.localeMonthsWide;
  }
  /**
   * Gets the month value of the Calendar.
   */
  get calendarMonthIndex() {
    return this._dateNavigationService.displayedCalendar.month;
  }
  /**
   * Focuses on the current calendar month when the View is initialized.
   */
  ngAfterViewInit() {
    this._datepickerFocusService.focusCell(this._elRef);
  }
  /**
   * Handles the Keyboard arrow navigation for the monthpicker.
   */
  onKeyDown(event) {
    if (event) {
      const key = normalizeKey(event.key);
      if (key === Keys.ArrowUp && this._focusedMonthIndex > 0) {
        event.preventDefault();
        this._focusedMonthIndex--;
        this._datepickerFocusService.focusCell(this._elRef);
      } else if (key === Keys.ArrowDown && this._focusedMonthIndex < 11) {
        event.preventDefault();
        this._focusedMonthIndex++;
        this._datepickerFocusService.focusCell(this._elRef);
      } else if (key === Keys.ArrowRight && this._focusedMonthIndex < 6) {
        event.preventDefault();
        this._focusedMonthIndex = this._focusedMonthIndex + 6;
        this._datepickerFocusService.focusCell(this._elRef);
      } else if (key === Keys.ArrowLeft && this._focusedMonthIndex > 5) {
        event.preventDefault();
        this._focusedMonthIndex = this._focusedMonthIndex - 6;
        this._datepickerFocusService.focusCell(this._elRef);
      }
    }
  }
  /**
   * Calls the DateNavigationService to update the month value of the calendar.
   * Also changes the view to the daypicker.
   */
  changeMonth(monthIndex) {
    this._dateNavigationService.changeMonth(monthIndex);
    this._viewManagerService.changeToDayView();
  }
  /**
   * Compares the month passed to the focused month and returns the tab index.
   */
  getTabIndex(monthIndex) {
    return monthIndex === this._focusedMonthIndex ? 0 : -1;
  }
};
ClrMonthpicker.ɵfac = function ClrMonthpicker_Factory(t3) {
  return new (t3 || ClrMonthpicker)(ɵɵdirectiveInject(ViewManagerService), ɵɵdirectiveInject(LocaleHelperService), ɵɵdirectiveInject(DateNavigationService), ɵɵdirectiveInject(DatepickerFocusService), ɵɵdirectiveInject(ElementRef));
};
ClrMonthpicker.ɵcmp = ɵɵdefineComponent({
  type: ClrMonthpicker,
  selectors: [["clr-monthpicker"]],
  hostAttrs: ["role", "application"],
  hostVars: 2,
  hostBindings: function ClrMonthpicker_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("keydown", function ClrMonthpicker_keydown_HostBindingHandler($event) {
        return ctx.onKeyDown($event);
      });
    }
    if (rf & 2) {
      ɵɵclassProp("monthpicker", true);
    }
  },
  decls: 1,
  vars: 1,
  consts: [["type", "button", "class", "calendar-btn month", 3, "is-selected", "click", 4, "ngFor", "ngForOf"], ["type", "button", 1, "calendar-btn", "month", 3, "click"]],
  template: function ClrMonthpicker_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, ClrMonthpicker_button_0_Template, 2, 4, "button", 0);
    }
    if (rf & 2) {
      ɵɵproperty("ngForOf", ctx.monthNames);
    }
  },
  dependencies: [NgForOf],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrMonthpicker, [{
    type: Component,
    args: [{
      selector: "clr-monthpicker",
      template: `
    <button
      type="button"
      class="calendar-btn month"
      *ngFor="let month of monthNames; let monthIndex = index"
      (click)="changeMonth(monthIndex)"
      [class.is-selected]="monthIndex === calendarMonthIndex"
      [attr.tabindex]="getTabIndex(monthIndex)"
    >
      {{ month }}
    </button>
  `,
      host: {
        "[class.monthpicker]": "true",
        role: "application"
      }
    }]
  }], function() {
    return [{
      type: ViewManagerService
    }, {
      type: LocaleHelperService
    }, {
      type: DateNavigationService
    }, {
      type: DatepickerFocusService
    }, {
      type: ElementRef
    }];
  }, {
    onKeyDown: [{
      type: HostListener,
      args: ["keydown", ["$event"]]
    }]
  });
})();
var YEARS_TO_DISPLAY = 10;
var YearRangeModel = class _YearRangeModel {
  constructor(year) {
    this.year = year;
    this.yearRange = [];
    this.generateYearRange();
  }
  /**
   * Gets the number in the middle of the range.
   */
  get middleYear() {
    return this.yearRange[Math.floor(this.yearRange.length / 2)];
  }
  /**
   * Generates the YearRangeModel for the next decade.
   */
  nextDecade() {
    return new _YearRangeModel(this.year + 10);
  }
  /**
   * Generates the YearRangeModel for the previous decade.
   */
  previousDecade() {
    return new _YearRangeModel(this.year - 10);
  }
  /**
   * Generates the YearRangeModel for the current decade.
   */
  currentDecade() {
    return new _YearRangeModel((/* @__PURE__ */ new Date()).getFullYear());
  }
  /**
   * Checks if the value is in the YearRangeModel.
   */
  inRange(value) {
    return this.yearRange.indexOf(value) > -1;
  }
  /**
   * Generates the year range based on the year parameter.
   * eg: If 2018 is passed the output will be [2010, 2011, ..., 2019]
   */
  generateYearRange() {
    const remainder = this.year % YEARS_TO_DISPLAY;
    const floor = this.year - remainder;
    const ceil = floor + YEARS_TO_DISPLAY;
    this.yearRange = this.generateRange(floor, ceil);
  }
  /**
   * Function which generate a range of numbers from floor to ceil.
   */
  generateRange(floor, ceil) {
    return Array.from({
      length: ceil - floor
    }, (_v, k) => k + floor);
  }
};
var ClrYearpicker = class {
  constructor(_dateNavigationService, _viewManagerService, _datepickerFocusService, _elRef, commonStrings) {
    this._dateNavigationService = _dateNavigationService;
    this._viewManagerService = _viewManagerService;
    this._datepickerFocusService = _datepickerFocusService;
    this._elRef = _elRef;
    this.commonStrings = commonStrings;
    this.yearRangeModel = new YearRangeModel(this.calendarYear);
    this._focusedYear = this.calendarYear;
  }
  /**
   * Gets the year which the user is currently on.
   */
  get calendarYear() {
    return this._dateNavigationService.displayedCalendar.year;
  }
  /**
   * Focuses on the current calendar year when the View is initialized.
   */
  ngAfterViewInit() {
    this._datepickerFocusService.focusCell(this._elRef);
  }
  /**
   * Handles the Keyboard arrow navigation for the yearpicker.
   */
  onKeyDown(event) {
    if (event) {
      const key = normalizeKey(event.key);
      if (key === Keys.ArrowUp) {
        event.preventDefault();
        this.incrementFocusYearBy(-1);
      } else if (key === Keys.ArrowDown) {
        event.preventDefault();
        this.incrementFocusYearBy(1);
      } else if (key === Keys.ArrowRight) {
        event.preventDefault();
        this.incrementFocusYearBy(5);
      } else if (key === Keys.ArrowLeft) {
        event.preventDefault();
        this.incrementFocusYearBy(-5);
      }
    }
  }
  /**
   * Calls the DateNavigationService to update the year value of the calendar.
   * Also changes the view to the daypicker.
   */
  changeYear(year) {
    this._dateNavigationService.changeYear(year);
    this._viewManagerService.changeToDayView();
  }
  /**
   * Updates the YearRangeModel to the previous decade.
   */
  previousDecade() {
    this.yearRangeModel = this.yearRangeModel.previousDecade();
  }
  /**
   * Updates the YearRangeModel to the current decade.
   */
  currentDecade() {
    if (!this.yearRangeModel.inRange(this._dateNavigationService.today.year)) {
      this.yearRangeModel = this.yearRangeModel.currentDecade();
    }
    this._datepickerFocusService.focusCell(this._elRef);
  }
  /**
   * Updates the YearRangeModel to the next decade.
   */
  nextDecade() {
    this.yearRangeModel = this.yearRangeModel.nextDecade();
  }
  /**
   * Compares the year passed to the focused year and returns the tab index.
   */
  getTabIndex(year) {
    if (!this.yearRangeModel.inRange(this._focusedYear)) {
      if (this.yearRangeModel.inRange(this.calendarYear)) {
        this._focusedYear = this.calendarYear;
      } else {
        this._focusedYear = this.yearRangeModel.middleYear;
      }
    }
    return this._focusedYear === year ? 0 : -1;
  }
  /**
   * Increments the focus year by the value passed. Updates the YearRangeModel if the
   * new value is not in the current decade.
   */
  incrementFocusYearBy(value) {
    this._focusedYear = this._focusedYear + value;
    if (!this.yearRangeModel.inRange(this._focusedYear)) {
      if (value > 0) {
        this.yearRangeModel = this.yearRangeModel.nextDecade();
      } else {
        this.yearRangeModel = this.yearRangeModel.previousDecade();
      }
    }
    this._datepickerFocusService.focusCell(this._elRef);
  }
};
ClrYearpicker.ɵfac = function ClrYearpicker_Factory(t3) {
  return new (t3 || ClrYearpicker)(ɵɵdirectiveInject(DateNavigationService), ɵɵdirectiveInject(ViewManagerService), ɵɵdirectiveInject(DatepickerFocusService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ClrCommonStringsService));
};
ClrYearpicker.ɵcmp = ɵɵdefineComponent({
  type: ClrYearpicker,
  selectors: [["clr-yearpicker"]],
  hostAttrs: ["role", "application"],
  hostVars: 2,
  hostBindings: function ClrYearpicker_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("keydown", function ClrYearpicker_keydown_HostBindingHandler($event) {
        return ctx.onKeyDown($event);
      });
    }
    if (rf & 2) {
      ɵɵclassProp("yearpicker", true);
    }
  },
  decls: 9,
  vars: 7,
  consts: [[1, "year-switchers"], ["type", "button", 1, "calendar-btn", "switcher", 3, "click"], ["shape", "angle", "direction", "left"], ["shape", "event"], ["shape", "angle", "direction", "right"], [1, "years"], ["type", "button", "class", "calendar-btn year", 3, "is-selected", "click", 4, "ngFor", "ngForOf"], ["type", "button", 1, "calendar-btn", "year", 3, "click"]],
  template: function ClrYearpicker_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0)(1, "button", 1);
      ɵɵlistener("click", function ClrYearpicker_Template_button_click_1_listener() {
        return ctx.previousDecade();
      });
      ɵɵelement(2, "cds-icon", 2);
      ɵɵelementEnd();
      ɵɵelementStart(3, "button", 1);
      ɵɵlistener("click", function ClrYearpicker_Template_button_click_3_listener() {
        return ctx.currentDecade();
      });
      ɵɵelement(4, "cds-icon", 3);
      ɵɵelementEnd();
      ɵɵelementStart(5, "button", 1);
      ɵɵlistener("click", function ClrYearpicker_Template_button_click_5_listener() {
        return ctx.nextDecade();
      });
      ɵɵelement(6, "cds-icon", 4);
      ɵɵelementEnd()();
      ɵɵelementStart(7, "div", 5);
      ɵɵtemplate(8, ClrYearpicker_button_8_Template, 2, 4, "button", 6);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵattribute("aria-label", ctx.commonStrings.keys.datepickerPreviousDecade);
      ɵɵadvance();
      ɵɵattribute("title", ctx.commonStrings.keys.datepickerPreviousDecade);
      ɵɵadvance();
      ɵɵattribute("aria-label", ctx.commonStrings.keys.datepickerCurrentDecade);
      ɵɵadvance();
      ɵɵattribute("title", ctx.commonStrings.keys.datepickerCurrentDecade);
      ɵɵadvance();
      ɵɵattribute("aria-label", ctx.commonStrings.keys.datepickerNextDecade);
      ɵɵadvance();
      ɵɵattribute("title", ctx.commonStrings.keys.datepickerNextDecade);
      ɵɵadvance(2);
      ɵɵproperty("ngForOf", ctx.yearRangeModel.yearRange);
    }
  },
  dependencies: [NgForOf, CdsIconCustomTag],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrYearpicker, [{
    type: Component,
    args: [{
      selector: "clr-yearpicker",
      template: `
    <div class="year-switchers">
      <button
        class="calendar-btn switcher"
        type="button"
        (click)="previousDecade()"
        [attr.aria-label]="commonStrings.keys.datepickerPreviousDecade"
      >
        <cds-icon shape="angle" direction="left" [attr.title]="commonStrings.keys.datepickerPreviousDecade"></cds-icon>
      </button>
      <button
        class="calendar-btn switcher"
        type="button"
        (click)="currentDecade()"
        [attr.aria-label]="commonStrings.keys.datepickerCurrentDecade"
      >
        <cds-icon shape="event" [attr.title]="commonStrings.keys.datepickerCurrentDecade"></cds-icon>
      </button>
      <button
        class="calendar-btn switcher"
        type="button"
        (click)="nextDecade()"
        [attr.aria-label]="commonStrings.keys.datepickerNextDecade"
      >
        <cds-icon shape="angle" direction="right" [attr.title]="commonStrings.keys.datepickerNextDecade"></cds-icon>
      </button>
    </div>
    <div class="years">
      <button
        *ngFor="let year of yearRangeModel.yearRange"
        type="button"
        class="calendar-btn year"
        [attr.tabindex]="getTabIndex(year)"
        [class.is-selected]="year === calendarYear"
        (click)="changeYear(year)"
      >
        {{ year }}
      </button>
    </div>
  `,
      host: {
        "[class.yearpicker]": "true",
        role: "application"
      }
    }]
  }], function() {
    return [{
      type: DateNavigationService
    }, {
      type: ViewManagerService
    }, {
      type: DatepickerFocusService
    }, {
      type: ElementRef
    }, {
      type: ClrCommonStringsService
    }];
  }, {
    onKeyDown: [{
      type: HostListener,
      args: ["keydown", ["$event"]]
    }]
  });
})();
var ClrDaypicker = class {
  constructor(_viewManagerService, _dateNavigationService, _localeHelperService, commonStrings) {
    this._viewManagerService = _viewManagerService;
    this._dateNavigationService = _dateNavigationService;
    this._localeHelperService = _localeHelperService;
    this.commonStrings = commonStrings;
  }
  get monthAttrString() {
    return this.commonStrings.parse(this.commonStrings.keys.datepickerSelectMonthText, {
      CALENDAR_MONTH: this.calendarMonth
    });
  }
  get yearAttrString() {
    return this.commonStrings.parse(this.commonStrings.keys.datepickerSelectYearText, {
      CALENDAR_YEAR: this.calendarYear.toString()
    });
  }
  /**
   * Returns the month value of the calendar in the TranslationWidth.Abbreviated format.
   */
  get calendarMonth() {
    return this._localeHelperService.localeMonthsAbbreviated[this._dateNavigationService.displayedCalendar.month];
  }
  /**
   * Returns the year value of the calendar.
   */
  get calendarYear() {
    return this._dateNavigationService.displayedCalendar.year;
  }
  /**
   * Calls the ViewManagerService to change to the monthpicker view.
   */
  changeToMonthView() {
    this._viewManagerService.changeToMonthView();
  }
  /**
   * Calls the ViewManagerService to change to the yearpicker view.
   */
  changeToYearView() {
    this._viewManagerService.changeToYearView();
  }
  /**
   * Calls the DateNavigationService to move to the next month.
   */
  nextMonth() {
    this._dateNavigationService.moveToNextMonth();
  }
  /**
   * Calls the DateNavigationService to move to the previous month.
   */
  previousMonth() {
    this._dateNavigationService.moveToPreviousMonth();
  }
  /**
   * Calls the DateNavigationService to move to the current month.
   */
  currentMonth() {
    this._dateNavigationService.moveToCurrentMonth();
  }
};
ClrDaypicker.ɵfac = function ClrDaypicker_Factory(t3) {
  return new (t3 || ClrDaypicker)(ɵɵdirectiveInject(ViewManagerService), ɵɵdirectiveInject(DateNavigationService), ɵɵdirectiveInject(LocaleHelperService), ɵɵdirectiveInject(ClrCommonStringsService));
};
ClrDaypicker.ɵcmp = ɵɵdefineComponent({
  type: ClrDaypicker,
  selectors: [["clr-daypicker"]],
  hostAttrs: ["role", "application"],
  hostVars: 2,
  hostBindings: function ClrDaypicker_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("daypicker", true);
    }
  },
  decls: 18,
  vars: 14,
  consts: [[1, "clr-sr-only"], [1, "calendar-header"], [1, "calendar-pickers"], ["type", "button", 1, "calendar-btn", "monthpicker-trigger", 3, "click"], ["type", "button", 1, "calendar-btn", "yearpicker-trigger", 3, "click"], [1, "calendar-switchers"], ["type", "button", 1, "calendar-btn", "switcher", 3, "click"], ["shape", "angle", "direction", "left"], ["shape", "event"], ["shape", "angle", "direction", "right"]],
  template: function ClrDaypicker_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0);
      ɵɵtext(1);
      ɵɵelementEnd();
      ɵɵelementStart(2, "div", 1)(3, "div", 2)(4, "button", 3);
      ɵɵlistener("click", function ClrDaypicker_Template_button_click_4_listener() {
        return ctx.changeToMonthView();
      });
      ɵɵtext(5);
      ɵɵelementEnd();
      ɵɵelementStart(6, "button", 4);
      ɵɵlistener("click", function ClrDaypicker_Template_button_click_6_listener() {
        return ctx.changeToYearView();
      });
      ɵɵtext(7);
      ɵɵelementEnd()();
      ɵɵelementStart(8, "div", 5)(9, "button", 6);
      ɵɵlistener("click", function ClrDaypicker_Template_button_click_9_listener() {
        return ctx.previousMonth();
      });
      ɵɵelement(10, "cds-icon", 7);
      ɵɵelementEnd();
      ɵɵelementStart(11, "button", 6);
      ɵɵlistener("click", function ClrDaypicker_Template_button_click_11_listener() {
        return ctx.currentMonth();
      });
      ɵɵelement(12, "cds-icon", 8);
      ɵɵelementEnd();
      ɵɵelementStart(13, "button", 6);
      ɵɵlistener("click", function ClrDaypicker_Template_button_click_13_listener() {
        return ctx.nextMonth();
      });
      ɵɵelement(14, "cds-icon", 9);
      ɵɵelementEnd()()();
      ɵɵelement(15, "clr-calendar");
      ɵɵelementStart(16, "div", 0);
      ɵɵtext(17);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵtextInterpolate(ctx.commonStrings.keys.modalContentStart);
      ɵɵadvance(3);
      ɵɵattribute("aria-label", ctx.monthAttrString)("title", ctx.monthAttrString);
      ɵɵadvance();
      ɵɵtextInterpolate1(" ", ctx.calendarMonth, " ");
      ɵɵadvance();
      ɵɵattribute("aria-label", ctx.yearAttrString)("title", ctx.yearAttrString);
      ɵɵadvance();
      ɵɵtextInterpolate1(" ", ctx.calendarYear, " ");
      ɵɵadvance(2);
      ɵɵattribute("aria-label", ctx.commonStrings.keys.datepickerPreviousMonth);
      ɵɵadvance();
      ɵɵattribute("title", ctx.commonStrings.keys.datepickerPreviousMonth);
      ɵɵadvance();
      ɵɵattribute("aria-label", ctx.commonStrings.keys.datepickerCurrentMonth);
      ɵɵadvance();
      ɵɵattribute("title", ctx.commonStrings.keys.datepickerCurrentMonth);
      ɵɵadvance();
      ɵɵattribute("aria-label", ctx.commonStrings.keys.datepickerNextMonth);
      ɵɵadvance();
      ɵɵattribute("title", ctx.commonStrings.keys.datepickerNextMonth);
      ɵɵadvance(3);
      ɵɵtextInterpolate(ctx.commonStrings.keys.modalContentEnd);
    }
  },
  dependencies: [CdsIconCustomTag, ClrCalendar],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDaypicker, [{
    type: Component,
    args: [{
      selector: "clr-daypicker",
      host: {
        "[class.daypicker]": "true",
        role: "application"
      },
      template: '<div class="clr-sr-only">{{commonStrings.keys.modalContentStart}}</div>\n<div class="calendar-header">\n  <div class="calendar-pickers">\n    <button\n      class="calendar-btn monthpicker-trigger"\n      type="button"\n      (click)="changeToMonthView()"\n      [attr.aria-label]="monthAttrString"\n      [attr.title]="monthAttrString"\n    >\n      {{calendarMonth}}\n    </button>\n    <button\n      class="calendar-btn yearpicker-trigger"\n      type="button"\n      (click)="changeToYearView()"\n      [attr.aria-label]="yearAttrString"\n      [attr.title]="yearAttrString"\n    >\n      {{calendarYear}}\n    </button>\n  </div>\n  <div class="calendar-switchers">\n    <button\n      class="calendar-btn switcher"\n      type="button"\n      (click)="previousMonth()"\n      [attr.aria-label]="commonStrings.keys.datepickerPreviousMonth"\n    >\n      <cds-icon shape="angle" direction="left" [attr.title]="commonStrings.keys.datepickerPreviousMonth"></cds-icon>\n    </button>\n    <button\n      class="calendar-btn switcher"\n      type="button"\n      (click)="currentMonth()"\n      [attr.aria-label]="commonStrings.keys.datepickerCurrentMonth"\n    >\n      <cds-icon shape="event" [attr.title]="commonStrings.keys.datepickerCurrentMonth"></cds-icon>\n    </button>\n    <button\n      class="calendar-btn switcher"\n      type="button"\n      (click)="nextMonth()"\n      [attr.aria-label]="commonStrings.keys.datepickerNextMonth"\n    >\n      <cds-icon shape="angle" direction="right" [attr.title]="commonStrings.keys.datepickerNextMonth"></cds-icon>\n    </button>\n  </div>\n</div>\n<clr-calendar></clr-calendar>\n<div class="clr-sr-only">{{commonStrings.keys.modalContentEnd}}</div>\n'
    }]
  }], function() {
    return [{
      type: ViewManagerService
    }, {
      type: DateNavigationService
    }, {
      type: LocaleHelperService
    }, {
      type: ClrCommonStringsService
    }];
  }, null);
})();
var ClrDatepickerViewManager = class {
  constructor(commonStrings, viewManagerService) {
    this.commonStrings = commonStrings;
    this.viewManagerService = viewManagerService;
  }
  /**
   * Returns if the current view is the monthpicker.
   */
  get isMonthView() {
    return this.viewManagerService.isMonthView;
  }
  /**
   * Returns if the current view is the yearpicker.
   */
  get isYearView() {
    return this.viewManagerService.isYearView;
  }
  /**
   * Returns if the current view is the daypicker.
   */
  get isDayView() {
    return this.viewManagerService.isDayView;
  }
};
ClrDatepickerViewManager.ɵfac = function ClrDatepickerViewManager_Factory(t3) {
  return new (t3 || ClrDatepickerViewManager)(ɵɵdirectiveInject(ClrCommonStringsService), ɵɵdirectiveInject(ViewManagerService));
};
ClrDatepickerViewManager.ɵcmp = ɵɵdefineComponent({
  type: ClrDatepickerViewManager,
  selectors: [["clr-datepicker-view-manager"]],
  hostAttrs: ["role", "dialog"],
  hostVars: 4,
  hostBindings: function ClrDatepickerViewManager_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("aria-modal", true)("aria-label", ctx.commonStrings.keys.datepickerDialogLabel);
      ɵɵclassProp("datepicker", true);
    }
  },
  features: [ɵɵProvidersFeature([DatepickerFocusService])],
  decls: 3,
  vars: 3,
  consts: [[4, "ngIf"]],
  template: function ClrDatepickerViewManager_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, ClrDatepickerViewManager_clr_monthpicker_0_Template, 1, 0, "clr-monthpicker", 0)(1, ClrDatepickerViewManager_clr_yearpicker_1_Template, 1, 0, "clr-yearpicker", 0)(2, ClrDatepickerViewManager_clr_daypicker_2_Template, 1, 0, "clr-daypicker", 0);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.isMonthView);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.isYearView);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.isDayView);
    }
  },
  dependencies: [NgIf, ClrMonthpicker, ClrYearpicker, ClrDaypicker],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDatepickerViewManager, [{
    type: Component,
    args: [{
      selector: "clr-datepicker-view-manager",
      providers: [DatepickerFocusService],
      host: {
        "[class.datepicker]": "true",
        "[attr.aria-modal]": "true",
        "[attr.aria-label]": "commonStrings.keys.datepickerDialogLabel",
        role: "dialog"
      },
      template: '<!--\n  ~ Copyright (c) 2016-2024 Broadcom. All Rights Reserved.\n  ~ The term "Broadcom" refers to Broadcom Inc. and/or its subsidiaries.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n-->\n\n<clr-monthpicker *ngIf="isMonthView"></clr-monthpicker>\n<clr-yearpicker *ngIf="isYearView"></clr-yearpicker>\n<clr-daypicker *ngIf="isDayView"></clr-daypicker>\n'
    }]
  }], function() {
    return [{
      type: ClrCommonStringsService
    }, {
      type: ViewManagerService
    }];
  }, null);
})();
var ClrDateContainer = class extends ClrAbstractContainer {
  constructor(renderer, toggleService, dateNavigationService, datepickerEnabledService, dateFormControlService, dateIOService, commonStrings, focusService, viewManagerService, controlClassService, layoutService, ngControlService, ifControlStateService) {
    super(ifControlStateService, layoutService, controlClassService, ngControlService);
    this.renderer = renderer;
    this.toggleService = toggleService;
    this.dateNavigationService = dateNavigationService;
    this.datepickerEnabledService = datepickerEnabledService;
    this.dateFormControlService = dateFormControlService;
    this.dateIOService = dateIOService;
    this.commonStrings = commonStrings;
    this.focusService = focusService;
    this.viewManagerService = viewManagerService;
    this.controlClassService = controlClassService;
    this.layoutService = layoutService;
    this.ngControlService = ngControlService;
    this.ifControlStateService = ifControlStateService;
    this.focus = false;
    this.subscriptions.push(this.focusService.focusChange.subscribe((state2) => {
      this.focus = state2;
    }));
    this.subscriptions.push(this.toggleService.openChange.subscribe(() => {
      this.dateFormControlService.markAsTouched();
    }));
  }
  set clrPosition(position) {
    if (position && ClrPopoverPositions[position]) {
      this.viewManagerService.position = ClrPopoverPositions[position];
    }
  }
  set actionButton(button) {
    this.toggleButton = button;
  }
  get popoverPosition() {
    return this.viewManagerService.position;
  }
  get open() {
    return this.toggleService.open;
  }
  /**
   * Returns if the Datepicker is enabled or not. If disabled, hides the datepicker trigger.
   */
  get isEnabled() {
    return this.datepickerEnabledService.isEnabled;
  }
  /**
   * Return if Datepicker is diabled or not as Form Control
   */
  get isInputDateDisabled() {
    return this.control && this.control.disabled || this.dateFormControlService && this.dateFormControlService.disabled;
  }
  ngAfterViewInit() {
    this.subscriptions.push(this.toggleService.openChange.subscribe((open) => {
      if (open) {
        this.initializeCalendar();
      } else {
        this.toggleButton.nativeElement.focus();
      }
    }));
    this.subscriptions.push(this.listenForDateChanges());
  }
  /**
   * Return the label for the toggle button.
   * If there's a selected date, the date is included in the label.
   */
  getToggleButtonLabel(day) {
    if (day) {
      const formattedDate = this.dateIOService.toLocaleDisplayFormatString(day.toDate());
      return this.commonStrings.parse(this.commonStrings.keys.datepickerToggleChangeDateLabel, {
        SELECTED_DATE: formattedDate
      });
    }
    return this.commonStrings.keys.datepickerToggleChooseDateLabel;
  }
  listenForDateChanges() {
    return this.dateNavigationService.selectedDayChange.pipe(startWith(this.dateNavigationService.selectedDay)).subscribe((day) => {
      if (this.isEnabled) {
        const label = this.getToggleButtonLabel(day);
        const toggleEl = this.toggleButton.nativeElement;
        this.renderer.setAttribute(toggleEl, "aria-label", label);
        this.renderer.setAttribute(toggleEl, "title", label);
      }
    });
  }
  /**
   * Processes the user input and Initializes the Calendar everytime the datepicker popover is open.
   */
  initializeCalendar() {
    this.dateNavigationService.initializeCalendar();
  }
};
ClrDateContainer.ɵfac = function ClrDateContainer_Factory(t3) {
  return new (t3 || ClrDateContainer)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ClrPopoverToggleService), ɵɵdirectiveInject(DateNavigationService), ɵɵdirectiveInject(DatepickerEnabledService), ɵɵdirectiveInject(DateFormControlService), ɵɵdirectiveInject(DateIOService), ɵɵdirectiveInject(ClrCommonStringsService), ɵɵdirectiveInject(FocusService2), ɵɵdirectiveInject(ViewManagerService), ɵɵdirectiveInject(ControlClassService), ɵɵdirectiveInject(LayoutService, 8), ɵɵdirectiveInject(NgControlService), ɵɵdirectiveInject(IfControlStateService));
};
ClrDateContainer.ɵcmp = ɵɵdefineComponent({
  type: ClrDateContainer,
  selectors: [["clr-date-container"]],
  viewQuery: function ClrDateContainer_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c27, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.actionButton = _t.first);
    }
  },
  hostVars: 8,
  hostBindings: function ClrDateContainer_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("clr-date-container", true)("clr-form-control-disabled", ctx.isInputDateDisabled)("clr-form-control", true)("clr-row", ctx.addGrid());
    }
  },
  inputs: {
    clrPosition: "clrPosition"
  },
  features: [ɵɵProvidersFeature([ControlIdService, LocaleHelperService, ControlClassService, FocusService2, NgControlService, DateIOService, DateNavigationService, DatepickerEnabledService, DateFormControlService, ViewManagerService, IfControlStateService]), ɵɵHostDirectivesFeature([ClrPopoverHostDirective]), ɵɵInheritDefinitionFeature],
  ngContentSelectors: _c29,
  decls: 13,
  vars: 14,
  consts: [["actionButton", ""], [4, "ngIf"], [1, "clr-control-container", 3, "ngClass"], ["clrPopoverAnchor", "", 1, "clr-input-wrapper"], [1, "clr-input-group"], ["type", "button", "clrPopoverOpenCloseButton", "", "class", "clr-input-group-icon-action", 3, "disabled", 4, "ngIf"], ["cdkTrapFocus", "", 4, "clrPopoverContent", "clrPopoverContentAt", "clrPopoverContentOutsideClickToClose", "clrPopoverContentScrollToClose"], ["class", "clr-validate-icon", "shape", "exclamation-circle", "status", "danger", "aria-hidden", "true", 4, "ngIf"], ["class", "clr-validate-icon", "shape", "check-circle", "status", "success", "aria-hidden", "true", 4, "ngIf"], ["type", "button", "clrPopoverOpenCloseButton", "", 1, "clr-input-group-icon-action", 3, "disabled"], ["status", "info", "shape", "calendar"], ["cdkTrapFocus", ""], ["shape", "exclamation-circle", "status", "danger", "aria-hidden", "true", 1, "clr-validate-icon"], ["shape", "check-circle", "status", "success", "aria-hidden", "true", 1, "clr-validate-icon"]],
  template: function ClrDateContainer_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c28);
      ɵɵprojection(0);
      ɵɵtemplate(1, ClrDateContainer_label_1_Template, 1, 0, "label", 1);
      ɵɵelementStart(2, "div", 2)(3, "div", 3)(4, "div", 4);
      ɵɵprojection(5, 1);
      ɵɵtemplate(6, ClrDateContainer_button_6_Template, 3, 1, "button", 5)(7, ClrDateContainer_clr_datepicker_view_manager_7_Template, 1, 0, "clr-datepicker-view-manager", 6);
      ɵɵelementEnd();
      ɵɵtemplate(8, ClrDateContainer_cds_icon_8_Template, 1, 0, "cds-icon", 7)(9, ClrDateContainer_cds_icon_9_Template, 1, 0, "cds-icon", 8);
      ɵɵelementEnd();
      ɵɵtemplate(10, ClrDateContainer_ng_content_10_Template, 1, 0, "ng-content", 1)(11, ClrDateContainer_ng_content_11_Template, 1, 0, "ng-content", 1)(12, ClrDateContainer_ng_content_12_Template, 1, 0, "ng-content", 1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.label && ctx.addGrid());
      ɵɵadvance();
      ɵɵproperty("ngClass", ctx.controlClass());
      ɵɵadvance(2);
      ɵɵclassProp("clr-focus", ctx.focus);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.isEnabled);
      ɵɵadvance();
      ɵɵproperty("clrPopoverContent", ctx.open)("clrPopoverContentAt", ctx.popoverPosition)("clrPopoverContentOutsideClickToClose", true)("clrPopoverContentScrollToClose", true);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showInvalid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showValid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showHelper);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showInvalid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showValid);
    }
  },
  dependencies: [NgClass, NgIf, CdkTrapFocusModule_CdkTrapFocus, ClrPopoverAnchor, ClrPopoverOpenCloseButton, ClrPopoverContent, CdsIconCustomTag, ClrLabel, ClrDatepickerViewManager],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDateContainer, [{
    type: Component,
    args: [{
      selector: "clr-date-container",
      template: `
    <ng-content select="label"></ng-content>
    <label *ngIf="!label && addGrid()"></label>
    <div class="clr-control-container" [ngClass]="controlClass()">
      <div class="clr-input-wrapper" clrPopoverAnchor>
        <div class="clr-input-group" [class.clr-focus]="focus">
          <ng-content select="[clrDate]"></ng-content>
          <button
            #actionButton
            type="button"
            clrPopoverOpenCloseButton
            class="clr-input-group-icon-action"
            [disabled]="isInputDateDisabled"
            *ngIf="isEnabled"
          >
            <cds-icon status="info" shape="calendar"></cds-icon>
          </button>
          <clr-datepicker-view-manager
            *clrPopoverContent="open; at: popoverPosition; outsideClickToClose: true; scrollToClose: true"
            cdkTrapFocus
          ></clr-datepicker-view-manager>
        </div>
        <cds-icon
          *ngIf="showInvalid"
          class="clr-validate-icon"
          shape="exclamation-circle"
          status="danger"
          aria-hidden="true"
        ></cds-icon>
        <cds-icon
          *ngIf="showValid"
          class="clr-validate-icon"
          shape="check-circle"
          status="success"
          aria-hidden="true"
        ></cds-icon>
      </div>
      <ng-content select="clr-control-helper" *ngIf="showHelper"></ng-content>
      <ng-content select="clr-control-error" *ngIf="showInvalid"></ng-content>
      <ng-content select="clr-control-success" *ngIf="showValid"></ng-content>
    </div>
  `,
      providers: [ControlIdService, LocaleHelperService, ControlClassService, FocusService2, NgControlService, DateIOService, DateNavigationService, DatepickerEnabledService, DateFormControlService, ViewManagerService, IfControlStateService],
      hostDirectives: [ClrPopoverHostDirective],
      host: {
        "[class.clr-date-container]": "true",
        "[class.clr-form-control-disabled]": "isInputDateDisabled",
        "[class.clr-form-control]": "true",
        "[class.clr-row]": "addGrid()"
      }
    }]
  }], function() {
    return [{
      type: Renderer2
    }, {
      type: ClrPopoverToggleService
    }, {
      type: DateNavigationService
    }, {
      type: DatepickerEnabledService
    }, {
      type: DateFormControlService
    }, {
      type: DateIOService
    }, {
      type: ClrCommonStringsService
    }, {
      type: FocusService2
    }, {
      type: ViewManagerService
    }, {
      type: ControlClassService
    }, {
      type: LayoutService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: NgControlService
    }, {
      type: IfControlStateService
    }];
  }, {
    clrPosition: [{
      type: Input,
      args: ["clrPosition"]
    }],
    actionButton: [{
      type: ViewChild,
      args: ["actionButton"]
    }]
  });
})();
var ClrDateInput = class extends WrappedFormControl {
  constructor(viewContainerRef, injector, el, renderer, control, container, dateIOService, dateNavigationService, datepickerEnabledService, dateFormControlService, platformId, focusService, datepickerFocusService) {
    super(viewContainerRef, ClrDateContainer, injector, control, renderer, el);
    this.el = el;
    this.renderer = renderer;
    this.control = control;
    this.container = container;
    this.dateIOService = dateIOService;
    this.dateNavigationService = dateNavigationService;
    this.datepickerEnabledService = datepickerEnabledService;
    this.dateFormControlService = dateFormControlService;
    this.platformId = platformId;
    this.focusService = focusService;
    this.datepickerFocusService = datepickerFocusService;
    this.dateChange = new EventEmitter(false);
    this.index = 1;
  }
  set date(date) {
    if (this.previousDateChange !== date) {
      this.updateDate(this.getValidDateValueFromDate(date));
    }
    if (!this.initialClrDateInputValue) {
      this.initialClrDateInputValue = date;
    }
  }
  set min(dateString) {
    this.dateIOService.setMinDate(dateString);
    this.triggerControlValidation();
  }
  set max(dateString) {
    this.dateIOService.setMaxDate(dateString);
    this.triggerControlValidation();
  }
  get disabled() {
    if (this.dateFormControlService) {
      return this.dateFormControlService.disabled;
    }
    return null;
  }
  set disabled(value) {
    if (this.dateFormControlService) {
      this.dateFormControlService.setDisabled(isBooleanAttributeSet(value));
    }
  }
  get placeholderText() {
    return this.placeholder ? this.placeholder : this.dateIOService.placeholderText;
  }
  get inputType() {
    return isPlatformBrowser(this.platformId) && this.usingNativeDatepicker() ? "date" : "text";
  }
  ngOnInit() {
    super.ngOnInit();
    this.populateServicesFromContainerComponent();
    this.subscriptions.push(this.listenForUserSelectedDayChanges(), this.listenForControlValueChanges(), this.listenForTouchChanges(), this.listenForDirtyChanges(), this.listenForInputRefocus());
  }
  ngAfterViewInit() {
    this.processInitialInputs();
  }
  setFocusStates() {
    this.setFocus(true);
  }
  triggerValidation() {
    super.triggerValidation();
    this.setFocus(false);
  }
  onValueChange(target) {
    const validDateValue = this.dateIOService.getDateValueFromDateString(target.value);
    if (this.usingClarityDatepicker() && validDateValue) {
      this.updateDate(validDateValue, true);
    } else if (this.usingNativeDatepicker()) {
      const [year, month, day] = target.value.split("-");
      this.updateDate(new Date(+year, +month - 1, +day), true);
    } else {
      this.emitDateOutput(null);
    }
  }
  usingClarityDatepicker() {
    return this.datepickerEnabledService.isEnabled;
  }
  usingNativeDatepicker() {
    return !this.datepickerEnabledService.isEnabled;
  }
  setFocus(focus) {
    if (this.focusService) {
      this.focusService.focused = focus;
    }
  }
  triggerControlValidation() {
    if (this.datepickerHasFormControl()) {
      this.control.control?.updateValueAndValidity({
        emitEvent: false
      });
      this.control.control?.setErrors(this.control.control.errors);
    }
  }
  populateServicesFromContainerComponent() {
    if (!this.container) {
      this.dateIOService = this.getProviderFromContainer(DateIOService);
      this.dateNavigationService = this.getProviderFromContainer(DateNavigationService);
      this.datepickerEnabledService = this.getProviderFromContainer(DatepickerEnabledService);
      this.dateFormControlService = this.getProviderFromContainer(DateFormControlService);
    }
  }
  processInitialInputs() {
    if (this.datepickerHasFormControl()) {
      this.updateDate(this.dateIOService.getDateValueFromDateString(this.control.value));
    } else {
      this.updateDate(this.initialClrDateInputValue);
    }
  }
  updateDate(value, setByUserInteraction = false) {
    const date = this.getValidDateValueFromDate(value);
    if (setByUserInteraction) {
      this.emitDateOutput(date);
    } else {
      this.previousDateChange = date;
    }
    if (this.dateNavigationService) {
      this.dateNavigationService.selectedDay = date ? new DayModel(date.getFullYear(), date.getMonth(), date.getDate()) : null;
    }
    this.updateInput(date);
  }
  updateInput(date) {
    if (date) {
      const dateString = this.dateIOService.toLocaleDisplayFormatString(date);
      if (this.usingNativeDatepicker()) {
        date.setMinutes(date.getMinutes() - date.getTimezoneOffset());
        this.renderer.setProperty(this.el.nativeElement, "valueAsDate", date);
      } else if (this.datepickerHasFormControl() && dateString !== this.control.value) {
        this.control.control.setValue(dateString);
      } else {
        this.renderer.setProperty(this.el.nativeElement, "value", dateString);
      }
    } else {
      this.renderer.setProperty(this.el.nativeElement, "value", "");
    }
  }
  getValidDateValueFromDate(date) {
    if (this.dateIOService) {
      const dateString = this.dateIOService.toLocaleDisplayFormatString(date);
      return this.dateIOService.getDateValueFromDateString(dateString);
    } else {
      return null;
    }
  }
  emitDateOutput(date) {
    if (!datesAreEqual(date, this.previousDateChange)) {
      this.dateChange.emit(date);
      this.previousDateChange = date;
    } else if (!date && this.previousDateChange) {
      this.dateChange.emit(null);
      this.previousDateChange = null;
    }
  }
  datepickerHasFormControl() {
    return !!this.control;
  }
  listenForControlValueChanges() {
    return of(this.datepickerHasFormControl()).pipe(
      filter((hasControl) => hasControl),
      switchMap(() => this.control.valueChanges),
      // only update date value if not being set by user
      filter(() => !this.datepickerFocusService.elementIsFocused(this.el.nativeElement))
    ).subscribe((value) => this.updateDate(this.dateIOService.getDateValueFromDateString(value)));
  }
  listenForUserSelectedDayChanges() {
    return this.dateNavigationService.selectedDayChange.subscribe((dayModel) => this.updateDate(dayModel.toDate(), true));
  }
  listenForTouchChanges() {
    return this.dateFormControlService.touchedChange.pipe(filter(() => this.datepickerHasFormControl())).subscribe(() => this.control.control.markAsTouched());
  }
  listenForDirtyChanges() {
    return this.dateFormControlService.dirtyChange.pipe(filter(() => this.datepickerHasFormControl())).subscribe(() => this.control.control.markAsDirty());
  }
  listenForInputRefocus() {
    return this.dateNavigationService.selectedDayChange.pipe(filter((date) => !!date)).subscribe(() => this.datepickerFocusService.focusInput(this.el.nativeElement));
  }
};
ClrDateInput.ɵfac = function ClrDateInput_Factory(t3) {
  return new (t3 || ClrDateInput)(ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgControl, 10), ɵɵdirectiveInject(ClrDateContainer, 8), ɵɵdirectiveInject(DateIOService, 8), ɵɵdirectiveInject(DateNavigationService, 8), ɵɵdirectiveInject(DatepickerEnabledService, 8), ɵɵdirectiveInject(DateFormControlService, 8), ɵɵdirectiveInject(PLATFORM_ID), ɵɵdirectiveInject(FocusService2, 8), ɵɵdirectiveInject(DatepickerFocusService));
};
ClrDateInput.ɵdir = ɵɵdefineDirective({
  type: ClrDateInput,
  selectors: [["", "clrDate", ""]],
  hostVars: 5,
  hostBindings: function ClrDateInput_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("focus", function ClrDateInput_focus_HostBindingHandler() {
        return ctx.setFocusStates();
      })("blur", function ClrDateInput_blur_HostBindingHandler() {
        return ctx.triggerValidation();
      })("change", function ClrDateInput_change_HostBindingHandler($event) {
        return ctx.onValueChange($event.target);
      });
    }
    if (rf & 2) {
      ɵɵhostProperty("disabled", ctx.disabled);
      ɵɵattribute("placeholder", ctx.placeholderText)("type", ctx.inputType);
      ɵɵclassProp("clr-input", true);
    }
  },
  inputs: {
    placeholder: "placeholder",
    date: [InputFlags.None, "clrDate", "date"],
    min: "min",
    max: "max",
    disabled: "disabled"
  },
  outputs: {
    dateChange: "clrDateChange"
  },
  features: [ɵɵProvidersFeature([DatepickerFocusService]), ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDateInput, [{
    type: Directive,
    args: [{
      selector: "[clrDate]",
      host: {
        "[class.clr-input]": "true"
      },
      providers: [DatepickerFocusService]
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }, {
      type: Injector
    }, {
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: NgControl,
      decorators: [{
        type: Self
      }, {
        type: Optional
      }]
    }, {
      type: ClrDateContainer,
      decorators: [{
        type: Optional
      }]
    }, {
      type: DateIOService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: DateNavigationService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: DatepickerEnabledService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: DateFormControlService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [PLATFORM_ID]
      }]
    }, {
      type: FocusService2,
      decorators: [{
        type: Optional
      }]
    }, {
      type: DatepickerFocusService
    }];
  }, {
    placeholder: [{
      type: Input
    }],
    dateChange: [{
      type: Output,
      args: ["clrDateChange"]
    }],
    date: [{
      type: Input,
      args: ["clrDate"]
    }],
    min: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    disabled: [{
      type: Input,
      args: ["disabled"]
    }, {
      type: HostBinding,
      args: ["disabled"]
    }],
    placeholderText: [{
      type: HostBinding,
      args: ["attr.placeholder"]
    }],
    inputType: [{
      type: HostBinding,
      args: ["attr.type"]
    }],
    setFocusStates: [{
      type: HostListener,
      args: ["focus"]
    }],
    triggerValidation: [{
      type: HostListener,
      args: ["blur"]
    }],
    onValueChange: [{
      type: HostListener,
      args: ["change", ["$event.target"]]
    }]
  });
})();
var ClrDateInputValidator = class {
  constructor(dateIOService) {
    this.dateIOService = dateIOService;
  }
  validate(control) {
    if (this.dateIOService) {
      const value = this.dateIOService.getDateValueFromDateString(control.value);
      const minDate = this.dateIOService.disabledDates.minDate.toDate();
      const maxDate = this.dateIOService.disabledDates.maxDate.toDate();
      if (value && value < this.dateIOService.disabledDates.minDate.toDate()) {
        return {
          min: {
            min: minDate.toLocaleDateString(),
            actual: value.toLocaleDateString()
          }
        };
      } else if (value && value > this.dateIOService.disabledDates.maxDate.toDate()) {
        return {
          max: {
            max: maxDate.toLocaleDateString(),
            actual: value.toLocaleDateString()
          }
        };
      }
    }
    return null;
  }
};
ClrDateInputValidator.ɵfac = function ClrDateInputValidator_Factory(t3) {
  return new (t3 || ClrDateInputValidator)(ɵɵdirectiveInject(DateIOService, 8));
};
ClrDateInputValidator.ɵdir = ɵɵdefineDirective({
  type: ClrDateInputValidator,
  selectors: [["", "clrDate", ""]],
  features: [ɵɵProvidersFeature([{
    provide: NG_VALIDATORS,
    useExisting: ClrDateInputValidator,
    multi: true
  }])]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDateInputValidator, [{
    type: Directive,
    args: [{
      selector: "[clrDate]",
      providers: [{
        provide: NG_VALIDATORS,
        useExisting: ClrDateInputValidator,
        multi: true
      }]
    }]
  }], function() {
    return [{
      type: DateIOService,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var CLR_DATEPICKER_DIRECTIVES = [ClrDay, ClrDateContainer, ClrDateInput, ClrDateInputValidator, ClrDatepickerViewManager, ClrMonthpicker, ClrYearpicker, ClrDaypicker, ClrCalendar];
var ClrDatepickerModule = class {
  constructor() {
    r.addIcons(e3, l, o3, a3, e);
  }
};
ClrDatepickerModule.ɵfac = function ClrDatepickerModule_Factory(t3) {
  return new (t3 || ClrDatepickerModule)();
};
ClrDatepickerModule.ɵmod = ɵɵdefineNgModule({
  type: ClrDatepickerModule,
  declarations: [ClrDay, ClrDateContainer, ClrDateInput, ClrDateInputValidator, ClrDatepickerViewManager, ClrMonthpicker, ClrYearpicker, ClrDaypicker, ClrCalendar],
  imports: [CommonModule, CdkTrapFocusModule, ClrHostWrappingModule, ClrConditionalModule, ClrPopoverModuleNext, ClrIconModule, ClrCommonFormsModule],
  exports: [ClrDay, ClrDateContainer, ClrDateInput, ClrDateInputValidator, ClrDatepickerViewManager, ClrMonthpicker, ClrYearpicker, ClrDaypicker, ClrCalendar]
});
ClrDatepickerModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, CdkTrapFocusModule, ClrHostWrappingModule, ClrConditionalModule, ClrPopoverModuleNext, ClrIconModule, ClrCommonFormsModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDatepickerModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, CdkTrapFocusModule, ClrHostWrappingModule, ClrConditionalModule, ClrPopoverModuleNext, ClrIconModule, ClrCommonFormsModule],
      declarations: [CLR_DATEPICKER_DIRECTIVES],
      exports: [CLR_DATEPICKER_DIRECTIVES]
    }]
  }], function() {
    return [];
  }, null);
})();
var ClrFileInputContainer = class extends ClrAbstractContainer {
  constructor() {
    super(...arguments);
    this.commonStrings = inject(ClrCommonStringsService);
  }
  get disabled() {
    return this.fileInput.elementRef.nativeElement.disabled;
  }
  get browseButtonDescribedBy() {
    return this.fileInput.elementRef.nativeElement.getAttribute("aria-describedby");
  }
  browse() {
    this.fileInput.elementRef.nativeElement.click();
  }
  clearSelectedFiles() {
    this.fileInput.elementRef.nativeElement.value = "";
    this.fileInput.elementRef.nativeElement.dispatchEvent(new Event("change", {
      bubbles: true,
      cancelable: true
    }));
    this.browseButtonElementRef.nativeElement.focus();
  }
};
ClrFileInputContainer.ɵfac = /* @__PURE__ */ (() => {
  let ɵClrFileInputContainer_BaseFactory;
  return function ClrFileInputContainer_Factory(t3) {
    return (ɵClrFileInputContainer_BaseFactory || (ɵClrFileInputContainer_BaseFactory = ɵɵgetInheritedFactory(ClrFileInputContainer)))(t3 || ClrFileInputContainer);
  };
})();
ClrFileInputContainer.ɵcmp = ɵɵdefineComponent({
  type: ClrFileInputContainer,
  selectors: [["clr-file-input-container"]],
  contentQueries: function ClrFileInputContainer_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ClrFileInput, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.fileInput = _t.first);
    }
  },
  viewQuery: function ClrFileInputContainer_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c30, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.browseButtonElementRef = _t.first);
    }
  },
  hostVars: 6,
  hostBindings: function ClrFileInputContainer_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("clr-form-control", true)("clr-form-control-disabled", ctx.disabled)("clr-row", ctx.addGrid());
    }
  },
  inputs: {
    customButtonLabel: [InputFlags.None, "clrButtonLabel", "customButtonLabel"]
  },
  features: [ɵɵProvidersFeature([IfControlStateService, NgControlService, ControlIdService, ControlClassService]), ɵɵInheritDefinitionFeature],
  ngContentSelectors: _c32,
  decls: 16,
  vars: 11,
  consts: [["browseButton", ""], [4, "ngIf"], [1, "clr-control-container", 3, "ngClass"], [1, "clr-file-input-wrapper"], ["type", "button", 1, "btn", "btn-sm", "clr-file-input-browse-button", 3, "click", "disabled"], ["shape", "folder-open"], [1, "clr-file-input-browse-button-text"], ["type", "button", "class", "btn btn-sm clr-file-input-clear-button", 3, "click", 4, "ngIf"], ["class", "clr-validate-icon", "shape", "exclamation-circle", "status", "danger", "aria-hidden", "true", 4, "ngIf"], ["class", "clr-validate-icon", "shape", "check-circle", "status", "success", "aria-hidden", "true", 4, "ngIf"], ["type", "button", 1, "btn", "btn-sm", "clr-file-input-clear-button", 3, "click"], ["shape", "times", "status", "neutral", "size", "md"], ["shape", "exclamation-circle", "status", "danger", "aria-hidden", "true", 1, "clr-validate-icon"], ["shape", "check-circle", "status", "success", "aria-hidden", "true", 1, "clr-validate-icon"]],
  template: function ClrFileInputContainer_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵprojectionDef(_c31);
      ɵɵprojection(0);
      ɵɵtemplate(1, ClrFileInputContainer_label_1_Template, 1, 0, "label", 1);
      ɵɵelementStart(2, "div", 2)(3, "div", 3);
      ɵɵprojection(4, 1);
      ɵɵelementStart(5, "button", 4, 0);
      ɵɵlistener("click", function ClrFileInputContainer_Template_button_click_5_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.browse());
      });
      ɵɵelement(7, "cds-icon", 5);
      ɵɵelementStart(8, "span", 6);
      ɵɵtext(9);
      ɵɵelementEnd()();
      ɵɵtemplate(10, ClrFileInputContainer_button_10_Template, 2, 1, "button", 7)(11, ClrFileInputContainer_cds_icon_11_Template, 1, 0, "cds-icon", 8)(12, ClrFileInputContainer_cds_icon_12_Template, 1, 0, "cds-icon", 9);
      ɵɵelementEnd();
      ɵɵtemplate(13, ClrFileInputContainer_ng_content_13_Template, 1, 0, "ng-content", 1)(14, ClrFileInputContainer_ng_content_14_Template, 1, 0, "ng-content", 1)(15, ClrFileInputContainer_ng_content_15_Template, 1, 0, "ng-content", 1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.label && ctx.addGrid());
      ɵɵadvance();
      ɵɵproperty("ngClass", ctx.controlClass());
      ɵɵadvance(3);
      ɵɵproperty("disabled", ctx.disabled);
      ɵɵattribute("aria-describedby", ctx.browseButtonDescribedBy);
      ɵɵadvance(4);
      ɵɵtextInterpolate1(" ", (ctx.fileInput == null ? null : ctx.fileInput.selection == null ? null : ctx.fileInput.selection.buttonLabel) || ctx.customButtonLabel || ctx.commonStrings.keys.browse, " ");
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.fileInput == null ? null : ctx.fileInput.selection == null ? null : ctx.fileInput.selection.fileCount);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showInvalid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showValid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showHelper);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showInvalid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showValid);
    }
  },
  dependencies: [NgClass, NgIf, CdsIconCustomTag, ClrLabel],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrFileInputContainer, [{
    type: Component,
    args: [{
      selector: "clr-file-input-container",
      template: `
    <ng-content select="label"></ng-content>
    <label *ngIf="!label && addGrid()"></label>
    <div class="clr-control-container" [ngClass]="controlClass()">
      <div class="clr-file-input-wrapper">
        <ng-content select="[clrFileInput]"></ng-content>
        <button
          #browseButton
          type="button"
          class="btn btn-sm clr-file-input-browse-button"
          [attr.aria-describedby]="browseButtonDescribedBy"
          [disabled]="disabled"
          (click)="browse()"
        >
          <cds-icon shape="folder-open"></cds-icon>
          <span class="clr-file-input-browse-button-text">
            {{ fileInput?.selection?.buttonLabel || customButtonLabel || commonStrings.keys.browse }}
          </span>
        </button>
        <button
          *ngIf="fileInput?.selection?.fileCount"
          type="button"
          class="btn btn-sm clr-file-input-clear-button"
          [attr.aria-label]="fileInput?.selection?.clearFilesButtonLabel"
          (click)="clearSelectedFiles()"
        >
          <cds-icon shape="times" status="neutral" size="md"></cds-icon>
        </button>
        <cds-icon
          *ngIf="showInvalid"
          class="clr-validate-icon"
          shape="exclamation-circle"
          status="danger"
          aria-hidden="true"
        ></cds-icon>
        <cds-icon
          *ngIf="showValid"
          class="clr-validate-icon"
          shape="check-circle"
          status="success"
          aria-hidden="true"
        ></cds-icon>
      </div>
      <ng-content select="clr-control-helper" *ngIf="showHelper"></ng-content>
      <ng-content select="clr-control-error" *ngIf="showInvalid"></ng-content>
      <ng-content select="clr-control-success" *ngIf="showValid"></ng-content>
    </div>
  `,
      host: {
        "[class.clr-form-control]": "true",
        "[class.clr-form-control-disabled]": "disabled",
        "[class.clr-row]": "addGrid()"
      },
      providers: [IfControlStateService, NgControlService, ControlIdService, ControlClassService]
    }]
  }], null, {
    customButtonLabel: [{
      type: Input,
      args: ["clrButtonLabel"]
    }],
    fileInput: [{
      type: ContentChild,
      args: [forwardRef(() => ClrFileInput)]
    }],
    browseButtonElementRef: [{
      type: ViewChild,
      args: ["browseButton"]
    }]
  });
})();
var ClrFileInput = class extends WrappedFormControl {
  constructor(injector, renderer, viewContainerRef, elementRef, control, commonStrings) {
    super(viewContainerRef, ClrFileInputContainer, injector, control, renderer, elementRef);
    this.elementRef = elementRef;
    this.commonStrings = commonStrings;
    this.selection = void 0;
  }
  handleChange() {
    this.updateSelection();
  }
  updateSelection() {
    const files = this.elementRef.nativeElement.files;
    let selectionButtonLabel;
    let clearFilesButtonLabel;
    if (files?.length === 1) {
      const filename = files[0].name;
      selectionButtonLabel = filename;
      clearFilesButtonLabel = this.commonStrings.parse(this.commonStrings.keys.clearFile, {
        FILE: filename
      });
    } else if (files?.length > 1) {
      const fileCount = files.length.toString();
      selectionButtonLabel = this.commonStrings.parse(this.commonStrings.keys.fileCount, {
        COUNT: fileCount
      });
      clearFilesButtonLabel = this.commonStrings.parse(this.commonStrings.keys.clearFiles, {
        COUNT: fileCount
      });
    }
    this.selection = {
      fileCount: files.length,
      buttonLabel: selectionButtonLabel,
      clearFilesButtonLabel
    };
  }
};
ClrFileInput.ɵfac = function ClrFileInput_Factory(t3) {
  return new (t3 || ClrFileInput)(ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgControl, 10), ɵɵdirectiveInject(ClrCommonStringsService));
};
ClrFileInput.ɵdir = ɵɵdefineDirective({
  type: ClrFileInput,
  selectors: [["input", "type", "file", "clrFileInput", ""]],
  hostVars: 2,
  hostBindings: function ClrFileInput_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("change", function ClrFileInput_change_HostBindingHandler() {
        return ctx.handleChange();
      });
    }
    if (rf & 2) {
      ɵɵclassProp("clr-file-input", true);
    }
  },
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrFileInput, [{
    type: Directive,
    args: [{
      selector: 'input[type="file"][clrFileInput]',
      host: {
        "[class.clr-file-input]": "true"
      }
    }]
  }], function() {
    return [{
      type: Injector
    }, {
      type: Renderer2
    }, {
      type: ViewContainerRef
    }, {
      type: ElementRef
    }, {
      type: NgControl,
      decorators: [{
        type: Self
      }, {
        type: Optional
      }]
    }, {
      type: ClrCommonStringsService
    }];
  }, {
    handleChange: [{
      type: HostListener,
      args: ["change"]
    }]
  });
})();
var ClrFileInputValidator = class {
  constructor(elementRef) {
    this.elementRef = elementRef;
  }
  validate(control) {
    const files = control.value;
    const fileInputElement = this.elementRef.nativeElement;
    const errors = {};
    if (fileInputElement.required && files?.length === 0) {
      errors.required = true;
    }
    if (fileInputElement.accept && files?.length > 0) {
      const accept = fileInputElement.accept.split(",").map((type) => type.trim());
      for (let i2 = 0; i2 < files.length; i2++) {
        const file = files.item(i2);
        const [fileExtension] = file.name.match(/\..+$/);
        if (!accept.includes(file.type) && !accept.includes(fileExtension)) {
          errors.accept = errors.accept || [];
          errors.accept.push({
            name: file.name,
            accept,
            type: file.type,
            extension: fileExtension
          });
        }
      }
    }
    if (this.minFileSize && files?.length > 0) {
      for (let i2 = 0; i2 < files.length; i2++) {
        const file = files.item(i2);
        if (file.size < this.minFileSize) {
          errors.minFileSize = errors.minFileSize || [];
          errors.minFileSize.push({
            name: file.name,
            minFileSize: this.minFileSize,
            actualFileSize: file.size
          });
        }
      }
    }
    if (this.maxFileSize && files?.length > 0) {
      for (let i2 = 0; i2 < files.length; i2++) {
        const file = files.item(i2);
        if (file.size > this.maxFileSize) {
          errors.maxFileSize = errors.maxFileSize || [];
          errors.maxFileSize.push({
            name: file.name,
            maxFileSize: this.maxFileSize,
            actualFileSize: file.size
          });
        }
      }
    }
    return Object.keys(errors).length ? errors : null;
  }
};
ClrFileInputValidator.ɵfac = function ClrFileInputValidator_Factory(t3) {
  return new (t3 || ClrFileInputValidator)(ɵɵdirectiveInject(ElementRef));
};
ClrFileInputValidator.ɵdir = ɵɵdefineDirective({
  type: ClrFileInputValidator,
  selectors: [["input", "type", "file", "clrFileInput", ""]],
  inputs: {
    minFileSize: [InputFlags.None, "clrMinFileSize", "minFileSize"],
    maxFileSize: [InputFlags.None, "clrMaxFileSize", "maxFileSize"]
  },
  features: [ɵɵProvidersFeature([{
    provide: NG_VALIDATORS,
    useExisting: ClrFileInputValidator,
    multi: true
  }])]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrFileInputValidator, [{
    type: Directive,
    args: [{
      selector: 'input[type="file"][clrFileInput]',
      providers: [{
        provide: NG_VALIDATORS,
        useExisting: ClrFileInputValidator,
        multi: true
      }]
    }]
  }], function() {
    return [{
      type: ElementRef
    }];
  }, {
    minFileSize: [{
      type: Input,
      args: ["clrMinFileSize"]
    }],
    maxFileSize: [{
      type: Input,
      args: ["clrMaxFileSize"]
    }]
  });
})();
function buildFileList(files) {
  const dataTransfer = new DataTransfer();
  for (const file of files) {
    dataTransfer.items.add(file);
  }
  return dataTransfer.files;
}
function selectFiles(fileInputElement, files) {
  fileInputElement.files = files instanceof FileList ? files : buildFileList(files);
  fileInputElement.dispatchEvent(new Event("change", {
    bubbles: true,
    cancelable: true
  }));
}
function clearFiles(fileInputElement) {
  fileInputElement.value = "";
  fileInputElement.dispatchEvent(new Event("change", {
    bubbles: true,
    cancelable: true
  }));
}
var ClrFileInputValueAccessor = class {
  constructor(elementRef) {
    this.elementRef = elementRef;
    this.onChange = (_value) => {
    };
    this.onTouched = () => {
    };
  }
  writeValue(value) {
    if (value !== void 0 && value !== null && !(value instanceof FileList)) {
      throw new Error("The value of a file input control must be a FileList.");
    }
    if (value) {
      selectFiles(this.elementRef.nativeElement, value);
    } else if (this.elementRef.nativeElement.files.length) {
      clearFiles(this.elementRef.nativeElement);
    }
  }
  registerOnChange(fn) {
    this.onChange = fn;
  }
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  handleChange() {
    this.onTouched();
    this.onChange(this.elementRef.nativeElement.files);
  }
};
ClrFileInputValueAccessor.ɵfac = function ClrFileInputValueAccessor_Factory(t3) {
  return new (t3 || ClrFileInputValueAccessor)(ɵɵdirectiveInject(ElementRef));
};
ClrFileInputValueAccessor.ɵdir = ɵɵdefineDirective({
  type: ClrFileInputValueAccessor,
  selectors: [["input", "type", "file", "clrFileInput", ""]],
  hostBindings: function ClrFileInputValueAccessor_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("change", function ClrFileInputValueAccessor_change_HostBindingHandler() {
        return ctx.handleChange();
      });
    }
  },
  features: [ɵɵProvidersFeature([{
    provide: NG_VALUE_ACCESSOR,
    useExisting: ClrFileInputValueAccessor,
    multi: true
  }])]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrFileInputValueAccessor, [{
    type: Directive,
    args: [{
      selector: 'input[type="file"][clrFileInput]',
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: ClrFileInputValueAccessor,
        multi: true
      }]
    }]
  }], function() {
    return [{
      type: ElementRef
    }];
  }, {
    handleChange: [{
      type: HostListener,
      args: ["change"]
    }]
  });
})();
var ClrFileInputModule = class {
  constructor() {
    r.addIcons(H);
  }
};
ClrFileInputModule.ɵfac = function ClrFileInputModule_Factory(t3) {
  return new (t3 || ClrFileInputModule)();
};
ClrFileInputModule.ɵmod = ɵɵdefineNgModule({
  type: ClrFileInputModule,
  declarations: [ClrFileInput, ClrFileInputContainer, ClrFileInputValidator, ClrFileInputValueAccessor],
  imports: [CommonModule, ClrIconModule, ClrCommonFormsModule],
  exports: [ClrCommonFormsModule, ClrFileInput, ClrFileInputContainer, ClrFileInputValidator, ClrFileInputValueAccessor]
});
ClrFileInputModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, ClrIconModule, ClrCommonFormsModule, ClrCommonFormsModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrFileInputModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, ClrIconModule, ClrCommonFormsModule],
      declarations: [ClrFileInput, ClrFileInputContainer, ClrFileInputValidator, ClrFileInputValueAccessor],
      exports: [ClrCommonFormsModule, ClrFileInput, ClrFileInputContainer, ClrFileInputValidator, ClrFileInputValueAccessor]
    }]
  }], function() {
    return [];
  }, null);
})();
var TOGGLE_SERVICE = new InjectionToken(void 0);
function ToggleServiceFactory() {
  return new BehaviorSubject(false);
}
var TOGGLE_SERVICE_PROVIDER = {
  provide: TOGGLE_SERVICE,
  useFactory: ToggleServiceFactory
};
var ClrPasswordContainer = class extends ClrAbstractContainer {
  constructor(ifControlStateService, layoutService, controlClassService, ngControlService, focusService, toggleService, commonStrings) {
    super(ifControlStateService, layoutService, controlClassService, ngControlService);
    this.focusService = focusService;
    this.toggleService = toggleService;
    this.commonStrings = commonStrings;
    this.show = false;
    this.focus = false;
    this._toggle = true;
    this.subscriptions.push(this.focusService.focusChange.subscribe((state2) => {
      this.focus = state2;
    }));
  }
  get clrToggle() {
    return this._toggle;
  }
  set clrToggle(state2) {
    this._toggle = state2;
    if (!state2) {
      this.show = false;
    }
  }
  toggle() {
    this.show = !this.show;
    this.toggleService.next(this.show);
  }
  showPasswordText(label) {
    return this.commonStrings.parse(this.commonStrings.keys.passwordShow, {
      LABEL: label
    });
  }
  hidePasswordText(label) {
    return this.commonStrings.parse(this.commonStrings.keys.passwordHide, {
      LABEL: label
    });
  }
};
ClrPasswordContainer.ɵfac = function ClrPasswordContainer_Factory(t3) {
  return new (t3 || ClrPasswordContainer)(ɵɵdirectiveInject(IfControlStateService), ɵɵdirectiveInject(LayoutService, 8), ɵɵdirectiveInject(ControlClassService), ɵɵdirectiveInject(NgControlService), ɵɵdirectiveInject(FocusService2), ɵɵdirectiveInject(TOGGLE_SERVICE), ɵɵdirectiveInject(ClrCommonStringsService));
};
ClrPasswordContainer.ɵcmp = ɵɵdefineComponent({
  type: ClrPasswordContainer,
  selectors: [["clr-password-container"]],
  hostVars: 6,
  hostBindings: function ClrPasswordContainer_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("clr-form-control", true)("clr-form-control-disabled", ctx.control == null ? null : ctx.control.disabled)("clr-row", ctx.addGrid());
    }
  },
  inputs: {
    clrToggle: "clrToggle"
  },
  features: [ɵɵProvidersFeature([NgControlService, ControlIdService, ControlClassService, FocusService2, TOGGLE_SERVICE_PROVIDER, IfControlStateService]), ɵɵInheritDefinitionFeature],
  ngContentSelectors: _c34,
  decls: 12,
  vars: 10,
  consts: [[4, "ngIf"], [1, "clr-control-container", 3, "ngClass"], [1, "clr-input-wrapper"], [1, "clr-input-group"], ["class", "clr-input-group-icon-action", "type", "button", 3, "disabled", "click", 4, "ngIf"], ["class", "clr-validate-icon", "shape", "exclamation-circle", "status", "danger", "aria-hidden", "true", 4, "ngIf"], ["class", "clr-validate-icon", "shape", "check-circle", "status", "success", "aria-hidden", "true", 4, "ngIf"], ["type", "button", 1, "clr-input-group-icon-action", 3, "click", "disabled"], [1, "clr-password-eye-icon"], [1, "clr-sr-only"], ["shape", "exclamation-circle", "status", "danger", "aria-hidden", "true", 1, "clr-validate-icon"], ["shape", "check-circle", "status", "success", "aria-hidden", "true", 1, "clr-validate-icon"]],
  template: function ClrPasswordContainer_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c33);
      ɵɵprojection(0);
      ɵɵtemplate(1, ClrPasswordContainer_label_1_Template, 1, 0, "label", 0);
      ɵɵelementStart(2, "div", 1)(3, "div", 2)(4, "div", 3);
      ɵɵprojection(5, 1);
      ɵɵtemplate(6, ClrPasswordContainer_button_6_Template, 4, 3, "button", 4);
      ɵɵelementEnd();
      ɵɵtemplate(7, ClrPasswordContainer_cds_icon_7_Template, 1, 0, "cds-icon", 5)(8, ClrPasswordContainer_cds_icon_8_Template, 1, 0, "cds-icon", 6);
      ɵɵelementEnd();
      ɵɵtemplate(9, ClrPasswordContainer_ng_content_9_Template, 1, 0, "ng-content", 0)(10, ClrPasswordContainer_ng_content_10_Template, 1, 0, "ng-content", 0)(11, ClrPasswordContainer_ng_content_11_Template, 1, 0, "ng-content", 0);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.label && ctx.addGrid());
      ɵɵadvance();
      ɵɵproperty("ngClass", ctx.controlClass());
      ɵɵadvance(2);
      ɵɵclassProp("clr-focus", ctx.focus);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.clrToggle);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showInvalid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showValid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showHelper);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showInvalid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showValid);
    }
  },
  dependencies: [NgClass, NgIf, CdsIconCustomTag, ClrLabel],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrPasswordContainer, [{
    type: Component,
    args: [{
      selector: "clr-password-container",
      template: `
    <ng-content select="label"></ng-content>
    <label *ngIf="!label && addGrid()"></label>
    <div class="clr-control-container" [ngClass]="controlClass()">
      <div class="clr-input-wrapper">
        <div class="clr-input-group" [class.clr-focus]="focus">
          <ng-content select="[clrPassword]"></ng-content>
          <button
            *ngIf="clrToggle"
            (click)="toggle()"
            [disabled]="control?.disabled"
            class="clr-input-group-icon-action"
            type="button"
          >
            <cds-icon class="clr-password-eye-icon" [attr.shape]="show ? 'eye-hide' : 'eye'"></cds-icon>
            <span class="clr-sr-only">
              {{ show ? hidePasswordText(label?.labelText) : showPasswordText(label?.labelText) }}
            </span>
          </button>
        </div>
        <cds-icon
          *ngIf="showInvalid"
          class="clr-validate-icon"
          shape="exclamation-circle"
          status="danger"
          aria-hidden="true"
        ></cds-icon>
        <cds-icon
          *ngIf="showValid"
          class="clr-validate-icon"
          shape="check-circle"
          status="success"
          aria-hidden="true"
        ></cds-icon>
      </div>
      <ng-content select="clr-control-helper" *ngIf="showHelper"></ng-content>
      <ng-content select="clr-control-error" *ngIf="showInvalid"></ng-content>
      <ng-content select="clr-control-success" *ngIf="showValid"></ng-content>
    </div>
  `,
      host: {
        "[class.clr-form-control]": "true",
        "[class.clr-form-control-disabled]": "control?.disabled",
        "[class.clr-row]": "addGrid()"
      },
      providers: [NgControlService, ControlIdService, ControlClassService, FocusService2, TOGGLE_SERVICE_PROVIDER, IfControlStateService]
    }]
  }], function() {
    return [{
      type: IfControlStateService
    }, {
      type: LayoutService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: ControlClassService
    }, {
      type: NgControlService
    }, {
      type: FocusService2
    }, {
      type: BehaviorSubject,
      decorators: [{
        type: Inject,
        args: [TOGGLE_SERVICE]
      }]
    }, {
      type: ClrCommonStringsService
    }];
  }, {
    clrToggle: [{
      type: Input,
      args: ["clrToggle"]
    }]
  });
})();
var ClrPassword = class extends WrappedFormControl {
  constructor(vcr, injector, control, renderer, el, focusService, toggleService) {
    super(vcr, ClrPasswordContainer, injector, control, renderer, el);
    this.focusService = focusService;
    this.toggleService = toggleService;
    this.index = 1;
    if (!this.focusService) {
      throw new Error("clrPassword requires being wrapped in <clr-password-container>");
    }
    this.subscriptions.push(this.toggleService.subscribe((toggle) => {
      renderer.setProperty(el.nativeElement, "type", toggle ? "text" : "password");
    }));
  }
  triggerFocus() {
    if (this.focusService) {
      this.focusService.focused = true;
    }
  }
  triggerValidation() {
    super.triggerValidation();
    if (this.focusService) {
      this.focusService.focused = false;
    }
  }
};
ClrPassword.ɵfac = function ClrPassword_Factory(t3) {
  return new (t3 || ClrPassword)(ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(NgControl, 10), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(FocusService2, 8), ɵɵdirectiveInject(TOGGLE_SERVICE, 8));
};
ClrPassword.ɵdir = ɵɵdefineDirective({
  type: ClrPassword,
  selectors: [["", "clrPassword", ""]],
  hostVars: 2,
  hostBindings: function ClrPassword_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("focus", function ClrPassword_focus_HostBindingHandler() {
        return ctx.triggerFocus();
      })("blur", function ClrPassword_blur_HostBindingHandler() {
        return ctx.triggerValidation();
      });
    }
    if (rf & 2) {
      ɵɵclassProp("clr-input", true);
    }
  },
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrPassword, [{
    type: Directive,
    args: [{
      selector: "[clrPassword]",
      host: {
        "[class.clr-input]": "true"
      }
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }, {
      type: Injector
    }, {
      type: NgControl,
      decorators: [{
        type: Self
      }, {
        type: Optional
      }]
    }, {
      type: Renderer2
    }, {
      type: ElementRef
    }, {
      type: FocusService2,
      decorators: [{
        type: Optional
      }]
    }, {
      type: BehaviorSubject,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [TOGGLE_SERVICE]
      }]
    }];
  }, {
    triggerFocus: [{
      type: HostListener,
      args: ["focus"]
    }],
    triggerValidation: [{
      type: HostListener,
      args: ["blur"]
    }]
  });
})();
var ClrPasswordModule = class {
  constructor() {
    r.addIcons(e4, r2, e3, l);
  }
};
ClrPasswordModule.ɵfac = function ClrPasswordModule_Factory(t3) {
  return new (t3 || ClrPasswordModule)();
};
ClrPasswordModule.ɵmod = ɵɵdefineNgModule({
  type: ClrPasswordModule,
  declarations: [ClrPassword, ClrPasswordContainer],
  imports: [CommonModule, FormsModule, ClrIconModule, ClrCommonFormsModule],
  exports: [ClrCommonFormsModule, ClrPassword, ClrPasswordContainer]
});
ClrPasswordModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, FormsModule, ClrIconModule, ClrCommonFormsModule, ClrCommonFormsModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrPasswordModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, FormsModule, ClrIconModule, ClrCommonFormsModule],
      declarations: [ClrPassword, ClrPasswordContainer],
      exports: [ClrCommonFormsModule, ClrPassword, ClrPasswordContainer]
    }]
  }], function() {
    return [];
  }, null);
})();
var ClrRadioWrapper = class {
  constructor() {
    this._dynamic = false;
  }
  ngOnInit() {
    if (this.label) {
      this.label.disableGrid();
    }
  }
};
ClrRadioWrapper.ɵfac = function ClrRadioWrapper_Factory(t3) {
  return new (t3 || ClrRadioWrapper)();
};
ClrRadioWrapper.ɵcmp = ɵɵdefineComponent({
  type: ClrRadioWrapper,
  selectors: [["clr-radio-wrapper"]],
  contentQueries: function ClrRadioWrapper_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ClrLabel, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.label = _t.first);
    }
  },
  hostVars: 2,
  hostBindings: function ClrRadioWrapper_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("clr-radio-wrapper", true);
    }
  },
  features: [ɵɵProvidersFeature([ControlIdService])],
  ngContentSelectors: _c36,
  decls: 3,
  vars: 1,
  consts: [[4, "ngIf"]],
  template: function ClrRadioWrapper_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c35);
      ɵɵprojection(0);
      ɵɵprojection(1, 1);
      ɵɵtemplate(2, ClrRadioWrapper_label_2_Template, 1, 0, "label", 0);
    }
    if (rf & 2) {
      ɵɵadvance(2);
      ɵɵproperty("ngIf", !ctx.label);
    }
  },
  dependencies: [NgIf, ClrLabel],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrRadioWrapper, [{
    type: Component,
    args: [{
      selector: "clr-radio-wrapper",
      template: `
    <ng-content select="[clrRadio]"></ng-content>
    <ng-content select="label"></ng-content>
    <label *ngIf="!label"></label>
  `,
      host: {
        "[class.clr-radio-wrapper]": "true"
      },
      providers: [ControlIdService]
    }]
  }], null, {
    label: [{
      type: ContentChild,
      args: [ClrLabel, {
        static: true
      }]
    }]
  });
})();
var ClrRadio = class extends WrappedFormControl {
  constructor(vcr, injector, control, renderer, el) {
    super(vcr, ClrRadioWrapper, injector, control, renderer, el);
  }
};
ClrRadio.ɵfac = function ClrRadio_Factory(t3) {
  return new (t3 || ClrRadio)(ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(NgControl, 10), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef));
};
ClrRadio.ɵdir = ɵɵdefineDirective({
  type: ClrRadio,
  selectors: [["", "clrRadio", ""]],
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrRadio, [{
    type: Directive,
    args: [{
      selector: "[clrRadio]"
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }, {
      type: Injector
    }, {
      type: NgControl,
      decorators: [{
        type: Self
      }, {
        type: Optional
      }]
    }, {
      type: Renderer2
    }, {
      type: ElementRef
    }];
  }, null);
})();
var ClrRadioContainer = class extends ClrAbstractContainer {
  constructor(layoutService, controlClassService, ngControlService, ifControlStateService) {
    super(ifControlStateService, layoutService, controlClassService, ngControlService);
    this.layoutService = layoutService;
    this.controlClassService = controlClassService;
    this.ngControlService = ngControlService;
    this.ifControlStateService = ifControlStateService;
    this.inline = false;
    this._generatedId = uniqueIdFactory();
  }
  /*
   * Here we want to support the following cases
   * clrInline - true by presence
   * clrInline="true|false" - unless it is explicitly false, strings are considered true
   * [clrInline]="true|false" - expect a boolean
   */
  get clrInline() {
    return this.inline;
  }
  set clrInline(value) {
    if (typeof value === "string") {
      this.inline = value === "false" ? false : true;
    } else {
      this.inline = !!value;
    }
  }
  ngAfterContentInit() {
    this.setAriaRoles();
    this.setAriaLabelledBy();
  }
  setAriaRoles() {
    this.role = this.radios.length ? "radiogroup" : null;
  }
  setAriaLabelledBy() {
    const _id = this.groupLabel?.nativeElement.getAttribute("id");
    if (!_id) {
      this.groupLabel?.nativeElement.setAttribute("id", this._generatedId);
      this.ariaLabelledBy = this.radios.length ? this._generatedId : null;
    } else {
      this.ariaLabelledBy = this.radios.length ? _id : null;
    }
  }
};
ClrRadioContainer.ɵfac = function ClrRadioContainer_Factory(t3) {
  return new (t3 || ClrRadioContainer)(ɵɵdirectiveInject(LayoutService, 8), ɵɵdirectiveInject(ControlClassService), ɵɵdirectiveInject(NgControlService), ɵɵdirectiveInject(IfControlStateService));
};
ClrRadioContainer.ɵcmp = ɵɵdefineComponent({
  type: ClrRadioContainer,
  selectors: [["clr-radio-container"]],
  contentQueries: function ClrRadioContainer_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ClrLabel, 7, ElementRef);
      ɵɵcontentQuery(dirIndex, ClrRadio, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.groupLabel = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.radios = _t);
    }
  },
  hostVars: 8,
  hostBindings: function ClrRadioContainer_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("role", ctx.role)("aria-labelledby", ctx.ariaLabelledBy);
      ɵɵclassProp("clr-form-control", true)("clr-form-control-disabled", ctx.control == null ? null : ctx.control.disabled)("clr-row", ctx.addGrid());
    }
  },
  inputs: {
    clrInline: "clrInline"
  },
  features: [ɵɵProvidersFeature([NgControlService, IfControlStateService, ControlClassService, ContainerIdService]), ɵɵInheritDefinitionFeature],
  ngContentSelectors: _c38,
  decls: 10,
  vars: 9,
  consts: [[4, "ngIf"], [1, "clr-control-container", 3, "ngClass"], [1, "clr-subtext-wrapper"], ["class", "clr-validate-icon", "shape", "exclamation-circle", "status", "danger", "aria-hidden", "true", 4, "ngIf"], ["class", "clr-validate-icon", "shape", "check-circle", "status", "success", "aria-hidden", "true", 4, "ngIf"], ["shape", "exclamation-circle", "status", "danger", "aria-hidden", "true", 1, "clr-validate-icon"], ["shape", "check-circle", "status", "success", "aria-hidden", "true", 1, "clr-validate-icon"]],
  template: function ClrRadioContainer_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c37);
      ɵɵprojection(0);
      ɵɵtemplate(1, ClrRadioContainer_label_1_Template, 1, 0, "label", 0);
      ɵɵelementStart(2, "div", 1);
      ɵɵprojection(3, 1);
      ɵɵelementStart(4, "div", 2);
      ɵɵtemplate(5, ClrRadioContainer_ng_content_5_Template, 1, 0, "ng-content", 0)(6, ClrRadioContainer_cds_icon_6_Template, 1, 0, "cds-icon", 3)(7, ClrRadioContainer_cds_icon_7_Template, 1, 0, "cds-icon", 4)(8, ClrRadioContainer_ng_content_8_Template, 1, 0, "ng-content", 0)(9, ClrRadioContainer_ng_content_9_Template, 1, 0, "ng-content", 0);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.label && ctx.addGrid());
      ɵɵadvance();
      ɵɵclassProp("clr-control-inline", ctx.clrInline);
      ɵɵproperty("ngClass", ctx.controlClass());
      ɵɵadvance(3);
      ɵɵproperty("ngIf", ctx.showHelper);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showInvalid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showValid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showInvalid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showValid);
    }
  },
  dependencies: [NgClass, NgIf, ClrLabel, CdsIconCustomTag],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrRadioContainer, [{
    type: Component,
    args: [{
      selector: "clr-radio-container",
      template: `
    <ng-content select="label"></ng-content>
    <label *ngIf="!label && addGrid()"></label>
    <div class="clr-control-container" [class.clr-control-inline]="clrInline" [ngClass]="controlClass()">
      <ng-content select="clr-radio-wrapper"></ng-content>
      <div class="clr-subtext-wrapper">
        <ng-content select="clr-control-helper" *ngIf="showHelper"></ng-content>
        <cds-icon
          *ngIf="showInvalid"
          class="clr-validate-icon"
          shape="exclamation-circle"
          status="danger"
          aria-hidden="true"
        ></cds-icon>
        <cds-icon
          *ngIf="showValid"
          class="clr-validate-icon"
          shape="check-circle"
          status="success"
          aria-hidden="true"
        ></cds-icon>
        <ng-content select="clr-control-error" *ngIf="showInvalid"></ng-content>
        <ng-content select="clr-control-success" *ngIf="showValid"></ng-content>
      </div>
    </div>
  `,
      host: {
        "[class.clr-form-control]": "true",
        "[class.clr-form-control-disabled]": "control?.disabled",
        "[class.clr-row]": "addGrid()",
        "[attr.role]": "role",
        "[attr.aria-labelledby]": "ariaLabelledBy"
      },
      providers: [NgControlService, IfControlStateService, ControlClassService, ContainerIdService]
    }]
  }], function() {
    return [{
      type: LayoutService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: ControlClassService
    }, {
      type: NgControlService
    }, {
      type: IfControlStateService
    }];
  }, {
    radios: [{
      type: ContentChildren,
      args: [ClrRadio, {
        descendants: true
      }]
    }],
    groupLabel: [{
      type: ContentChild,
      args: [ClrLabel, {
        read: ElementRef,
        static: true
      }]
    }],
    clrInline: [{
      type: Input
    }]
  });
})();
var ClrRadioModule = class {
  constructor() {
    r.addIcons(e3, l);
  }
};
ClrRadioModule.ɵfac = function ClrRadioModule_Factory(t3) {
  return new (t3 || ClrRadioModule)();
};
ClrRadioModule.ɵmod = ɵɵdefineNgModule({
  type: ClrRadioModule,
  declarations: [ClrRadio, ClrRadioContainer, ClrRadioWrapper],
  imports: [CommonModule, ClrCommonFormsModule, ClrHostWrappingModule, ClrIconModule],
  exports: [ClrCommonFormsModule, ClrRadio, ClrRadioContainer, ClrRadioWrapper]
});
ClrRadioModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, ClrCommonFormsModule, ClrHostWrappingModule, ClrIconModule, ClrCommonFormsModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrRadioModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, ClrCommonFormsModule, ClrHostWrappingModule, ClrIconModule],
      declarations: [ClrRadio, ClrRadioContainer, ClrRadioWrapper],
      exports: [ClrCommonFormsModule, ClrRadio, ClrRadioContainer, ClrRadioWrapper]
    }]
  }], function() {
    return [];
  }, null);
})();
var ClrRangeContainer = class extends ClrAbstractContainer {
  constructor(layoutService, controlClassService, ngControlService, renderer, idService, ifControlStateService) {
    super(ifControlStateService, layoutService, controlClassService, ngControlService);
    this.renderer = renderer;
    this.idService = idService;
    this.ifControlStateService = ifControlStateService;
    this._hasProgress = false;
  }
  get hasProgress() {
    return this._hasProgress;
  }
  set hasProgress(val) {
    const valBool = !!val;
    if (valBool !== this._hasProgress) {
      this._hasProgress = valBool;
    }
  }
  getRangeProgressFillWidth() {
    const input = this.selectRangeElement();
    if (!input) {
      return this.lastRangeProgressFillWidth;
    }
    const inputWidth = input.offsetWidth;
    const inputMinValue = +input.min;
    let inputMaxValue = +input.max;
    if (inputMinValue === 0 && inputMaxValue === 0) {
      inputMaxValue = 100;
    }
    const inputMiddle = (inputMinValue + inputMaxValue) / 2;
    const inputValue = !!this.control && this.control.value !== void 0 ? this.control.value : inputMiddle;
    const valueAsPercent = (inputValue - inputMinValue) * 100 / (inputMaxValue - inputMinValue);
    this.lastRangeProgressFillWidth = valueAsPercent * inputWidth / 100 + "px";
    return this.lastRangeProgressFillWidth;
  }
  selectRangeElement() {
    try {
      return this.renderer.selectRootElement("[clrRange]#" + this.idService.id);
    } catch {
      return void 0;
    }
  }
};
ClrRangeContainer.ɵfac = function ClrRangeContainer_Factory(t3) {
  return new (t3 || ClrRangeContainer)(ɵɵdirectiveInject(LayoutService, 8), ɵɵdirectiveInject(ControlClassService), ɵɵdirectiveInject(NgControlService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ControlIdService), ɵɵdirectiveInject(IfControlStateService));
};
ClrRangeContainer.ɵcmp = ɵɵdefineComponent({
  type: ClrRangeContainer,
  selectors: [["clr-range-container"]],
  hostVars: 6,
  hostBindings: function ClrRangeContainer_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("clr-form-control", true)("clr-form-control-disabled", ctx.control == null ? null : ctx.control.disabled)("clr-row", ctx.addGrid());
    }
  },
  inputs: {
    hasProgress: [InputFlags.None, "clrRangeHasProgress", "hasProgress"]
  },
  features: [ɵɵProvidersFeature([IfControlStateService, NgControlService, ControlIdService, ControlClassService]), ɵɵInheritDefinitionFeature],
  ngContentSelectors: _c40,
  decls: 11,
  vars: 10,
  consts: [[4, "ngIf"], [1, "clr-control-container", 3, "ngClass"], [1, "clr-range-wrapper"], ["class", "fill-input", 3, "width", 4, "ngIf"], ["class", "clr-validate-icon", "shape", "exclamation-circle", "status", "danger", "aria-hidden", "true", 4, "ngIf"], ["class", "clr-validate-icon", "shape", "check-circle", "status", "success", "aria-hidden", "true", 4, "ngIf"], [1, "fill-input"], ["shape", "exclamation-circle", "status", "danger", "aria-hidden", "true", 1, "clr-validate-icon"], ["shape", "check-circle", "status", "success", "aria-hidden", "true", 1, "clr-validate-icon"]],
  template: function ClrRangeContainer_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c39);
      ɵɵprojection(0);
      ɵɵtemplate(1, ClrRangeContainer_label_1_Template, 1, 0, "label", 0);
      ɵɵelementStart(2, "div", 1)(3, "div", 2);
      ɵɵprojection(4, 1);
      ɵɵtemplate(5, ClrRangeContainer_span_5_Template, 1, 2, "span", 3)(6, ClrRangeContainer_cds_icon_6_Template, 1, 0, "cds-icon", 4)(7, ClrRangeContainer_cds_icon_7_Template, 1, 0, "cds-icon", 5);
      ɵɵelementEnd();
      ɵɵtemplate(8, ClrRangeContainer_ng_content_8_Template, 1, 0, "ng-content", 0)(9, ClrRangeContainer_ng_content_9_Template, 1, 0, "ng-content", 0)(10, ClrRangeContainer_ng_content_10_Template, 1, 0, "ng-content", 0);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.label && ctx.addGrid());
      ɵɵadvance();
      ɵɵproperty("ngClass", ctx.controlClass());
      ɵɵadvance();
      ɵɵclassProp("progress-fill", ctx.hasProgress);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.hasProgress);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showInvalid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showValid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showHelper);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showInvalid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showValid);
    }
  },
  dependencies: [NgClass, NgIf, ClrLabel, CdsIconCustomTag],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrRangeContainer, [{
    type: Component,
    args: [{
      selector: "clr-range-container",
      template: `
    <ng-content select="label"></ng-content>
    <label *ngIf="!label && addGrid()"></label>
    <div class="clr-control-container" [ngClass]="controlClass()">
      <div class="clr-range-wrapper" [class.progress-fill]="hasProgress">
        <ng-content select="[clrRange]"></ng-content>
        <span *ngIf="hasProgress" class="fill-input" [style.width]="getRangeProgressFillWidth()"></span>
        <cds-icon
          *ngIf="showInvalid"
          class="clr-validate-icon"
          shape="exclamation-circle"
          status="danger"
          aria-hidden="true"
        ></cds-icon>
        <cds-icon
          *ngIf="showValid"
          class="clr-validate-icon"
          shape="check-circle"
          status="success"
          aria-hidden="true"
        ></cds-icon>
      </div>
      <ng-content select="clr-control-helper" *ngIf="showHelper"></ng-content>
      <ng-content select="clr-control-error" *ngIf="showInvalid"></ng-content>
      <ng-content select="clr-control-success" *ngIf="showValid"></ng-content>
    </div>
  `,
      host: {
        "[class.clr-form-control]": "true",
        "[class.clr-form-control-disabled]": "control?.disabled",
        "[class.clr-row]": "addGrid()"
      },
      providers: [IfControlStateService, NgControlService, ControlIdService, ControlClassService]
    }]
  }], function() {
    return [{
      type: LayoutService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: ControlClassService
    }, {
      type: NgControlService
    }, {
      type: Renderer2
    }, {
      type: ControlIdService
    }, {
      type: IfControlStateService
    }];
  }, {
    hasProgress: [{
      type: Input,
      args: ["clrRangeHasProgress"]
    }]
  });
})();
var ClrRange = class extends WrappedFormControl {
  constructor(vcr, injector, control, renderer, el) {
    super(vcr, ClrRangeContainer, injector, control, renderer, el);
  }
};
ClrRange.ɵfac = function ClrRange_Factory(t3) {
  return new (t3 || ClrRange)(ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(NgControl, 10), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef));
};
ClrRange.ɵdir = ɵɵdefineDirective({
  type: ClrRange,
  selectors: [["", "clrRange", ""]],
  hostVars: 2,
  hostBindings: function ClrRange_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("clr-range", true);
    }
  },
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrRange, [{
    type: Directive,
    args: [{
      selector: "[clrRange]",
      host: {
        "[class.clr-range]": "true"
      }
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }, {
      type: Injector
    }, {
      type: NgControl,
      decorators: [{
        type: Self
      }, {
        type: Optional
      }]
    }, {
      type: Renderer2
    }, {
      type: ElementRef
    }];
  }, null);
})();
var ClrRangeModule = class {
  constructor() {
    r.addIcons(e3, l);
  }
};
ClrRangeModule.ɵfac = function ClrRangeModule_Factory(t3) {
  return new (t3 || ClrRangeModule)();
};
ClrRangeModule.ɵmod = ɵɵdefineNgModule({
  type: ClrRangeModule,
  declarations: [ClrRange, ClrRangeContainer],
  imports: [CommonModule, ClrCommonFormsModule, ClrHostWrappingModule, ClrIconModule],
  exports: [ClrCommonFormsModule, ClrRange, ClrRangeContainer]
});
ClrRangeModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, ClrCommonFormsModule, ClrHostWrappingModule, ClrIconModule, ClrCommonFormsModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrRangeModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, ClrCommonFormsModule, ClrHostWrappingModule, ClrIconModule],
      declarations: [ClrRange, ClrRangeContainer],
      exports: [ClrCommonFormsModule, ClrRange, ClrRangeContainer]
    }]
  }], function() {
    return [];
  }, null);
})();
var ClrSelectContainer = class extends ClrAbstractContainer {
  constructor(layoutService, controlClassService, ngControlService, ifControlStateService) {
    super(ifControlStateService, layoutService, controlClassService, ngControlService);
    this.layoutService = layoutService;
    this.controlClassService = controlClassService;
    this.ngControlService = ngControlService;
    this.ifControlStateService = ifControlStateService;
    this.multi = false;
  }
  ngOnInit() {
    this.subscriptions.push(this.ngControlService.controlChanges.subscribe((control) => {
      if (control) {
        this.multi = control.valueAccessor instanceof SelectMultipleControlValueAccessor;
        this.control = control;
      }
    }));
  }
  wrapperClass() {
    return this.multi ? "clr-multiselect-wrapper" : "clr-select-wrapper";
  }
};
ClrSelectContainer.ɵfac = function ClrSelectContainer_Factory(t3) {
  return new (t3 || ClrSelectContainer)(ɵɵdirectiveInject(LayoutService, 8), ɵɵdirectiveInject(ControlClassService), ɵɵdirectiveInject(NgControlService), ɵɵdirectiveInject(IfControlStateService));
};
ClrSelectContainer.ɵcmp = ɵɵdefineComponent({
  type: ClrSelectContainer,
  selectors: [["clr-select-container"]],
  contentQueries: function ClrSelectContainer_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, SelectMultipleControlValueAccessor, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.multiple = _t.first);
    }
  },
  hostVars: 6,
  hostBindings: function ClrSelectContainer_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("clr-form-control", true)("clr-form-control-disabled", ctx.control == null ? null : ctx.control.disabled)("clr-row", ctx.addGrid());
    }
  },
  features: [ɵɵProvidersFeature([IfControlStateService, NgControlService, ControlIdService, ControlClassService]), ɵɵInheritDefinitionFeature],
  ngContentSelectors: _c42,
  decls: 10,
  vars: 8,
  consts: [[4, "ngIf"], [1, "clr-control-container", 3, "ngClass"], [3, "ngClass"], ["class", "clr-validate-icon", "shape", "exclamation-circle", "status", "danger", "aria-hidden", "true", 4, "ngIf"], ["class", "clr-validate-icon", "shape", "check-circle", "status", "success", "aria-hidden", "true", 4, "ngIf"], ["shape", "exclamation-circle", "status", "danger", "aria-hidden", "true", 1, "clr-validate-icon"], ["shape", "check-circle", "status", "success", "aria-hidden", "true", 1, "clr-validate-icon"]],
  template: function ClrSelectContainer_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c41);
      ɵɵprojection(0);
      ɵɵtemplate(1, ClrSelectContainer_label_1_Template, 1, 0, "label", 0);
      ɵɵelementStart(2, "div", 1)(3, "div", 2);
      ɵɵprojection(4, 1);
      ɵɵtemplate(5, ClrSelectContainer_cds_icon_5_Template, 1, 0, "cds-icon", 3)(6, ClrSelectContainer_cds_icon_6_Template, 1, 0, "cds-icon", 4);
      ɵɵelementEnd();
      ɵɵtemplate(7, ClrSelectContainer_ng_content_7_Template, 1, 0, "ng-content", 0)(8, ClrSelectContainer_ng_content_8_Template, 1, 0, "ng-content", 0)(9, ClrSelectContainer_ng_content_9_Template, 1, 0, "ng-content", 0);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.label && ctx.addGrid());
      ɵɵadvance();
      ɵɵproperty("ngClass", ctx.controlClass());
      ɵɵadvance();
      ɵɵproperty("ngClass", ctx.wrapperClass());
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.showInvalid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showValid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showHelper);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showInvalid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showValid);
    }
  },
  dependencies: [NgClass, NgIf, CdsIconCustomTag, ClrLabel],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrSelectContainer, [{
    type: Component,
    args: [{
      selector: "clr-select-container",
      template: `
    <ng-content select="label"></ng-content>
    <label *ngIf="!label && addGrid()"></label>
    <div class="clr-control-container" [ngClass]="controlClass()">
      <div [ngClass]="wrapperClass()">
        <ng-content select="[clrSelect]"></ng-content>
        <cds-icon
          *ngIf="showInvalid"
          class="clr-validate-icon"
          shape="exclamation-circle"
          status="danger"
          aria-hidden="true"
        ></cds-icon>
        <cds-icon
          *ngIf="showValid"
          class="clr-validate-icon"
          shape="check-circle"
          status="success"
          aria-hidden="true"
        ></cds-icon>
      </div>
      <ng-content select="clr-control-helper" *ngIf="showHelper"></ng-content>
      <ng-content select="clr-control-error" *ngIf="showInvalid"></ng-content>
      <ng-content select="clr-control-success" *ngIf="showValid"></ng-content>
    </div>
  `,
      host: {
        "[class.clr-form-control]": "true",
        "[class.clr-form-control-disabled]": "control?.disabled",
        "[class.clr-row]": "addGrid()"
      },
      providers: [IfControlStateService, NgControlService, ControlIdService, ControlClassService]
    }]
  }], function() {
    return [{
      type: LayoutService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: ControlClassService
    }, {
      type: NgControlService
    }, {
      type: IfControlStateService
    }];
  }, {
    multiple: [{
      type: ContentChild,
      args: [SelectMultipleControlValueAccessor, {
        static: false
      }]
    }]
  });
})();
var ClrSelect = class extends WrappedFormControl {
  constructor(vcr, injector, control, renderer, el) {
    super(vcr, ClrSelectContainer, injector, control, renderer, el);
    this.index = 1;
  }
};
ClrSelect.ɵfac = function ClrSelect_Factory(t3) {
  return new (t3 || ClrSelect)(ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(NgControl, 10), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef));
};
ClrSelect.ɵdir = ɵɵdefineDirective({
  type: ClrSelect,
  selectors: [["", "clrSelect", ""]],
  hostVars: 2,
  hostBindings: function ClrSelect_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("clr-select", true);
    }
  },
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrSelect, [{
    type: Directive,
    args: [{
      selector: "[clrSelect]",
      host: {
        "[class.clr-select]": "true"
      }
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }, {
      type: Injector
    }, {
      type: NgControl,
      decorators: [{
        type: Self
      }, {
        type: Optional
      }]
    }, {
      type: Renderer2
    }, {
      type: ElementRef
    }];
  }, null);
})();
var ClrSelectModule = class {
  constructor() {
    r.addIcons(e3, l);
  }
};
ClrSelectModule.ɵfac = function ClrSelectModule_Factory(t3) {
  return new (t3 || ClrSelectModule)();
};
ClrSelectModule.ɵmod = ɵɵdefineNgModule({
  type: ClrSelectModule,
  declarations: [ClrSelect, ClrSelectContainer],
  imports: [CommonModule, FormsModule, ClrIconModule, ClrCommonFormsModule],
  exports: [ClrCommonFormsModule, ClrSelect, ClrSelectContainer]
});
ClrSelectModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, FormsModule, ClrIconModule, ClrCommonFormsModule, ClrCommonFormsModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrSelectModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, FormsModule, ClrIconModule, ClrCommonFormsModule],
      declarations: [ClrSelect, ClrSelectContainer],
      exports: [ClrCommonFormsModule, ClrSelect, ClrSelectContainer]
    }]
  }], function() {
    return [];
  }, null);
})();
var ClrTextareaContainer = class extends ClrAbstractContainer {
};
ClrTextareaContainer.ɵfac = /* @__PURE__ */ (() => {
  let ɵClrTextareaContainer_BaseFactory;
  return function ClrTextareaContainer_Factory(t3) {
    return (ɵClrTextareaContainer_BaseFactory || (ɵClrTextareaContainer_BaseFactory = ɵɵgetInheritedFactory(ClrTextareaContainer)))(t3 || ClrTextareaContainer);
  };
})();
ClrTextareaContainer.ɵcmp = ɵɵdefineComponent({
  type: ClrTextareaContainer,
  selectors: [["clr-textarea-container"]],
  hostVars: 6,
  hostBindings: function ClrTextareaContainer_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("clr-form-control", true)("clr-form-control-disabled", ctx.control == null ? null : ctx.control.disabled)("clr-row", ctx.addGrid());
    }
  },
  features: [ɵɵProvidersFeature([IfControlStateService, NgControlService, ControlIdService, ControlClassService]), ɵɵInheritDefinitionFeature],
  ngContentSelectors: _c44,
  decls: 10,
  vars: 7,
  consts: [[4, "ngIf"], [1, "clr-control-container", 3, "ngClass"], [1, "clr-textarea-wrapper"], ["class", "clr-validate-icon", "shape", "exclamation-circle", "status", "danger", "aria-hidden", "true", 4, "ngIf"], ["class", "clr-validate-icon", "shape", "check-circle", "status", "success", "aria-hidden", "true", 4, "ngIf"], ["shape", "exclamation-circle", "status", "danger", "aria-hidden", "true", 1, "clr-validate-icon"], ["shape", "check-circle", "status", "success", "aria-hidden", "true", 1, "clr-validate-icon"]],
  template: function ClrTextareaContainer_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c43);
      ɵɵprojection(0);
      ɵɵtemplate(1, ClrTextareaContainer_label_1_Template, 1, 0, "label", 0);
      ɵɵelementStart(2, "div", 1)(3, "div", 2);
      ɵɵprojection(4, 1);
      ɵɵtemplate(5, ClrTextareaContainer_cds_icon_5_Template, 1, 0, "cds-icon", 3)(6, ClrTextareaContainer_cds_icon_6_Template, 1, 0, "cds-icon", 4);
      ɵɵelementEnd();
      ɵɵtemplate(7, ClrTextareaContainer_ng_content_7_Template, 1, 0, "ng-content", 0)(8, ClrTextareaContainer_ng_content_8_Template, 1, 0, "ng-content", 0)(9, ClrTextareaContainer_ng_content_9_Template, 1, 0, "ng-content", 0);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.label && ctx.addGrid());
      ɵɵadvance();
      ɵɵproperty("ngClass", ctx.controlClass());
      ɵɵadvance(3);
      ɵɵproperty("ngIf", ctx.showInvalid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showValid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showHelper);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showInvalid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showValid);
    }
  },
  dependencies: [NgClass, NgIf, CdsIconCustomTag, ClrLabel],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrTextareaContainer, [{
    type: Component,
    args: [{
      selector: "clr-textarea-container",
      template: `
    <ng-content select="label"></ng-content>
    <label *ngIf="!label && addGrid()"></label>
    <div class="clr-control-container" [ngClass]="controlClass()">
      <div class="clr-textarea-wrapper">
        <ng-content select="[clrTextarea]"></ng-content>
        <cds-icon
          *ngIf="showInvalid"
          class="clr-validate-icon"
          shape="exclamation-circle"
          status="danger"
          aria-hidden="true"
        ></cds-icon>
        <cds-icon
          *ngIf="showValid"
          class="clr-validate-icon"
          shape="check-circle"
          status="success"
          aria-hidden="true"
        ></cds-icon>
      </div>
      <ng-content select="clr-control-helper" *ngIf="showHelper"></ng-content>
      <ng-content select="clr-control-error" *ngIf="showInvalid"></ng-content>
      <ng-content select="clr-control-success" *ngIf="showValid"></ng-content>
    </div>
  `,
      host: {
        "[class.clr-form-control]": "true",
        "[class.clr-form-control-disabled]": "control?.disabled",
        "[class.clr-row]": "addGrid()"
      },
      providers: [IfControlStateService, NgControlService, ControlIdService, ControlClassService]
    }]
  }], null, null);
})();
var ClrTextarea = class extends WrappedFormControl {
  constructor(vcr, injector, control, renderer, el) {
    super(vcr, ClrTextareaContainer, injector, control, renderer, el);
    this.index = 1;
  }
};
ClrTextarea.ɵfac = function ClrTextarea_Factory(t3) {
  return new (t3 || ClrTextarea)(ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(NgControl, 10), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef));
};
ClrTextarea.ɵdir = ɵɵdefineDirective({
  type: ClrTextarea,
  selectors: [["", "clrTextarea", ""]],
  hostVars: 2,
  hostBindings: function ClrTextarea_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("clr-textarea", true);
    }
  },
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrTextarea, [{
    type: Directive,
    args: [{
      selector: "[clrTextarea]",
      host: {
        "[class.clr-textarea]": "true"
      }
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }, {
      type: Injector
    }, {
      type: NgControl,
      decorators: [{
        type: Self
      }, {
        type: Optional
      }]
    }, {
      type: Renderer2
    }, {
      type: ElementRef
    }];
  }, null);
})();
var ClrTextareaModule = class {
  constructor() {
    r.addIcons(e3, l);
  }
};
ClrTextareaModule.ɵfac = function ClrTextareaModule_Factory(t3) {
  return new (t3 || ClrTextareaModule)();
};
ClrTextareaModule.ɵmod = ɵɵdefineNgModule({
  type: ClrTextareaModule,
  declarations: [ClrTextarea, ClrTextareaContainer],
  imports: [CommonModule, FormsModule, ClrIconModule, ClrCommonFormsModule],
  exports: [ClrCommonFormsModule, ClrTextarea, ClrTextareaContainer]
});
ClrTextareaModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, FormsModule, ClrIconModule, ClrCommonFormsModule, ClrCommonFormsModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrTextareaModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, FormsModule, ClrIconModule, ClrCommonFormsModule],
      declarations: [ClrTextarea, ClrTextareaContainer],
      exports: [ClrCommonFormsModule, ClrTextarea, ClrTextareaContainer]
    }]
  }], function() {
    return [];
  }, null);
})();
var ClrFormsModule = class {
};
ClrFormsModule.ɵfac = function ClrFormsModule_Factory(t3) {
  return new (t3 || ClrFormsModule)();
};
ClrFormsModule.ɵmod = ɵɵdefineNgModule({
  type: ClrFormsModule,
  imports: [CommonModule],
  exports: [ClrCommonFormsModule, ClrCheckboxModule, ClrComboboxModule, ClrDatepickerModule, ClrFileInputModule, ClrInputModule, ClrPasswordModule, ClrRadioModule, ClrSelectModule, ClrTextareaModule, ClrRangeModule, ClrDatalistModule]
});
ClrFormsModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, ClrCommonFormsModule, ClrCheckboxModule, ClrComboboxModule, ClrDatepickerModule, ClrFileInputModule, ClrInputModule, ClrPasswordModule, ClrRadioModule, ClrSelectModule, ClrTextareaModule, ClrRangeModule, ClrDatalistModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrFormsModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      exports: [ClrCommonFormsModule, ClrCheckboxModule, ClrComboboxModule, ClrDatepickerModule, ClrFileInputModule, ClrInputModule, ClrPasswordModule, ClrRadioModule, ClrSelectModule, ClrTextareaModule, ClrRangeModule, ClrDatalistModule]
    }]
  }], null, null);
})();
var ClrExpandableAnimationModule = class {
};
ClrExpandableAnimationModule.ɵfac = function ClrExpandableAnimationModule_Factory(t3) {
  return new (t3 || ClrExpandableAnimationModule)();
};
ClrExpandableAnimationModule.ɵmod = ɵɵdefineNgModule({
  type: ClrExpandableAnimationModule,
  declarations: [ClrExpandableAnimation],
  imports: [CommonModule],
  exports: [ClrExpandableAnimation]
});
ClrExpandableAnimationModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrExpandableAnimationModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      declarations: [EXPANDABLE_ANIMATION_DIRECTIVES],
      exports: [EXPANDABLE_ANIMATION_DIRECTIVES]
    }]
  }], null, null);
})();
var CdkDragModule_CdkDrag = class extends CdkDrag {
  /**
   * Include the constructor to forward all the dependencies to the base class
   * as a workaround to fix Angular "ɵɵinvalidFactoryDep" error after upgrading storybook
   * https://github.com/storybookjs/storybook/issues/23534
   */
  constructor(elementRef, dropContainer, document2, ngZone, viewContainerRef, config, dir, dragDrop, changeDetectorRef) {
    super(elementRef, dropContainer, document2, ngZone, viewContainerRef, config, dir, dragDrop, changeDetectorRef);
  }
};
CdkDragModule_CdkDrag.ɵfac = function CdkDragModule_CdkDrag_Factory(t3) {
  return new (t3 || CdkDragModule_CdkDrag)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(CDK_DROP_LIST, 8), ɵɵdirectiveInject(DOCUMENT, 8), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(CDK_DRAG_CONFIG, 8), ɵɵdirectiveInject(Directionality), ɵɵdirectiveInject(DragDrop), ɵɵdirectiveInject(ChangeDetectorRef));
};
CdkDragModule_CdkDrag.ɵdir = ɵɵdefineDirective({
  type: CdkDragModule_CdkDrag,
  selectors: [["", "cdkDrag", ""]],
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkDragModule_CdkDrag, [{
    type: Directive,
    args: [{
      selector: "[cdkDrag]"
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [CDK_DROP_LIST]
      }]
    }, {
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [DOCUMENT]
      }]
    }, {
      type: NgZone
    }, {
      type: ViewContainerRef
    }, {
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [CDK_DRAG_CONFIG]
      }]
    }, {
      type: Directionality
    }, {
      type: DragDrop
    }, {
      type: ChangeDetectorRef
    }];
  }, null);
})();
var CdkDragModule = class {
};
CdkDragModule.ɵfac = function CdkDragModule_Factory(t3) {
  return new (t3 || CdkDragModule)();
};
CdkDragModule.ɵmod = ɵɵdefineNgModule({
  type: CdkDragModule,
  declarations: [CdkDragModule_CdkDrag],
  exports: [CdkDragModule_CdkDrag]
});
CdkDragModule.ɵinj = ɵɵdefineInjector({});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkDragModule, [{
    type: NgModule,
    args: [{
      declarations: [CdkDragModule_CdkDrag],
      exports: [CdkDragModule_CdkDrag]
    }]
  }], null, null);
})();
var OutsideClick = class {
  constructor(host, renderer, ngZone) {
    this.strict = false;
    this.outsideClick = new EventEmitter(false);
    ngZone.runOutsideAngular(() => {
      this.documentClickListener = renderer.listen("document", "click", (event) => {
        if (host.nativeElement === event.target) {
          return;
        }
        if (!this.strict && host.nativeElement.contains(event.target)) {
          return;
        }
        ngZone.run(() => {
          this.outsideClick.emit(event);
        });
      });
    });
  }
  ngOnDestroy() {
    this.documentClickListener();
  }
};
OutsideClick.ɵfac = function OutsideClick_Factory(t3) {
  return new (t3 || OutsideClick)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone));
};
OutsideClick.ɵdir = ɵɵdefineDirective({
  type: OutsideClick,
  selectors: [["", "clrOutsideClick", ""]],
  inputs: {
    strict: [InputFlags.None, "clrStrict", "strict"]
  },
  outputs: {
    outsideClick: "clrOutsideClick"
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(OutsideClick, [{
    type: Directive,
    args: [{
      selector: "[clrOutsideClick]"
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: NgZone
    }];
  }, {
    strict: [{
      type: Input,
      args: ["clrStrict"]
    }],
    outsideClick: [{
      type: Output,
      args: ["clrOutsideClick"]
    }]
  });
})();
var OUSTIDE_CLICK_DIRECTIVES = [OutsideClick];
var ClrOutsideClickModule = class {
};
ClrOutsideClickModule.ɵfac = function ClrOutsideClickModule_Factory(t3) {
  return new (t3 || ClrOutsideClickModule)();
};
ClrOutsideClickModule.ɵmod = ɵɵdefineNgModule({
  type: ClrOutsideClickModule,
  declarations: [OutsideClick],
  imports: [CommonModule],
  exports: [OutsideClick]
});
ClrOutsideClickModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrOutsideClickModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      declarations: [OUSTIDE_CLICK_DIRECTIVES],
      exports: [OUSTIDE_CLICK_DIRECTIVES]
    }]
  }], null, null);
})();
var CustomFilter = class {
};
var StateDebouncer = class {
  constructor() {
    this.nbChanges = 0;
    this._change = new Subject();
  }
  // We do not want to expose the Subject itself, but the Observable which is read-only
  get change() {
    return this._change.asObservable();
  }
  changeStart() {
    this.nbChanges++;
  }
  changeDone() {
    if (--this.nbChanges === 0) {
      this._change.next();
    }
  }
};
StateDebouncer.ɵfac = function StateDebouncer_Factory(t3) {
  return new (t3 || StateDebouncer)();
};
StateDebouncer.ɵprov = ɵɵdefineInjectable({
  token: StateDebouncer,
  factory: StateDebouncer.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StateDebouncer, [{
    type: Injectable
  }], null, null);
})();
var Page = class {
  constructor(stateDebouncer) {
    this.stateDebouncer = stateDebouncer;
    this.activated = false;
    this._size = 0;
    this._current = 1;
    this._change = new Subject();
    this.preventEmit = false;
    this._sizeChange = new Subject();
  }
  get size() {
    return this._size;
  }
  set size(size) {
    const oldSize = this._size;
    if (size !== oldSize) {
      if (!this.preventEmit) {
        this.stateDebouncer.changeStart();
      }
      this._size = size;
      if (size === 0) {
        this._current = 1;
      } else {
        this._current = Math.floor(oldSize / size * (this._current - 1)) + 1;
      }
      if (!this.preventEmit) {
        this._change.next(this._current);
        this._sizeChange.next(this._size);
        this.stateDebouncer.changeDone();
      }
    }
    this.preventEmit = false;
  }
  get totalItems() {
    return this._totalItems || 0;
  }
  set totalItems(total) {
    this._totalItems = total;
    if (this.current > this.last) {
      this.current = this.last;
    }
  }
  get last() {
    if (this._last) {
      return this._last;
    }
    if (this.size > 0 && this.totalItems) {
      return Math.ceil(this.totalItems / this.size);
    }
    return 1;
  }
  set last(page) {
    this._last = page;
  }
  // We do not want to expose the Subject itself, but the Observable which is read-only
  get change() {
    return this._change.asObservable();
  }
  get sizeChange() {
    return this._sizeChange.asObservable();
  }
  get current() {
    return this._current;
  }
  set current(page) {
    if (page !== this._current) {
      this.stateDebouncer.changeStart();
      this._current = page;
      this._change.next(page);
      this.stateDebouncer.changeDone();
    }
  }
  /**
   * Index of the first item displayed on the current page, starting at 0, -1 if none displayed
   */
  get firstItem() {
    if (this._totalItems === 0) {
      return -1;
    }
    if (this.size === 0) {
      return 0;
    }
    return (this.current - 1) * this.size;
  }
  /**
   * Index of the last item displayed on the current page, starting at 0, -1 if none displayed
   */
  get lastItem() {
    if (this._totalItems === 0) {
      return -1;
    }
    if (this.size === 0) {
      return this.totalItems - 1;
    }
    let lastInPage = this.current * this.size - 1;
    if (this.totalItems) {
      lastInPage = Math.min(lastInPage, this.totalItems - 1);
    }
    return lastInPage;
  }
  /**
   * Moves to the previous page if it exists
   */
  previous() {
    if (this.current > 1) {
      this.current--;
    }
  }
  /**
   * Moves to the next page if it exists
   */
  next() {
    if (this.current < this.last) {
      this.current++;
    }
  }
  /**
   * Resets the page size to 0
   */
  resetPageSize(preventEmit = false) {
    this.preventEmit = preventEmit;
    this.size = 0;
  }
};
Page.ɵfac = function Page_Factory(t3) {
  return new (t3 || Page)(ɵɵinject(StateDebouncer));
};
Page.ɵprov = ɵɵdefineInjectable({
  token: Page,
  factory: Page.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Page, [{
    type: Injectable
  }], function() {
    return [{
      type: StateDebouncer
    }];
  }, null);
})();
var FiltersProvider = class {
  constructor(_page, stateDebouncer) {
    this._page = _page;
    this.stateDebouncer = stateDebouncer;
    this._change = new Subject();
    this._all = [];
  }
  // We do not want to expose the Subject itself, but the Observable which is read-only
  get change() {
    return this._change.asObservable();
  }
  /**
   * Tests if at least one filter is currently active
   */
  hasActiveFilters() {
    for (const {
      filter: filter2
    } of this._all) {
      if (filter2 && filter2.isActive()) {
        return true;
      }
    }
    return false;
  }
  /**
   * Returns a list of all currently active filters
   */
  getActiveFilters() {
    const ret = [];
    for (const {
      filter: filter2
    } of this._all) {
      if (filter2 && filter2.isActive()) {
        ret.push(filter2);
      }
    }
    return ret;
  }
  /**
   * Registers a filter, and returns a deregistration function
   */
  add(filter2) {
    const subscription = filter2.changes.subscribe(() => this.resetPageAndEmitFilterChange([filter2]));
    let hasUnregistered = false;
    const registered = new RegisteredFilter(filter2, () => {
      if (hasUnregistered) {
        return;
      }
      subscription.unsubscribe();
      const matchIndex = this._all.findIndex((item) => item.filter === filter2);
      if (matchIndex >= 0) {
        this._all.splice(matchIndex, 1);
      }
      if (filter2.isActive()) {
        this.resetPageAndEmitFilterChange([]);
      }
      hasUnregistered = true;
    });
    this._all.push(registered);
    if (filter2.isActive()) {
      this.resetPageAndEmitFilterChange([filter2]);
    }
    return registered;
  }
  /**
   * Accepts an item if it is accepted by all currently active filters
   */
  accepts(item) {
    for (const {
      filter: filter2
    } of this._all) {
      if (filter2 && filter2.isActive() && !filter2.accepts(item)) {
        return false;
      }
    }
    return true;
  }
  resetPageAndEmitFilterChange(filters) {
    this.stateDebouncer.changeStart();
    this._page.current = 1;
    this._change.next(filters);
    this.stateDebouncer.changeDone();
  }
};
FiltersProvider.ɵfac = function FiltersProvider_Factory(t3) {
  return new (t3 || FiltersProvider)(ɵɵinject(Page), ɵɵinject(StateDebouncer));
};
FiltersProvider.ɵprov = ɵɵdefineInjectable({
  token: FiltersProvider,
  factory: FiltersProvider.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FiltersProvider, [{
    type: Injectable
  }], function() {
    return [{
      type: Page
    }, {
      type: StateDebouncer
    }];
  }, null);
})();
var RegisteredFilter = class {
  constructor(filter2, unregister) {
    this.filter = filter2;
    this.unregister = unregister;
  }
};
var DatagridFilterRegistrar = class {
  constructor(filters) {
    this.filters = filters;
  }
  get filter() {
    return this.registered && this.registered.filter;
  }
  ngOnDestroy() {
    this.deleteFilter();
  }
  setFilter(filter2) {
    this.deleteFilter();
    if (filter2 instanceof RegisteredFilter) {
      this.registered = filter2;
    } else if (filter2) {
      this.registered = this.filters.add(filter2);
    }
  }
  deleteFilter() {
    if (this.registered) {
      this.registered.unregister();
      delete this.registered;
    }
  }
};
DatagridFilterRegistrar.ɵfac = function DatagridFilterRegistrar_Factory(t3) {
  return new (t3 || DatagridFilterRegistrar)(ɵɵdirectiveInject(FiltersProvider));
};
DatagridFilterRegistrar.ɵdir = ɵɵdefineDirective({
  type: DatagridFilterRegistrar
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DatagridFilterRegistrar, [{
    type: Directive
  }], function() {
    return [{
      type: FiltersProvider
    }];
  }, null);
})();
function getTabableItems(el) {
  const tabableSelector = ["a[href]", "area[href]", "input:not([disabled])", "button:not([disabled])", "select:not([disabled])", "textarea:not([disabled])", "iframe", "object", "embed", "*[tabindex]", "*[contenteditable=true]", "[role=button]:not([disabled])"].join(",");
  return Array.from(el.querySelectorAll(tabableSelector));
}
var KeyNavigationGridController = class {
  constructor(zone) {
    this.zone = zone;
    this.skipItemFocus = false;
    this.listenersAdded = false;
    this.destroy$ = new Subject();
    this._activeCell = null;
    this.config = {
      keyGridRows: "[role=row]:not(.datagrid-placeholder)",
      keyGridCells: "[role=gridcell]:not(.datagrid-hidden-column):not(.datagrid-placeholder-content), [role=columnheader]:not(.datagrid-hidden-column):not(.datagrid-placeholder-content), .datagrid-detail-caret",
      keyGrid: "[role=grid]"
    };
  }
  get grid() {
    return this.host?.querySelector(this.config.keyGrid);
  }
  get rows() {
    return this.host?.querySelectorAll(this.config.keyGridRows);
  }
  get cells() {
    return this.host?.querySelectorAll(this.config.keyGridCells);
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  addListeners() {
    if (this.listenersAdded) {
      return;
    }
    this.zone.runOutsideAngular(() => {
      fromEvent(this.grid, "mousedown").pipe(takeUntil(this.destroy$)).subscribe((e5) => {
        if (e5.buttons === 1 && !e5.ctrlKey) {
          const activeCell = this.cells ? Array.from(this.cells).find((c2) => c2 === e5.target || c2 === e5.target.closest(this.config.keyGridCells)) : null;
          if (activeCell) {
            this.setActiveCell(activeCell);
          }
        }
      });
      fromEvent(this.grid, "wheel").pipe(takeUntil(this.destroy$)).subscribe(() => {
        this.removeActiveCell();
      });
      fromEvent(this.grid, "keydown").pipe(takeUntil(this.destroy$)).subscribe((e5) => {
        if (e5.target.classList.contains("drag-handle") && (e5.code === "ArrowLeft" || e5.code === "ArrowRight")) {
          return;
        }
        if (e5.code === "ArrowUp" || e5.code === "ArrowDown" || e5.code === "ArrowLeft" || e5.code === "ArrowRight" || e5.code === "End" || e5.code === "Home" || e5.code === "PageUp" || e5.code === "PageDown") {
          const {
            x,
            y
          } = this.getNextItemCoordinate(e5);
          const activeItem = this.rows ? Array.from(this.rows[y].querySelectorAll(this.config.keyGridCells))[x] : null;
          if (activeItem) {
            this.setActiveCell(activeItem);
          }
          e5.preventDefault();
        }
      });
    });
    this.listenersAdded = true;
  }
  initializeKeyGrid(host) {
    this.host = host;
    this.addListeners();
    this.resetKeyGrid();
  }
  resetKeyGrid() {
    this.cells?.forEach((i2) => i2.setAttribute("tabindex", "-1"));
    const firstCell = this.cells ? this.cells[0] : null;
    firstCell?.setAttribute("tabindex", "0");
  }
  removeActiveCell() {
    this._activeCell = null;
  }
  getActiveCell() {
    return this._activeCell;
  }
  setActiveCell(activeCell) {
    const prior = this.cells ? Array.from(this.cells).find((c2) => c2.getAttribute("tabindex") === "0") : null;
    if (prior) {
      prior.setAttribute("tabindex", "-1");
    }
    activeCell.setAttribute("tabindex", "0");
    this._activeCell = activeCell;
    const items = getTabableItems(activeCell);
    const item = activeCell.getAttribute("role") !== "columnheader" && items[0] ? items[0] : activeCell;
    if (!this.skipItemFocus) {
      item.focus();
    }
  }
  getNextItemCoordinate(e5) {
    let currentCell = this.cells ? Array.from(this.cells).find((i2) => i2.getAttribute("tabindex") === "0") : null;
    if (e5.code === "Tab") {
      currentCell = document.activeElement;
    }
    const currentRow = this.rows && currentCell ? Array.from(this.rows).find((r7) => r7.contains(currentCell)) : null;
    const numOfRows = this.rows ? this.rows.length - 1 : 0;
    const numOfColumns = this.cells ? Math.floor(this.cells.length / this.rows.length - 1) : 0;
    let x = currentRow && currentCell ? Array.from(currentRow.querySelectorAll(this.config.keyGridCells)).indexOf(currentCell) : 0;
    let y = currentRow && currentCell && this.rows ? Array.from(this.rows).indexOf(currentRow) : 0;
    const dir = this.host.dir;
    const inlineStart = dir === "rtl" ? "ArrowRight" : "ArrowLeft";
    const inlineEnd = dir === "rtl" ? "ArrowLeft" : "ArrowRight";
    const itemsPerPage = Math.floor(this.host?.querySelector(".datagrid").clientHeight / this.rows[0].clientHeight) - 1 || 0;
    if (e5.code === "ArrowUp" && y !== 0) {
      y = y - 1;
    } else if (e5.code === "ArrowDown" && y < numOfRows) {
      y = y + 1;
    } else if (e5.code === inlineStart && x !== 0) {
      x = x - 1;
    } else if (e5.code === inlineEnd && x < numOfColumns) {
      x = x + 1;
    } else if (e5.code === "End") {
      x = numOfColumns;
      if (e5.ctrlKey) {
        y = numOfRows;
      }
    } else if (e5.code === "Home") {
      x = 0;
      if (e5.ctrlKey) {
        y = 0;
      }
    } else if (e5.code === "PageUp") {
      y = y - itemsPerPage > 0 ? y - itemsPerPage + 1 : 1;
    } else if (e5.code === "PageDown") {
      y = y + itemsPerPage < numOfRows ? y + itemsPerPage : numOfRows;
    }
    return {
      x,
      y
    };
  }
};
KeyNavigationGridController.ɵfac = function KeyNavigationGridController_Factory(t3) {
  return new (t3 || KeyNavigationGridController)(ɵɵinject(NgZone));
};
KeyNavigationGridController.ɵprov = ɵɵdefineInjectable({
  token: KeyNavigationGridController,
  factory: KeyNavigationGridController.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(KeyNavigationGridController, [{
    type: Injectable
  }], function() {
    return [{
      type: NgZone
    }];
  }, null);
})();
var ClrDatagridFilter = class extends DatagridFilterRegistrar {
  constructor(_filters, commonStrings, smartToggleService, platformId, elementRef, keyNavigation) {
    super(_filters);
    this.commonStrings = commonStrings;
    this.smartToggleService = smartToggleService;
    this.platformId = platformId;
    this.elementRef = elementRef;
    this.keyNavigation = keyNavigation;
    this.openChange = new EventEmitter(false);
    this.ariaExpanded = false;
    this.popoverId = uniqueIdFactory();
    this.smartPosition = {
      axis: ClrAxis.VERTICAL,
      side: ClrSide.AFTER,
      anchor: ClrAlignment.END,
      content: ClrAlignment.END
    };
    this._open = false;
    this.subs = [];
    this.subs.push(smartToggleService.openChange.subscribe((change) => {
      this.open = change;
      this.ariaExpanded = change;
    }));
  }
  get open() {
    return this._open;
  }
  set open(open) {
    open = !!open;
    if (this.open !== open) {
      this.smartToggleService.open = open;
      this.openChange.emit(open);
      if (!open && isPlatformBrowser(this.platformId)) {
        this.anchor.nativeElement.focus();
      }
      if (this.keyNavigation) {
        this.keyNavigation.skipItemFocus = open;
      }
      this._open = open;
    }
  }
  set customFilter(filter2) {
    this.setFilter(filter2);
  }
  /**
   * Indicates if the filter is currently active
   */
  get active() {
    return !!this.filter && this.filter.isActive();
  }
  ngOnChanges() {
    setTimeout(() => {
      this.setToggleButtonAriaLabel();
    });
  }
  ngOnDestroy() {
    super.ngOnDestroy();
    this.subs.forEach((sub) => sub.unsubscribe());
  }
  /**
   * This is not in a getter to prevent "expression has changed after it was checked" errors.
   * And it's more performant this way since it only runs on change.
   */
  setToggleButtonAriaLabel() {
    const columnElement = this.elementRef.nativeElement?.closest("clr-dg-column");
    const columnTitleElement = columnElement?.querySelector(".datagrid-column-title");
    const columnTitle = columnTitleElement?.textContent.trim().toLocaleLowerCase();
    this.toggleButtonAriaLabel = this.commonStrings.parse(this.commonStrings.keys.datagridFilterAriaLabel, {
      COLUMN: columnTitle || ""
    });
  }
};
ClrDatagridFilter.ɵfac = function ClrDatagridFilter_Factory(t3) {
  return new (t3 || ClrDatagridFilter)(ɵɵdirectiveInject(FiltersProvider), ɵɵdirectiveInject(ClrCommonStringsService), ɵɵdirectiveInject(ClrPopoverToggleService), ɵɵdirectiveInject(PLATFORM_ID), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(KeyNavigationGridController, 8));
};
ClrDatagridFilter.ɵcmp = ɵɵdefineComponent({
  type: ClrDatagridFilter,
  selectors: [["clr-dg-filter"]],
  viewQuery: function ClrDatagridFilter_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c45, 5, ElementRef);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.anchor = _t.first);
    }
  },
  inputs: {
    open: [InputFlags.None, "clrDgFilterOpen", "open"],
    customFilter: [InputFlags.None, "clrDgFilter", "customFilter"]
  },
  outputs: {
    openChange: "clrDgFilterOpenChange"
  },
  features: [ɵɵProvidersFeature([{
    provide: CustomFilter,
    useExisting: ClrDatagridFilter
  }]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature],
  ngContentSelectors: _c02,
  decls: 4,
  vars: 13,
  consts: [["anchor", ""], ["type", "button", "clrPopoverAnchor", "", "clrPopoverOpenCloseButton", "", 1, "datagrid-filter-toggle"], ["solid", ""], ["class", "datagrid-filter", "cdkTrapFocus", "", "role", "dialog", 3, "id", 4, "clrPopoverContent", "clrPopoverContentAt", "clrPopoverContentOutsideClickToClose", "clrPopoverContentScrollToClose"], ["cdkTrapFocus", "", "role", "dialog", 1, "datagrid-filter", 3, "id"], [1, "datagrid-filter-close-wrapper"], ["type", "button", "clrPopoverCloseButton", "", 1, "close"], ["shape", "window-close"]],
  template: function ClrDatagridFilter_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "button", 1, 0);
      ɵɵelement(2, "cds-icon", 2);
      ɵɵelementEnd();
      ɵɵtemplate(3, ClrDatagridFilter_div_3_Template, 5, 3, "div", 3);
    }
    if (rf & 2) {
      ɵɵclassProp("datagrid-filter-open", ctx.open)("datagrid-filtered", ctx.active);
      ɵɵattribute("aria-label", ctx.toggleButtonAriaLabel)("aria-expanded", ctx.ariaExpanded)("aria-controls", ctx.popoverId);
      ɵɵadvance(2);
      ɵɵattribute("status", ctx.active ? "info" : null)("shape", ctx.active ? "filter-grid-circle" : "filter-grid");
      ɵɵadvance();
      ɵɵproperty("clrPopoverContent", ctx.open)("clrPopoverContentAt", ctx.smartPosition)("clrPopoverContentOutsideClickToClose", true)("clrPopoverContentScrollToClose", true);
    }
  },
  dependencies: [CdkTrapFocusModule_CdkTrapFocus, CdsIconCustomTag, ClrPopoverAnchor, ClrPopoverCloseButton, ClrPopoverOpenCloseButton, ClrPopoverContent],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDatagridFilter, [{
    type: Component,
    args: [{
      selector: "clr-dg-filter",
      // We register this component as a CustomFilter, for the parent column to detect it.
      providers: [{
        provide: CustomFilter,
        useExisting: ClrDatagridFilter
      }],
      template: `
    <button
      class="datagrid-filter-toggle"
      type="button"
      #anchor
      [attr.aria-label]="toggleButtonAriaLabel"
      [attr.aria-expanded]="ariaExpanded"
      [attr.aria-controls]="popoverId"
      clrPopoverAnchor
      clrPopoverOpenCloseButton
      [class.datagrid-filter-open]="open"
      [class.datagrid-filtered]="active"
    >
      <cds-icon
        [attr.status]="active ? 'info' : null"
        [attr.shape]="active ? 'filter-grid-circle' : 'filter-grid'"
        solid
      ></cds-icon>
    </button>

    <div
      class="datagrid-filter"
      [id]="popoverId"
      cdkTrapFocus
      *clrPopoverContent="open; at: smartPosition; outsideClickToClose: true; scrollToClose: true"
      role="dialog"
      [attr.aria-label]="commonStrings.keys.datagridFilterDialogAriaLabel"
    >
      <div class="datagrid-filter-close-wrapper">
        <button type="button" class="close" clrPopoverCloseButton>
          <cds-icon shape="window-close" [attr.title]="commonStrings.keys.close"></cds-icon>
        </button>
      </div>

      <ng-content></ng-content>
    </div>
  `
    }]
  }], function() {
    return [{
      type: FiltersProvider
    }, {
      type: ClrCommonStringsService
    }, {
      type: ClrPopoverToggleService
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [PLATFORM_ID]
      }]
    }, {
      type: ElementRef
    }, {
      type: KeyNavigationGridController,
      decorators: [{
        type: Optional
      }]
    }];
  }, {
    openChange: [{
      type: Output,
      args: ["clrDgFilterOpenChange"]
    }],
    anchor: [{
      type: ViewChild,
      args: ["anchor", {
        read: ElementRef
      }]
    }],
    open: [{
      type: Input,
      args: ["clrDgFilterOpen"]
    }],
    customFilter: [{
      type: Input,
      args: ["clrDgFilter"]
    }]
  });
})();
var NestedProperty = class {
  constructor(prop) {
    this.prop = prop;
    if (prop.indexOf(".") >= 0) {
      this.splitProp = prop.split(".");
    }
  }
  // Safe getter for a deep object property, will not throw an error but return
  // undefined if one of the intermediate properties is null or undefined.
  getPropValue(item) {
    if (this.splitProp) {
      let value = item;
      for (const nestedProp of this.splitProp) {
        if (value === null || typeof value === "undefined" || typeof value[nestedProp] === "undefined") {
          return void 0;
        }
        value = value[nestedProp];
      }
      return value;
    } else {
      return item[this.prop];
    }
  }
};
var DatagridPropertyNumericFilter = class {
  constructor(prop, exact = false) {
    this.prop = prop;
    this.exact = exact;
    this.nestedProp = new NestedProperty(prop);
  }
  accepts(item, low, high) {
    const propValue = this.nestedProp.getPropValue(item);
    if (propValue === void 0) {
      return false;
    }
    if (low !== null && (typeof propValue !== "number" || propValue < low)) {
      return false;
    }
    if (high !== null && (typeof propValue !== "number" || propValue > high)) {
      return false;
    }
    return true;
  }
};
var DatagridNumericFilterImpl = class _DatagridNumericFilterImpl {
  constructor(filterFn) {
    this.filterFn = filterFn;
    this._changes = new Subject();
    this._low = null;
    this._high = null;
  }
  // We do not want to expose the Subject itself, but the Observable which is read-only
  get changes() {
    return this._changes.asObservable();
  }
  get value() {
    return [this._low, this._high];
  }
  set value(vals) {
    const low = vals[0];
    const high = vals[1];
    if (low !== this._low || high !== this._high) {
      this._low = low;
      this._high = high;
      this._changes.next([this._low, this._high]);
    }
  }
  get low() {
    return this._low;
  }
  set low(low) {
    if (low !== this._low) {
      this._low = low;
      this._changes.next([this._low, this._high]);
    }
  }
  get high() {
    return this._high;
  }
  set high(high) {
    if (high !== this._high) {
      this._high = high;
      this._changes.next([this._low, this._high]);
    }
  }
  get state() {
    if (this.filterFn instanceof DatagridPropertyNumericFilter) {
      return {
        property: this.filterFn.prop,
        low: this._low,
        high: this._high
      };
    }
    return this;
  }
  /**
   * Indicates if the filter is currently active, (at least one input is set)
   */
  isActive() {
    return this._low !== null || this.high !== null;
  }
  /**
   * Tests if an item matches a search text
   */
  accepts(item) {
    return this.filterFn.accepts(item, this._low, this._high);
  }
  equals(other) {
    if (other instanceof _DatagridNumericFilterImpl) {
      if (other.filterFn instanceof DatagridPropertyNumericFilter) {
        return this.filterFn instanceof DatagridPropertyNumericFilter && other.filterFn.prop === this.filterFn.prop && other.low === this._low && other.high === this._high;
      }
      return other === this;
    }
    return false;
  }
};
var DatagridNumericFilter = class extends DatagridFilterRegistrar {
  constructor(filters, domAdapter, commonStrings, popoverToggleService, ngZone) {
    super(filters);
    this.domAdapter = domAdapter;
    this.commonStrings = commonStrings;
    this.popoverToggleService = popoverToggleService;
    this.ngZone = ngZone;
    this.filterValueChange = new EventEmitter();
    this.open = false;
    this.subscriptions = [];
  }
  /**
   * Common setter for the input values
   */
  get value() {
    return [this.filter.low, this.filter.high];
  }
  set value(values) {
    if (this.filter && Array.isArray(values)) {
      if (values && (values[0] !== this.filter.low || values[1] !== this.filter.high)) {
        if (typeof values[0] === "number") {
          this.filter.low = values[0];
        } else {
          this.filter.low = null;
        }
        if (typeof values[1] === "number") {
          this.filter.high = values[1];
        } else {
          this.filter.high = null;
        }
        this.filterValueChange.emit(values);
      }
    } else {
      this.initFilterValues = values;
    }
  }
  /**
   * Customizable filter logic based on high and low values
   */
  set customNumericFilter(value) {
    if (value instanceof RegisteredFilter) {
      this.setFilter(value);
    } else {
      this.setFilter(new DatagridNumericFilterImpl(value));
    }
    if (this.initFilterValues) {
      this.value = this.initFilterValues;
      delete this.initFilterValues;
    }
  }
  get maxPlaceholderValue() {
    return this.maxPlaceholder || this.commonStrings.keys.maxValue;
  }
  get minPlaceholderValue() {
    return this.minPlaceholder || this.commonStrings.keys.minValue;
  }
  get low() {
    if (typeof this.filter.low === "number" && isFinite(this.filter.low)) {
      return this.filter.low;
    } else {
      return null;
    }
  }
  set low(low) {
    if (typeof low === "number" && low !== this.filter.low) {
      this.filter.low = low;
      this.filterValueChange.emit([this.filter.low, this.filter.high]);
    } else if (typeof low !== "number") {
      this.filter.low = null;
      this.filterValueChange.emit([this.filter.low, this.filter.high]);
    }
  }
  get high() {
    if (typeof this.filter.high === "number" && isFinite(this.filter.high)) {
      return this.filter.high;
    } else {
      return null;
    }
  }
  set high(high) {
    if (typeof high === "number" && high !== this.filter.high) {
      this.filter.high = high;
      this.filterValueChange.emit([this.filter.low, this.filter.high]);
    } else if (typeof high !== "number") {
      this.filter.high = null;
      this.filterValueChange.emit([this.filter.low, this.filter.high]);
    }
  }
  ngAfterViewInit() {
    this.subscriptions.push(this.popoverToggleService.openChange.subscribe((openChange) => {
      this.open = openChange;
      this.ngZone.runOutsideAngular(() => {
        requestAnimationFrame(() => {
          this.domAdapter.focus(this.input.nativeElement);
        });
      });
    }));
  }
  ngOnDestroy() {
    super.ngOnDestroy();
    this.subscriptions.forEach((sub) => {
      sub.unsubscribe();
    });
  }
};
DatagridNumericFilter.ɵfac = function DatagridNumericFilter_Factory(t3) {
  return new (t3 || DatagridNumericFilter)(ɵɵdirectiveInject(FiltersProvider), ɵɵdirectiveInject(DomAdapter), ɵɵdirectiveInject(ClrCommonStringsService), ɵɵdirectiveInject(ClrPopoverToggleService), ɵɵdirectiveInject(NgZone));
};
DatagridNumericFilter.ɵcmp = ɵɵdefineComponent({
  type: DatagridNumericFilter,
  selectors: [["clr-dg-numeric-filter"]],
  viewQuery: function DatagridNumericFilter_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c46, 5);
      ɵɵviewQuery(ClrDatagridFilter, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.input = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.filterContainer = _t.first);
    }
  },
  inputs: {
    minPlaceholder: [InputFlags.None, "clrFilterMinPlaceholder", "minPlaceholder"],
    maxPlaceholder: [InputFlags.None, "clrFilterMaxPlaceholder", "maxPlaceholder"],
    value: [InputFlags.None, "clrFilterValue", "value"],
    customNumericFilter: [InputFlags.None, "clrDgNumericFilter", "customNumericFilter"]
  },
  outputs: {
    filterValueChange: "clrFilterValueChange"
  },
  features: [ɵɵProvidersFeature([{
    provide: CustomFilter,
    useExisting: DatagridNumericFilter
  }]), ɵɵInheritDefinitionFeature],
  decls: 6,
  vars: 8,
  consts: [["input_low", ""], ["input_high", ""], [3, "clrDgFilterOpenChange", "clrDgFilter", "clrDgFilterOpen"], ["type", "number", "autocomplete", "off", "name", "low", 1, "datagrid-numeric-filter-input", 3, "ngModelChange", "ngModel", "placeholder"], [1, "datagrid-filter-input-spacer"], ["type", "number", "autocomplete", "off", "name", "high", 1, "datagrid-numeric-filter-input", 3, "ngModelChange", "ngModel", "placeholder"]],
  template: function DatagridNumericFilter_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵelementStart(0, "clr-dg-filter", 2);
      ɵɵtwoWayListener("clrDgFilterOpenChange", function DatagridNumericFilter_Template_clr_dg_filter_clrDgFilterOpenChange_0_listener($event) {
        ɵɵrestoreView(_r1);
        ɵɵtwoWayBindingSet(ctx.open, $event) || (ctx.open = $event);
        return ɵɵresetView($event);
      });
      ɵɵelementStart(1, "input", 3, 0);
      ɵɵtwoWayListener("ngModelChange", function DatagridNumericFilter_Template_input_ngModelChange_1_listener($event) {
        ɵɵrestoreView(_r1);
        ɵɵtwoWayBindingSet(ctx.low, $event) || (ctx.low = $event);
        return ɵɵresetView($event);
      });
      ɵɵelementEnd();
      ɵɵelement(3, "span", 4);
      ɵɵelementStart(4, "input", 5, 1);
      ɵɵtwoWayListener("ngModelChange", function DatagridNumericFilter_Template_input_ngModelChange_4_listener($event) {
        ɵɵrestoreView(_r1);
        ɵɵtwoWayBindingSet(ctx.high, $event) || (ctx.high = $event);
        return ɵɵresetView($event);
      });
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵproperty("clrDgFilter", ctx.registered);
      ɵɵtwoWayProperty("clrDgFilterOpen", ctx.open);
      ɵɵadvance();
      ɵɵtwoWayProperty("ngModel", ctx.low);
      ɵɵproperty("placeholder", ctx.minPlaceholderValue);
      ɵɵattribute("aria-label", ctx.minPlaceholderValue);
      ɵɵadvance(3);
      ɵɵtwoWayProperty("ngModel", ctx.high);
      ɵɵproperty("placeholder", ctx.maxPlaceholderValue);
      ɵɵattribute("aria-label", ctx.maxPlaceholderValue);
    }
  },
  dependencies: [DefaultValueAccessor, NumberValueAccessor, NgControlStatus, NgModel, ClrDatagridFilter],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DatagridNumericFilter, [{
    type: Component,
    args: [{
      selector: "clr-dg-numeric-filter",
      providers: [{
        provide: CustomFilter,
        useExisting: DatagridNumericFilter
      }],
      template: `
    <clr-dg-filter [clrDgFilter]="registered" [(clrDgFilterOpen)]="open">
      <input
        class="datagrid-numeric-filter-input"
        #input_low
        type="number"
        autocomplete="off"
        name="low"
        [(ngModel)]="low"
        [placeholder]="minPlaceholderValue"
        [attr.aria-label]="minPlaceholderValue"
      />
      <span class="datagrid-filter-input-spacer"></span>
      <input
        class="datagrid-numeric-filter-input"
        #input_high
        type="number"
        autocomplete="off"
        name="high"
        [(ngModel)]="high"
        [placeholder]="maxPlaceholderValue"
        [attr.aria-label]="maxPlaceholderValue"
      />
    </clr-dg-filter>
  `
    }]
  }], function() {
    return [{
      type: FiltersProvider
    }, {
      type: DomAdapter
    }, {
      type: ClrCommonStringsService
    }, {
      type: ClrPopoverToggleService
    }, {
      type: NgZone
    }];
  }, {
    minPlaceholder: [{
      type: Input,
      args: ["clrFilterMinPlaceholder"]
    }],
    maxPlaceholder: [{
      type: Input,
      args: ["clrFilterMaxPlaceholder"]
    }],
    filterValueChange: [{
      type: Output,
      args: ["clrFilterValueChange"]
    }],
    input: [{
      type: ViewChild,
      args: ["input_low"]
    }],
    filterContainer: [{
      type: ViewChild,
      args: [ClrDatagridFilter]
    }],
    value: [{
      type: Input,
      args: ["clrFilterValue"]
    }],
    customNumericFilter: [{
      type: Input,
      args: ["clrDgNumericFilter"]
    }]
  });
})();
var DatagridPropertyStringFilter = class {
  constructor(prop, exact = false) {
    this.prop = prop;
    this.exact = exact;
    this.nestedProp = new NestedProperty(prop);
  }
  accepts(item, search) {
    const propValue = this.nestedProp.getPropValue(item);
    if (typeof propValue === "undefined") {
      return false;
    } else if (this.exact) {
      return ("" + propValue).toLowerCase() === search;
    } else {
      return ("" + propValue).toLowerCase().indexOf(search) >= 0;
    }
  }
};
var DatagridStringFilterImpl = class _DatagridStringFilterImpl {
  constructor(filterFn) {
    this.filterFn = filterFn;
    this._changes = new Subject();
    this._lowerCaseValue = "";
    this._rawValue = "";
  }
  // We do not want to expose the Subject itself, but the Observable which is read-only
  get changes() {
    return this._changes.asObservable();
  }
  get lowerCaseValue() {
    return this._lowerCaseValue;
  }
  get state() {
    if (this.filterFn instanceof DatagridPropertyStringFilter) {
      return {
        property: this.filterFn.prop,
        value: this.value
      };
    }
    return this;
  }
  get value() {
    return this._rawValue;
  }
  /**
   * Common setter for the input value
   */
  set value(value) {
    if (!value) {
      value = "";
    }
    if (value !== this._rawValue) {
      this._rawValue = value;
      this._lowerCaseValue = value.toLowerCase().trim();
      this._changes.next(value);
    }
  }
  /**
   * Indicates if the filter is currently active, meaning the input is not empty
   */
  isActive() {
    return !!this.value;
  }
  /**
   * Tests if an item matches a search text
   */
  accepts(item) {
    return this.filterFn.accepts(item, this.lowerCaseValue);
  }
  equals(other) {
    if (other instanceof _DatagridStringFilterImpl) {
      if (other.filterFn instanceof DatagridPropertyStringFilter) {
        return this.filterFn instanceof DatagridPropertyStringFilter && other.filterFn.prop === this.filterFn.prop && other.value === this.value;
      }
      return other === this;
    }
    return false;
  }
};
var DatagridStringFilter = class extends DatagridFilterRegistrar {
  constructor(filters, domAdapter, commonStrings, smartToggleService, ngZone) {
    super(filters);
    this.domAdapter = domAdapter;
    this.commonStrings = commonStrings;
    this.smartToggleService = smartToggleService;
    this.ngZone = ngZone;
    this.filterValueChange = new EventEmitter();
    this.open = false;
    this.subs = [];
  }
  /**
   * Customizable filter logic based on a search text
   */
  set customStringFilter(value) {
    if (value instanceof RegisteredFilter) {
      this.setFilter(value);
    } else {
      this.setFilter(new DatagridStringFilterImpl(value));
    }
    if (this.initFilterValue) {
      this.value = this.initFilterValue;
      delete this.initFilterValue;
    }
  }
  /**
   * Common setter for the input value
   */
  get value() {
    return this.filter.value;
  }
  set value(value) {
    if (this.filter && typeof value === "string") {
      if (!value) {
        value = "";
      }
      if (value !== this.filter.value) {
        this.filter.value = value;
        this.filterValueChange.emit(value);
      }
    } else {
      this.initFilterValue = value;
    }
  }
  get placeholderValue() {
    return this.placeholder || this.commonStrings.keys.filterItems;
  }
  ngAfterViewInit() {
    this.subs.push(this.smartToggleService.openChange.subscribe((openChange) => {
      this.open = openChange;
      this.ngZone.runOutsideAngular(() => {
        requestAnimationFrame(() => {
          this.domAdapter.focus(this.input.nativeElement);
        });
      });
    }));
  }
  ngOnDestroy() {
    super.ngOnDestroy();
    this.subs.forEach((sub) => sub.unsubscribe());
  }
};
DatagridStringFilter.ɵfac = function DatagridStringFilter_Factory(t3) {
  return new (t3 || DatagridStringFilter)(ɵɵdirectiveInject(FiltersProvider), ɵɵdirectiveInject(DomAdapter), ɵɵdirectiveInject(ClrCommonStringsService), ɵɵdirectiveInject(ClrPopoverToggleService), ɵɵdirectiveInject(NgZone));
};
DatagridStringFilter.ɵcmp = ɵɵdefineComponent({
  type: DatagridStringFilter,
  selectors: [["clr-dg-string-filter"]],
  viewQuery: function DatagridStringFilter_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c47, 5);
      ɵɵviewQuery(ClrDatagridFilter, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.input = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.filterContainer = _t.first);
    }
  },
  inputs: {
    placeholder: [InputFlags.None, "clrFilterPlaceholder", "placeholder"],
    customStringFilter: [InputFlags.None, "clrDgStringFilter", "customStringFilter"],
    value: [InputFlags.None, "clrFilterValue", "value"]
  },
  outputs: {
    filterValueChange: "clrFilterValueChange"
  },
  features: [ɵɵProvidersFeature([{
    provide: CustomFilter,
    useExisting: DatagridStringFilter
  }]), ɵɵInheritDefinitionFeature],
  decls: 3,
  vars: 5,
  consts: [["input", ""], [3, "clrDgFilterOpenChange", "clrDgFilter", "clrDgFilterOpen"], ["type", "text", "autocomplete", "off", "name", "search", 1, "clr-input", 3, "ngModelChange", "ngModel", "placeholder"]],
  template: function DatagridStringFilter_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵelementStart(0, "clr-dg-filter", 1);
      ɵɵtwoWayListener("clrDgFilterOpenChange", function DatagridStringFilter_Template_clr_dg_filter_clrDgFilterOpenChange_0_listener($event) {
        ɵɵrestoreView(_r1);
        ɵɵtwoWayBindingSet(ctx.open, $event) || (ctx.open = $event);
        return ɵɵresetView($event);
      });
      ɵɵelementStart(1, "input", 2, 0);
      ɵɵtwoWayListener("ngModelChange", function DatagridStringFilter_Template_input_ngModelChange_1_listener($event) {
        ɵɵrestoreView(_r1);
        ɵɵtwoWayBindingSet(ctx.value, $event) || (ctx.value = $event);
        return ɵɵresetView($event);
      });
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵproperty("clrDgFilter", ctx.registered);
      ɵɵtwoWayProperty("clrDgFilterOpen", ctx.open);
      ɵɵadvance();
      ɵɵtwoWayProperty("ngModel", ctx.value);
      ɵɵproperty("placeholder", ctx.placeholderValue);
      ɵɵattribute("aria-label", ctx.placeholderValue);
    }
  },
  dependencies: [DefaultValueAccessor, NgControlStatus, NgModel, ClrDatagridFilter],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DatagridStringFilter, [{
    type: Component,
    args: [{
      selector: "clr-dg-string-filter",
      providers: [{
        provide: CustomFilter,
        useExisting: DatagridStringFilter
      }],
      template: `
    <clr-dg-filter [clrDgFilter]="registered" [(clrDgFilterOpen)]="open">
      <input
        #input
        type="text"
        autocomplete="off"
        name="search"
        [(ngModel)]="value"
        class="clr-input"
        [attr.aria-label]="placeholderValue"
        [placeholder]="placeholderValue"
      />
    </clr-dg-filter>
  `
    }]
  }], function() {
    return [{
      type: FiltersProvider
    }, {
      type: DomAdapter
    }, {
      type: ClrCommonStringsService
    }, {
      type: ClrPopoverToggleService
    }, {
      type: NgZone
    }];
  }, {
    placeholder: [{
      type: Input,
      args: ["clrFilterPlaceholder"]
    }],
    filterValueChange: [{
      type: Output,
      args: ["clrFilterValueChange"]
    }],
    input: [{
      type: ViewChild,
      args: ["input"]
    }],
    filterContainer: [{
      type: ViewChild,
      args: [ClrDatagridFilter]
    }],
    customStringFilter: [{
      type: Input,
      args: ["clrDgStringFilter"]
    }],
    value: [{
      type: Input,
      args: ["clrFilterValue"]
    }]
  });
})();
var DatagridWillyWonka = class extends WillyWonka {
};
DatagridWillyWonka.ɵfac = /* @__PURE__ */ (() => {
  let ɵDatagridWillyWonka_BaseFactory;
  return function DatagridWillyWonka_Factory(t3) {
    return (ɵDatagridWillyWonka_BaseFactory || (ɵDatagridWillyWonka_BaseFactory = ɵɵgetInheritedFactory(DatagridWillyWonka)))(t3 || DatagridWillyWonka);
  };
})();
DatagridWillyWonka.ɵdir = ɵɵdefineDirective({
  type: DatagridWillyWonka,
  selectors: [["clr-datagrid"]],
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DatagridWillyWonka, [{
    type: Directive,
    args: [{
      selector: "clr-datagrid"
    }]
  }], null, null);
})();
var RowActionService = class {
  constructor() {
    this.actionableCount = 0;
  }
  /**
   * false means no rows with action
   */
  get hasActionableRow() {
    return this.actionableCount > 0;
  }
  register() {
    this.actionableCount++;
  }
  unregister() {
    this.actionableCount--;
  }
};
RowActionService.ɵfac = function RowActionService_Factory(t3) {
  return new (t3 || RowActionService)();
};
RowActionService.ɵprov = ɵɵdefineInjectable({
  token: RowActionService,
  factory: RowActionService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RowActionService, [{
    type: Injectable
  }], null, null);
})();
var ActionableOompaLoompa = class extends OompaLoompa {
  constructor(cdr, willyWonka, rowActions) {
    if (!willyWonka) {
      throw new Error("clr-dg-row should only be used inside of a clr-datagrid");
    }
    super(cdr, willyWonka);
    this.rowActions = rowActions;
  }
  get flavor() {
    return this.rowActions.hasActionableRow;
  }
};
ActionableOompaLoompa.ɵfac = function ActionableOompaLoompa_Factory(t3) {
  return new (t3 || ActionableOompaLoompa)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(DatagridWillyWonka, 8), ɵɵdirectiveInject(RowActionService));
};
ActionableOompaLoompa.ɵdir = ɵɵdefineDirective({
  type: ActionableOompaLoompa,
  selectors: [["clr-datagrid"], ["clr-dg-row"]],
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ActionableOompaLoompa, [{
    type: Directive,
    args: [{
      selector: "clr-datagrid, clr-dg-row"
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: DatagridWillyWonka,
      decorators: [{
        type: Optional
      }]
    }, {
      type: RowActionService
    }];
  }, null);
})();
var ModalStackService = class {
  constructor(platformId) {
    this.platformId = platformId;
    this.modalStack = [];
    this.keyUpEventListener = this.onKeyUp.bind(this);
  }
  trackModalOpen(openedModal) {
    if (this.modalStack.includes(openedModal) === false) {
      this.modalStack.unshift(openedModal);
    }
    if (isPlatformBrowser(this.platformId)) {
      document.body.addEventListener("keyup", this.keyUpEventListener);
    }
  }
  trackModalClose(closedModal) {
    const closedModalIndex = this.modalStack.indexOf(closedModal);
    if (closedModalIndex > -1) {
      this.modalStack.splice(closedModalIndex, 1);
    }
    if (this.modalStack.length === 0 && isPlatformBrowser(this.platformId)) {
      document.body.removeEventListener("keyup", this.keyUpEventListener);
    }
  }
  onKeyUp(event) {
    if (this.modalStack.length && normalizeKey(event.key) === Keys.Escape) {
      document.activeElement.blur();
      this.modalStack[0].close();
    }
  }
};
ModalStackService.ɵfac = function ModalStackService_Factory(t3) {
  return new (t3 || ModalStackService)(ɵɵinject(PLATFORM_ID));
};
ModalStackService.ɵprov = ɵɵdefineInjectable({
  token: ModalStackService,
  factory: ModalStackService.ɵfac,
  providedIn: "root"
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ModalStackService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], function() {
    return [{
      type: void 0,
      decorators: [{
        type: Inject,
        args: [PLATFORM_ID]
      }]
    }];
  }, null);
})();
var DetailService = class {
  constructor(modalStackService) {
    this.modalStackService = modalStackService;
    this.preventScroll = false;
    this.toggleState = false;
    this._enabled = false;
    this._state = new BehaviorSubject(this.toggleState);
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(state2) {
    this._enabled = state2;
  }
  get preventFocusScroll() {
    return this.preventScroll;
  }
  set preventFocusScroll(preventScroll) {
    this.preventScroll = preventScroll;
  }
  get state() {
    return this.cache;
  }
  get stateChange() {
    return this._state.asObservable();
  }
  get isOpen() {
    return this.toggleState === true;
  }
  open(item, button) {
    this.cache = item;
    this.button = button;
    this.toggleState = true;
    this._state.next(this.toggleState);
    this.modalStackService.trackModalOpen(this);
  }
  close() {
    this.toggleState = false;
    this.returnFocus();
    this._state.next(this.toggleState);
    this.modalStackService.trackModalClose(this);
  }
  returnFocus() {
    if (this.button) {
      this.button.focus({
        preventScroll: this.preventFocusScroll
      });
      this.button = null;
    }
  }
  toggle(item, button) {
    if (this.isRowOpen(item) || !item) {
      this.close();
    } else {
      this.open(item, button);
    }
  }
  isRowOpen(item) {
    return !!(this.toggleState && this.cache === item);
  }
};
DetailService.ɵfac = function DetailService_Factory(t3) {
  return new (t3 || DetailService)(ɵɵinject(ModalStackService));
};
DetailService.ɵprov = ɵɵdefineInjectable({
  token: DetailService,
  factory: DetailService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DetailService, [{
    type: Injectable
  }], function() {
    return [{
      type: ModalStackService
    }];
  }, null);
})();
var ExpandableRowsCount = class {
  constructor(detailService) {
    this.detailService = detailService;
    this.expandableCount = 0;
  }
  /**
   * false means no rows with action
   * check if details are on, and disable rows entirely
   */
  get hasExpandableRow() {
    return !this.detailService.enabled && this.expandableCount > 0;
  }
  register() {
    this.expandableCount++;
  }
  unregister() {
    this.expandableCount--;
  }
};
ExpandableRowsCount.ɵfac = function ExpandableRowsCount_Factory(t3) {
  return new (t3 || ExpandableRowsCount)(ɵɵinject(DetailService));
};
ExpandableRowsCount.ɵprov = ɵɵdefineInjectable({
  token: ExpandableRowsCount,
  factory: ExpandableRowsCount.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ExpandableRowsCount, [{
    type: Injectable
  }], function() {
    return [{
      type: DetailService
    }];
  }, null);
})();
var ExpandableOompaLoompa = class extends OompaLoompa {
  constructor(cdr, willyWonka, expandableCount) {
    if (!willyWonka) {
      throw new Error("clr-dg-row should only be used inside of a clr-datagrid");
    }
    super(cdr, willyWonka);
    this.expandableCount = expandableCount;
  }
  get flavor() {
    return this.expandableCount.hasExpandableRow;
  }
};
ExpandableOompaLoompa.ɵfac = function ExpandableOompaLoompa_Factory(t3) {
  return new (t3 || ExpandableOompaLoompa)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(DatagridWillyWonka, 8), ɵɵdirectiveInject(ExpandableRowsCount));
};
ExpandableOompaLoompa.ɵdir = ɵɵdefineDirective({
  type: ExpandableOompaLoompa,
  selectors: [["clr-datagrid"], ["clr-dg-row"]],
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ExpandableOompaLoompa, [{
    type: Directive,
    args: [{
      selector: "clr-datagrid, clr-dg-row"
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: DatagridWillyWonka,
      decorators: [{
        type: Optional
      }]
    }, {
      type: ExpandableRowsCount
    }];
  }, null);
})();
var DatagridPropertyComparator = class {
  constructor(prop) {
    this.prop = prop;
    this.nestedProp = new NestedProperty(prop);
  }
  compare(a4, b) {
    let propA = this.nestedProp.getPropValue(a4);
    let propB = this.nestedProp.getPropValue(b);
    if (typeof propA === "string") {
      propA = propA.toLowerCase();
    }
    if (typeof propB === "string") {
      propB = propB.toLowerCase();
    }
    if (typeof propA === "undefined" || propA === null) {
      if (typeof propB === "undefined" || propB === null) {
        return 0;
      } else {
        return 1;
      }
    } else {
      if (typeof propB === "undefined" || propB === null) {
        return -1;
      } else if (propA < propB) {
        return -1;
      } else if (propA > propB) {
        return 1;
      } else {
        return 0;
      }
    }
  }
};
var ClrDatagridSortOrder;
(function(ClrDatagridSortOrder2) {
  ClrDatagridSortOrder2[ClrDatagridSortOrder2["UNSORTED"] = 0] = "UNSORTED";
  ClrDatagridSortOrder2[ClrDatagridSortOrder2["ASC"] = 1] = "ASC";
  ClrDatagridSortOrder2[ClrDatagridSortOrder2["DESC"] = -1] = "DESC";
})(ClrDatagridSortOrder || (ClrDatagridSortOrder = {}));
var WrappedColumn = class {
  constructor() {
    this._dynamic = false;
  }
  ngAfterViewInit() {
    this.columnView = this.templateRef.createEmbeddedView(null);
  }
  ngOnDestroy() {
    this.columnView.destroy();
  }
};
WrappedColumn.ɵfac = function WrappedColumn_Factory(t3) {
  return new (t3 || WrappedColumn)();
};
WrappedColumn.ɵcmp = ɵɵdefineComponent({
  type: WrappedColumn,
  selectors: [["dg-wrapped-column"]],
  viewQuery: function WrappedColumn_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c48, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.templateRef = _t.first);
    }
  },
  ngContentSelectors: _c02,
  decls: 2,
  vars: 0,
  consts: [["columnPortal", ""]],
  template: function WrappedColumn_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵtemplate(0, WrappedColumn_ng_template_0_Template, 1, 0, "ng-template", null, 0, ɵɵtemplateRefExtractor);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(WrappedColumn, [{
    type: Component,
    args: [{
      selector: "dg-wrapped-column",
      template: `
    <ng-template #columnPortal>
      <ng-content></ng-content>
    </ng-template>
  `
    }]
  }], null, {
    templateRef: [{
      type: ViewChild,
      args: ["columnPortal"]
    }]
  });
})();
var Sort = class {
  constructor(stateDebouncer) {
    this.stateDebouncer = stateDebouncer;
    this._reverse = false;
    this._change = new Subject();
  }
  get comparator() {
    return this._comparator;
  }
  set comparator(value) {
    this.stateDebouncer.changeStart();
    this._comparator = value;
    this.emitChange();
    this.stateDebouncer.changeDone();
  }
  get reverse() {
    return this._reverse;
  }
  set reverse(value) {
    this.stateDebouncer.changeStart();
    this._reverse = value;
    this.emitChange();
    this.stateDebouncer.changeDone();
  }
  // We do not want to expose the Subject itself, but the Observable which is read-only
  get change() {
    return this._change.asObservable();
  }
  /**
   * Sets a comparator as the current one, or toggles reverse if the comparator is already used. The
   * optional forceReverse input parameter allows to override that toggling behavior by sorting in
   * reverse order if `true`.
   *
   * @memberof Sort
   */
  toggle(sortBy, forceReverse) {
    this.stateDebouncer.changeStart();
    if (this.comparator === sortBy) {
      this._reverse = typeof forceReverse !== "undefined" ? forceReverse || !this._reverse : !this._reverse;
    } else {
      this._comparator = sortBy;
      this._reverse = typeof forceReverse !== "undefined" ? forceReverse : false;
    }
    this.emitChange();
    this.stateDebouncer.changeDone();
  }
  /**
   * Clears the current sorting order
   */
  clear() {
    this.comparator = null;
  }
  /**
   * Compares two objects according to the current comparator
   */
  compare(a4, b) {
    return (this.reverse ? -1 : 1) * this.comparator.compare(a4, b);
  }
  emitChange() {
    this._change.next(this);
  }
};
Sort.ɵfac = function Sort_Factory(t3) {
  return new (t3 || Sort)(ɵɵinject(StateDebouncer));
};
Sort.ɵprov = ɵɵdefineInjectable({
  token: Sort,
  factory: Sort.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Sort, [{
    type: Injectable
  }], function() {
    return [{
      type: StateDebouncer
    }];
  }, null);
})();
var DatagridRenderStep;
(function(DatagridRenderStep2) {
  DatagridRenderStep2[DatagridRenderStep2["ALIGN_COLUMNS"] = 0] = "ALIGN_COLUMNS";
  DatagridRenderStep2[DatagridRenderStep2["CALCULATE_MODE_ON"] = 1] = "CALCULATE_MODE_ON";
  DatagridRenderStep2[DatagridRenderStep2["CALCULATE_MODE_OFF"] = 2] = "CALCULATE_MODE_OFF";
  DatagridRenderStep2[DatagridRenderStep2["CLEAR_WIDTHS"] = 3] = "CLEAR_WIDTHS";
  DatagridRenderStep2[DatagridRenderStep2["COMPUTE_COLUMN_WIDTHS"] = 4] = "COMPUTE_COLUMN_WIDTHS";
})(DatagridRenderStep || (DatagridRenderStep = {}));
var DatagridRenderOrganizer = class {
  constructor() {
    this._renderStep = new Subject();
    this.alreadySized = false;
  }
  get renderStep() {
    return this._renderStep.asObservable();
  }
  filterRenderSteps(step) {
    return this.renderStep.pipe(filter((testStep) => step === testStep));
  }
  resize() {
    this._renderStep.next(DatagridRenderStep.CALCULATE_MODE_ON);
    if (this.alreadySized) {
      this._renderStep.next(DatagridRenderStep.CLEAR_WIDTHS);
    }
    this._renderStep.next(DatagridRenderStep.COMPUTE_COLUMN_WIDTHS);
    this._renderStep.next(DatagridRenderStep.ALIGN_COLUMNS);
    this.alreadySized = true;
    this._renderStep.next(DatagridRenderStep.CALCULATE_MODE_OFF);
  }
};
DatagridRenderOrganizer.ɵfac = function DatagridRenderOrganizer_Factory(t3) {
  return new (t3 || DatagridRenderOrganizer)();
};
DatagridRenderOrganizer.ɵprov = ɵɵdefineInjectable({
  token: DatagridRenderOrganizer,
  factory: DatagridRenderOrganizer.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DatagridRenderOrganizer, [{
    type: Injectable
  }], null, null);
})();
var MIN_COLUMN_WIDTH = 96;
var ColumnResizerService = class {
  constructor(el, domAdapter, organizer) {
    this.el = el;
    this.domAdapter = domAdapter;
    this.organizer = organizer;
    this._resizedBy = 0;
  }
  get resizedBy() {
    return this._resizedBy;
  }
  get minColumnWidth() {
    return this.domAdapter.minWidth(this.el.nativeElement) || MIN_COLUMN_WIDTH;
  }
  get maxResizeRange() {
    return this.widthBeforeResize - this.minColumnWidth;
  }
  get widthAfterResize() {
    return this.widthBeforeResize + this._resizedBy;
  }
  startResize() {
    this._resizedBy = 0;
    this.isWithinMaxResizeRange = true;
    this.widthBeforeResize = this.domAdapter.clientRect(this.el.nativeElement).width;
  }
  endResize() {
    this.organizer.resize();
  }
  calculateResize(resizedBy) {
    if (resizedBy < -this.maxResizeRange) {
      this._resizedBy = -this.maxResizeRange;
      this.isWithinMaxResizeRange = false;
    } else {
      this._resizedBy = resizedBy;
      this.isWithinMaxResizeRange = true;
    }
  }
};
ColumnResizerService.ɵfac = function ColumnResizerService_Factory(t3) {
  return new (t3 || ColumnResizerService)(ɵɵinject(ElementRef), ɵɵinject(DomAdapter), ɵɵinject(DatagridRenderOrganizer));
};
ColumnResizerService.ɵprov = ɵɵdefineInjectable({
  token: ColumnResizerService,
  factory: ColumnResizerService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnResizerService, [{
    type: Injectable
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: DomAdapter
    }, {
      type: DatagridRenderOrganizer
    }];
  }, null);
})();
var TableSizeService = class {
  constructor(platformId) {
    this.platformId = platformId;
  }
  get tableRef() {
    return this._tableRef;
  }
  set tableRef(element) {
    this._tableRef = element;
  }
  set table(table) {
    if (isPlatformBrowser(this.platformId) && table.nativeElement) {
      this.tableRef = table.nativeElement.querySelector(".datagrid-table");
    }
  }
  // Used when resizing columns to show the column border being dragged.
  getColumnDragHeight() {
    if (!this.tableRef) {
      return null;
    }
    return `${this.tableRef.clientHeight}px`;
  }
};
TableSizeService.ɵfac = function TableSizeService_Factory(t3) {
  return new (t3 || TableSizeService)(ɵɵinject(PLATFORM_ID));
};
TableSizeService.ɵprov = ɵɵdefineInjectable({
  token: TableSizeService,
  factory: TableSizeService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TableSizeService, [{
    type: Injectable
  }], function() {
    return [{
      type: void 0,
      decorators: [{
        type: Inject,
        args: [PLATFORM_ID]
      }]
    }];
  }, null);
})();
var KEYBOARD_RESIZE_LENGTH = 12;
var ClrDatagridColumnSeparator = class {
  constructor(columnResizerService, renderer, ngZone, tableSizeService, commonString, document2) {
    this.columnResizerService = columnResizerService;
    this.renderer = renderer;
    this.ngZone = ngZone;
    this.tableSizeService = tableSizeService;
    this.commonString = commonString;
    this.document = document2;
    this.columnSeparatorId = uniqueIdFactory();
    this.resizeStartedOnKeyDown = false;
    this.unlisteners = [];
  }
  get descriptionId() {
    return `${this.columnSeparatorId}-aria-describedby`;
  }
  get resizeTrackerEl() {
    return this.resizeTrackerRef.nativeElement;
  }
  get columnHandleEl() {
    return this.columnHandleRef.nativeElement;
  }
  ngAfterViewInit() {
    this.ngZone.runOutsideAngular(() => {
      this.unlisteners.push(this.renderer.listen(this.columnHandleEl, "keydown", (event) => {
        this.showTrackerOnFirstKeyDown(event);
        this.moveTrackerOnKeyDown(event);
      }));
      this.unlisteners.push(this.renderer.listen(this.columnHandleEl, "keyup", (event) => {
        this.hideTrackerOnKeyUp(event);
      }));
    });
  }
  ngOnDestroy() {
    this.unlisteners.forEach((unlistener) => unlistener());
  }
  showTracker() {
    this.columnResizerService.startResize();
    const tableHeight = this.tableSizeService.getColumnDragHeight();
    this.renderer.setStyle(this.resizeTrackerEl, "height", tableHeight);
    this.renderer.setStyle(this.resizeTrackerEl, "display", "block");
  }
  moveTracker(movedBy) {
    this.columnResizerService.calculateResize(movedBy);
    this.renderer.setStyle(this.resizeTrackerEl, "transform", `translateX(${this.columnResizerService.resizedBy}px)`);
    this.renderer.setStyle(this.document.body, "cursor", "col-resize");
    this.redFlagTracker();
  }
  hideTracker() {
    this.columnResizerService.endResize();
    this.renderer.setStyle(this.resizeTrackerEl, "display", "none");
    this.renderer.setStyle(this.resizeTrackerEl, "transform", `translateX(0px)`);
    this.renderer.setStyle(this.columnHandleEl, "transform", `translateX(0px)`);
    this.renderer.setStyle(this.document.body, "cursor", "auto");
  }
  showTrackerOnFirstKeyDown(event) {
    if (!this.resizeStartedOnKeyDown && (this.isArrowLeftKeyEvent(event) || this.isArrowRightKeyEvent(event))) {
      this.resizeStartedOnKeyDown = true;
      this.renderer.addClass(this.resizeTrackerEl, "on-arrow-key-resize");
      this.showTracker();
    }
  }
  moveTrackerOnKeyDown(event) {
    if (this.isArrowLeftKeyEvent(event)) {
      event.stopPropagation();
      this.moveTracker(this.columnResizerService.resizedBy - KEYBOARD_RESIZE_LENGTH);
    } else if (this.isArrowRightKeyEvent(event)) {
      event.stopPropagation();
      this.moveTracker(this.columnResizerService.resizedBy + KEYBOARD_RESIZE_LENGTH);
    }
  }
  hideTrackerOnKeyUp(event) {
    if (this.resizeStartedOnKeyDown && (this.isArrowLeftKeyEvent(event) || this.isArrowRightKeyEvent(event))) {
      this.resizeStartedOnKeyDown = false;
      this.renderer.removeClass(this.resizeTrackerEl, "on-arrow-key-resize");
      this.hideTracker();
      this.columnHandleEl.focus();
    }
  }
  redFlagTracker() {
    if (this.isWithinMaxResizeRange !== this.columnResizerService.isWithinMaxResizeRange) {
      this.isWithinMaxResizeRange = this.columnResizerService.isWithinMaxResizeRange;
      if (!this.isWithinMaxResizeRange) {
        this.renderer.addClass(this.resizeTrackerEl, "exceeded-max");
      } else {
        this.renderer.removeClass(this.resizeTrackerEl, "exceeded-max");
      }
    }
  }
  isArrowLeftKeyEvent(event) {
    return normalizeKey(event.key) === Keys.ArrowLeft;
  }
  isArrowRightKeyEvent(event) {
    return normalizeKey(event.key) === Keys.ArrowRight;
  }
};
ClrDatagridColumnSeparator.ɵfac = function ClrDatagridColumnSeparator_Factory(t3) {
  return new (t3 || ClrDatagridColumnSeparator)(ɵɵdirectiveInject(ColumnResizerService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(TableSizeService), ɵɵdirectiveInject(ClrCommonStringsService), ɵɵdirectiveInject(DOCUMENT));
};
ClrDatagridColumnSeparator.ɵcmp = ɵɵdefineComponent({
  type: ClrDatagridColumnSeparator,
  selectors: [["clr-dg-column-separator"]],
  viewQuery: function ClrDatagridColumnSeparator_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c49, 5);
      ɵɵviewQuery(_c50, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.resizeTrackerRef = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.columnHandleRef = _t.first);
    }
  },
  hostVars: 2,
  hostBindings: function ClrDatagridColumnSeparator_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("datagrid-column-separator", true);
    }
  },
  decls: 6,
  vars: 4,
  consts: [["columnHandle", ""], ["resizeTracker", ""], ["type", "button", "cdkDrag", "", "cdkDragLockAxis", "x", 1, "datagrid-column-handle", 3, "cdkDragStarted", "cdkDragMoved", "cdkDragEnded"], [1, "clr-sr-only"], [1, "datagrid-column-resize-tracker"]],
  template: function ClrDatagridColumnSeparator_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵelementStart(0, "button", 2, 0);
      ɵɵlistener("cdkDragStarted", function ClrDatagridColumnSeparator_Template_button_cdkDragStarted_0_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.showTracker());
      })("cdkDragMoved", function ClrDatagridColumnSeparator_Template_button_cdkDragMoved_0_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.moveTracker($event.distance.x));
      })("cdkDragEnded", function ClrDatagridColumnSeparator_Template_button_cdkDragEnded_0_listener($event) {
        ɵɵrestoreView(_r1);
        ctx.hideTracker();
        return ɵɵresetView($event.source._dragRef.reset());
      });
      ɵɵelementEnd();
      ɵɵelementStart(2, "span", 3);
      ɵɵtext(3);
      ɵɵelementEnd();
      ɵɵelement(4, "div", 4, 1);
    }
    if (rf & 2) {
      ɵɵattribute("aria-label", ctx.commonString.keys.columnSeparatorAriaLabel)("aria-describedby", ctx.descriptionId);
      ɵɵadvance(2);
      ɵɵattribute("id", ctx.descriptionId);
      ɵɵadvance();
      ɵɵtextInterpolate1(" ", ctx.commonString.keys.columnSeparatorDescription, " ");
    }
  },
  dependencies: [CdkDragModule_CdkDrag],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDatagridColumnSeparator, [{
    type: Component,
    args: [{
      selector: "clr-dg-column-separator",
      template: `
    <button
      type="button"
      class="datagrid-column-handle"
      [attr.aria-label]="commonString.keys.columnSeparatorAriaLabel"
      [attr.aria-describedby]="descriptionId"
      cdkDrag
      cdkDragLockAxis="x"
      (cdkDragStarted)="showTracker()"
      (cdkDragMoved)="moveTracker($event.distance.x)"
      (cdkDragEnded)="hideTracker(); $event.source._dragRef.reset()"
      #columnHandle
    ></button>
    <span class="clr-sr-only" [attr.id]="descriptionId">
      {{ commonString.keys.columnSeparatorDescription }}
    </span>
    <div class="datagrid-column-resize-tracker" #resizeTracker></div>
  `,
      host: {
        "[class.datagrid-column-separator]": "true"
      }
    }]
  }], function() {
    return [{
      type: ColumnResizerService
    }, {
      type: Renderer2
    }, {
      type: NgZone
    }, {
      type: TableSizeService
    }, {
      type: ClrCommonStringsService
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [DOCUMENT]
      }]
    }];
  }, {
    resizeTrackerRef: [{
      type: ViewChild,
      args: ["resizeTracker"]
    }],
    columnHandleRef: [{
      type: ViewChild,
      args: ["columnHandle"]
    }]
  });
})();
var ClrDatagridColumn = class extends DatagridFilterRegistrar {
  constructor(_sort, filters, vcr, detailService, changeDetectorRef) {
    super(filters);
    this._sort = _sort;
    this.vcr = vcr;
    this.detailService = detailService;
    this.changeDetectorRef = changeDetectorRef;
    this.sortOrderChange = new EventEmitter();
    this.filterValueChange = new EventEmitter();
    this.showSeparator = true;
    this.customFilter = false;
    this._colType = "string";
    this._sortOrder = ClrDatagridSortOrder.UNSORTED;
    this.subscriptions = [];
    this.subscriptions.push(this.listenForSortingChanges());
    this.subscriptions.push(this.listenForDetailPaneChanges());
  }
  // TODO: We might want to make this an enum in the future
  get colType() {
    return this._colType;
  }
  set colType(value) {
    this._colType = value;
  }
  get field() {
    return this._field;
  }
  set field(field) {
    if (typeof field === "string") {
      this._field = field;
      if (!this._sortBy) {
        this._sortBy = new DatagridPropertyComparator(field);
      }
    }
  }
  get sortBy() {
    return this._sortBy;
  }
  set sortBy(comparator) {
    if (typeof comparator === "string") {
      this._sortBy = new DatagridPropertyComparator(comparator);
    } else {
      if (comparator) {
        this._sortBy = comparator;
      } else {
        if (this.field) {
          this._sortBy = new DatagridPropertyComparator(this.field);
        } else {
          delete this._sortBy;
        }
      }
    }
  }
  get sortOrder() {
    return this._sortOrder;
  }
  set sortOrder(value) {
    if (typeof value === "undefined") {
      return;
    }
    if (this._sortOrder === value) {
      return;
    }
    switch (value) {
      default:
      case ClrDatagridSortOrder.UNSORTED:
        this._sort.clear();
        break;
      case ClrDatagridSortOrder.ASC:
        this.sort(false);
        break;
      case ClrDatagridSortOrder.DESC:
        this.sort(true);
        break;
    }
  }
  set updateFilterValue(newValue) {
    if (this.filter) {
      if (this.filter instanceof DatagridStringFilterImpl) {
        if (!newValue || typeof newValue !== "string") {
          newValue = "";
        }
        if (newValue !== this.filter.value) {
          this.filter.value = newValue;
        }
      } else if (this.filter instanceof DatagridNumericFilterImpl) {
        if (!newValue || !(newValue instanceof Array)) {
          newValue = [null, null];
        }
        if (newValue.length === 2 && (newValue[0] !== this.filter.value[0] || newValue[1] !== this.filter.value[1])) {
          this.filter.value = newValue;
        }
      }
    } else {
      this.initFilterValue = newValue;
    }
  }
  set projectedFilter(custom) {
    if (custom) {
      this.deleteFilter();
      this.customFilter = true;
    }
  }
  /**
   * Indicates if the column is sortable
   */
  get sortable() {
    return !!this._sortBy;
  }
  get ariaSort() {
    switch (this._sortOrder) {
      default:
      case ClrDatagridSortOrder.UNSORTED:
        return "none";
      case ClrDatagridSortOrder.ASC:
        return "ascending";
      case ClrDatagridSortOrder.DESC:
        return "descending";
    }
  }
  get sortDirection() {
    return this._sortDirection;
  }
  /**
   * @NOTE type `any` here is to let us pass templateStrictMode, because in our code we try to handle
   * two types of filters String and Number with the same variable but both of them work with different
   * format we got an error for casting. We could not cast anything inside the template so to not mess the
   * casting, the last type is set to `any`
   *
   * Orignial types: string | [number, number]
   */
  get filterValue() {
    if (this.filter instanceof DatagridStringFilterImpl || this.filter instanceof DatagridNumericFilterImpl) {
      return this.filter.value;
    }
    return null;
  }
  set filterValue(newValue) {
    if (this.filter instanceof DatagridStringFilterImpl || this.filter instanceof DatagridNumericFilterImpl) {
      this.updateFilterValue = newValue;
      this.filterValueChange.emit(this.filter.value);
    }
  }
  get _view() {
    return this.wrappedInjector.get(WrappedColumn, this.vcr).columnView;
  }
  ngOnInit() {
    this.wrappedInjector = new HostWrapper(WrappedColumn, this.vcr);
  }
  ngOnChanges(changes) {
    if (changes.colType && changes.colType.currentValue && changes.colType.currentValue !== changes.colType.previousValue) {
      if (!this.customFilter && !this.filter && this.colType && this.field) {
        this.setupDefaultFilter(this.field, this.colType);
      }
    }
    if (changes.field && changes.field.currentValue && changes.field.currentValue !== changes.field.previousValue) {
      if (!this.customFilter && this.colType) {
        this.setupDefaultFilter(this.field, this.colType);
      }
    }
  }
  ngOnDestroy() {
    super.ngOnDestroy();
    this.subscriptions.forEach((s2) => s2.unsubscribe());
  }
  /**
   * Sorts the datagrid based on this column
   */
  sort(reverse) {
    if (!this.sortable) {
      return;
    }
    this._sort.toggle(this._sortBy, reverse);
    this._sortOrder = this._sort.reverse ? ClrDatagridSortOrder.DESC : ClrDatagridSortOrder.ASC;
    this._sortDirection = this._sortOrder === ClrDatagridSortOrder.DESC ? "down" : "up";
    this.sortOrderChange.emit(this._sortOrder);
  }
  listenForDetailPaneChanges() {
    return this.detailService.stateChange.subscribe((state2) => {
      if (this.showSeparator !== !state2) {
        this.showSeparator = !state2;
        this.changeDetectorRef.markForCheck();
      }
    });
  }
  listenForSortingChanges() {
    return this._sort.change.subscribe((sort) => {
      this.changeDetectorRef.markForCheck();
      if (this.sortOrder !== ClrDatagridSortOrder.UNSORTED && sort.comparator !== this._sortBy) {
        this._sortOrder = ClrDatagridSortOrder.UNSORTED;
        this.sortOrderChange.emit(this._sortOrder);
        this._sortDirection = null;
      }
    });
  }
  setupDefaultFilter(field, colType) {
    if (colType === "number") {
      this.setFilter(new DatagridNumericFilterImpl(new DatagridPropertyNumericFilter(field)));
    } else if (colType === "string") {
      this.setFilter(new DatagridStringFilterImpl(new DatagridPropertyStringFilter(field)));
    }
    if (this.filter && this.initFilterValue) {
      this.updateFilterValue = this.initFilterValue;
      delete this.initFilterValue;
    }
  }
};
ClrDatagridColumn.ɵfac = function ClrDatagridColumn_Factory(t3) {
  return new (t3 || ClrDatagridColumn)(ɵɵdirectiveInject(Sort), ɵɵdirectiveInject(FiltersProvider), ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(DetailService), ɵɵdirectiveInject(ChangeDetectorRef));
};
ClrDatagridColumn.ɵcmp = ɵɵdefineComponent({
  type: ClrDatagridColumn,
  selectors: [["clr-dg-column"]],
  contentQueries: function ClrDatagridColumn_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, CustomFilter, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.projectedFilter = _t.first);
    }
  },
  hostAttrs: ["role", "columnheader"],
  hostVars: 3,
  hostBindings: function ClrDatagridColumn_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("aria-sort", ctx.ariaSort);
      ɵɵclassProp("datagrid-column", true);
    }
  },
  inputs: {
    filterStringPlaceholder: [InputFlags.None, "clrFilterStringPlaceholder", "filterStringPlaceholder"],
    filterNumberMaxPlaceholder: [InputFlags.None, "clrFilterNumberMaxPlaceholder", "filterNumberMaxPlaceholder"],
    filterNumberMinPlaceholder: [InputFlags.None, "clrFilterNumberMinPlaceholder", "filterNumberMinPlaceholder"],
    colType: [InputFlags.None, "clrDgColType", "colType"],
    field: [InputFlags.None, "clrDgField", "field"],
    sortBy: [InputFlags.None, "clrDgSortBy", "sortBy"],
    sortOrder: [InputFlags.None, "clrDgSortOrder", "sortOrder"],
    updateFilterValue: [InputFlags.None, "clrFilterValue", "updateFilterValue"]
  },
  outputs: {
    sortOrderChange: "clrDgSortOrderChange",
    filterValueChange: "clrFilterValueChange"
  },
  features: [ɵɵHostDirectivesFeature([ClrPopoverHostDirective]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature],
  ngContentSelectors: _c52,
  decls: 9,
  vars: 5,
  consts: [["columnTitle", ""], [1, "datagrid-column-flex"], ["class", "datagrid-column-title", "type", "button", 3, "click", 4, "ngIf"], [3, "clrFilterPlaceholder", "clrDgStringFilter", "clrFilterValue", "clrFilterValueChange", 4, "ngIf"], [3, "clrFilterMaxPlaceholder", "clrFilterMinPlaceholder", "clrDgNumericFilter", "clrFilterValue", "clrFilterValueChange", 4, "ngIf"], ["class", "datagrid-column-title", 4, "ngIf"], [4, "ngIf"], ["type", "button", 1, "datagrid-column-title", 3, "click"], [4, "ngTemplateOutlet"], ["shape", "arrow", "aria-hidden", "true", "class", "sort-icon", 4, "ngIf"], ["shape", "arrow", "aria-hidden", "true", 1, "sort-icon"], [3, "clrFilterValueChange", "clrFilterPlaceholder", "clrDgStringFilter", "clrFilterValue"], [3, "clrFilterValueChange", "clrFilterMaxPlaceholder", "clrFilterMinPlaceholder", "clrDgNumericFilter", "clrFilterValue"], [1, "datagrid-column-title"]],
  template: function ClrDatagridColumn_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c51);
      ɵɵelementStart(0, "div", 1);
      ɵɵtemplate(1, ClrDatagridColumn_button_1_Template, 3, 2, "button", 2);
      ɵɵprojection(2);
      ɵɵtemplate(3, ClrDatagridColumn_clr_dg_string_filter_3_Template, 1, 3, "clr-dg-string-filter", 3)(4, ClrDatagridColumn_clr_dg_numeric_filter_4_Template, 1, 4, "clr-dg-numeric-filter", 4)(5, ClrDatagridColumn_ng_template_5_Template, 1, 0, "ng-template", null, 0, ɵɵtemplateRefExtractor)(7, ClrDatagridColumn_span_7_Template, 2, 1, "span", 5)(8, ClrDatagridColumn_clr_dg_column_separator_8_Template, 1, 0, "clr-dg-column-separator", 6);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.sortable);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.field && !ctx.customFilter && ctx.colType == "string");
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.field && !ctx.customFilter && ctx.colType == "number");
      ɵɵadvance(3);
      ɵɵproperty("ngIf", !ctx.sortable);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showSeparator);
    }
  },
  dependencies: [NgIf, NgTemplateOutlet, CdsIconCustomTag, ClrDatagridColumnSeparator, DatagridNumericFilter, DatagridStringFilter],
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDatagridColumn, [{
    type: Component,
    args: [{
      selector: "clr-dg-column",
      template: `
    <div class="datagrid-column-flex">
      <button class="datagrid-column-title" *ngIf="sortable" (click)="sort()" type="button">
        <ng-container *ngTemplateOutlet="columnTitle"></ng-container>
        <cds-icon
          *ngIf="sortDirection"
          shape="arrow"
          [attr.direction]="sortDirection"
          aria-hidden="true"
          class="sort-icon"
        ></cds-icon>
      </button>
      <!-- I'm really not happy with that select since it's not very scalable -->
      <ng-content select="clr-dg-filter, clr-dg-string-filter, clr-dg-numeric-filter"></ng-content>

      <clr-dg-string-filter
        *ngIf="field && !customFilter && colType == 'string'"
        [clrFilterPlaceholder]="filterStringPlaceholder"
        [clrDgStringFilter]="registered"
        [(clrFilterValue)]="filterValue"
      ></clr-dg-string-filter>

      <clr-dg-numeric-filter
        *ngIf="field && !customFilter && colType == 'number'"
        [clrFilterMaxPlaceholder]="filterNumberMaxPlaceholder"
        [clrFilterMinPlaceholder]="filterNumberMinPlaceholder"
        [clrDgNumericFilter]="registered"
        [(clrFilterValue)]="filterValue"
      ></clr-dg-numeric-filter>

      <ng-template #columnTitle>
        <ng-content></ng-content>
      </ng-template>

      <span class="datagrid-column-title" *ngIf="!sortable">
        <ng-container *ngTemplateOutlet="columnTitle"></ng-container>
      </span>

      <clr-dg-column-separator *ngIf="showSeparator"></clr-dg-column-separator>
    </div>
  `,
      hostDirectives: [ClrPopoverHostDirective],
      host: {
        "[class.datagrid-column]": "true",
        "[attr.aria-sort]": "ariaSort",
        role: "columnheader"
      },
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], function() {
    return [{
      type: Sort
    }, {
      type: FiltersProvider
    }, {
      type: ViewContainerRef
    }, {
      type: DetailService
    }, {
      type: ChangeDetectorRef
    }];
  }, {
    filterStringPlaceholder: [{
      type: Input,
      args: ["clrFilterStringPlaceholder"]
    }],
    filterNumberMaxPlaceholder: [{
      type: Input,
      args: ["clrFilterNumberMaxPlaceholder"]
    }],
    filterNumberMinPlaceholder: [{
      type: Input,
      args: ["clrFilterNumberMinPlaceholder"]
    }],
    sortOrderChange: [{
      type: Output,
      args: ["clrDgSortOrderChange"]
    }],
    filterValueChange: [{
      type: Output,
      args: ["clrFilterValueChange"]
    }],
    colType: [{
      type: Input,
      args: ["clrDgColType"]
    }],
    field: [{
      type: Input,
      args: ["clrDgField"]
    }],
    sortBy: [{
      type: Input,
      args: ["clrDgSortBy"]
    }],
    sortOrder: [{
      type: Input,
      args: ["clrDgSortOrder"]
    }],
    updateFilterValue: [{
      type: Input,
      args: ["clrFilterValue"]
    }],
    projectedFilter: [{
      type: ContentChild,
      args: [CustomFilter]
    }]
  });
})();
var Items = class {
  constructor(_filters, _sort, _page) {
    this._filters = _filters;
    this._sort = _sort;
    this._page = _page;
    this.loading = false;
    this._smart = false;
    this._displayed = [];
    this._change = new Subject();
    this._allChanges = new Subject();
    this.trackBy = (item) => item;
  }
  get smart() {
    return this._smart;
  }
  get all() {
    return this._all;
  }
  set all(items) {
    this._all = items;
    this.emitAllChanges(items);
    if (this.smart) {
      this._filterItems();
    } else {
      this._displayed = items;
      this.emitChange();
    }
  }
  get displayed() {
    return this._displayed;
  }
  // We do not want to expose the Subject itself, but the Observable which is read-only
  get change() {
    return this._change.asObservable();
  }
  get allChanges() {
    return this._allChanges.asObservable();
  }
  /**
   * Checks if we don't have data to process yet, to abort early operations
   */
  get uninitialized() {
    return !this._all;
  }
  /**
   * Cleans up our subscriptions to other providers
   */
  destroy() {
    if (this._filtersSub) {
      this._filtersSub.unsubscribe();
    }
    if (this._sortSub) {
      this._sortSub.unsubscribe();
    }
    if (this._pageSub) {
      this._pageSub.unsubscribe();
    }
  }
  smartenUp() {
    this._smart = true;
    this._filtersSub = this._filters.change.subscribe(() => this._filterItems());
    this._sortSub = this._sort.change.subscribe(() => {
      if (!this._sort.comparator) {
        this._filterItems();
      } else {
        this._sortItems();
      }
    });
    this._pageSub = this._page.change.subscribe(() => this._changePage());
  }
  /**
   * Manually recompute the list of displayed items
   */
  refresh() {
    if (this.smart) {
      this._filterItems();
    }
  }
  emitChange() {
    this._change.next(this.displayed);
  }
  emitAllChanges(items) {
    this._allChanges.next(items);
  }
  /**
   * FiltersProvider items from the raw list
   */
  _filterItems() {
    if (this.uninitialized) {
      return;
    }
    if (this._filters.hasActiveFilters()) {
      this._filtered = this._all.filter((item) => this._filters.accepts(item));
    } else {
      this._filtered = this._all.slice();
    }
    this._page.totalItems = this._filtered.length;
    this._sortItems();
  }
  /**
   * Sorts items in the filtered list
   */
  _sortItems() {
    if (this.uninitialized) {
      return;
    }
    if (this._sort.comparator) {
      this._filtered.sort((a4, b) => this._sort.compare(a4, b));
    }
    this._changePage();
  }
  /**
   * Extracts the current page from the sorted list
   */
  _changePage() {
    if (this.uninitialized || this._page.activated && this._page.size === 0) {
      return;
    }
    if (this._page.size > 0) {
      this._displayed = this._filtered.slice(this._page.firstItem, this._page.lastItem + 1);
    } else {
      this._displayed = this._filtered;
    }
    this.emitChange();
  }
};
Items.ɵfac = function Items_Factory(t3) {
  return new (t3 || Items)(ɵɵinject(FiltersProvider), ɵɵinject(Sort), ɵɵinject(Page));
};
Items.ɵprov = ɵɵdefineInjectable({
  token: Items,
  factory: Items.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Items, [{
    type: Injectable
  }], function() {
    return [{
      type: FiltersProvider
    }, {
      type: Sort
    }, {
      type: Page
    }];
  }, null);
})();
var ClrDatagridItems = class {
  constructor(template, differs, items, vcr) {
    this.template = template;
    this.differs = differs;
    this.items = items;
    this.vcr = vcr;
    this.differ = null;
    this.subscriptions = [];
    items.smartenUp();
    this.iterableProxy = new NgForOf(this.vcr, this.template, this.differs);
    this.subscriptions.push(items.change.subscribe((newItems) => {
      this.iterableProxy.ngForOf = newItems;
      this.iterableProxy.ngDoCheck();
    }));
  }
  set rawItems(items) {
    this._rawItems = items ? items : [];
  }
  set trackBy(value) {
    this.iterableProxy.ngForTrackBy = value;
  }
  /**
   * Asserts the correct type of the template context that the directive will render.
   * See https://angular.io/guide/structural-directives#typing-the-directives-context
   *
   * The presence of this method is a signal to the Ivy template type-check compiler that the
   * structural directive renders its template with a specific context type.
   */
  static ngTemplateContextGuard(_dir, _ctx) {
    return true;
  }
  ngDoCheck() {
    if (!this.differ) {
      this.differ = this.differs.find(this._rawItems).create(this.iterableProxy.ngForTrackBy);
    }
    if (this.differ) {
      const changes = this.differ.diff(this._rawItems);
      if (changes) {
        this.items.all = this._rawItems;
      }
    }
  }
  ngOnDestroy() {
    this.subscriptions.forEach((sub) => sub.unsubscribe());
  }
};
ClrDatagridItems.ɵfac = function ClrDatagridItems_Factory(t3) {
  return new (t3 || ClrDatagridItems)(ɵɵdirectiveInject(TemplateRef), ɵɵdirectiveInject(IterableDiffers), ɵɵdirectiveInject(Items), ɵɵdirectiveInject(ViewContainerRef));
};
ClrDatagridItems.ɵdir = ɵɵdefineDirective({
  type: ClrDatagridItems,
  selectors: [["", "clrDgItems", "", "clrDgItemsOf", ""]],
  inputs: {
    rawItems: [InputFlags.None, "clrDgItemsOf", "rawItems"],
    trackBy: [InputFlags.None, "clrDgItemsTrackBy", "trackBy"]
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDatagridItems, [{
    type: Directive,
    args: [{
      selector: "[clrDgItems][clrDgItemsOf]"
    }]
  }], function() {
    return [{
      type: TemplateRef
    }, {
      type: IterableDiffers
    }, {
      type: Items
    }, {
      type: ViewContainerRef
    }];
  }, {
    rawItems: [{
      type: Input,
      args: ["clrDgItemsOf"]
    }],
    trackBy: [{
      type: Input,
      args: ["clrDgItemsTrackBy"]
    }]
  });
})();
var ClrDatagridPlaceholder = class {
  constructor(items) {
    this.items = items;
  }
  /**
   * Tests if the datagrid is empty, meaning it doesn't contain any items
   */
  get emptyDatagrid() {
    return !this.items.loading && (!this.items.displayed || this.items.displayed.length === 0);
  }
};
ClrDatagridPlaceholder.ɵfac = function ClrDatagridPlaceholder_Factory(t3) {
  return new (t3 || ClrDatagridPlaceholder)(ɵɵdirectiveInject(Items));
};
ClrDatagridPlaceholder.ɵcmp = ɵɵdefineComponent({
  type: ClrDatagridPlaceholder,
  selectors: [["clr-dg-placeholder"]],
  hostVars: 2,
  hostBindings: function ClrDatagridPlaceholder_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("datagrid-placeholder-container", true);
    }
  },
  ngContentSelectors: _c02,
  decls: 4,
  vars: 4,
  consts: [["role", "row", 1, "datagrid-placeholder"], ["class", "datagrid-placeholder-image", 4, "ngIf"], ["role", "gridcell", 1, "datagrid-placeholder-content"], [4, "ngIf"], [1, "datagrid-placeholder-image"]],
  template: function ClrDatagridPlaceholder_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "div", 0);
      ɵɵtemplate(1, ClrDatagridPlaceholder_div_1_Template, 1, 0, "div", 1);
      ɵɵelementStart(2, "span", 2);
      ɵɵtemplate(3, ClrDatagridPlaceholder_ng_content_3_Template, 1, 0, "ng-content", 3);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵclassProp("datagrid-empty", ctx.emptyDatagrid);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.emptyDatagrid);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.emptyDatagrid);
    }
  },
  dependencies: [NgIf],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDatagridPlaceholder, [{
    type: Component,
    args: [{
      selector: "clr-dg-placeholder",
      template: `
    <div class="datagrid-placeholder" [class.datagrid-empty]="emptyDatagrid" role="row">
      <div class="datagrid-placeholder-image" *ngIf="emptyDatagrid"></div>
      <span role="gridcell" class="datagrid-placeholder-content"><ng-content *ngIf="emptyDatagrid"></ng-content></span>
    </div>
  `,
      host: {
        "[class.datagrid-placeholder-container]": "true"
      }
    }]
  }], function() {
    return [{
      type: Items
    }];
  }, null);
})();
var SignpostFocusManager = class {
  set triggerEl(value) {
    this._triggerEl = value;
  }
  focusTrigger() {
    if (this._triggerEl) {
      this._triggerEl.focus();
    }
  }
};
SignpostFocusManager.ɵfac = function SignpostFocusManager_Factory(t3) {
  return new (t3 || SignpostFocusManager)();
};
SignpostFocusManager.ɵprov = ɵɵdefineInjectable({
  token: SignpostFocusManager,
  factory: SignpostFocusManager.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SignpostFocusManager, [{
    type: Injectable
  }], null, null);
})();
var SignpostIdService = class {
  constructor() {
    this._id = new Subject();
  }
  get id() {
    return this._id.asObservable();
  }
  setId(id) {
    this._id.next(id);
  }
};
SignpostIdService.ɵfac = function SignpostIdService_Factory(t3) {
  return new (t3 || SignpostIdService)();
};
SignpostIdService.ɵprov = ɵɵdefineInjectable({
  token: SignpostIdService,
  factory: SignpostIdService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SignpostIdService, [{
    type: Injectable
  }], null, null);
})();
var ClrSignpostTrigger = class {
  constructor(toggleService, el, signpostIdService, signpostFocusManager, document2, platformId) {
    this.toggleService = toggleService;
    this.el = el;
    this.signpostIdService = signpostIdService;
    this.signpostFocusManager = signpostFocusManager;
    this.platformId = platformId;
    this.ariaExpanded = false;
    this.subscriptions = [];
    this.document = document2;
  }
  ngOnInit() {
    this.signpostFocusManager.triggerEl = this.el.nativeElement;
    this.subscriptions.push(this.toggleService.openChange.subscribe((isOpen) => {
      this.ariaExpanded = isOpen;
      const prevIsOpen = this.isOpen;
      this.isOpen = isOpen;
      if (!this.isOpen && prevIsOpen) {
        this.focusOnClose();
      }
    }), this.signpostIdService.id.subscribe((idChange) => this.ariaControl = idChange));
  }
  ngOnDestroy() {
    this.subscriptions.forEach((sub) => sub.unsubscribe());
  }
  /**********
   *
   * @description
   * click handler for the ClrSignpost trigger button used to hide/show ClrSignpostContent.
   */
  onSignpostTriggerClick(event) {
    this.toggleService.toggleWithEvent(event);
  }
  focusOnClose() {
    if (!isPlatformBrowser(this.platformId)) {
      return;
    }
    if (!this.isOpen && this.document.activeElement === this.document.body) {
      this.signpostFocusManager.focusTrigger();
    }
  }
};
ClrSignpostTrigger.ɵfac = function ClrSignpostTrigger_Factory(t3) {
  return new (t3 || ClrSignpostTrigger)(ɵɵdirectiveInject(ClrPopoverToggleService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(SignpostIdService), ɵɵdirectiveInject(SignpostFocusManager), ɵɵdirectiveInject(DOCUMENT), ɵɵdirectiveInject(PLATFORM_ID));
};
ClrSignpostTrigger.ɵdir = ɵɵdefineDirective({
  type: ClrSignpostTrigger,
  selectors: [["", "clrSignpostTrigger", ""]],
  hostAttrs: [1, "signpost-trigger"],
  hostVars: 4,
  hostBindings: function ClrSignpostTrigger_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function ClrSignpostTrigger_click_HostBindingHandler($event) {
        return ctx.onSignpostTriggerClick($event);
      });
    }
    if (rf & 2) {
      ɵɵattribute("aria-expanded", ctx.ariaExpanded)("aria-controls", ctx.ariaControl);
      ɵɵclassProp("active", ctx.isOpen);
    }
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrSignpostTrigger, [{
    type: Directive,
    args: [{
      selector: "[clrSignpostTrigger]",
      host: {
        class: "signpost-trigger",
        "[attr.aria-expanded]": "ariaExpanded",
        "[attr.aria-controls]": "ariaControl",
        "[class.active]": "isOpen"
      }
    }]
  }], function() {
    return [{
      type: ClrPopoverToggleService
    }, {
      type: ElementRef
    }, {
      type: SignpostIdService
    }, {
      type: SignpostFocusManager
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [DOCUMENT]
      }]
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [PLATFORM_ID]
      }]
    }];
  }, {
    onSignpostTriggerClick: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }]
  });
})();
var ClrSignpost = class {
  constructor(commonStrings) {
    this.commonStrings = commonStrings;
    this.useCustomTrigger = false;
  }
  /**********
   * @property signPostTrigger
   *
   * @description
   * Uses ContentChild to check for a user supplied element with the ClrSignpostTrigger on it.
   *
   */
  set customTrigger(trigger2) {
    this.useCustomTrigger = !!trigger2;
  }
};
ClrSignpost.ɵfac = function ClrSignpost_Factory(t3) {
  return new (t3 || ClrSignpost)(ɵɵdirectiveInject(ClrCommonStringsService));
};
ClrSignpost.ɵcmp = ɵɵdefineComponent({
  type: ClrSignpost,
  selectors: [["clr-signpost"]],
  contentQueries: function ClrSignpost_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ClrSignpostTrigger, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.customTrigger = _t.first);
    }
  },
  hostVars: 2,
  hostBindings: function ClrSignpost_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("signpost", true);
    }
  },
  features: [ɵɵProvidersFeature([SignpostFocusManager, SignpostIdService]), ɵɵHostDirectivesFeature([ClrPopoverHostDirective])],
  ngContentSelectors: _c02,
  decls: 2,
  vars: 1,
  consts: [[4, "ngIf"], ["type", "button", "clrSignpostTrigger", "", 1, "signpost-action", "btn", "btn-sm", "btn-icon", "btn-link"], ["shape", "info-circle"]],
  template: function ClrSignpost_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵtemplate(0, ClrSignpost_ng_container_0_Template, 3, 2, "ng-container", 0);
      ɵɵprojection(1);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", !ctx.useCustomTrigger);
    }
  },
  dependencies: [NgIf, CdsIconCustomTag, ClrSignpostTrigger],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrSignpost, [{
    type: Component,
    args: [{
      selector: "clr-signpost",
      template: `
    <ng-container *ngIf="!useCustomTrigger">
      <button
        type="button"
        class="signpost-action btn btn-sm btn-icon btn-link"
        clrSignpostTrigger
        [attr.aria-label]="commonStrings.keys.signpostToggle"
      >
        <cds-icon shape="info-circle" [attr.title]="commonStrings.keys.info"></cds-icon>
      </button>
    </ng-container>

    <ng-content></ng-content>
  `,
      host: {
        "[class.signpost]": "true"
      },
      providers: [SignpostFocusManager, SignpostIdService],
      hostDirectives: [ClrPopoverHostDirective]
    }]
  }], function() {
    return [{
      type: ClrCommonStringsService
    }];
  }, {
    customTrigger: [{
      type: ContentChild,
      args: [ClrSignpostTrigger]
    }]
  });
})();
var WrappedCell = class {
  constructor() {
    this._dynamic = false;
  }
  ngAfterViewInit() {
    this.cellView = this.templateRef.createEmbeddedView(null);
  }
  ngOnDestroy() {
    this.cellView.destroy();
  }
};
WrappedCell.ɵfac = function WrappedCell_Factory(t3) {
  return new (t3 || WrappedCell)();
};
WrappedCell.ɵcmp = ɵɵdefineComponent({
  type: WrappedCell,
  selectors: [["dg-wrapped-cell"]],
  viewQuery: function WrappedCell_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c53, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.templateRef = _t.first);
    }
  },
  ngContentSelectors: _c02,
  decls: 2,
  vars: 0,
  consts: [["cellPortal", ""]],
  template: function WrappedCell_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵtemplate(0, WrappedCell_ng_template_0_Template, 1, 0, "ng-template", null, 0, ɵɵtemplateRefExtractor);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(WrappedCell, [{
    type: Component,
    args: [{
      selector: "dg-wrapped-cell",
      template: `
    <ng-template #cellPortal>
      <ng-content></ng-content>
    </ng-template>
  `
    }]
  }], null, {
    templateRef: [{
      type: ViewChild,
      args: ["cellPortal"]
    }]
  });
})();
var ClrDatagridCell = class {
  constructor(vcr) {
    this.vcr = vcr;
  }
  get _view() {
    return this.wrappedInjector.get(WrappedCell, this.vcr).cellView;
  }
  ngOnInit() {
    this.wrappedInjector = new HostWrapper(WrappedCell, this.vcr);
  }
};
ClrDatagridCell.ɵfac = function ClrDatagridCell_Factory(t3) {
  return new (t3 || ClrDatagridCell)(ɵɵdirectiveInject(ViewContainerRef));
};
ClrDatagridCell.ɵcmp = ɵɵdefineComponent({
  type: ClrDatagridCell,
  selectors: [["clr-dg-cell"]],
  contentQueries: function ClrDatagridCell_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ClrSignpost, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.signpost = _t);
    }
  },
  hostAttrs: ["role", "gridcell"],
  hostVars: 4,
  hostBindings: function ClrDatagridCell_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("datagrid-cell", true)("datagrid-signpost-trigger", ctx.signpost.length > 0);
    }
  },
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function ClrDatagridCell_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDatagridCell, [{
    type: Component,
    args: [{
      selector: "clr-dg-cell",
      template: `<ng-content></ng-content>`,
      host: {
        "[class.datagrid-cell]": "true",
        "[class.datagrid-signpost-trigger]": "signpost.length > 0",
        role: "gridcell"
      }
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }];
  }, {
    signpost: [{
      type: ContentChildren,
      args: [ClrSignpost]
    }]
  });
})();
var nbRow$1 = 0;
var DatagridIfExpandService = class extends IfExpandService {
  constructor() {
    super();
    this.expandableId = "";
    this._replace = new BehaviorSubject(false);
    this._animate = new Subject();
    nbRow$1++;
    this.expandableId = "clr-dg-expandable-row-" + nbRow$1;
  }
  // due to the es5 spec if the set is overridden on base class the getter must also be overridden
  get expanded() {
    return this._expanded;
  }
  set expanded(value) {
    value = !!value;
    if (value !== this._expanded) {
      this._expanded = value;
      this._animate.next();
      this._expandChange.next(value);
    }
  }
  get replace() {
    return this._replace.asObservable();
  }
  get animate() {
    return this._animate.asObservable();
  }
  loadingStateChange(state2) {
    super.loadingStateChange(state2);
    if (state2 !== ClrLoadingState.LOADING) {
      this._animate.next();
    }
  }
  setReplace(replaceValue) {
    this._replace.next(replaceValue);
  }
};
DatagridIfExpandService.ɵfac = function DatagridIfExpandService_Factory(t3) {
  return new (t3 || DatagridIfExpandService)();
};
DatagridIfExpandService.ɵprov = ɵɵdefineInjectable({
  token: DatagridIfExpandService,
  factory: DatagridIfExpandService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DatagridIfExpandService, [{
    type: Injectable
  }], function() {
    return [];
  }, null);
})();
var DatagridDisplayMode;
(function(DatagridDisplayMode2) {
  DatagridDisplayMode2[DatagridDisplayMode2["DISPLAY"] = 0] = "DISPLAY";
  DatagridDisplayMode2[DatagridDisplayMode2["CALCULATE"] = 1] = "CALCULATE";
})(DatagridDisplayMode || (DatagridDisplayMode = {}));
var SelectionType;
(function(SelectionType2) {
  SelectionType2[SelectionType2["None"] = 0] = "None";
  SelectionType2[SelectionType2["Single"] = 1] = "Single";
  SelectionType2[SelectionType2["Multi"] = 2] = "Multi";
})(SelectionType || (SelectionType = {}));
var WrappedRow = class {
  constructor() {
    this._dynamic = false;
  }
  ngAfterViewInit() {
    this.rowView = this.templateRef.createEmbeddedView(null);
  }
  ngOnDestroy() {
    this.rowView.destroy();
  }
};
WrappedRow.ɵfac = function WrappedRow_Factory(t3) {
  return new (t3 || WrappedRow)();
};
WrappedRow.ɵcmp = ɵɵdefineComponent({
  type: WrappedRow,
  selectors: [["dg-wrapped-row"]],
  viewQuery: function WrappedRow_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c54, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.templateRef = _t.first);
    }
  },
  ngContentSelectors: _c02,
  decls: 2,
  vars: 0,
  consts: [["rowPortal", ""]],
  template: function WrappedRow_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵtemplate(0, WrappedRow_ng_template_0_Template, 1, 0, "ng-template", null, 0, ɵɵtemplateRefExtractor);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(WrappedRow, [{
    type: Component,
    args: [{
      selector: "dg-wrapped-row",
      template: `
    <ng-template #rowPortal>
      <ng-content></ng-content>
    </ng-template>
  `
    }]
  }], null, {
    templateRef: [{
      type: ViewChild,
      args: ["rowPortal"]
    }]
  });
})();
var nbSelection = 0;
var Selection = class {
  constructor(_items, _filters) {
    this._items = _items;
    this._filters = _filters;
    this.preserveSelection = false;
    this.shiftPressed = false;
    this.rowSelectionMode = false;
    this.prevSelectionRefs = [];
    this.lockedRefs = [];
    this.valueCollector = new Subject();
    this._selectionType = SelectionType.None;
    this._change = new Subject();
    this.subscriptions = [];
    this.id = "clr-dg-selection" + nbSelection++;
    this.subscriptions.push(this._filters.change.subscribe(() => {
      if (!this._selectable || this.preserveSelection) {
        return;
      }
      this.clearSelection();
    }));
    this.subscriptions.push(this._items.allChanges.subscribe((updatedItems) => {
      const updateLockedRef = [];
      switch (this.selectionType) {
        case SelectionType.None: {
          break;
        }
        case SelectionType.Single: {
          let newSingle;
          let selectionUpdated = false;
          if (this.currentSingle && !this.prevSingleSelectionRef) {
            this.prevSingleSelectionRef = this._items.trackBy(this.currentSingle);
          }
          updatedItems.forEach((item) => {
            const ref = this._items.trackBy(item);
            if (this.prevSingleSelectionRef === ref) {
              newSingle = item;
              selectionUpdated = true;
            }
            if (this.lockedRefs.indexOf(ref) > -1) {
              updateLockedRef.push(ref);
            }
          });
          if (this._items.smart && !newSingle) {
            selectionUpdated = true;
          }
          setTimeout(() => {
            if (selectionUpdated) {
              this.currentSingle = newSingle;
            }
          }, 0);
          break;
        }
        case SelectionType.Multi: {
          let leftOver = this.current.slice();
          let selectionUpdated = false;
          if (this.current.length > 0 && this.prevSelectionRefs.length !== this.current.length) {
            this.prevSelectionRefs = [];
            this.current.forEach((item) => {
              this.prevSelectionRefs.push(this._items.trackBy(item));
            });
          }
          updatedItems.forEach((item) => {
            const ref = this._items.trackBy(item);
            if (this.lockedRefs.indexOf(ref) > -1) {
              updateLockedRef.push(ref);
            }
          });
          if (leftOver.length > 0) {
            updatedItems.forEach((item) => {
              const ref = this._items.trackBy(item);
              const selectedIndex = this.prevSelectionRefs.indexOf(ref);
              if (selectedIndex > -1) {
                leftOver[selectedIndex] = item;
                selectionUpdated = true;
              }
            });
            if (this._items.smart) {
              leftOver = leftOver.filter((selected) => updatedItems.indexOf(selected) > -1);
              if (this.current.length !== leftOver.length) {
                selectionUpdated = true;
              }
            }
            setTimeout(() => {
              if (selectionUpdated) {
                this.current = leftOver;
              }
            }, 0);
          }
          break;
        }
        default: {
          break;
        }
      }
      this.lockedRefs = updateLockedRef;
    }));
    this.subscriptions.push(this.valueCollector.pipe(debounceTime(0)).subscribe(() => this.emitChange()));
  }
  get selectionType() {
    return this._selectionType;
  }
  set selectionType(value) {
    if (value === this.selectionType) {
      return;
    }
    this._selectionType = value;
    if (value === SelectionType.None) {
      delete this.current;
    } else {
      this.updateCurrent([], false);
    }
  }
  get current() {
    return this._current;
  }
  set current(value) {
    this.updateCurrent(value, true);
  }
  get currentSingle() {
    return this._currentSingle;
  }
  set currentSingle(value) {
    if (value === this._currentSingle) {
      return;
    }
    this._currentSingle = value;
    if (value) {
      this.prevSingleSelectionRef = this._items.trackBy(value);
    }
    this.emitChange();
  }
  // We do not want to expose the Subject itself, but the Observable which is read-only
  get change() {
    return this._change.asObservable();
  }
  get _selectable() {
    return this._selectionType === SelectionType.Multi || this._selectionType === SelectionType.Single;
  }
  clearSelection() {
    this._current = [];
    this.prevSelectionRefs = [];
    this.prevSingleSelectionRef = null;
    this._currentSingle = null;
    this.emitChange();
  }
  /**
   * Cleans up our subscriptions to other providers
   */
  destroy() {
    this.subscriptions.forEach((sub) => sub.unsubscribe());
  }
  updateCurrent(value, emit) {
    this._current = value;
    if (emit) {
      this.valueCollector.next(value);
    }
  }
  /**
   * Checks if an item is currently selected
   */
  isSelected(item) {
    if (this._selectionType === SelectionType.Single) {
      return this.currentSingle === item;
    } else if (this._selectionType === SelectionType.Multi) {
      return this.current.indexOf(item) >= 0;
    }
    return false;
  }
  /**
   * Selects or deselects an item
   */
  setSelected(item, selected) {
    const index = this.current ? this.current.indexOf(item) : -1;
    switch (this._selectionType) {
      case SelectionType.None:
        break;
      case SelectionType.Single:
        break;
      case SelectionType.Multi:
        if (index >= 0 && !selected) {
          this.deselectItem(index);
        } else if (index < 0 && selected) {
          this.selectItem(item);
        }
        break;
      default:
        break;
    }
  }
  /**
   * Checks if all currently displayed items are selected
   */
  isAllSelected() {
    if (this._selectionType !== SelectionType.Multi || !this._items.displayed) {
      return false;
    }
    const displayedItems = this._items.displayed.filter((item) => {
      return this.isLocked(item) === false;
    });
    const nbDisplayed = displayedItems.length;
    if (nbDisplayed < 1) {
      return false;
    }
    const temp = displayedItems.filter((item) => this.current.indexOf(item) > -1);
    return temp.length === displayedItems.length;
  }
  /**
   * Lock and unlock item
   */
  lockItem(item, lock) {
    if (this.canItBeLocked()) {
      const ref = this._items.trackBy(item);
      if (lock === true) {
        this.lockedRefs.push(ref);
      } else {
        this.lockedRefs = this.lockedRefs.filter((lockedItem) => ref !== lockedItem);
      }
    }
  }
  /**
   * Check is item locked or not by searching into lockedRefs for entry
   */
  isLocked(item) {
    if (this.canItBeLocked()) {
      const ref = this._items.trackBy(item);
      return this.lockedRefs.indexOf(ref) > -1;
    }
    return false;
  }
  /**
   * Selects or deselects all currently displayed items
   */
  toggleAll() {
    if (this._selectionType === SelectionType.None || this._selectionType === SelectionType.Single) {
      return;
    }
    if (this.isAllSelected()) {
      this._items.displayed.forEach((item) => {
        const currentIndex = this.current.indexOf(item);
        if (currentIndex > -1 && this.isLocked(item) === false) {
          this.deselectItem(currentIndex);
        }
      });
    } else {
      this._items.displayed.forEach((item) => {
        if (this.current.indexOf(item) < 0 && this.isLocked(item) === false) {
          this.selectItem(item);
        }
      });
    }
  }
  /**
   * Selects an item
   */
  selectItem(item) {
    this.current = this.current.concat(item);
    this.prevSelectionRefs.push(this._items.trackBy(item));
  }
  /**
   * Deselects an item
   */
  deselectItem(indexOfItem) {
    this.current = this.current.slice(0, indexOfItem).concat(this.current.slice(indexOfItem + 1));
    if (indexOfItem < this.prevSelectionRefs.length) {
      const removedItems = this.prevSelectionRefs.splice(indexOfItem, 1);
      this.lockedRefs = this.lockedRefs.filter((locked) => locked !== removedItems[0]);
    }
  }
  /**
   * Make sure that it could be locked
   */
  canItBeLocked() {
    return this._selectionType !== SelectionType.None;
  }
  emitChange() {
    if (this._selectionType === SelectionType.Single) {
      this._change.next(this.currentSingle);
    } else if (this._selectionType === SelectionType.Multi) {
      this._change.next(this.current);
    }
  }
};
Selection.ɵfac = function Selection_Factory(t3) {
  return new (t3 || Selection)(ɵɵinject(Items), ɵɵinject(FiltersProvider));
};
Selection.ɵprov = ɵɵdefineInjectable({
  token: Selection,
  factory: Selection.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Selection, [{
    type: Injectable
  }], function() {
    return [{
      type: Items
    }, {
      type: FiltersProvider
    }];
  }, null);
})();
var DisplayModeService = class {
  constructor(renderOrganizer) {
    this._view = new BehaviorSubject(DatagridDisplayMode.DISPLAY);
    this.subscriptions = [];
    this.subscriptions.push(renderOrganizer.filterRenderSteps(DatagridRenderStep.CALCULATE_MODE_ON).subscribe(() => this._view.next(DatagridDisplayMode.CALCULATE)));
    this.subscriptions.push(renderOrganizer.filterRenderSteps(DatagridRenderStep.CALCULATE_MODE_OFF).subscribe(() => this._view.next(DatagridDisplayMode.DISPLAY)));
  }
  get view() {
    return this._view.asObservable();
  }
  ngOnDestroy() {
    this.subscriptions.forEach((sub) => sub.unsubscribe());
  }
};
DisplayModeService.ɵfac = function DisplayModeService_Factory(t3) {
  return new (t3 || DisplayModeService)(ɵɵinject(DatagridRenderOrganizer));
};
DisplayModeService.ɵprov = ɵɵdefineInjectable({
  token: DisplayModeService,
  factory: DisplayModeService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DisplayModeService, [{
    type: Injectable
  }], function() {
    return [{
      type: DatagridRenderOrganizer
    }];
  }, null);
})();
var ClrDatagridSelectionCellDirective = class {
  constructor(selection) {
    this.selection = selection;
  }
  onSelectionCellClick(event) {
    if (this.selection.rowSelectionMode) {
      return;
    }
    if (event.target.tagName !== "LABEL" && event.target.tagName !== "INPUT") {
      event.target.querySelector("input")?.click();
    }
  }
};
ClrDatagridSelectionCellDirective.ɵfac = function ClrDatagridSelectionCellDirective_Factory(t3) {
  return new (t3 || ClrDatagridSelectionCellDirective)(ɵɵdirectiveInject(Selection));
};
ClrDatagridSelectionCellDirective.ɵdir = ɵɵdefineDirective({
  type: ClrDatagridSelectionCellDirective,
  selectors: [["", 8, "datagrid-select"]],
  hostBindings: function ClrDatagridSelectionCellDirective_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function ClrDatagridSelectionCellDirective_click_HostBindingHandler($event) {
        return ctx.onSelectionCellClick($event);
      });
    }
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDatagridSelectionCellDirective, [{
    type: Directive,
    args: [{
      selector: ".datagrid-select"
    }]
  }], function() {
    return [{
      type: Selection
    }];
  }, {
    onSelectionCellClick: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }]
  });
})();
var nbRow = 0;
var ClrDatagridRow = class {
  constructor(selection, rowActionService, globalExpandable, expand, detailService, displayMode, vcr, renderer, el, commonStrings, items, document2) {
    this.selection = selection;
    this.rowActionService = rowActionService;
    this.globalExpandable = globalExpandable;
    this.expand = expand;
    this.detailService = detailService;
    this.displayMode = displayMode;
    this.vcr = vcr;
    this.renderer = renderer;
    this.el = el;
    this.commonStrings = commonStrings;
    this.items = items;
    this.document = document2;
    this.selectedChanged = new EventEmitter(false);
    this.expandedChange = new EventEmitter(false);
    this.displayCells = false;
    this.expandAnimationTrigger = false;
    this.SELECTION_TYPE = SelectionType;
    this.itemChanges = new ReplaySubject(1);
    this._selected = false;
    this._detailOpenLabel = "";
    this._detailCloseLabel = "";
    this._rowSelectionLabel = "";
    this.subscriptions = [];
    this._selectable = true;
    nbRow++;
    this.id = "clr-dg-row" + nbRow;
    this.radioId = "clr-dg-row-rd" + nbRow;
    this.checkboxId = "clr-dg-row-cb" + nbRow;
    this.expandableId = expand.expandableId;
    this.subscriptions.push(combineLatest(this.expand.replace, this.expand.expandChange).subscribe(([expandReplaceValue, expandChangeValue]) => {
      if (expandReplaceValue && expandChangeValue) {
        this.replaced = true;
        this.renderer.addClass(this.el.nativeElement, "datagrid-row-replaced");
      } else {
        this.replaced = false;
        this.renderer.removeClass(this.el.nativeElement, "datagrid-row-replaced");
      }
    }));
  }
  /**
   * Model of the row, to use for selection
   */
  get item() {
    return this._item;
  }
  set item(item) {
    this._item = item;
    this.itemChanges.next(item);
    this.clrDgSelectable = this._selectable;
  }
  get clrDgSelectable() {
    return !this.selection.isLocked(this.item);
  }
  set clrDgSelectable(value) {
    if (this.item) {
      this.selection.lockItem(this.item, value === "false" || value === false);
    }
    this._selectable = value;
  }
  /**
   * Indicates if the row is selected
   */
  get selected() {
    if (this.selection.selectionType === SelectionType.None) {
      return this._selected;
    } else {
      return this.selection.isSelected(this.item);
    }
  }
  set selected(value) {
    if (this.selection.selectionType === SelectionType.None) {
      this._selected = value;
    } else {
      if (value && this.selection.selectionType === SelectionType.Multi) {
        this.rangeSelect();
      } else {
        this.selection.rangeStart = null;
      }
      this.selection.setSelected(this.item, value);
    }
  }
  get expanded() {
    return this.expand.expanded;
  }
  set expanded(value) {
    this.expand.expanded = value;
  }
  get clrDgDetailOpenLabel() {
    return this._detailOpenLabel ? this._detailOpenLabel : this.commonStrings.keys.open;
  }
  set clrDgDetailOpenLabel(label) {
    this._detailOpenLabel = label;
  }
  get clrDgDetailCloseLabel() {
    return this._detailCloseLabel ? this._detailCloseLabel : this.commonStrings.keys.close;
  }
  set clrDgDetailCloseLabel(label) {
    this._detailCloseLabel = label;
  }
  // CDE-151: Rename this field to clrDgRowSelectionLabel in v16
  get clrDgRowSelectionLabel() {
    return this._rowSelectionLabel ? this._rowSelectionLabel : this.commonStrings.keys.select;
  }
  set clrDgRowSelectionLabel(label) {
    this._rowSelectionLabel = label;
  }
  get _view() {
    return this.wrappedInjector.get(WrappedRow, this.vcr).rowView;
  }
  ngOnInit() {
    this.wrappedInjector = new HostWrapper(WrappedRow, this.vcr);
    this.selection.lockItem(this.item, this.clrDgSelectable === false);
  }
  ngAfterContentInit() {
    this.dgCells.changes.subscribe(() => {
      this.dgCells.forEach((cell) => {
        if (!cell._view.destroyed) {
          this._scrollableCells.insert(cell._view);
        }
      });
    });
  }
  ngAfterViewInit() {
    this.subscriptions.push(this.displayMode.view.subscribe((viewChange) => {
      for (let i2 = this._scrollableCells.length; i2 > 0; i2--) {
        this._scrollableCells.detach();
      }
      for (let i2 = this._calculatedCells.length; i2 > 0; i2--) {
        this._calculatedCells.detach();
      }
      if (viewChange === DatagridDisplayMode.CALCULATE) {
        this.displayCells = false;
        this.dgCells.forEach((cell) => {
          if (!cell._view.destroyed) {
            this._calculatedCells.insert(cell._view);
          }
        });
      } else {
        this.displayCells = true;
        this.dgCells.forEach((cell) => {
          if (!cell._view.destroyed) {
            this._scrollableCells.insert(cell._view);
          }
        });
      }
    }), this.expand.animate.subscribe(() => {
      this.expandAnimationTrigger = !this.expandAnimationTrigger;
    }));
  }
  ngOnDestroy() {
    this.subscriptions.forEach((sub) => sub.unsubscribe());
  }
  toggle(selected = !this.selected) {
    if (selected !== this.selected) {
      this.selected = selected;
      this.selectedChanged.emit(selected);
    }
  }
  toggleExpand() {
    if (this.expand.expandable) {
      this.expandAnimation.updateStartHeight();
      this.expanded = !this.expanded;
      this.expandedChange.emit(this.expanded);
    }
  }
  /**
   * The default behavior in Chrome and Firefox for shift-clicking on a label is to perform text-selection.
   * This prevents our intended range-selection, because this text-selection overrides our shift-click event.
   * We need to clear the stored selection range when shift-clicking. This will override the mostly unused shift-click
   * selection browser functionality, which is inconsistently implemented in browsers anyway.
   */
  clearRanges(event) {
    if (event.shiftKey) {
      this.document.getSelection().removeAllRanges();
      if (window.navigator.userAgent.indexOf("Firefox") !== -1) {
        event.preventDefault();
        this.toggle(true);
      }
    }
  }
  /**
   * @deprecated related to clrDgRowSelection, which is deprecated
   */
  selectRow(selected = !this.selected, $event) {
    if ($event.target.tagName === "LABEL") {
      return;
    }
    if (this.selection.selectionType === this.SELECTION_TYPE.Single) {
      this.selection.currentSingle = this.item;
    } else {
      this.toggle(selected);
    }
  }
  rangeSelect() {
    const items = this.items.displayed;
    if (!items) {
      return;
    }
    const startIx = items.indexOf(this.selection.rangeStart);
    if (this.selection.rangeStart && this.selection.current.includes(this.selection.rangeStart) && this.selection.shiftPressed && startIx !== -1) {
      const endIx = items.indexOf(this.item);
      const newSelection = new Set(this.selection.current.concat(items.slice(Math.min(startIx, endIx), Math.max(startIx, endIx) + 1)));
      this.selection.clearSelection();
      this.selection.current.push(...newSelection);
    } else {
      this.selection.rangeStart = this.item;
    }
  }
};
ClrDatagridRow.ɵfac = function ClrDatagridRow_Factory(t3) {
  return new (t3 || ClrDatagridRow)(ɵɵdirectiveInject(Selection), ɵɵdirectiveInject(RowActionService), ɵɵdirectiveInject(ExpandableRowsCount), ɵɵdirectiveInject(DatagridIfExpandService), ɵɵdirectiveInject(DetailService), ɵɵdirectiveInject(DisplayModeService), ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ClrCommonStringsService), ɵɵdirectiveInject(Items), ɵɵdirectiveInject(DOCUMENT));
};
ClrDatagridRow.ɵcmp = ɵɵdefineComponent({
  type: ClrDatagridRow,
  selectors: [["clr-dg-row"]],
  contentQueries: function ClrDatagridRow_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ClrDatagridCell, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.dgCells = _t);
    }
  },
  viewQuery: function ClrDatagridRow_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(ClrExpandableAnimation, 5);
      ɵɵviewQuery(_c55, 5);
      ɵɵviewQuery(_c56, 5, ViewContainerRef);
      ɵɵviewQuery(_c57, 5, ViewContainerRef);
      ɵɵviewQuery(_c58, 5, ViewContainerRef);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.expandAnimation = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.detailButton = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._stickyCells = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._scrollableCells = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._calculatedCells = _t.first);
    }
  },
  hostAttrs: ["role", "rowgroup"],
  hostVars: 5,
  hostBindings: function ClrDatagridRow_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("aria-owns", ctx.id);
      ɵɵclassProp("datagrid-row", true)("datagrid-selected", ctx.selected);
    }
  },
  inputs: {
    item: [InputFlags.None, "clrDgItem", "item"],
    clrDgSelectable: "clrDgSelectable",
    selected: [InputFlags.None, "clrDgSelected", "selected"],
    expanded: [InputFlags.None, "clrDgExpanded", "expanded"],
    clrDgDetailOpenLabel: "clrDgDetailOpenLabel",
    clrDgDetailCloseLabel: "clrDgDetailCloseLabel",
    clrDgRowSelectionLabel: "clrDgRowSelectionLabel"
  },
  outputs: {
    selectedChanged: "clrDgSelectedChange",
    expandedChange: "clrDgExpandedChange"
  },
  features: [ɵɵProvidersFeature([DatagridIfExpandService, {
    provide: IfExpandService,
    useExisting: DatagridIfExpandService
  }, {
    provide: LoadingListener,
    useExisting: DatagridIfExpandService
  }])],
  ngContentSelectors: _c60,
  decls: 9,
  vars: 3,
  consts: [["detail", ""], ["rowContent", ""], ["calculatedCells", ""], ["stickyCells", ""], ["scrollableCells", ""], ["detailButton", ""], ["class", "datagrid-row-clickable", 3, "mousedown", "click", 4, "ngIf"], [3, "clrExpandTrigger", 4, "ngIf"], [4, "ngIf"], [1, "datagrid-row-clickable", 3, "mousedown", "click"], [3, "clrExpandTrigger"], [3, "ngTemplateOutlet"], ["role", "row", 1, "datagrid-row-master", "datagrid-row-flex", 3, "id"], [1, "datagrid-row-sticky"], ["class", "datagrid-select datagrid-fixed-column datagrid-cell", "role", "gridcell", 3, "ngClass", 4, "ngIf"], ["class", "datagrid-row-actions datagrid-fixed-column datagrid-cell", "role", "gridcell", 4, "ngIf"], ["class", "datagrid-expandable-caret datagrid-fixed-column datagrid-cell", "role", "gridcell", 4, "ngIf"], ["class", "datagrid-detail-caret datagrid-fixed-column datagrid-cell", "role", "gridcell", 4, "ngIf"], [1, "datagrid-row-scrollable", 3, "ngClass"], [1, "datagrid-scrolling-cells"], ["role", "gridcell", 1, "datagrid-select", "datagrid-fixed-column", "datagrid-cell", 3, "ngClass"], ["tabindex", "-1", "type", "checkbox", "clrCheckbox", "", 3, "ngModelChange", "ngModel", "id", "disabled"], [1, "clr-control-label", "clr-col-null", 3, "click", "for"], [1, "clr-sr-only"], ["tabindex", "-1", "type", "radio", "clrRadio", "", 3, "ngModelChange", "id", "name", "value", "ngModel", "checked", "disabled"], [1, "clr-control-label", "clr-col-null", 3, "for"], ["role", "gridcell", 1, "datagrid-row-actions", "datagrid-fixed-column", "datagrid-cell"], ["role", "gridcell", 1, "datagrid-expandable-caret", "datagrid-fixed-column", "datagrid-cell"], ["tabindex", "-1", "type", "button", "class", "datagrid-expandable-caret-button", 3, "click", 4, "ngIf"], ["clrSmall", "", 4, "ngIf"], ["tabindex", "-1", "type", "button", 1, "datagrid-expandable-caret-button", 3, "click"], ["shape", "angle", 1, "datagrid-expandable-caret-icon"], ["clrSmall", ""], ["role", "gridcell", 1, "datagrid-detail-caret", "datagrid-fixed-column", "datagrid-cell"], ["tabindex", "-1", "type", "button", "aria-haspopup", "dialog", 1, "datagrid-detail-caret-button", 3, "click"], ["shape", "angle-double", 1, "datagrid-detail-caret-icon"]],
  template: function ClrDatagridRow_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c59);
      ɵɵtemplate(0, ClrDatagridRow_div_0_Template, 3, 2, "div", 6)(1, ClrDatagridRow_clr_expandable_animation_1_Template, 2, 2, "clr-expandable-animation", 7)(2, ClrDatagridRow_2_Template, 1, 1, null, 8)(3, ClrDatagridRow_ng_template_3_Template, 1, 0, "ng-template", null, 0, ɵɵtemplateRefExtractor)(5, ClrDatagridRow_ng_template_5_Template, 16, 13, "ng-template", null, 1, ɵɵtemplateRefExtractor);
      ɵɵelementContainer(7, null, 2);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.selection.rowSelectionMode);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.selection.rowSelectionMode && ctx.expand.expandable);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.selection.rowSelectionMode && !ctx.expand.expandable);
    }
  },
  dependencies: [NgClass, NgIf, NgTemplateOutlet, CdsIconCustomTag, ClrLabel, ClrCheckbox, ClrCheckboxWrapper, ClrRadio, ClrRadioWrapper, DefaultValueAccessor, CheckboxControlValueAccessor, RadioControlValueAccessor, NgControlStatus, NgModel, ClrExpandableAnimation, ClrSpinner, ClrDatagridSelectionCellDirective],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDatagridRow, [{
    type: Component,
    args: [{
      selector: "clr-dg-row",
      host: {
        "[class.datagrid-row]": "true",
        "[class.datagrid-selected]": "selected",
        "[attr.aria-owns]": "id",
        role: "rowgroup"
      },
      providers: [DatagridIfExpandService, {
        provide: IfExpandService,
        useExisting: DatagridIfExpandService
      }, {
        provide: LoadingListener,
        useExisting: DatagridIfExpandService
      }],
      template: `<!--
  We need to wrap the #rowContent in label element if we are in rowSelectionMode.
  Clicking of that wrapper label will equate to clicking on the whole row, which triggers the checkbox to toggle.
-->
<div
  class="datagrid-row-clickable"
  *ngIf="selection.rowSelectionMode"
  (mousedown)="clearRanges($event)"
  (click)="selectRow(!selected, $event)"
>
  <clr-expandable-animation [clrExpandTrigger]="expandAnimationTrigger" *ngIf="expand.expandable">
    <ng-template [ngTemplateOutlet]="rowContent"></ng-template>
  </clr-expandable-animation>
  <ng-template [ngTemplateOutlet]="rowContent" *ngIf="!expand.expandable"></ng-template>
</div>

<clr-expandable-animation
  *ngIf="!selection.rowSelectionMode && expand.expandable"
  [clrExpandTrigger]="expandAnimationTrigger"
>
  <ng-template [ngTemplateOutlet]="rowContent"></ng-template>
</clr-expandable-animation>

<ng-template *ngIf="!selection.rowSelectionMode && !expand.expandable" [ngTemplateOutlet]="rowContent"></ng-template>

<!--
    We need the "project into template" hacks because we need this in 2 different places
    depending on whether the details replace the row or not.
-->
<ng-template #detail>
  <ng-content select="clr-dg-row-detail"></ng-content>
</ng-template>

<ng-template #rowContent>
  <div
    role="row"
    [id]="id"
    class="datagrid-row-master datagrid-row-flex"
    [class.datagrid-row-detail-open]="detailService.isRowOpen(item)"
  >
    <div class="datagrid-row-sticky">
      <!-- Sticky elements here -->
      <ng-container #stickyCells>
        <div
          *ngIf="selection.selectionType === SELECTION_TYPE.Multi"
          class="datagrid-select datagrid-fixed-column datagrid-cell"
          [ngClass]="{ 'clr-form-control-disabled': !clrDgSelectable }"
          role="gridcell"
        >
          <clr-checkbox-wrapper>
            <input
              tabindex="-1"
              type="checkbox"
              clrCheckbox
              [ngModel]="selected"
              (ngModelChange)="toggle($event)"
              [id]="checkboxId"
              [disabled]="clrDgSelectable ? null : true"
              [attr.aria-disabled]="clrDgSelectable ? null : true"
            />
            <!-- Usage of class clr-col-null here prevents clr-col-* classes from being added when a datagrid is wrapped inside clrForm -->
            <label [for]="checkboxId" class="clr-control-label clr-col-null" (click)="clearRanges($event)">
              <span class="clr-sr-only">{{clrDgRowSelectionLabel || commonStrings.keys.select}}</span>
            </label>
          </clr-checkbox-wrapper>
        </div>
        <div
          *ngIf="selection.selectionType === SELECTION_TYPE.Single"
          class="datagrid-select datagrid-fixed-column datagrid-cell"
          [ngClass]="{ 'clr-form-control-disabled': !clrDgSelectable }"
          role="gridcell"
        >
          <clr-radio-wrapper>
            <input
              tabindex="-1"
              type="radio"
              clrRadio
              [id]="radioId"
              [name]="selection.id + '-radio'"
              [value]="item"
              [(ngModel)]="selection.currentSingle"
              [checked]="selection.currentSingle === item"
              [disabled]="clrDgSelectable ? null : true"
              [attr.aria-disabled]="clrDgSelectable ? null : true"
            />
            <label class="clr-control-label clr-col-null" [for]="radioId">
              <span class="clr-sr-only">{{ clrDgRowSelectionLabel || commonStrings.keys.select }}</span>
            </label>
          </clr-radio-wrapper>
        </div>
        <div
          *ngIf="rowActionService.hasActionableRow"
          class="datagrid-row-actions datagrid-fixed-column datagrid-cell"
          role="gridcell"
        >
          <ng-content select="clr-dg-action-overflow"></ng-content>
        </div>
        <div
          *ngIf="globalExpandable.hasExpandableRow"
          class="datagrid-expandable-caret datagrid-fixed-column datagrid-cell"
          role="gridcell"
        >
          <ng-container *ngIf="expand.expandable">
            <button
              tabindex="-1"
              *ngIf="!expand.loading"
              (click)="toggleExpand()"
              type="button"
              class="datagrid-expandable-caret-button"
              [attr.aria-expanded]="expand.expanded"
              [attr.aria-label]="expand.expanded ? clrDgDetailCloseLabel : clrDgDetailOpenLabel"
              [attr.aria-controls]="expandableId"
            >
              <cds-icon
                shape="angle"
                class="datagrid-expandable-caret-icon"
                [attr.direction]="expand.expanded ? 'down' : 'right'"
                [attr.title]="expand.expanded ? commonStrings.keys.collapse : commonStrings.keys.expand"
              ></cds-icon>
            </button>
            <clr-spinner *ngIf="expand.loading" clrSmall>{{ commonStrings.keys.loading }}</clr-spinner>
          </ng-container>
        </div>
        <div
          *ngIf="detailService.enabled"
          class="datagrid-detail-caret datagrid-fixed-column datagrid-cell"
          role="gridcell"
        >
          <button
            tabindex="-1"
            (click)="detailService.toggle(item, detailButton)"
            type="button"
            #detailButton
            class="datagrid-detail-caret-button"
            [class.is-open]="detailService.isRowOpen(item)"
            [attr.aria-label]="detailService.isRowOpen(item) ? clrDgDetailCloseLabel : clrDgDetailOpenLabel"
            [attr.aria-expanded]="detailService.isRowOpen(item)"
            [attr.aria-controls]="detailService.id"
            aria-haspopup="dialog"
          >
            <cds-icon
              shape="angle-double"
              [attr.direction]="detailService.isRowOpen(item) ? 'left' : 'right'"
              class="datagrid-detail-caret-icon"
              [attr.title]="detailService.isRowOpen(item) ? commonStrings.keys.close: commonStrings.keys.open"
            ></cds-icon>
          </button>
        </div>
      </ng-container>
      <!-- placeholder for projecting other sticky cells as pinned-->
    </div>
    <div class="datagrid-row-scrollable" [ngClass]="{'is-replaced': replaced && expanded}">
      <div class="datagrid-scrolling-cells">
        <ng-content select="clr-dg-cell"></ng-content>
        <ng-container #scrollableCells></ng-container>
      </div>
      <!-- details here when replace, re-visit when sticky container is used for pinned cells -->
      <ng-template *ngIf="replaced && !expand.loading" [ngTemplateOutlet]="detail"></ng-template>
      <ng-template *ngIf="!replaced && !expand.loading" [ngTemplateOutlet]="detail"></ng-template>
    </div>
  </div>
</ng-template>

<ng-container #calculatedCells></ng-container>
`
    }]
  }], function() {
    return [{
      type: Selection
    }, {
      type: RowActionService
    }, {
      type: ExpandableRowsCount
    }, {
      type: DatagridIfExpandService
    }, {
      type: DetailService
    }, {
      type: DisplayModeService
    }, {
      type: ViewContainerRef
    }, {
      type: Renderer2
    }, {
      type: ElementRef
    }, {
      type: ClrCommonStringsService
    }, {
      type: Items
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [DOCUMENT]
      }]
    }];
  }, {
    selectedChanged: [{
      type: Output,
      args: ["clrDgSelectedChange"]
    }],
    expandedChange: [{
      type: Output,
      args: ["clrDgExpandedChange"]
    }],
    dgCells: [{
      type: ContentChildren,
      args: [ClrDatagridCell]
    }],
    expandAnimation: [{
      type: ViewChild,
      args: [ClrExpandableAnimation]
    }],
    detailButton: [{
      type: ViewChild,
      args: ["detailButton"]
    }],
    _stickyCells: [{
      type: ViewChild,
      args: ["stickyCells", {
        read: ViewContainerRef
      }]
    }],
    _scrollableCells: [{
      type: ViewChild,
      args: ["scrollableCells", {
        read: ViewContainerRef
      }]
    }],
    _calculatedCells: [{
      type: ViewChild,
      args: ["calculatedCells", {
        read: ViewContainerRef
      }]
    }],
    item: [{
      type: Input,
      args: ["clrDgItem"]
    }],
    clrDgSelectable: [{
      type: Input,
      args: ["clrDgSelectable"]
    }],
    selected: [{
      type: Input,
      args: ["clrDgSelected"]
    }],
    expanded: [{
      type: Input,
      args: ["clrDgExpanded"]
    }],
    clrDgDetailOpenLabel: [{
      type: Input
    }],
    clrDgDetailCloseLabel: [{
      type: Input
    }],
    clrDgRowSelectionLabel: [{
      type: Input
    }]
  });
})();
var DatagridColumnChanges;
(function(DatagridColumnChanges2) {
  DatagridColumnChanges2[DatagridColumnChanges2["WIDTH"] = 0] = "WIDTH";
  DatagridColumnChanges2[DatagridColumnChanges2["HIDDEN"] = 1] = "HIDDEN";
  DatagridColumnChanges2[DatagridColumnChanges2["INITIALIZE"] = 2] = "INITIALIZE";
})(DatagridColumnChanges || (DatagridColumnChanges = {}));
var ALL_COLUMN_CHANGES = Object.keys(DatagridColumnChanges).map((key) => DatagridColumnChanges[key]).filter((key) => key === parseInt(key, 10) && key !== DatagridColumnChanges.INITIALIZE);
var ColumnsService = class {
  constructor() {
    this.columns = [];
    this.columnsStateChange = new BehaviorSubject(null);
    this._cache = [];
  }
  get columnStates() {
    return this.columns.map((column) => column.value);
  }
  get hasHideableColumns() {
    return this.columnStates.filter((state2) => state2.hideable).length > 0;
  }
  cache() {
    this._cache = this.columns.map((subject) => {
      const value = __spreadValues({}, subject.value);
      delete value.changes;
      return value;
    });
  }
  hasCache() {
    return !!this._cache.length;
  }
  resetToLastCache() {
    this._cache.forEach((state2, index) => {
      const cachedState = __spreadProps(__spreadValues({}, state2), {
        changes: ALL_COLUMN_CHANGES
      });
      this.columns[index].next(cachedState);
      this.columnsStateChange.next(cachedState);
    });
    this._cache = [];
  }
  // Helper method to emit a change to a column only when there is an actual diff to process for that column
  emitStateChangeAt(columnIndex, diff) {
    if (!this.columns[columnIndex]) {
      return;
    }
    this.emitStateChange(this.columns[columnIndex], diff);
  }
  emitStateChange(column, diff) {
    const changedState = __spreadValues(__spreadValues({}, column.value), diff);
    column.next(changedState);
    this.columnsStateChange.next(changedState);
  }
};
ColumnsService.ɵfac = function ColumnsService_Factory(t3) {
  return new (t3 || ColumnsService)();
};
ColumnsService.ɵprov = ɵɵdefineInjectable({
  token: ColumnsService,
  factory: ColumnsService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ColumnsService, [{
    type: Injectable
  }], null, null);
})();
var StateProvider = class {
  constructor(filters, sort, page, debouncer) {
    this.filters = filters;
    this.sort = sort;
    this.page = page;
    this.debouncer = debouncer;
    this.change = this.debouncer.change.pipe(map(() => this.state));
  }
  /*
   * By making this a getter, we open the possibility for a setter in the future.
   * It's been requested a couple times.
   */
  get state() {
    const state2 = {};
    if (this.page.size > 0) {
      state2.page = {
        from: this.page.firstItem,
        to: this.page.lastItem,
        size: this.page.size,
        current: this.page.current
      };
    }
    if (this.sort.comparator) {
      if (this.sort.comparator instanceof DatagridPropertyComparator) {
        state2.sort = {
          by: this.sort.comparator.prop,
          reverse: this.sort.reverse
        };
      } else {
        state2.sort = {
          by: this.sort.comparator,
          reverse: this.sort.reverse
        };
      }
    }
    const activeFilters = this.filters.getActiveFilters();
    if (activeFilters.length > 0) {
      state2.filters = [];
      for (const filter2 of activeFilters) {
        if (filter2.state) {
          state2.filters.push(filter2.state);
        } else {
          state2.filters.push(filter2);
        }
      }
    }
    return state2;
  }
};
StateProvider.ɵfac = function StateProvider_Factory(t3) {
  return new (t3 || StateProvider)(ɵɵinject(FiltersProvider), ɵɵinject(Sort), ɵɵinject(Page), ɵɵinject(StateDebouncer));
};
StateProvider.ɵprov = ɵɵdefineInjectable({
  token: StateProvider,
  factory: StateProvider.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StateProvider, [{
    type: Injectable
  }], function() {
    return [{
      type: FiltersProvider
    }, {
      type: Sort
    }, {
      type: Page
    }, {
      type: StateDebouncer
    }];
  }, null);
})();
var STRICT_WIDTH_CLASS = "datagrid-fixed-width";
var HIDDEN_COLUMN_CLASS = "datagrid-hidden-column";
var DatagridCellRenderer = class {
  constructor(el, renderer, organizer) {
    this.el = el;
    this.renderer = renderer;
    this.subscriptions = [];
    this.subscriptions.push(organizer.filterRenderSteps(DatagridRenderStep.CLEAR_WIDTHS).subscribe(() => this.clearWidth()));
  }
  ngOnDestroy() {
    this.subscriptions.forEach((sub) => sub.unsubscribe());
    if (this.stateSubscription) {
      this.stateSubscription.unsubscribe();
    }
  }
  resetState(state2) {
    this.setWidth(state2);
    this.setHidden(state2);
  }
  setWidth(state2) {
    if (state2.strictWidth) {
      this.renderer.addClass(this.el.nativeElement, STRICT_WIDTH_CLASS);
    } else {
      this.renderer.removeClass(this.el.nativeElement, STRICT_WIDTH_CLASS);
    }
    this.renderer.setStyle(this.el.nativeElement, "width", state2.width + "px");
  }
  setHidden(state2) {
    if (state2.hidden) {
      this.renderer.addClass(this.el.nativeElement, HIDDEN_COLUMN_CLASS);
    } else {
      this.renderer.removeClass(this.el.nativeElement, HIDDEN_COLUMN_CLASS);
    }
  }
  clearWidth() {
    this.renderer.removeClass(this.el.nativeElement, STRICT_WIDTH_CLASS);
    this.renderer.setStyle(this.el.nativeElement, "width", null);
  }
};
DatagridCellRenderer.ɵfac = function DatagridCellRenderer_Factory(t3) {
  return new (t3 || DatagridCellRenderer)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(DatagridRenderOrganizer));
};
DatagridCellRenderer.ɵdir = ɵɵdefineDirective({
  type: DatagridCellRenderer,
  selectors: [["clr-dg-cell"]]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DatagridCellRenderer, [{
    type: Directive,
    args: [{
      selector: "clr-dg-cell"
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: DatagridRenderOrganizer
    }];
  }, null);
})();
var DatagridRowRenderer = class {
  constructor(columnsService) {
    this.columnsService = columnsService;
    this.subscriptions = [];
  }
  ngAfterContentInit() {
    this.setCellsState();
    this.subscriptions.push(this.cells.changes.subscribe(() => {
      this.setCellsState();
    }));
  }
  ngOnDestroy() {
    this.subscriptions.forEach((sub) => sub.unsubscribe());
  }
  setCellsState() {
    if (this.cells.length === this.columnsService.columns.length) {
      this.cells.forEach((cell, index) => {
        if (this.columnsService.columns[index]) {
          cell.resetState(this.columnsService.columns[index].value);
        }
      });
    }
  }
};
DatagridRowRenderer.ɵfac = function DatagridRowRenderer_Factory(t3) {
  return new (t3 || DatagridRowRenderer)(ɵɵdirectiveInject(ColumnsService));
};
DatagridRowRenderer.ɵdir = ɵɵdefineDirective({
  type: DatagridRowRenderer,
  selectors: [["clr-dg-row"], ["clr-dg-row-detail"]],
  contentQueries: function DatagridRowRenderer_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, DatagridCellRenderer, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.cells = _t);
    }
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DatagridRowRenderer, [{
    type: Directive,
    args: [{
      selector: "clr-dg-row, clr-dg-row-detail"
    }]
  }], function() {
    return [{
      type: ColumnsService
    }];
  }, {
    cells: [{
      type: ContentChildren,
      args: [DatagridCellRenderer]
    }]
  });
})();
var ClrDatagrid = class {
  constructor(organizer, items, expandableRows, selection, rowActionService, stateProvider, displayMode, renderer, detailService, document2, el, page, commonStrings, columnsService, keyNavigation, zone) {
    this.organizer = organizer;
    this.items = items;
    this.expandableRows = expandableRows;
    this.selection = selection;
    this.rowActionService = rowActionService;
    this.stateProvider = stateProvider;
    this.displayMode = displayMode;
    this.renderer = renderer;
    this.detailService = detailService;
    this.document = document2;
    this.el = el;
    this.page = page;
    this.commonStrings = commonStrings;
    this.columnsService = columnsService;
    this.keyNavigation = keyNavigation;
    this.zone = zone;
    this.clrDgSingleSelectionAriaLabel = this.commonStrings.keys.singleSelectionAriaLabel;
    this.clrDgSingleActionableAriaLabel = this.commonStrings.keys.singleActionableAriaLabel;
    this.clrDetailExpandableAriaLabel = this.commonStrings.keys.detailExpandableAriaLabel;
    this.clrDgDisablePageFocus = false;
    this.selectedChanged = new EventEmitter(false);
    this.singleSelectedChanged = new EventEmitter(false);
    this.refresh = new EventEmitter(false);
    this.SELECTION_TYPE = SelectionType;
    this._subscriptions = [];
    const datagridId = uniqueIdFactory();
    this.selectAllId = "clr-dg-select-all-" + datagridId;
    this.detailService.id = datagridId;
  }
  /**
   * Freezes the datagrid while data is loading
   */
  get loading() {
    return this.items.loading;
  }
  set loading(value) {
    this.items.loading = value;
  }
  /**
   * Array of all selected items
   */
  set selected(value) {
    if (value) {
      this.selection.selectionType = SelectionType.Multi;
    } else {
      this.selection.selectionType = SelectionType.None;
    }
    this.selection.updateCurrent(value, false);
  }
  /**
   * Selected item in single-select mode
   */
  set singleSelected(value) {
    this.selection.selectionType = SelectionType.Single;
    if (value) {
      this.selection.currentSingle = value;
    } else if (this.selection.currentSingle) {
      this.selection.currentSingle = null;
    }
  }
  set clrDgPreserveSelection(state2) {
    this.selection.preserveSelection = state2;
  }
  /**
   * @deprecated since 2.0, remove in 3.0
   *
   * Selection/Deselection on row click mode
   */
  set rowSelectionMode(value) {
    this.selection.rowSelectionMode = value;
  }
  set trackBy(value) {
    this.items.trackBy = value;
  }
  /**
   * Indicates if all currently displayed items are selected
   */
  get allSelected() {
    return this.selection.isAllSelected();
  }
  set allSelected(_value) {
    this.selection.toggleAll();
  }
  ngAfterContentInit() {
    if (!this.items.smart) {
      this.items.all = this.rows.map((row) => row.item);
    }
    const rowItemsChanges = this.rows.changes.pipe(switchMap((rows) => merge(
      // immediate update
      of(rows.map((row) => row.item)),
      // subsequent updates once per tick
      combineLatest(rows.map((row) => row.itemChanges)).pipe(debounceTime(0))
    )));
    this._subscriptions.push(rowItemsChanges.subscribe((all) => {
      if (!this.items.smart) {
        this.items.all = all;
      }
    }), this.rows.changes.subscribe(() => {
      for (let i2 = this._displayedRows.length - 1; i2 >= 0; i2--) {
        if (this._displayedRows.get(i2).destroyed) {
          this._displayedRows.remove(i2);
        }
      }
      this.rows.forEach((row) => {
        this._displayedRows.insert(row._view);
      });
      if (this.detailService.state && this.detailService.isOpen) {
        const row = this.rows.find((row2) => this.items.trackBy(row2.item) === this.items.trackBy(this.detailService.state));
        if (row) {
          this.detailService.open(row.item, row.detailButton.nativeElement);
        } else if (!this.hasVirtualScroller) {
          setTimeout(() => {
            this.detailService.close();
          });
        }
      }
      const active = this.keyNavigation.getActiveCell();
      if (active) {
        this.zone.runOutsideAngular(() => {
          setTimeout(() => this.keyNavigation.setActiveCell(active));
        });
      }
    }));
  }
  /**
   * Our setup happens in the view of some of our components, so we wait for it to be done before starting
   */
  ngAfterViewInit() {
    this.keyNavigation.initializeKeyGrid(this.el.nativeElement);
    this.refresh.emit(this.stateProvider.state);
    this._subscriptions.push(
      this.stateProvider.change.subscribe((state2) => this.refresh.emit(state2)),
      this.selection.change.subscribe((s2) => {
        if (this.selection.selectionType === SelectionType.Single) {
          this.singleSelectedChanged.emit(s2);
        } else if (this.selection.selectionType === SelectionType.Multi) {
          this.selectedChanged.emit(s2);
        }
      }),
      // Reinitialize arrow key navigation on page changes
      this.page.change.subscribe(() => {
        this.keyNavigation.resetKeyGrid();
        if (!this.clrDgDisablePageFocus) {
          this.datagridTable.nativeElement.focus();
        }
      }),
      // A subscription that listens for displayMode changes on the datagrid
      this.displayMode.view.subscribe((viewChange) => {
        for (let i2 = this._projectedDisplayColumns.length; i2 > 0; i2--) {
          this._projectedDisplayColumns.detach();
        }
        for (let i2 = this._projectedCalculationColumns.length; i2 > 0; i2--) {
          this._projectedCalculationColumns.detach();
        }
        for (let i2 = this._calculationRows.length; i2 > 0; i2--) {
          this._calculationRows.detach();
        }
        for (let i2 = this._displayedRows.length; i2 > 0; i2--) {
          this._displayedRows.detach();
        }
        if (viewChange === DatagridDisplayMode.DISPLAY) {
          this.renderer.removeClass(this.el.nativeElement, "datagrid-calculate-mode");
          this.columns.forEach((column) => {
            this._projectedDisplayColumns.insert(column._view);
          });
          this.rows.forEach((row) => {
            this._displayedRows.insert(row._view);
          });
        } else {
          this.renderer.addClass(this.el.nativeElement, "datagrid-calculate-mode");
          this.columns.forEach((column) => {
            this._projectedCalculationColumns.insert(column._view);
          });
          this.rows.forEach((row) => {
            this._calculationRows.insert(row._view);
          });
        }
      })
    );
    this.zone.runOutsideAngular(() => {
      this._subscriptions.push(fromEvent(this.document.body, "keydown").subscribe((event) => {
        if (event.key === "Shift") {
          this.selection.shiftPressed = true;
        }
      }), fromEvent(this.document.body, "keyup").subscribe((event) => {
        if (event.key === "Shift") {
          this.selection.shiftPressed = false;
        }
      }));
    });
  }
  ngOnDestroy() {
    this._subscriptions.forEach((sub) => sub.unsubscribe());
  }
  toggleAllSelected($event) {
    $event.preventDefault();
    if (this.hasVirtualScroller) {
      return;
    }
    this.allSelected = !this.allSelected;
  }
  resize() {
    this.organizer.resize();
  }
  /**
   * Public method to re-trigger the computation of displayed items manually
   */
  dataChanged() {
    this.items.refresh();
  }
};
ClrDatagrid.ɵfac = function ClrDatagrid_Factory(t3) {
  return new (t3 || ClrDatagrid)(ɵɵdirectiveInject(DatagridRenderOrganizer), ɵɵdirectiveInject(Items), ɵɵdirectiveInject(ExpandableRowsCount), ɵɵdirectiveInject(Selection), ɵɵdirectiveInject(RowActionService), ɵɵdirectiveInject(StateProvider), ɵɵdirectiveInject(DisplayModeService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(DetailService), ɵɵdirectiveInject(DOCUMENT), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Page), ɵɵdirectiveInject(ClrCommonStringsService), ɵɵdirectiveInject(ColumnsService), ɵɵdirectiveInject(KeyNavigationGridController), ɵɵdirectiveInject(NgZone));
};
ClrDatagrid.ɵcmp = ɵɵdefineComponent({
  type: ClrDatagrid,
  selectors: [["clr-datagrid"]],
  contentQueries: function ClrDatagrid_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ClrDatagridItems, 5);
      ɵɵcontentQuery(dirIndex, ClrDatagridPlaceholder, 5);
      ɵɵcontentQuery(dirIndex, ClrDatagridColumn, 4);
      ɵɵcontentQuery(dirIndex, ClrDatagridRow, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.iterator = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.placeholder = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.columns = _t);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.rows = _t);
    }
  },
  viewQuery: function ClrDatagrid_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c63, 5, ElementRef);
      ɵɵviewQuery(_c64, 5, ElementRef);
      ɵɵviewQuery(_c65, 5, ViewContainerRef);
      ɵɵviewQuery(_c66, 5, ViewContainerRef);
      ɵɵviewQuery(_c67, 5, ViewContainerRef);
      ɵɵviewQuery(_c68, 5, ViewContainerRef);
      ɵɵviewQuery(_c69, 5, ViewContainerRef);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.datagrid = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.datagridTable = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.scrollableColumns = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._projectedDisplayColumns = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._projectedCalculationColumns = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._displayedRows = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._calculationRows = _t.first);
    }
  },
  hostVars: 4,
  hostBindings: function ClrDatagrid_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("datagrid-host", true)("datagrid-detail-open", ctx.detailService.isOpen);
    }
  },
  inputs: {
    loadingMoreItems: [InputFlags.None, "clrLoadingMoreItems", "loadingMoreItems"],
    clrDgSingleSelectionAriaLabel: "clrDgSingleSelectionAriaLabel",
    clrDgSingleActionableAriaLabel: "clrDgSingleActionableAriaLabel",
    clrDetailExpandableAriaLabel: "clrDetailExpandableAriaLabel",
    clrDgDisablePageFocus: "clrDgDisablePageFocus",
    loading: [InputFlags.None, "clrDgLoading", "loading"],
    selected: [InputFlags.None, "clrDgSelected", "selected"],
    singleSelected: [InputFlags.None, "clrDgSingleSelected", "singleSelected"],
    clrDgPreserveSelection: "clrDgPreserveSelection",
    rowSelectionMode: [InputFlags.None, "clrDgRowSelection", "rowSelectionMode"],
    trackBy: [InputFlags.None, "clrDgItemsTrackBy", "trackBy"]
  },
  outputs: {
    selectedChanged: "clrDgSelectedChange",
    singleSelectedChanged: "clrDgSingleSelectedChange",
    refresh: "clrDgRefresh"
  },
  features: [ɵɵProvidersFeature([Selection, Sort, FiltersProvider, Page, Items, DatagridRenderOrganizer, RowActionService, ExpandableRowsCount, StateDebouncer, DetailService, StateProvider, TableSizeService, ColumnsService, DisplayModeService, KeyNavigationGridController])],
  ngContentSelectors: _c71,
  decls: 35,
  vars: 9,
  consts: [["datagrid", ""], ["datagridTable", ""], ["projectedDisplayColumns", ""], ["displayedRows", ""], ["projectedCalculationColumns", ""], ["calculationRows", ""], [1, "datagrid-outer-wrapper"], [1, "datagrid-inner-wrapper"], [1, "datagrid"], [1, "datagrid-table-wrapper"], ["role", "grid", "tabindex", "-1", 1, "datagrid-table"], ["role", "rowgroup", 1, "datagrid-header"], ["role", "row", 1, "datagrid-row"], [1, "datagrid-row-master", "datagrid-row-flex"], [1, "datagrid-row-sticky"], ["role", "columnheader", "class", "datagrid-column datagrid-select datagrid-fixed-column", 3, "keydown.space", 4, "ngIf"], ["role", "columnheader", "class", "datagrid-column datagrid-select datagrid-fixed-column", 4, "ngIf"], ["role", "columnheader", "class", "datagrid-column datagrid-row-actions datagrid-fixed-column", 4, "ngIf"], ["role", "columnheader", "class", "datagrid-column datagrid-expandable-caret datagrid-fixed-column", 4, "ngIf"], [1, "datagrid-row-scrollable"], ["role", "presentation", 1, "datagrid-rows"], ["class", "datagrid-row-loading", 4, "ngIf"], [4, "ngIf"], ["class", "datagrid-spinner", 4, "ngIf"], [1, "datagrid-calculation-table"], [1, "datagrid-calculation-header"], ["role", "columnheader", 1, "datagrid-column", "datagrid-select", "datagrid-fixed-column", 3, "keydown.space"], ["class", "clr-checkbox-wrapper", 4, "ngIf"], [1, "datagrid-column-separator"], [1, "clr-checkbox-wrapper"], ["type", "checkbox", "tabindex", "-1", 3, "ngModelChange", "id", "ngModel"], [1, "clr-control-label", "clr-col-null", 3, "for"], [1, "clr-sr-only"], ["role", "columnheader", 1, "datagrid-column", "datagrid-select", "datagrid-fixed-column"], ["role", "columnheader", 1, "datagrid-column", "datagrid-row-actions", "datagrid-fixed-column"], ["role", "columnheader", 1, "datagrid-column", "datagrid-expandable-caret", "datagrid-fixed-column"], [1, "datagrid-row-loading"], ["clrMedium", ""], [1, "datagrid-spinner"]],
  template: function ClrDatagrid_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c70);
      ɵɵprojection(0);
      ɵɵelementStart(1, "div", 6)(2, "div", 7)(3, "div", 8, 0)(5, "div", 9)(6, "div", 10, 1)(8, "div", 11)(9, "div", 12)(10, "div", 13)(11, "div", 14);
      ɵɵtemplate(12, ClrDatagrid_div_12_Template, 3, 1, "div", 15)(13, ClrDatagrid_div_13_Template, 4, 1, "div", 16)(14, ClrDatagrid_div_14_Template, 4, 1, "div", 17)(15, ClrDatagrid_div_15_Template, 4, 1, "div", 18);
      ɵɵelementEnd();
      ɵɵelementStart(16, "div", 19);
      ɵɵelementContainer(17, null, 2);
      ɵɵelementEnd()()()();
      ɵɵelementStart(19, "div", 20);
      ɵɵtemplate(20, ClrDatagrid_clr_dg_row_20_Template, 5, 1, "clr-dg-row", 21);
      ɵɵelementContainer(21, null, 3);
      ɵɵtemplate(23, ClrDatagrid_clr_dg_row_23_Template, 5, 1, "clr-dg-row", 21);
      ɵɵprojection(24, 1);
      ɵɵtemplate(25, ClrDatagrid_clr_dg_placeholder_25_Template, 1, 0, "clr-dg-placeholder", 22);
      ɵɵelementEnd()()()();
      ɵɵprojection(26, 2);
      ɵɵtemplate(27, ClrDatagrid_div_27_Template, 3, 0, "div", 23);
      ɵɵelementEnd();
      ɵɵprojection(28, 3);
      ɵɵelementEnd();
      ɵɵelementStart(29, "div", 24)(30, "div", 25);
      ɵɵelementContainer(31, null, 4);
      ɵɵelementEnd();
      ɵɵelementContainer(33, null, 5);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance(3);
      ɵɵattribute("aria-hidden", ctx.detailService.isOpen ? true : null);
      ɵɵadvance(9);
      ɵɵproperty("ngIf", ctx.selection.selectionType === ctx.SELECTION_TYPE.Multi);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.selection.selectionType === ctx.SELECTION_TYPE.Single);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.rowActionService.hasActionableRow);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.expandableRows.hasExpandableRow || ctx.detailService.enabled);
      ɵɵadvance(5);
      ɵɵproperty("ngIf", ctx.loadingMoreItems);
      ɵɵadvance(3);
      ɵɵproperty("ngIf", ctx.loadingMoreItems);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", !ctx.placeholder);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.loading);
    }
  },
  dependencies: [NgIf, ClrLabel, CheckboxControlValueAccessor, NgControlStatus, NgModel, ClrSpinner, ClrDatagridCell, ClrDatagridPlaceholder, ClrDatagridRow, ClrDatagridSelectionCellDirective, DatagridCellRenderer, DatagridRowRenderer, ActionableOompaLoompa, ExpandableOompaLoompa],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDatagrid, [{
    type: Component,
    args: [{
      selector: "clr-datagrid",
      providers: [Selection, Sort, FiltersProvider, Page, Items, DatagridRenderOrganizer, RowActionService, ExpandableRowsCount, StateDebouncer, DetailService, StateProvider, TableSizeService, ColumnsService, DisplayModeService, KeyNavigationGridController],
      host: {
        "[class.datagrid-host]": "true",
        "[class.datagrid-detail-open]": "detailService.isOpen"
      },
      template: '<!--\n  ~ Copyright (c) 2016-2024 Broadcom. All Rights Reserved.\n  ~ The term "Broadcom" refers to Broadcom Inc. and/or its subsidiaries.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n  -->\n\n<ng-content select="clr-dg-action-bar"></ng-content>\n<div class="datagrid-outer-wrapper">\n  <div class="datagrid-inner-wrapper">\n    <div class="datagrid" #datagrid [attr.aria-hidden]="detailService.isOpen ? true : null">\n      <div class="datagrid-table-wrapper">\n        <div role="grid" class="datagrid-table" tabindex="-1" #datagridTable>\n          <div role="rowgroup" class="datagrid-header">\n            <div role="row" class="datagrid-row">\n              <div class="datagrid-row-master datagrid-row-flex">\n                <div class="datagrid-row-sticky">\n                  <!--header for datagrid where you can select multiple rows -->\n                  <div\n                    role="columnheader"\n                    class="datagrid-column datagrid-select datagrid-fixed-column"\n                    *ngIf="selection.selectionType === SELECTION_TYPE.Multi"\n                    (keydown.space)="toggleAllSelected($event)"\n                  >\n                    <div *ngIf="!hasVirtualScroller" class="clr-checkbox-wrapper">\n                      <!-- We need to move focus and space-key handling to the parent because of keyboard arrow key navigation,\n                           which is not able to transfer focus directly on the input when focused with the tab key -->\n                      <input\n                        type="checkbox"\n                        [id]="selectAllId"\n                        [(ngModel)]="allSelected"\n                        [attr.aria-label]="commonStrings.keys.selectAll"\n                        tabindex="-1"\n                      />\n                      <!-- Usage of class clr-col-null here prevents clr-col-* classes from being added when a datagrid is wrapped inside clrForm -->\n                      <label [for]="selectAllId" class="clr-control-label clr-col-null">\n                        <span class="clr-sr-only">{{commonStrings.keys.selectAll}}</span>\n                      </label>\n                    </div>\n\n                    <div class="datagrid-column-separator"></div>\n                  </div>\n                  <!-- header for datagrid where you can select one row only -->\n                  <div\n                    role="columnheader"\n                    class="datagrid-column datagrid-select datagrid-fixed-column"\n                    *ngIf="selection.selectionType === SELECTION_TYPE.Single"\n                  >\n                    <div class="clr-sr-only">{{clrDgSingleSelectionAriaLabel}}</div>\n                    <div class="datagrid-column-separator"></div>\n                  </div>\n                  <!-- header for single row action; only displayType if we have at least one actionable row in datagrid -->\n                  <div\n                    role="columnheader"\n                    class="datagrid-column datagrid-row-actions datagrid-fixed-column"\n                    *ngIf="rowActionService.hasActionableRow"\n                  >\n                    <div class="clr-sr-only">{{clrDgSingleActionableAriaLabel}}</div>\n                    <div class="datagrid-column-separator"></div>\n                  </div>\n                  <!-- header for carets; only displayType if we have at least one expandable row in datagrid -->\n                  <div\n                    role="columnheader"\n                    class="datagrid-column datagrid-expandable-caret datagrid-fixed-column"\n                    *ngIf="expandableRows.hasExpandableRow || detailService.enabled"\n                  >\n                    <div class="clr-sr-only">{{clrDetailExpandableAriaLabel}}</div>\n                    <div class="datagrid-column-separator"></div>\n                  </div>\n                </div>\n                <div class="datagrid-row-scrollable">\n                  <ng-container #projectedDisplayColumns></ng-container>\n                </div>\n              </div>\n            </div>\n          </div>\n\n          <div role="presentation" class="datagrid-rows">\n            <clr-dg-row class="datagrid-row-loading" *ngIf="loadingMoreItems">\n              <clr-dg-cell>\n                <clr-spinner clrMedium></clr-spinner>\n                <span>{{ commonStrings.keys.loading }}</span>\n              </clr-dg-cell>\n            </clr-dg-row>\n\n            <ng-container #displayedRows></ng-container>\n\n            <clr-dg-row class="datagrid-row-loading" *ngIf="loadingMoreItems">\n              <clr-dg-cell>\n                <clr-spinner clrMedium></clr-spinner>\n                <span>{{ commonStrings.keys.loading }}</span>\n              </clr-dg-cell>\n            </clr-dg-row>\n\n            <!-- Custom placeholder overrides the default empty one -->\n            <ng-content select="clr-dg-placeholder"></ng-content>\n            <clr-dg-placeholder *ngIf="!placeholder"></clr-dg-placeholder>\n          </div>\n        </div>\n      </div>\n    </div>\n    <ng-content select="clr-dg-footer"></ng-content>\n    <div class="datagrid-spinner" *ngIf="loading">\n      <clr-spinner clrMedium>Loading</clr-spinner>\n    </div>\n  </div>\n  <ng-content select="[clrIfDetail],clr-dg-detail"></ng-content>\n</div>\n\n<div class="datagrid-calculation-table">\n  <div class="datagrid-calculation-header">\n    <ng-container #projectedCalculationColumns></ng-container>\n  </div>\n  <ng-container #calculationRows></ng-container>\n</div>\n'
    }]
  }], function() {
    return [{
      type: DatagridRenderOrganizer
    }, {
      type: Items
    }, {
      type: ExpandableRowsCount
    }, {
      type: Selection
    }, {
      type: RowActionService
    }, {
      type: StateProvider
    }, {
      type: DisplayModeService
    }, {
      type: Renderer2
    }, {
      type: DetailService
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [DOCUMENT]
      }]
    }, {
      type: ElementRef
    }, {
      type: Page
    }, {
      type: ClrCommonStringsService
    }, {
      type: ColumnsService
    }, {
      type: KeyNavigationGridController
    }, {
      type: NgZone
    }];
  }, {
    loadingMoreItems: [{
      type: Input,
      args: ["clrLoadingMoreItems"]
    }],
    clrDgSingleSelectionAriaLabel: [{
      type: Input
    }],
    clrDgSingleActionableAriaLabel: [{
      type: Input
    }],
    clrDetailExpandableAriaLabel: [{
      type: Input
    }],
    clrDgDisablePageFocus: [{
      type: Input
    }],
    selectedChanged: [{
      type: Output,
      args: ["clrDgSelectedChange"]
    }],
    singleSelectedChanged: [{
      type: Output,
      args: ["clrDgSingleSelectedChange"]
    }],
    refresh: [{
      type: Output,
      args: ["clrDgRefresh"]
    }],
    iterator: [{
      type: ContentChild,
      args: [ClrDatagridItems]
    }],
    placeholder: [{
      type: ContentChild,
      args: [ClrDatagridPlaceholder]
    }],
    columns: [{
      type: ContentChildren,
      args: [ClrDatagridColumn]
    }],
    rows: [{
      type: ContentChildren,
      args: [ClrDatagridRow]
    }],
    datagrid: [{
      type: ViewChild,
      args: ["datagrid", {
        read: ElementRef
      }]
    }],
    datagridTable: [{
      type: ViewChild,
      args: ["datagridTable", {
        read: ElementRef
      }]
    }],
    scrollableColumns: [{
      type: ViewChild,
      args: ["scrollableColumns", {
        read: ViewContainerRef
      }]
    }],
    _projectedDisplayColumns: [{
      type: ViewChild,
      args: ["projectedDisplayColumns", {
        read: ViewContainerRef
      }]
    }],
    _projectedCalculationColumns: [{
      type: ViewChild,
      args: ["projectedCalculationColumns", {
        read: ViewContainerRef
      }]
    }],
    _displayedRows: [{
      type: ViewChild,
      args: ["displayedRows", {
        read: ViewContainerRef
      }]
    }],
    _calculationRows: [{
      type: ViewChild,
      args: ["calculationRows", {
        read: ViewContainerRef
      }]
    }],
    loading: [{
      type: Input,
      args: ["clrDgLoading"]
    }],
    selected: [{
      type: Input,
      args: ["clrDgSelected"]
    }],
    singleSelected: [{
      type: Input,
      args: ["clrDgSingleSelected"]
    }],
    clrDgPreserveSelection: [{
      type: Input
    }],
    rowSelectionMode: [{
      type: Input,
      args: ["clrDgRowSelection"]
    }],
    trackBy: [{
      type: Input,
      args: ["clrDgItemsTrackBy"]
    }]
  });
})();
var ClrDatagridActionBar = class {
};
ClrDatagridActionBar.ɵfac = function ClrDatagridActionBar_Factory(t3) {
  return new (t3 || ClrDatagridActionBar)();
};
ClrDatagridActionBar.ɵcmp = ɵɵdefineComponent({
  type: ClrDatagridActionBar,
  selectors: [["clr-dg-action-bar"]],
  hostVars: 2,
  hostBindings: function ClrDatagridActionBar_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("datagrid-action-bar", true);
    }
  },
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function ClrDatagridActionBar_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDatagridActionBar, [{
    type: Component,
    args: [{
      selector: "clr-dg-action-bar",
      template: `<ng-content></ng-content>`,
      host: {
        "[class.datagrid-action-bar]": "true"
      }
    }]
  }], null, null);
})();
var clrDgActionId = 0;
var ClrDatagridActionOverflow = class {
  constructor(rowActionService, commonStrings, platformId, zone, smartToggleService) {
    this.rowActionService = rowActionService;
    this.commonStrings = commonStrings;
    this.platformId = platformId;
    this.zone = zone;
    this.smartToggleService = smartToggleService;
    this.openChange = new EventEmitter(false);
    this.popoverId = uniqueIdFactory();
    this.smartPosition = {
      axis: ClrAxis.HORIZONTAL,
      side: ClrSide.AFTER,
      anchor: ClrAlignment.CENTER,
      content: ClrAlignment.CENTER
    };
    this._open = false;
    this.subscriptions = [];
    this.rowActionService.register();
    this.subscriptions.push(this.smartToggleService.openChange.subscribe((openState) => {
      this.open = openState;
    }), this.smartToggleService.popoverVisible.subscribe((visible) => {
      if (visible) {
        this.initializeFocus();
      }
    }));
    this.popoverId = "clr-action-menu" + clrDgActionId++;
  }
  get open() {
    return this._open;
  }
  set open(open) {
    const openState = !!open;
    if (!!openState !== this.open) {
      this.smartToggleService.open = openState;
      this.openChange.emit(openState);
      this._open = openState;
    }
  }
  ngOnDestroy() {
    this.rowActionService.unregister();
    this.subscriptions.forEach((sub) => sub.unsubscribe());
  }
  closeOverflowContent(event) {
    this.smartToggleService.toggleWithEvent(event);
  }
  initializeFocus() {
    if (isPlatformBrowser(this.platformId)) {
      const buttons = Array.from(document.querySelectorAll("button.action-item"));
      if (buttons.length) {
        this.keyFocus.current = 0;
        this.keyFocus.focusableItems = buttons;
        this.keyFocus.focusCurrent();
      }
    }
  }
};
ClrDatagridActionOverflow.ɵfac = function ClrDatagridActionOverflow_Factory(t3) {
  return new (t3 || ClrDatagridActionOverflow)(ɵɵdirectiveInject(RowActionService), ɵɵdirectiveInject(ClrCommonStringsService), ɵɵdirectiveInject(PLATFORM_ID), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ClrPopoverToggleService));
};
ClrDatagridActionOverflow.ɵcmp = ɵɵdefineComponent({
  type: ClrDatagridActionOverflow,
  selectors: [["clr-dg-action-overflow"]],
  viewQuery: function ClrDatagridActionOverflow_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(ClrKeyFocus, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.keyFocus = _t.first);
    }
  },
  inputs: {
    buttonLabel: [InputFlags.None, "clrDgActionOverflowButtonLabel", "buttonLabel"],
    open: [InputFlags.None, "clrDgActionOverflowOpen", "open"]
  },
  outputs: {
    openChange: "clrDgActionOverflowOpenChange"
  },
  features: [ɵɵHostDirectivesFeature([ClrPopoverHostDirective])],
  ngContentSelectors: _c02,
  decls: 4,
  vars: 8,
  consts: [["anchor", ""], ["tabindex", "-1", "type", "button", "role", "button", "aria-haspopup", "true", "clrPopoverAnchor", "", "clrPopoverOpenCloseButton", "", 1, "datagrid-action-toggle"], ["shape", "ellipsis-vertical"], ["class", "datagrid-action-overflow", "clrKeyFocus", "", "cdkTrapFocus", "", 3, "id", "click", 4, "clrPopoverContent", "clrPopoverContentAt", "clrPopoverContentOutsideClickToClose", "clrPopoverContentScrollToClose"], ["clrKeyFocus", "", "cdkTrapFocus", "", 1, "datagrid-action-overflow", 3, "click", "id"]],
  template: function ClrDatagridActionOverflow_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "button", 1, 0);
      ɵɵelement(2, "cds-icon", 2);
      ɵɵelementEnd();
      ɵɵtemplate(3, ClrDatagridActionOverflow_div_3_Template, 2, 3, "div", 3);
    }
    if (rf & 2) {
      ɵɵattribute("aria-controls", ctx.popoverId)("aria-expanded", ctx.open)("aria-label", ctx.buttonLabel || ctx.commonStrings.keys.rowActions);
      ɵɵadvance(2);
      ɵɵattribute("title", ctx.buttonLabel || ctx.commonStrings.keys.rowActions);
      ɵɵadvance();
      ɵɵproperty("clrPopoverContent", ctx.open)("clrPopoverContentAt", ctx.smartPosition)("clrPopoverContentOutsideClickToClose", true)("clrPopoverContentScrollToClose", true);
    }
  },
  dependencies: [CdkTrapFocusModule_CdkTrapFocus, CdsIconCustomTag, ClrPopoverAnchor, ClrPopoverOpenCloseButton, ClrPopoverContent, ClrKeyFocus],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDatagridActionOverflow, [{
    type: Component,
    args: [{
      selector: "clr-dg-action-overflow",
      hostDirectives: [ClrPopoverHostDirective],
      template: `
    <button
      tabindex="-1"
      class="datagrid-action-toggle"
      type="button"
      role="button"
      aria-haspopup="true"
      #anchor
      [attr.aria-controls]="popoverId"
      [attr.aria-expanded]="open"
      [attr.aria-label]="buttonLabel || commonStrings.keys.rowActions"
      clrPopoverAnchor
      clrPopoverOpenCloseButton
    >
      <cds-icon shape="ellipsis-vertical" [attr.title]="buttonLabel || commonStrings.keys.rowActions"></cds-icon>
    </button>

    <div
      class="datagrid-action-overflow"
      [id]="popoverId"
      [attr.aria-hidden]="!open"
      [attr.id]="popoverId"
      clrKeyFocus
      cdkTrapFocus
      (click)="closeOverflowContent($event)"
      *clrPopoverContent="open; at: smartPosition; outsideClickToClose: true; scrollToClose: true"
    >
      <ng-content></ng-content>
    </div>
  `
    }]
  }], function() {
    return [{
      type: RowActionService
    }, {
      type: ClrCommonStringsService
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [PLATFORM_ID]
      }]
    }, {
      type: NgZone
    }, {
      type: ClrPopoverToggleService
    }];
  }, {
    buttonLabel: [{
      type: Input,
      args: ["clrDgActionOverflowButtonLabel"]
    }],
    openChange: [{
      type: Output,
      args: ["clrDgActionOverflowOpenChange"]
    }],
    keyFocus: [{
      type: ViewChild,
      args: [ClrKeyFocus]
    }],
    open: [{
      type: Input,
      args: ["clrDgActionOverflowOpen"]
    }]
  });
})();
var columnToggleTrackByFn = (index) => index;
var ClrDatagridColumnToggleButton = class {
  constructor(commonStrings, columnsService) {
    this.commonStrings = commonStrings;
    this.columnsService = columnsService;
    this.allSelected = new EventEmitter();
  }
  get clrAllSelected() {
    return this.allSelected.asObservable();
  }
  get allHideablesVisible() {
    return this.hideableColumns().filter((column) => column.value.hidden).length === 0;
  }
  selectAll() {
    this.hideableColumns().forEach((hideableColumn) => this.columnsService.emitStateChange(hideableColumn, {
      hidden: false,
      changes: [DatagridColumnChanges.HIDDEN]
    }));
    this.allSelected.next(true);
  }
  hideableColumns() {
    return this.columnsService.columns.filter((column) => column.value.hideable);
  }
};
ClrDatagridColumnToggleButton.ɵfac = function ClrDatagridColumnToggleButton_Factory(t3) {
  return new (t3 || ClrDatagridColumnToggleButton)(ɵɵdirectiveInject(ClrCommonStringsService), ɵɵdirectiveInject(ColumnsService));
};
ClrDatagridColumnToggleButton.ɵcmp = ɵɵdefineComponent({
  type: ClrDatagridColumnToggleButton,
  selectors: [["clr-dg-column-toggle-button"]],
  outputs: {
    clrAllSelected: "clrAllSelected"
  },
  decls: 2,
  vars: 2,
  consts: [["type", "button", 1, "btn", "btn-sm", "btn-link", "switch-button", 3, "click", "disabled"]],
  template: function ClrDatagridColumnToggleButton_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "button", 0);
      ɵɵlistener("click", function ClrDatagridColumnToggleButton_Template_button_click_0_listener() {
        return ctx.selectAll();
      });
      ɵɵtext(1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("disabled", ctx.allHideablesVisible);
      ɵɵadvance();
      ɵɵtextInterpolate1(" ", ctx.commonStrings.keys.selectAll, " ");
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDatagridColumnToggleButton, [{
    type: Component,
    args: [{
      selector: "clr-dg-column-toggle-button",
      template: `
    <button
      class="btn btn-sm btn-link switch-button"
      (click)="selectAll()"
      [disabled]="allHideablesVisible"
      type="button"
    >
      {{ commonStrings.keys.selectAll }}
    </button>
  `
    }]
  }], function() {
    return [{
      type: ClrCommonStringsService
    }, {
      type: ColumnsService
    }];
  }, {
    clrAllSelected: [{
      type: Output,
      args: ["clrAllSelected"]
    }]
  });
})();
var ClrDatagridColumnToggle = class {
  constructor(commonStrings, columnsService, popoverToggleService) {
    this.commonStrings = commonStrings;
    this.columnsService = columnsService;
    this.popoverId = uniqueIdFactory();
    this.smartPosition = {
      axis: ClrAxis.VERTICAL,
      side: ClrSide.BEFORE,
      anchor: ClrAlignment.START,
      content: ClrAlignment.START
    };
    this.trackByFn = columnToggleTrackByFn;
    this.subscription = popoverToggleService.openChange.subscribe((change) => this.openState = change);
  }
  get allColumnsVisible() {
    return this._allColumnsVisible;
  }
  set allColumnsVisible(value) {
    this._allColumnsVisible = value;
  }
  get hideableColumnStates() {
    const hideables = this.columnsService.columns.filter((column) => column.value.hideable);
    return hideables.map((column) => column.value);
  }
  get hasOnlyOneVisibleColumn() {
    const nbNonHideableColumns = this.columnsService.columns.length - this.hideableColumnStates.length;
    return nbNonHideableColumns === 0 && this.hideableColumnStates.filter((columnState) => !columnState.hidden).length === 1;
  }
  ngOnDestroy() {
    this.subscription.unsubscribe();
  }
  toggleColumnState(columnState, event) {
    const columnToToggle = this.columnsService.columns.filter((column) => column.value === columnState)[0];
    this.columnsService.emitStateChange(columnToToggle, {
      hidden: event,
      changes: [DatagridColumnChanges.HIDDEN]
    });
  }
  toggleSwitchPanel() {
    this.openState = !this.openState;
  }
  allColumnsSelected() {
    this.allSelectedElement.nativeElement.focus();
  }
};
ClrDatagridColumnToggle.ɵfac = function ClrDatagridColumnToggle_Factory(t3) {
  return new (t3 || ClrDatagridColumnToggle)(ɵɵdirectiveInject(ClrCommonStringsService), ɵɵdirectiveInject(ColumnsService), ɵɵdirectiveInject(ClrPopoverToggleService));
};
ClrDatagridColumnToggle.ɵcmp = ɵɵdefineComponent({
  type: ClrDatagridColumnToggle,
  selectors: [["clr-dg-column-toggle"]],
  viewQuery: function ClrDatagridColumnToggle_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c72, 5, ElementRef);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.allSelectedElement = _t.first);
    }
  },
  hostVars: 4,
  hostBindings: function ClrDatagridColumnToggle_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("column-switch-wrapper", true)("active", ctx.openState);
    }
  },
  features: [ɵɵHostDirectivesFeature([ClrPopoverHostDirective])],
  decls: 3,
  vars: 8,
  consts: [["allSelected", ""], ["role", "button", "type", "button", "clrPopoverAnchor", "", "clrPopoverOpenCloseButton", "", 1, "btn", "btn-sm", "column-toggle--action"], ["class", "column-switch", "role", "dialog", "cdkTrapFocus", "", 3, "id", 4, "clrPopoverContent", "clrPopoverContentAt", "clrPopoverContentOutsideClickToClose", "clrPopoverContentScrollToClose"], ["role", "dialog", "cdkTrapFocus", "", 1, "column-switch", 3, "id"], [1, "switch-header"], ["tabindex", "-1", 1, "clr-sr-only"], ["clrPopoverCloseButton", "", "type", "button", 1, "btn", "btn-sm", "btn-link", "toggle-switch-close-button"], ["shape", "window-close", "aria-hidden", "true"], [1, "clr-sr-only"], [1, "switch-content", "list-unstyled"], [4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "switch-footer"], [3, "clrAllSelected"], ["clrCheckbox", "", "type", "checkbox", 3, "ngModelChange", "disabled", "ngModel"], [3, "ngTemplateOutlet"]],
  template: function ClrDatagridColumnToggle_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "button", 1);
      ɵɵtext(1);
      ɵɵelementEnd();
      ɵɵtemplate(2, ClrDatagridColumnToggle_div_2_Template, 15, 9, "div", 2);
    }
    if (rf & 2) {
      ɵɵattribute("aria-controls", ctx.popoverId)("aria-owns", ctx.popoverId)("aria-expanded", ctx.openState);
      ɵɵadvance();
      ɵɵtextInterpolate1(" ", ctx.commonStrings.keys.pickColumns, " ");
      ɵɵadvance();
      ɵɵproperty("clrPopoverContent", ctx.openState)("clrPopoverContentAt", ctx.smartPosition)("clrPopoverContentOutsideClickToClose", true)("clrPopoverContentScrollToClose", true);
    }
  },
  dependencies: [NgForOf, NgTemplateOutlet, CdkTrapFocusModule_CdkTrapFocus, CdsIconCustomTag, ClrLabel, ClrCheckbox, ClrCheckboxWrapper, CheckboxControlValueAccessor, NgControlStatus, NgModel, ClrPopoverAnchor, ClrPopoverCloseButton, ClrPopoverOpenCloseButton, ClrPopoverContent, ClrDatagridColumnToggleButton],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDatagridColumnToggle, [{
    type: Component,
    args: [{
      selector: "clr-dg-column-toggle",
      template: `
    <button
      role="button"
      type="button"
      class="btn btn-sm column-toggle--action"
      clrPopoverAnchor
      clrPopoverOpenCloseButton
      [attr.aria-controls]="popoverId"
      [attr.aria-owns]="popoverId"
      [attr.aria-expanded]="openState"
    >
      {{ commonStrings.keys.pickColumns }}
    </button>
    <div
      class="column-switch"
      role="dialog"
      [attr.aria-label]="commonStrings.keys.showColumnsMenuDescription"
      [id]="popoverId"
      cdkTrapFocus
      *clrPopoverContent="openState; at: smartPosition; outsideClickToClose: true; scrollToClose: true"
    >
      <div class="switch-header">
        <div class="clr-sr-only" tabindex="-1" #allSelected>{{ commonStrings.keys.allColumnsSelected }}</div>
        <h2>{{ commonStrings.keys.showColumns }}</h2>
        <button
          class="btn btn-sm btn-link toggle-switch-close-button"
          clrPopoverCloseButton
          type="button"
          [attr.aria-label]="commonStrings.keys.close"
        >
          <cds-icon shape="window-close" aria-hidden="true" [attr.title]="commonStrings.keys.close"></cds-icon>
          <span class="clr-sr-only">{{ commonStrings.keys.close }}</span>
        </button>
      </div>
      <ul class="switch-content list-unstyled">
        <li *ngFor="let columnState of hideableColumnStates; trackBy: trackByFn">
          <clr-checkbox-wrapper>
            <input
              clrCheckbox
              type="checkbox"
              [disabled]="hasOnlyOneVisibleColumn && !columnState.hidden"
              [ngModel]="!columnState.hidden"
              (ngModelChange)="toggleColumnState(columnState, !$event)"
            />
            <label>
              <ng-template [ngTemplateOutlet]="columnState.titleTemplateRef"></ng-template>
            </label>
          </clr-checkbox-wrapper>
        </li>
      </ul>
      <div class="switch-footer">
        <clr-dg-column-toggle-button (clrAllSelected)="allColumnsSelected()"></clr-dg-column-toggle-button>
      </div>
    </div>
  `,
      host: {
        "[class.column-switch-wrapper]": "true",
        "[class.active]": "openState"
      },
      hostDirectives: [ClrPopoverHostDirective]
    }]
  }], function() {
    return [{
      type: ClrCommonStringsService
    }, {
      type: ColumnsService
    }, {
      type: ClrPopoverToggleService
    }];
  }, {
    allSelectedElement: [{
      type: ViewChild,
      args: ["allSelected", {
        read: ElementRef
      }]
    }]
  });
})();
var ClrDatagridDetailHeader = class {
  constructor(detailService, commonStrings) {
    this.detailService = detailService;
    this.commonStrings = commonStrings;
  }
  get titleId() {
    return `${this.detailService.id}-title`;
  }
  ngAfterViewInit() {
    this.title.nativeElement.focus();
  }
};
ClrDatagridDetailHeader.ɵfac = function ClrDatagridDetailHeader_Factory(t3) {
  return new (t3 || ClrDatagridDetailHeader)(ɵɵdirectiveInject(DetailService), ɵɵdirectiveInject(ClrCommonStringsService));
};
ClrDatagridDetailHeader.ɵcmp = ɵɵdefineComponent({
  type: ClrDatagridDetailHeader,
  selectors: [["clr-dg-detail-header"]],
  viewQuery: function ClrDatagridDetailHeader_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c73, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.title = _t.first);
    }
  },
  hostVars: 2,
  hostBindings: function ClrDatagridDetailHeader_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("datagrid-detail-header", true);
    }
  },
  ngContentSelectors: _c02,
  decls: 6,
  vars: 2,
  consts: [["title", ""], ["tabindex", "-1", 1, "datagrid-detail-header-title", 3, "id"], [1, "datagrid-detail-pane-close"], ["type", "button", 1, "btn", "btn-link", 3, "click"], ["shape", "times"]],
  template: function ClrDatagridDetailHeader_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵprojectionDef();
      ɵɵelementStart(0, "div", 1, 0);
      ɵɵprojection(2);
      ɵɵelementEnd();
      ɵɵelementStart(3, "div", 2)(4, "button", 3);
      ɵɵlistener("click", function ClrDatagridDetailHeader_Template_button_click_4_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.detailService.close());
      });
      ɵɵelement(5, "cds-icon", 4);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵproperty("id", ctx.titleId);
      ɵɵadvance(4);
      ɵɵattribute("aria-label", ctx.commonStrings.keys.close);
    }
  },
  dependencies: [CdsIconCustomTag],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDatagridDetailHeader, [{
    type: Component,
    args: [{
      selector: "clr-dg-detail-header",
      host: {
        "[class.datagrid-detail-header]": "true"
      },
      template: `
    <div #title class="datagrid-detail-header-title" tabindex="-1" [id]="titleId">
      <ng-content></ng-content>
    </div>
    <div class="datagrid-detail-pane-close">
      <button
        type="button"
        class="btn btn-link"
        (click)="detailService.close()"
        [attr.aria-label]="commonStrings.keys.close"
      >
        <cds-icon shape="times"></cds-icon>
      </button>
    </div>
  `
    }]
  }], function() {
    return [{
      type: DetailService
    }, {
      type: ClrCommonStringsService
    }];
  }, {
    title: [{
      type: ViewChild,
      args: ["title"]
    }]
  });
})();
var ClrDatagridDetail = class {
  constructor(detailService, commonStrings) {
    this.detailService = detailService;
    this.commonStrings = commonStrings;
  }
  get labelledBy() {
    if (this.ariaLabelledBy) {
      return this.header ? `${this.header.titleId} ${this.ariaLabelledBy}` : this.ariaLabelledBy;
    } else if (this.ariaLabel) {
      return null;
    } else {
      return this.header?.titleId || "";
    }
  }
  get label() {
    if (!this.ariaLabelledBy) {
      return this.ariaLabel || null;
    } else {
      return null;
    }
  }
  close() {
    this.detailService.close();
  }
};
ClrDatagridDetail.ɵfac = function ClrDatagridDetail_Factory(t3) {
  return new (t3 || ClrDatagridDetail)(ɵɵdirectiveInject(DetailService), ɵɵdirectiveInject(ClrCommonStringsService));
};
ClrDatagridDetail.ɵcmp = ɵɵdefineComponent({
  type: ClrDatagridDetail,
  selectors: [["clr-dg-detail"]],
  contentQueries: function ClrDatagridDetail_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ClrDatagridDetailHeader, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.header = _t.first);
    }
  },
  hostVars: 2,
  hostBindings: function ClrDatagridDetail_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("datagrid-detail-pane", true);
    }
  },
  inputs: {
    ariaLabelledBy: [InputFlags.None, "clrDetailAriaLabelledBy", "ariaLabelledBy"],
    ariaLabel: [InputFlags.None, "clrDetailAriaLabel", "ariaLabel"]
  },
  ngContentSelectors: _c02,
  decls: 1,
  vars: 1,
  consts: [["cdkTrapFocus", "", "class", "datagrid-detail-pane-content", "role", "dialog", "aria-modal", "true", 3, "cdkTrapFocusAutoCapture", "id", 4, "ngIf"], ["cdkTrapFocus", "", "role", "dialog", "aria-modal", "true", 1, "datagrid-detail-pane-content", 3, "cdkTrapFocusAutoCapture", "id"], [1, "clr-sr-only"]],
  template: function ClrDatagridDetail_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵtemplate(0, ClrDatagridDetail_div_0_Template, 6, 6, "div", 0);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.detailService.isOpen);
    }
  },
  dependencies: [NgIf, CdkTrapFocusModule_CdkTrapFocus],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDatagridDetail, [{
    type: Component,
    args: [{
      selector: "clr-dg-detail",
      host: {
        "[class.datagrid-detail-pane]": "true"
      },
      // We put the *ngIf on the cdkTrapFocus so it doesn't always exist on the page
      // have to test for presence of header for aria-describedby because it was causing unit tests to crash
      template: `
    <div
      cdkTrapFocus
      [cdkTrapFocusAutoCapture]="!header"
      class="datagrid-detail-pane-content"
      *ngIf="detailService.isOpen"
      role="dialog"
      [id]="detailService.id"
      aria-modal="true"
      [attr.aria-labelledby]="labelledBy"
      [attr.aria-label]="label"
    >
      <div class="clr-sr-only">{{ commonStrings.keys.detailPaneStart }}</div>
      <ng-content></ng-content>
      <div class="clr-sr-only">{{ commonStrings.keys.detailPaneEnd }}</div>
    </div>
  `
    }]
  }], function() {
    return [{
      type: DetailService
    }, {
      type: ClrCommonStringsService
    }];
  }, {
    ariaLabelledBy: [{
      type: Input,
      args: ["clrDetailAriaLabelledBy"]
    }],
    ariaLabel: [{
      type: Input,
      args: ["clrDetailAriaLabel"]
    }],
    header: [{
      type: ContentChild,
      args: [ClrDatagridDetailHeader]
    }]
  });
})();
var ClrDatagridDetailBody = class {
};
ClrDatagridDetailBody.ɵfac = function ClrDatagridDetailBody_Factory(t3) {
  return new (t3 || ClrDatagridDetailBody)();
};
ClrDatagridDetailBody.ɵcmp = ɵɵdefineComponent({
  type: ClrDatagridDetailBody,
  selectors: [["clr-dg-detail-body"]],
  hostVars: 2,
  hostBindings: function ClrDatagridDetailBody_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("datagrid-detail-body", true);
    }
  },
  ngContentSelectors: _c02,
  decls: 2,
  vars: 0,
  consts: [[1, "clr-dg-detail-body-wrapper"]],
  template: function ClrDatagridDetailBody_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "div", 0);
      ɵɵprojection(1);
      ɵɵelementEnd();
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDatagridDetailBody, [{
    type: Component,
    args: [{
      selector: "clr-dg-detail-body",
      template: `
    <div class="clr-dg-detail-body-wrapper">
      <ng-content></ng-content>
    </div>
  `,
      host: {
        "[class.datagrid-detail-body]": "true"
      }
    }]
  }], null, null);
})();
var DatagridDetailRegisterer = class {
  constructor(expandableRowsCount) {
    this.expandableRowsCount = expandableRowsCount;
    if (this.expandableRowsCount) {
      this.expandableRowsCount.register();
    }
  }
  ngOnDestroy() {
    if (this.expandableRowsCount) {
      this.expandableRowsCount.unregister();
    }
  }
};
DatagridDetailRegisterer.ɵfac = function DatagridDetailRegisterer_Factory(t3) {
  return new (t3 || DatagridDetailRegisterer)(ɵɵdirectiveInject(ExpandableRowsCount, 8));
};
DatagridDetailRegisterer.ɵdir = ɵɵdefineDirective({
  type: DatagridDetailRegisterer,
  selectors: [["", "clrIfExpanded", ""]]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DatagridDetailRegisterer, [{
    type: Directive,
    args: [{
      selector: "[clrIfExpanded]"
    }]
  }], function() {
    return [{
      type: ExpandableRowsCount,
      decorators: [{
        type: Optional
      }]
    }];
  }, null);
})();
var ClrDatagridFooter = class {
  constructor(selection, detailService, columnsService, commonStrings) {
    this.selection = selection;
    this.detailService = detailService;
    this.columnsService = columnsService;
    this.commonStrings = commonStrings;
    this.SELECTION_TYPE = SelectionType;
  }
  get hasHideableColumns() {
    return this.columnsService.hasHideableColumns;
  }
};
ClrDatagridFooter.ɵfac = function ClrDatagridFooter_Factory(t3) {
  return new (t3 || ClrDatagridFooter)(ɵɵdirectiveInject(Selection), ɵɵdirectiveInject(DetailService), ɵɵdirectiveInject(ColumnsService), ɵɵdirectiveInject(ClrCommonStringsService));
};
ClrDatagridFooter.ɵcmp = ɵɵdefineComponent({
  type: ClrDatagridFooter,
  selectors: [["clr-dg-footer"]],
  hostVars: 2,
  hostBindings: function ClrDatagridFooter_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("datagrid-footer", true);
    }
  },
  ngContentSelectors: _c75,
  decls: 3,
  vars: 2,
  consts: [[4, "ngIf"], [1, "clr-form-control-disabled"], [1, "datagrid-footer-select"], ["clrCheckbox", "", "type", "checkbox", "checked", "checked", "disabled", ""], [1, "clr-sr-only"], [1, "datagrid-footer-description"]],
  template: function ClrDatagridFooter_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c74);
      ɵɵtemplate(0, ClrDatagridFooter_ng_container_0_Template, 8, 2, "ng-container", 0)(1, ClrDatagridFooter_ng_container_1_Template, 4, 1, "ng-container", 0);
      ɵɵprojection(2);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.selection.selectionType === ctx.SELECTION_TYPE.Multi && ctx.selection.current.length > 0);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.detailService.isOpen);
    }
  },
  dependencies: [NgIf, ClrLabel, ClrCheckbox, ClrCheckboxWrapper, ClrDatagridColumnToggle],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDatagridFooter, [{
    type: Component,
    args: [{
      selector: "clr-dg-footer",
      template: `
    <ng-container *ngIf="selection.selectionType === SELECTION_TYPE.Multi && selection.current.length > 0">
      <div class="clr-form-control-disabled">
        <clr-checkbox-wrapper class="datagrid-footer-select">
          <input clrCheckbox type="checkbox" checked="checked" disabled />
          <label>{{ selection.current.length }}</label>
          <span class="clr-sr-only">{{ commonStrings.keys.selectedRows }}</span>
        </clr-checkbox-wrapper>
      </div>
    </ng-container>
    <ng-container *ngIf="!detailService.isOpen">
      <clr-dg-column-toggle *ngIf="hasHideableColumns"></clr-dg-column-toggle>
      <div class="datagrid-footer-description">
        <ng-content></ng-content>
      </div>
    </ng-container>
    <ng-content select="clr-dg-pagination"></ng-content>
  `,
      host: {
        "[class.datagrid-footer]": "true"
      }
    }]
  }], function() {
    return [{
      type: Selection
    }, {
      type: DetailService
    }, {
      type: ColumnsService
    }, {
      type: ClrCommonStringsService
    }];
  }, null);
})();
var COLUMN_STATE = new InjectionToken("COLUMN_STATE");
function columnStateFactory() {
  return new BehaviorSubject({
    changes: []
  });
}
var COLUMN_STATE_PROVIDER = {
  provide: COLUMN_STATE,
  useFactory: columnStateFactory
};
var ClrDatagridHideableColumn = class {
  constructor(titleTemplateRef, viewContainerRef, columnsService, columnState) {
    this.titleTemplateRef = titleTemplateRef;
    this.viewContainerRef = viewContainerRef;
    this.columnsService = columnsService;
    this.columnState = columnState;
    this.hiddenChange = new EventEmitter();
    this.subscriptions = [];
    this.viewContainerRef.createEmbeddedView(this.titleTemplateRef);
    if (!this.columnState) {
      throw new Error("The *clrDgHideableColumn directive can only be used inside of a clr-dg-column component.");
    }
  }
  /**
   *
   * @description
   * Setter fn for the @Input with the same name as this structural directive.
   * It allows the user to pre-configure the column's hide/show state. { hidden: true }
   * It's more verbose but has more Clarity.
   *
   * @example
   * *clrDgHideableColumn
   * *clrDgHideableColumn={hidden: false}
   * *clrDgHideableColumn={hidden: true}
   *
   */
  set clrDgHideableColumn(value) {
    if (typeof value === "string") {
      this.clrDgHidden = false;
      return;
    }
    this.clrDgHidden = value && value.hidden ? value.hidden : false;
  }
  set clrDgHidden(hidden) {
    this._hidden = hidden ? hidden : false;
    this.columnsService.emitStateChange(this.columnState, {
      hidden: this._hidden,
      changes: [DatagridColumnChanges.HIDDEN]
    });
  }
  ngOnInit() {
    this.columnsService.emitStateChange(this.columnState, {
      hideable: true,
      titleTemplateRef: this.titleTemplateRef,
      hidden: this._hidden,
      changes: [DatagridColumnChanges.HIDDEN]
    });
    this.subscriptions.push(this.columnState.subscribe((state2) => {
      if (state2.changes && state2.changes.indexOf(DatagridColumnChanges.HIDDEN) > -1) {
        this.hiddenChange.emit(state2.hidden);
      }
    }));
  }
  ngOnDestroy() {
    this.subscriptions.forEach((sub) => sub.unsubscribe());
  }
};
ClrDatagridHideableColumn.ɵfac = function ClrDatagridHideableColumn_Factory(t3) {
  return new (t3 || ClrDatagridHideableColumn)(ɵɵdirectiveInject(TemplateRef), ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(ColumnsService), ɵɵdirectiveInject(COLUMN_STATE, 8));
};
ClrDatagridHideableColumn.ɵdir = ɵɵdefineDirective({
  type: ClrDatagridHideableColumn,
  selectors: [["", "clrDgHideableColumn", ""]],
  inputs: {
    clrDgHideableColumn: "clrDgHideableColumn",
    clrDgHidden: "clrDgHidden"
  },
  outputs: {
    hiddenChange: "clrDgHiddenChange"
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDatagridHideableColumn, [{
    type: Directive,
    args: [{
      selector: "[clrDgHideableColumn]"
    }]
  }], function() {
    return [{
      type: TemplateRef
    }, {
      type: ViewContainerRef
    }, {
      type: ColumnsService
    }, {
      type: BehaviorSubject,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [COLUMN_STATE]
      }]
    }];
  }, {
    hiddenChange: [{
      type: Output,
      args: ["clrDgHiddenChange"]
    }],
    clrDgHideableColumn: [{
      type: Input,
      args: ["clrDgHideableColumn"]
    }],
    clrDgHidden: [{
      type: Input,
      args: ["clrDgHidden"]
    }]
  });
})();
var ClrIfDetail = class {
  constructor(templateRef, viewContainer, detailService) {
    this.templateRef = templateRef;
    this.viewContainer = viewContainer;
    this.detailService = detailService;
    this.stateChange = new EventEmitter(null);
    this.subscriptions = [];
    this.skip = false;
    this.detailService.enabled = true;
  }
  set state(model) {
    if (!this.skip) {
      this.detailService.toggle(model);
    }
    this.skip = false;
  }
  get viewContext() {
    return {
      $implicit: this.detailService.state
    };
  }
  ngOnInit() {
    this.subscriptions.push(this.detailService.stateChange.subscribe((state2) => {
      if (state2 === true) {
        this.togglePanel(true);
      } else {
        this.togglePanel(false);
      }
    }));
  }
  ngOnDestroy() {
    this.subscriptions.forEach((sub) => sub.unsubscribe());
  }
  togglePanel(showPanel) {
    let stateChangeParams = null;
    if (showPanel === true) {
      if (!this.embeddedViewRef) {
        const viewContext = this._createContextForwardProxy();
        this.embeddedViewRef = this.viewContainer.createEmbeddedView(this.templateRef, viewContext);
      }
      this.skip = true;
      stateChangeParams = this.detailService.state;
    } else {
      this.viewContainer.clear();
      this.embeddedViewRef = null;
    }
    this.stateChange.emit(stateChangeParams);
  }
  /**
   * For a given outlet instance, we create a proxy object that delegates
   * to the user-specified context. This allows changing, or swapping out
   * the context object completely without having to destroy/re-create the view.
   */
  _createContextForwardProxy() {
    return new Proxy({}, {
      set: (_target, prop, newValue) => {
        if (!this.viewContext) {
          return false;
        }
        return Reflect.set(this.viewContext, prop, newValue);
      },
      get: (_target, prop, receiver) => {
        if (!this.viewContext) {
          return void 0;
        }
        return Reflect.get(this.viewContext, prop, receiver);
      }
    });
  }
};
ClrIfDetail.ɵfac = function ClrIfDetail_Factory(t3) {
  return new (t3 || ClrIfDetail)(ɵɵdirectiveInject(TemplateRef), ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(DetailService));
};
ClrIfDetail.ɵdir = ɵɵdefineDirective({
  type: ClrIfDetail,
  selectors: [["", "clrIfDetail", ""]],
  inputs: {
    state: [InputFlags.None, "clrIfDetail", "state"]
  },
  outputs: {
    stateChange: "clrIfDetailChange"
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrIfDetail, [{
    type: Directive,
    args: [{
      selector: "[clrIfDetail]"
    }]
  }], function() {
    return [{
      type: TemplateRef
    }, {
      type: ViewContainerRef
    }, {
      type: DetailService
    }];
  }, {
    stateChange: [{
      type: Output,
      args: ["clrIfDetailChange"]
    }],
    state: [{
      type: Input,
      args: ["clrIfDetail"]
    }]
  });
})();
var ClrDatagridPageSize = class {
  constructor(page) {
    this.page = page;
    this.pageSizeOptionsId = uniqueIdFactory();
  }
  ngOnInit() {
    if (!this.pageSizeOptions || this.pageSizeOptions.length === 0) {
      this.pageSizeOptions = [this.page.size];
    }
  }
};
ClrDatagridPageSize.ɵfac = function ClrDatagridPageSize_Factory(t3) {
  return new (t3 || ClrDatagridPageSize)(ɵɵdirectiveInject(Page));
};
ClrDatagridPageSize.ɵcmp = ɵɵdefineComponent({
  type: ClrDatagridPageSize,
  selectors: [["clr-dg-page-size"]],
  inputs: {
    pageSizeOptions: [InputFlags.None, "clrPageSizeOptions", "pageSizeOptions"],
    pageSizeOptionsId: [InputFlags.None, "clrPageSizeOptionsId", "pageSizeOptionsId"]
  },
  ngContentSelectors: _c02,
  decls: 5,
  vars: 6,
  consts: [[3, "for"], [1, "clr-select-wrapper"], [3, "ngModelChange", "id", "ngModel"], [3, "ngValue", 4, "ngFor", "ngForOf"], [3, "ngValue"]],
  template: function ClrDatagridPageSize_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "label", 0);
      ɵɵprojection(1);
      ɵɵelementEnd();
      ɵɵelementStart(2, "div", 1)(3, "select", 2);
      ɵɵtwoWayListener("ngModelChange", function ClrDatagridPageSize_Template_select_ngModelChange_3_listener($event) {
        ɵɵtwoWayBindingSet(ctx.page.size, $event) || (ctx.page.size = $event);
        return $event;
      });
      ɵɵtemplate(4, ClrDatagridPageSize_option_4_Template, 2, 2, "option", 3);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵproperty("for", ctx.pageSizeOptionsId);
      ɵɵadvance(3);
      ɵɵclassProp("clr-page-size-select", true);
      ɵɵproperty("id", ctx.pageSizeOptionsId);
      ɵɵtwoWayProperty("ngModel", ctx.page.size);
      ɵɵadvance();
      ɵɵproperty("ngForOf", ctx.pageSizeOptions);
    }
  },
  dependencies: [NgForOf, ClrLabel, NgSelectOption, ɵNgSelectMultipleOption, SelectControlValueAccessor, NgControlStatus, NgModel],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDatagridPageSize, [{
    type: Component,
    args: [{
      selector: "clr-dg-page-size",
      template: `
    <label [for]="pageSizeOptionsId"><ng-content></ng-content></label>
    <div class="clr-select-wrapper">
      <select [id]="pageSizeOptionsId" [class.clr-page-size-select]="true" [(ngModel)]="page.size">
        <option *ngFor="let option of pageSizeOptions" [ngValue]="option">{{ option }}</option>
      </select>
    </div>
  `
    }]
  }], function() {
    return [{
      type: Page
    }];
  }, {
    pageSizeOptions: [{
      type: Input,
      args: ["clrPageSizeOptions"]
    }],
    pageSizeOptionsId: [{
      type: Input,
      args: ["clrPageSizeOptionsId"]
    }]
  });
})();
var ClrDatagridPagination = class {
  constructor(page, commonStrings, detailService) {
    this.page = page;
    this.commonStrings = commonStrings;
    this.detailService = detailService;
    this.currentChanged = new EventEmitter(false);
    this.page.activated = true;
  }
  /**
   * Page size
   */
  get pageSize() {
    return this.page.size;
  }
  set pageSize(size) {
    if (typeof size === "number") {
      this.page.size = size;
    }
  }
  /**
   * Total items (needed to guess the last page)
   */
  get totalItems() {
    return this.page.totalItems;
  }
  set totalItems(total) {
    if (typeof total === "number") {
      this.page.totalItems = total;
    }
  }
  /**
   * Last page
   */
  get lastPage() {
    return this.page.last;
  }
  set lastPage(last) {
    if (typeof last === "number") {
      this.page.last = last;
    }
  }
  /**
   * Current page
   */
  get currentPage() {
    return this.page.current;
  }
  set currentPage(page) {
    if (typeof page === "number") {
      this.page.current = page;
    }
  }
  /**
   * Index of the first item displayed on the current page, starting at 0, -1 if none displayed
   */
  get firstItem() {
    return this.page.firstItem;
  }
  /**
   * Index of the last item displayed on the current page, starting at 0, -1 if none displayed
   */
  get lastItem() {
    return this.page.lastItem;
  }
  /**
   * Conditionally adds page numbers before and after the current page
   */
  get middlePages() {
    const middlePages = [];
    if (this.page.current > 1) {
      middlePages.push(this.page.current - 1);
    }
    middlePages.push(this.page.current);
    if (this.page.current < this.page.last) {
      middlePages.push(this.page.current + 1);
    }
    return middlePages;
  }
  /**********
   * Subscription to the Page service for page changes.
   * Note: this only emits after the datagrid is initialized/stabalized and the page changes.
   */
  ngOnInit() {
    if (!this.page.size) {
      this.page.size = 10;
    }
    this._pageSubscription = this.page.change.subscribe((current) => this.currentChanged.emit(current));
  }
  ngOnDestroy() {
    this.page.resetPageSize(true);
    if (this._pageSubscription) {
      this._pageSubscription.unsubscribe();
    }
  }
  /**
   * Moves to the previous page if it exists
   */
  previous() {
    this.page.previous();
  }
  /**
   * Moves to the next page if it exists
   */
  next() {
    this.page.next();
  }
  verifyCurrentPage(event) {
    const parsed = parseInt(event.target.value, 10);
    if (parsed !== this.page.current) {
      event.target.value = this.page.current;
    }
  }
  /**
   * We only update the pagination's current page on enter.
   */
  updateCurrentPage(event) {
    const parsed = parseInt(event.target.value, 10);
    if (!isNaN(parsed)) {
      if (parsed < 1) {
        this.page.current = 1;
      } else if (parsed > this.page.last) {
        this.page.current = this.page.last;
      } else {
        this.page.current = parsed;
      }
    }
    this.currentPageInputRef.nativeElement.value = this.page.current;
  }
};
ClrDatagridPagination.ɵfac = function ClrDatagridPagination_Factory(t3) {
  return new (t3 || ClrDatagridPagination)(ɵɵdirectiveInject(Page), ɵɵdirectiveInject(ClrCommonStringsService), ɵɵdirectiveInject(DetailService));
};
ClrDatagridPagination.ɵcmp = ɵɵdefineComponent({
  type: ClrDatagridPagination,
  selectors: [["clr-dg-pagination"]],
  contentQueries: function ClrDatagridPagination_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ClrDatagridPageSize, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._pageSizeComponent = _t.first);
    }
  },
  viewQuery: function ClrDatagridPagination_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c76, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.currentPageInputRef = _t.first);
    }
  },
  hostVars: 2,
  hostBindings: function ClrDatagridPagination_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("pagination", true);
    }
  },
  inputs: {
    disableCurrentPageInput: [InputFlags.None, "clrDgPageInputDisabled", "disableCurrentPageInput"],
    pageSize: [InputFlags.None, "clrDgPageSize", "pageSize"],
    totalItems: [InputFlags.None, "clrDgTotalItems", "totalItems"],
    lastPage: [InputFlags.None, "clrDgLastPage", "lastPage"],
    currentPage: [InputFlags.None, "clrDgPage", "currentPage"]
  },
  outputs: {
    currentChanged: "clrDgPageChange"
  },
  ngContentSelectors: _c78,
  decls: 2,
  vars: 2,
  consts: [["readOnly", ""], ["currentPageInput", ""], [4, "ngIf"], ["class", "pagination-size", 4, "ngIf"], [1, "pagination-description"], ["class", "pagination-list", 4, "ngIf"], [1, "pagination-size"], [1, "pagination-list"], ["type", "button", 1, "pagination-first", 3, "click", "disabled"], [1, "clr-sr-only"], ["shape", "step-forward-2", "direction", "down"], ["type", "button", 1, "pagination-previous", 3, "click", "disabled"], ["shape", "angle", "direction", "left"], ["type", "text", "class", "pagination-current clr-input", 3, "size", "value", "keydown.enter", "blur", 4, "ngIf", "ngIfElse"], ["type", "button", 1, "pagination-next", 3, "click", "disabled"], ["shape", "angle", "direction", "right"], ["type", "button", 1, "pagination-last", 3, "click", "disabled"], ["shape", "step-forward-2", "direction", "up"], ["type", "text", 1, "pagination-current", "clr-input", 3, "keydown.enter", "blur", "size", "value"], [1, "pagination-description-compact"]],
  template: function ClrDatagridPagination_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c77);
      ɵɵtemplate(0, ClrDatagridPagination_ng_container_0_Template, 5, 2, "ng-container", 2)(1, ClrDatagridPagination_ng_container_1_Template, 14, 10, "ng-container", 2);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", !ctx.detailService.isOpen);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.detailService.isOpen);
    }
  },
  dependencies: [NgIf, CdsIconCustomTag],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDatagridPagination, [{
    type: Component,
    args: [{
      selector: "clr-dg-pagination",
      template: `
    <ng-container *ngIf="!detailService.isOpen">
      <div class="pagination-size" *ngIf="_pageSizeComponent">
        <ng-content select="clr-dg-page-size"></ng-content>
      </div>
      <div class="pagination-description">
        <ng-content></ng-content>
      </div>
      <div class="pagination-list" *ngIf="page.last > 1">
        <button
          type="button"
          class="pagination-first"
          [disabled]="page.current <= 1"
          (click)="page.current = 1"
          [attr.aria-label]="commonStrings.keys.firstPage"
        >
          <span class="clr-sr-only">{{ commonStrings.keys.firstPage }}</span>
          <cds-icon shape="step-forward-2" direction="down"></cds-icon>
        </button>
        <button
          type="button"
          class="pagination-previous"
          [disabled]="page.current <= 1"
          (click)="page.current = page.current - 1"
          [attr.aria-label]="commonStrings.keys.previousPage"
        >
          <span class="clr-sr-only">{{ commonStrings.keys.previousPage }}</span>
          <cds-icon shape="angle" direction="left"></cds-icon>
        </button>
        <input
          *ngIf="!disableCurrentPageInput; else readOnly"
          #currentPageInput
          type="text"
          class="pagination-current clr-input"
          [size]="page.last.toString().length"
          [value]="page.current"
          (keydown.enter)="updateCurrentPage($event)"
          (blur)="verifyCurrentPage($event)"
          [attr.aria-label]="commonStrings.keys.currentPage"
        />
        <ng-template #readOnly>
          <span>{{ page.current }}</span>
        </ng-template>

        &nbsp;/&nbsp;<span [attr.aria-label]="commonStrings.keys.totalPages">{{ page.last }}</span>
        <button
          type="button"
          class="pagination-next"
          [disabled]="page.current >= page.last"
          (click)="page.current = page.current + 1"
          [attr.aria-label]="commonStrings.keys.nextPage"
        >
          <span class="clr-sr-only">{{ commonStrings.keys.nextPage }}</span>
          <cds-icon shape="angle" direction="right"></cds-icon>
        </button>
        <button
          type="button"
          class="pagination-last"
          [disabled]="page.current >= page.last"
          (click)="page.current = page.last"
          [attr.aria-label]="commonStrings.keys.lastPage"
        >
          <span class="clr-sr-only">{{ commonStrings.keys.lastPage }}</span>
          <cds-icon shape="step-forward-2" direction="up"></cds-icon>
        </button>
      </div>
    </ng-container>
    <ng-container *ngIf="detailService.isOpen">
      <div class="pagination-description-compact">
        {{ page.firstItem + 1 }}-{{ page.lastItem + 1 }} / {{ page.totalItems }}
      </div>
      <div class="pagination-list">
        <button
          type="button"
          class="pagination-previous"
          [disabled]="page.current <= 1"
          (click)="page.current = page.current - 1"
          [attr.aria-label]="commonStrings.keys.previousPage"
        >
          <span class="clr-sr-only">{{ commonStrings.keys.previousPage }}</span>
          <cds-icon shape="angle" direction="left"></cds-icon>
        </button>
        <span>{{ page.current }}</span>
        <button
          type="button"
          class="pagination-next"
          [disabled]="page.current >= page.last"
          (click)="page.current = page.current + 1"
          [attr.aria-label]="commonStrings.keys.nextPage"
        >
          <span class="clr-sr-only">{{ commonStrings.keys.nextPage }}</span>
          <cds-icon shape="angle" direction="right"></cds-icon>
        </button>
      </div>
    </ng-container>
  `,
      host: {
        "[class.pagination]": "true"
      }
    }]
  }], function() {
    return [{
      type: Page
    }, {
      type: ClrCommonStringsService
    }, {
      type: DetailService
    }];
  }, {
    disableCurrentPageInput: [{
      type: Input,
      args: ["clrDgPageInputDisabled"]
    }],
    currentChanged: [{
      type: Output,
      args: ["clrDgPageChange"]
    }],
    _pageSizeComponent: [{
      type: ContentChild,
      args: [ClrDatagridPageSize]
    }],
    currentPageInputRef: [{
      type: ViewChild,
      args: ["currentPageInput"]
    }],
    pageSize: [{
      type: Input,
      args: ["clrDgPageSize"]
    }],
    totalItems: [{
      type: Input,
      args: ["clrDgTotalItems"]
    }],
    lastPage: [{
      type: Input,
      args: ["clrDgLastPage"]
    }],
    currentPage: [{
      type: Input,
      args: ["clrDgPage"]
    }]
  });
})();
var ClrDatagridRowDetail = class {
  constructor(selection, rowActionService, expand, expandableRows, commonStrings) {
    this.selection = selection;
    this.rowActionService = rowActionService;
    this.expand = expand;
    this.expandableRows = expandableRows;
    this.commonStrings = commonStrings;
    this.replacedRow = false;
    this.SELECTION_TYPE = SelectionType;
    this.subscriptions = [];
  }
  set replace(value) {
    this.expand.setReplace(!!value);
  }
  get beginningOfExpandableContentAriaText() {
    return this._beginningOfExpandableContentAriaText || `${this.commonStrings.keys.datagridExpandableBeginningOf} 
      ${this.commonStrings.keys.datagridExpandableRowContent}`;
  }
  get endOfExpandableContentAriaText() {
    return this._endOfExpandableContentAriaText || `${this.commonStrings.keys.datagridExpandableEndOf} 
      ${this.commonStrings.keys.datagridExpandableRowContent}`;
  }
  ngAfterContentInit() {
    this.subscriptions.push(this.expand.replace.subscribe((replaceChange) => {
      this.replacedRow = replaceChange;
    }));
  }
  ngOnDestroy() {
    this.subscriptions.forEach((sub) => sub.unsubscribe());
  }
};
ClrDatagridRowDetail.ɵfac = function ClrDatagridRowDetail_Factory(t3) {
  return new (t3 || ClrDatagridRowDetail)(ɵɵdirectiveInject(Selection), ɵɵdirectiveInject(RowActionService), ɵɵdirectiveInject(DatagridIfExpandService), ɵɵdirectiveInject(ExpandableRowsCount), ɵɵdirectiveInject(ClrCommonStringsService));
};
ClrDatagridRowDetail.ɵcmp = ɵɵdefineComponent({
  type: ClrDatagridRowDetail,
  selectors: [["clr-dg-row-detail"]],
  contentQueries: function ClrDatagridRowDetail_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ClrDatagridCell, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.cells = _t);
    }
  },
  hostAttrs: ["role", "gridcell"],
  hostVars: 7,
  hostBindings: function ClrDatagridRowDetail_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("id", ctx.expand.expandableId);
      ɵɵclassProp("datagrid-row-flex", true)("datagrid-row-detail", true)("datagrid-container", ctx.cells.length === 0);
    }
  },
  inputs: {
    _beginningOfExpandableContentAriaText: [InputFlags.None, "clrRowDetailBeginningAriaText", "_beginningOfExpandableContentAriaText"],
    _endOfExpandableContentAriaText: [InputFlags.None, "clrRowDetailEndAriaText", "_endOfExpandableContentAriaText"],
    replace: [InputFlags.None, "clrDgReplace", "replace"]
  },
  ngContentSelectors: _c02,
  decls: 5,
  vars: 3,
  consts: [[1, "clr-sr-only"]],
  template: function ClrDatagridRowDetail_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "div", 0);
      ɵɵtext(1);
      ɵɵelementEnd();
      ɵɵprojection(2);
      ɵɵelementStart(3, "div", 0);
      ɵɵtext(4);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵtextInterpolate2(" ", ctx.beginningOfExpandableContentAriaText, " ", ctx.commonStrings.keys.datagridExpandableRowsHelperText, " ");
      ɵɵadvance(3);
      ɵɵtextInterpolate(ctx.endOfExpandableContentAriaText);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDatagridRowDetail, [{
    type: Component,
    args: [{
      selector: "clr-dg-row-detail",
      template: `
    <div class="clr-sr-only">
      {{ beginningOfExpandableContentAriaText }}
      {{ commonStrings.keys.datagridExpandableRowsHelperText }}
    </div>
    <ng-content></ng-content>
    <div class="clr-sr-only">{{ endOfExpandableContentAriaText }}</div>
  `,
      host: {
        "[class.datagrid-row-flex]": "true",
        "[class.datagrid-row-detail]": "true",
        "[class.datagrid-container]": "cells.length === 0",
        "[attr.id]": "expand.expandableId",
        role: "gridcell"
      }
    }]
  }], function() {
    return [{
      type: Selection
    }, {
      type: RowActionService
    }, {
      type: DatagridIfExpandService
    }, {
      type: ExpandableRowsCount
    }, {
      type: ClrCommonStringsService
    }];
  }, {
    _beginningOfExpandableContentAriaText: [{
      type: Input,
      args: ["clrRowDetailBeginningAriaText"]
    }],
    _endOfExpandableContentAriaText: [{
      type: Input,
      args: ["clrRowDetailEndAriaText"]
    }],
    cells: [{
      type: ContentChildren,
      args: [ClrDatagridCell]
    }],
    replace: [{
      type: Input,
      args: ["clrDgReplace"]
    }]
  });
})();
var defaultCdkFixedSizeVirtualScrollInputs = {
  itemSize: 32,
  minBufferPx: 200,
  maxBufferPx: 400
};
var ClrDatagridVirtualScrollDirective = class {
  constructor(changeDetectorRef, iterableDiffers, items, ngZone, templateRef, viewContainerRef, directionality, scrollDispatcher, viewportRuler, datagrid, columnsService, injector) {
    this.changeDetectorRef = changeDetectorRef;
    this.iterableDiffers = iterableDiffers;
    this.items = items;
    this.ngZone = ngZone;
    this.templateRef = templateRef;
    this.viewContainerRef = viewContainerRef;
    this.directionality = directionality;
    this.scrollDispatcher = scrollDispatcher;
    this.viewportRuler = viewportRuler;
    this.datagrid = datagrid;
    this.columnsService = columnsService;
    this.injector = injector;
    this.renderedRangeChange = new EventEmitter();
    this._cdkFixedSizeVirtualScrollInputs = __spreadValues({}, defaultCdkFixedSizeVirtualScrollInputs);
    this.subscriptions = [];
    this.mutationChanges = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.target.classList.contains("datagrid-compact") && this.itemSize > 24) {
          this.itemSize = 24;
        }
      });
    });
    this.viewRepeater = new _RecycleViewRepeaterStrategy();
    this.cdkVirtualForInputs = {
      cdkVirtualForTrackBy: (index) => index
    };
    this.items.smartenUp();
    this.datagrid.hasVirtualScroller = true;
    this.datagrid.detailService.preventFocusScroll = true;
    this.datagridElementRef = this.datagrid.el;
    this.cdkVirtualForTemplateCacheSize = 20;
    this.mutationChanges.observe(this.datagridElementRef.nativeElement, {
      attributeFilter: ["class"],
      attributeOldValue: true
    });
    this.virtualScrollStrategy = new FixedSizeVirtualScrollStrategy(this._cdkFixedSizeVirtualScrollInputs.itemSize, this._cdkFixedSizeVirtualScrollInputs.minBufferPx, this._cdkFixedSizeVirtualScrollInputs.maxBufferPx);
  }
  get cdkVirtualForOf() {
    return this.cdkVirtualForInputs.cdkVirtualForOf;
  }
  set cdkVirtualForOf(value) {
    this.cdkVirtualForInputs.cdkVirtualForOf = value;
    this.items.all = value;
    this.updateCdkVirtualForInputs();
  }
  get cdkVirtualForTrackBy() {
    return this.cdkVirtualForInputs.cdkVirtualForTrackBy;
  }
  set cdkVirtualForTrackBy(value) {
    this.cdkVirtualForInputs.cdkVirtualForTrackBy = value;
    this.updateCdkVirtualForInputs();
  }
  get cdkVirtualForTemplate() {
    return this?.cdkVirtualForInputs?.cdkVirtualForTemplate;
  }
  set cdkVirtualForTemplate(value) {
    this.cdkVirtualForInputs.cdkVirtualForTemplate = value;
    this.updateCdkVirtualForInputs();
  }
  get cdkVirtualForTemplateCacheSize() {
    return this.cdkVirtualForInputs.cdkVirtualForTemplateCacheSize;
  }
  set cdkVirtualForTemplateCacheSize(value) {
    this.cdkVirtualForInputs.cdkVirtualForTemplateCacheSize = coerceNumberProperty(value);
    this.updateCdkVirtualForInputs();
  }
  get itemSize() {
    return this._cdkFixedSizeVirtualScrollInputs.itemSize;
  }
  set itemSize(value) {
    this._cdkFixedSizeVirtualScrollInputs.itemSize = coerceNumberProperty(value);
    this.updateFixedSizeVirtualScrollInputs();
  }
  get minBufferPx() {
    return this._cdkFixedSizeVirtualScrollInputs.minBufferPx;
  }
  set minBufferPx(value) {
    this._cdkFixedSizeVirtualScrollInputs.minBufferPx = coerceNumberProperty(value);
    this.updateFixedSizeVirtualScrollInputs();
  }
  get maxBufferPx() {
    return this._cdkFixedSizeVirtualScrollInputs.maxBufferPx;
  }
  set maxBufferPx(value) {
    this._cdkFixedSizeVirtualScrollInputs.maxBufferPx = coerceNumberProperty(value);
    this.updateFixedSizeVirtualScrollInputs();
  }
  ngAfterViewInit() {
    this.injector.runInContext(() => {
      this.virtualScrollViewport = this.createVirtualScrollViewportForDatagrid(this.changeDetectorRef, this.ngZone, this.directionality, this.scrollDispatcher, this.viewportRuler, this.datagridElementRef, this.virtualScrollStrategy);
      this.cdkVirtualFor = new CdkVirtualForOf(this.viewContainerRef, this.templateRef, this.iterableDiffers, this.viewRepeater, this.virtualScrollViewport, this.ngZone);
      this.virtualScrollViewport.ngOnInit();
    });
    this.gridRoleElement = this.datagridElementRef.nativeElement.querySelector('[role="grid"]');
    this.updateCdkVirtualForInputs();
    this.subscriptions.push(this.items.change.subscribe((newItems) => {
      this.cdkVirtualFor.cdkVirtualForOf = newItems;
    }), this.cdkVirtualFor.dataStream.subscribe((data) => {
      this.updateAriaRowCount(data.length);
    }), this.virtualScrollViewport.renderedRangeStream.subscribe((renderedRange) => {
      this.renderedRangeChange.emit(renderedRange);
    }), this.datagrid.refresh.subscribe((datagridState) => {
      if (datagridState.filters) {
        this.virtualScrollViewport.scrollToIndex(0);
      }
    }), this.columnsService.columnsStateChange.subscribe(() => {
      this.viewRepeater.detach();
    }));
  }
  ngDoCheck() {
    this.cdkVirtualFor?.ngDoCheck();
    this.updateAriaRowIndexes();
  }
  ngOnDestroy() {
    this.cdkVirtualFor?.ngOnDestroy();
    this.virtualScrollViewport?.ngOnDestroy();
    this.mutationChanges?.disconnect();
    this.subscriptions.forEach((subscription) => {
      subscription.unsubscribe();
    });
  }
  updateCdkVirtualForInputs() {
    if (this.cdkVirtualFor) {
      for (const cdkVirtualForInputKey of Object.keys(this.cdkVirtualForInputs)) {
        if (this.cdkVirtualFor[cdkVirtualForInputKey] !== this.cdkVirtualForInputs[cdkVirtualForInputKey]) {
          this.cdkVirtualFor[cdkVirtualForInputKey] = this.cdkVirtualForInputs[cdkVirtualForInputKey];
        }
      }
    }
  }
  updateFixedSizeVirtualScrollInputs() {
    if (this.virtualScrollStrategy) {
      this.virtualScrollStrategy.updateItemAndBufferSize(this._cdkFixedSizeVirtualScrollInputs.itemSize, this._cdkFixedSizeVirtualScrollInputs.minBufferPx, this._cdkFixedSizeVirtualScrollInputs.maxBufferPx);
    }
  }
  updateAriaRowCount(rowCount) {
    this.gridRoleElement?.setAttribute("aria-rowcount", rowCount.toString());
  }
  updateAriaRowIndexes() {
    for (let i2 = 0; i2 < this.viewContainerRef.length; i2++) {
      const viewRef = this.viewContainerRef.get(i2);
      const rootElements = viewRef.rootNodes;
      const datagridRowElement = rootElements.find((rowElement) => rowElement.tagName === "CLR-DG-ROW");
      const rowRoleElement = datagridRowElement?.querySelector('[role="row"]');
      rowRoleElement?.setAttribute("aria-rowindex", (viewRef.context.index + 1).toString());
    }
  }
  createVirtualScrollViewportForDatagrid(changeDetectorRef, ngZone, directionality, scrollDispatcher, viewportRuler, datagridElementRef, virtualScrollStrategy) {
    const datagridDivElement = datagridElementRef.nativeElement.querySelector(".datagrid");
    const datagridTableElement = datagridElementRef.nativeElement.querySelector(".datagrid-table");
    const datagridRowsElement = datagridElementRef.nativeElement.querySelector(".datagrid-rows");
    const datagridDivElementRef = {
      nativeElement: datagridDivElement
    };
    let topOffset = 0;
    let totalContentSize = 0;
    function updateDatagridElementStyles() {
      datagridRowsElement.style.transform = `translateY(${topOffset}px)`;
      datagridRowsElement.style.height = `${totalContentSize - topOffset}px`;
    }
    const virtualScrollViewport = new CdkVirtualScrollViewport(datagridDivElementRef, changeDetectorRef, ngZone, virtualScrollStrategy, directionality, scrollDispatcher, viewportRuler, null);
    virtualScrollViewport._contentWrapper = {
      nativeElement: {
        style: {
          set transform(value) {
            topOffset = value === void 0 ? 0 : +/translateY\(([0-9]+)px\)/.exec(value)?.[1];
            updateDatagridElementStyles();
          }
        }
      }
    };
    virtualScrollViewport.setTotalContentSize = (value) => {
      totalContentSize = value;
      datagridTableElement.style.height = `${totalContentSize}px`;
      updateDatagridElementStyles();
    };
    return virtualScrollViewport;
  }
};
ClrDatagridVirtualScrollDirective.ɵfac = function ClrDatagridVirtualScrollDirective_Factory(t3) {
  return new (t3 || ClrDatagridVirtualScrollDirective)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(IterableDiffers), ɵɵdirectiveInject(Items, 4), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(TemplateRef), ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(Directionality), ɵɵdirectiveInject(ScrollDispatcher), ɵɵdirectiveInject(ViewportRuler), ɵɵdirectiveInject(ClrDatagrid), ɵɵdirectiveInject(ColumnsService), ɵɵdirectiveInject(EnvironmentInjector));
};
ClrDatagridVirtualScrollDirective.ɵdir = ɵɵdefineDirective({
  type: ClrDatagridVirtualScrollDirective,
  selectors: [["", "ClrVirtualScroll", ""]],
  inputs: {
    cdkVirtualForOf: [InputFlags.None, "clrVirtualRowsOf", "cdkVirtualForOf"],
    cdkVirtualForTrackBy: [InputFlags.None, "clrVirtualRowsTrackBy", "cdkVirtualForTrackBy"],
    cdkVirtualForTemplate: [InputFlags.None, "clrVirtualRowsTemplate", "cdkVirtualForTemplate"],
    cdkVirtualForTemplateCacheSize: [InputFlags.None, "clrVirtualRowsTemplateCacheSize", "cdkVirtualForTemplateCacheSize"],
    itemSize: [InputFlags.None, "clrVirtualRowsItemSize", "itemSize"],
    minBufferPx: [InputFlags.None, "clrVirtualRowsMinBufferPx", "minBufferPx"],
    maxBufferPx: [InputFlags.None, "clrVirtualRowsMaxBufferPx", "maxBufferPx"]
  },
  outputs: {
    renderedRangeChange: "renderedRangeChange"
  },
  features: [ɵɵProvidersFeature([Items])]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDatagridVirtualScrollDirective, [{
    type: Directive,
    args: [{
      selector: "[ClrVirtualScroll]",
      providers: [Items]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: IterableDiffers
    }, {
      type: Items,
      decorators: [{
        type: SkipSelf
      }]
    }, {
      type: NgZone
    }, {
      type: TemplateRef
    }, {
      type: ViewContainerRef
    }, {
      type: Directionality
    }, {
      type: ScrollDispatcher
    }, {
      type: ViewportRuler
    }, {
      type: ClrDatagrid
    }, {
      type: ColumnsService
    }, {
      type: EnvironmentInjector
    }];
  }, {
    renderedRangeChange: [{
      type: Output
    }],
    cdkVirtualForOf: [{
      type: Input,
      args: ["clrVirtualRowsOf"]
    }],
    cdkVirtualForTrackBy: [{
      type: Input,
      args: ["clrVirtualRowsTrackBy"]
    }],
    cdkVirtualForTemplate: [{
      type: Input,
      args: ["clrVirtualRowsTemplate"]
    }],
    cdkVirtualForTemplateCacheSize: [{
      type: Input,
      args: ["clrVirtualRowsTemplateCacheSize"]
    }],
    itemSize: [{
      type: Input,
      args: ["clrVirtualRowsItemSize"]
    }],
    minBufferPx: [{
      type: Input,
      args: ["clrVirtualRowsMinBufferPx"]
    }],
    maxBufferPx: [{
      type: Input,
      args: ["clrVirtualRowsMaxBufferPx"]
    }]
  });
})();
var DatagridHeaderRenderer = class {
  constructor(el, renderer, organizer, domAdapter, columnResizerService, columnsService, columnState) {
    this.el = el;
    this.renderer = renderer;
    this.organizer = organizer;
    this.domAdapter = domAdapter;
    this.columnResizerService = columnResizerService;
    this.columnsService = columnsService;
    this.columnState = columnState;
    this.resizeEmitter = new EventEmitter();
    this.widthSet = false;
    this.autoSet = false;
    this.subscriptions = [];
    this.subscriptions.push(this.organizer.filterRenderSteps(DatagridRenderStep.CLEAR_WIDTHS).subscribe(() => this.clearWidth()));
  }
  ngOnDestroy() {
    this.subscriptions.forEach((sub) => sub.unsubscribe());
  }
  getColumnWidthState() {
    const strictWidth = this.detectStrictWidth();
    return {
      width: this.computeWidth(strictWidth),
      strictWidth
    };
  }
  setColumnState(index) {
    this.columnsService.columns[index] = this.columnState;
  }
  setWidth(state2) {
    if (state2.strictWidth) {
      if (this.columnResizerService.resizedBy) {
        this.resizeEmitter.emit(state2.width);
        this.renderer.setStyle(this.el.nativeElement, "width", state2.width + "px");
        this.widthSet = false;
      }
      this.renderer.addClass(this.el.nativeElement, STRICT_WIDTH_CLASS);
      this.autoSet = false;
    } else {
      this.renderer.removeClass(this.el.nativeElement, STRICT_WIDTH_CLASS);
      this.renderer.setStyle(this.el.nativeElement, "width", state2.width + "px");
      this.widthSet = true;
      this.autoSet = true;
    }
  }
  setHidden(state2) {
    if (state2.hidden) {
      this.renderer.addClass(this.el.nativeElement, HIDDEN_COLUMN_CLASS);
    } else {
      this.renderer.removeClass(this.el.nativeElement, HIDDEN_COLUMN_CLASS);
    }
  }
  clearWidth() {
    if (this.widthSet && !this.columnResizerService.resizedBy) {
      this.renderer.setStyle(this.el.nativeElement, "width", null);
    }
    if (this.autoSet) {
      this.renderer.removeClass(this.el.nativeElement, STRICT_WIDTH_CLASS);
    }
  }
  detectStrictWidth() {
    if (this.columnResizerService.resizedBy) {
      return this.columnResizerService.widthAfterResize;
    } else if (this.autoSet) {
      return 0;
    } else {
      return this.domAdapter.userDefinedWidth(this.el.nativeElement);
    }
  }
  computeWidth(strictWidth) {
    let width = strictWidth;
    if (!width) {
      width = this.domAdapter.scrollWidth(this.el.nativeElement);
    }
    return width;
  }
};
DatagridHeaderRenderer.ɵfac = function DatagridHeaderRenderer_Factory(t3) {
  return new (t3 || DatagridHeaderRenderer)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(DatagridRenderOrganizer), ɵɵdirectiveInject(DomAdapter), ɵɵdirectiveInject(ColumnResizerService), ɵɵdirectiveInject(ColumnsService), ɵɵdirectiveInject(COLUMN_STATE));
};
DatagridHeaderRenderer.ɵdir = ɵɵdefineDirective({
  type: DatagridHeaderRenderer,
  selectors: [["clr-dg-column"]],
  outputs: {
    resizeEmitter: "clrDgColumnResize"
  },
  features: [ɵɵProvidersFeature([ColumnResizerService, COLUMN_STATE_PROVIDER])]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DatagridHeaderRenderer, [{
    type: Directive,
    args: [{
      selector: "clr-dg-column",
      providers: [ColumnResizerService, COLUMN_STATE_PROVIDER]
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: DatagridRenderOrganizer
    }, {
      type: DomAdapter
    }, {
      type: ColumnResizerService
    }, {
      type: ColumnsService
    }, {
      type: BehaviorSubject,
      decorators: [{
        type: Inject,
        args: [COLUMN_STATE]
      }]
    }];
  }, {
    resizeEmitter: [{
      type: Output,
      args: ["clrDgColumnResize"]
    }]
  });
})();
var NoopDomAdapter = class {
  userDefinedWidth(_element) {
    return 0;
  }
  scrollBarWidth(_element) {
    return 0;
  }
  scrollWidth(_element) {
    return 0;
  }
  computedHeight(_element) {
    return 0;
  }
  clientRect(_element) {
    return {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0,
      width: 0,
      height: 0
    };
  }
  minWidth(_element) {
    return 0;
  }
  focus(_element) {
  }
};
NoopDomAdapter.ɵfac = function NoopDomAdapter_Factory(t3) {
  return new (t3 || NoopDomAdapter)();
};
NoopDomAdapter.ɵprov = ɵɵdefineInjectable({
  token: NoopDomAdapter,
  factory: NoopDomAdapter.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NoopDomAdapter, [{
    type: Injectable
  }], null, null);
})();
var domAdapterFactory = (platformId) => {
  if (isPlatformBrowser(platformId)) {
    return new DomAdapter();
  } else {
    return new NoopDomAdapter();
  }
};
var DatagridMainRenderer = class {
  constructor(organizer, items, page, domAdapter, el, renderer, detailService, tableSizeService, columnsService, ngZone, keyNavigation) {
    this.organizer = organizer;
    this.items = items;
    this.page = page;
    this.domAdapter = domAdapter;
    this.el = el;
    this.renderer = renderer;
    this.detailService = detailService;
    this.tableSizeService = tableSizeService;
    this.columnsService = columnsService;
    this.ngZone = ngZone;
    this.keyNavigation = keyNavigation;
    this._heightSet = false;
    this.shouldStabilizeColumns = true;
    this.subscriptions = [];
    this.columnsSizesStable = false;
    this.subscriptions.push(this.organizer.filterRenderSteps(DatagridRenderStep.COMPUTE_COLUMN_WIDTHS).subscribe(() => this.computeHeadersWidth()));
    this.subscriptions.push(this.page.sizeChange.subscribe(() => {
      if (this._heightSet) {
        this.resetDatagridHeight();
      }
    }));
    this.subscriptions.push(this.detailService.stateChange.subscribe((state2) => this.toggleDetailPane(state2)));
    this.subscriptions.push(this.items.change.subscribe(() => this.shouldStabilizeColumns = true));
  }
  ngOnInit() {
    this.columnsService.columnsStateChange.subscribe((change) => this.columnStateChanged(change));
  }
  ngAfterContentInit() {
    this.setupColumns();
    this.subscriptions.push(this.headers.changes.subscribe(() => {
      this.setupColumns();
      this.columnsSizesStable = false;
      this.stabilizeColumns();
    }));
  }
  // Initialize and set Table width for horizontal scrolling here.
  ngAfterViewInit() {
    this.tableSizeService.table = this.el;
  }
  ngAfterViewChecked() {
    if (this.shouldStabilizeColumns) {
      this.stabilizeColumns();
    }
    if (this.shouldComputeHeight()) {
      this.ngZone.runOutsideAngular(() => {
        setTimeout(() => {
          this.computeDatagridHeight();
        });
      });
    }
  }
  ngOnDestroy() {
    this.subscriptions.forEach((sub) => sub.unsubscribe());
  }
  toggleDetailPane(state2) {
    if (this.headers) {
      if (state2 && !this.columnsService.hasCache()) {
        this.columnsService.cache();
        this.headers.forEach((_header, index) => {
          if (index > 0) {
            this.columnsService.emitStateChangeAt(index, {
              changes: [DatagridColumnChanges.HIDDEN],
              hidden: state2
            });
          }
        });
      } else if (!state2) {
        this.columnsService.resetToLastCache();
      }
    }
  }
  setupColumns() {
    this.headers.forEach((header, index) => header.setColumnState(index));
    this.columnsService.columns.splice(this.headers.length);
    this.columnsService.columns.forEach((column, index) => {
      this.columnsService.emitStateChange(column, {
        changes: [DatagridColumnChanges.INITIALIZE],
        columnIndex: index
      });
    });
  }
  shouldComputeHeight() {
    if (!this._heightSet && this.page.size > 0) {
      if (this.items.displayed.length === this.page.size) {
        return true;
      }
    }
    return false;
  }
  /**
   * Computes the height of the datagrid.
   *
   * NOTE: We had to choose to set the height instead of the min-height because
   * IE 11 requires the height on the parent for the children flex grow/shrink properties to work.
   * When we used min-height, 1 1 auto doesn't used to work in IE11 :-(
   * But this doesn't affect the fix. It works in both fixed & variable height datagrids.
   *
   * Refer: http://stackoverflow.com/questions/24396205/flex-grow-not-working-in-internet-explorer-11-0
   */
  computeDatagridHeight() {
    const height = window.getComputedStyle(this.el.nativeElement).height;
    this.renderer.setStyle(this.el.nativeElement, "height", height);
    this._heightSet = true;
  }
  resetDatagridHeight() {
    this.renderer.setStyle(this.el.nativeElement, "height", "");
    this._heightSet = false;
  }
  /**
   * Makes each header compute its width.
   */
  computeHeadersWidth() {
    const nbColumns = this.headers.length;
    const headerWidths = this.headers.map((header) => {
      return header.getColumnWidthState();
    });
    let allStrict = true;
    this.headers.forEach((header, index) => {
      const state2 = __spreadValues({
        changes: [DatagridColumnChanges.WIDTH]
      }, headerWidths[index]);
      if (!state2.strictWidth) {
        allStrict = false;
      }
      if (nbColumns === index + 1 && allStrict) {
        state2.strictWidth = 0;
      }
      this.columnsService.emitStateChangeAt(index, state2);
    });
  }
  columnStateChanged(state2) {
    if (!this.headers || state2.columnIndex == null) {
      return;
    }
    const columnIndex = state2.columnIndex;
    if (state2.changes && state2.changes.length) {
      state2.changes.forEach((change) => {
        switch (change) {
          case DatagridColumnChanges.WIDTH:
            this.headers.get(columnIndex).setWidth(state2);
            this.rows.forEach((row) => {
              if (row?.cells.length === this.columnsService.columns.length) {
                row.cells.get(columnIndex).setWidth(state2);
              }
            });
            break;
          case DatagridColumnChanges.HIDDEN:
            this.headers.get(columnIndex).setHidden(state2);
            this.rows.forEach((row) => {
              if (row.cells && row.cells.length) {
                row.cells.get(columnIndex).setHidden(state2);
              }
            });
            this.keyNavigation.resetKeyGrid();
            break;
          case DatagridColumnChanges.INITIALIZE:
            if (state2.hideable && state2.hidden) {
              this.headers.get(columnIndex).setHidden(state2);
              this.rows.forEach((row) => {
                row.setCellsState();
              });
            }
            break;
          default:
            break;
        }
      });
    }
  }
  /**
   * Triggers a whole re-rendring cycle to set column sizes, if needed.
   */
  stabilizeColumns() {
    this.shouldStabilizeColumns = false;
    if (this.columnsSizesStable) {
      return;
    }
    if (this.items.displayed.length > 0) {
      this.organizer.resize();
      this.columnsSizesStable = true;
    }
  }
};
DatagridMainRenderer.ɵfac = function DatagridMainRenderer_Factory(t3) {
  return new (t3 || DatagridMainRenderer)(ɵɵdirectiveInject(DatagridRenderOrganizer), ɵɵdirectiveInject(Items), ɵɵdirectiveInject(Page), ɵɵdirectiveInject(DomAdapter), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(DetailService), ɵɵdirectiveInject(TableSizeService), ɵɵdirectiveInject(ColumnsService), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(KeyNavigationGridController));
};
DatagridMainRenderer.ɵdir = ɵɵdefineDirective({
  type: DatagridMainRenderer,
  selectors: [["clr-datagrid"]],
  contentQueries: function DatagridMainRenderer_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, DatagridHeaderRenderer, 4);
      ɵɵcontentQuery(dirIndex, DatagridRowRenderer, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headers = _t);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.rows = _t);
    }
  },
  features: [ɵɵProvidersFeature([{
    provide: DomAdapter,
    useFactory: domAdapterFactory,
    deps: [PLATFORM_ID]
  }])]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DatagridMainRenderer, [{
    type: Directive,
    args: [{
      selector: "clr-datagrid",
      providers: [{
        provide: DomAdapter,
        useFactory: domAdapterFactory,
        deps: [PLATFORM_ID]
      }]
    }]
  }], function() {
    return [{
      type: DatagridRenderOrganizer
    }, {
      type: Items
    }, {
      type: Page
    }, {
      type: DomAdapter
    }, {
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: DetailService
    }, {
      type: TableSizeService
    }, {
      type: ColumnsService
    }, {
      type: NgZone
    }, {
      type: KeyNavigationGridController
    }];
  }, {
    headers: [{
      type: ContentChildren,
      args: [DatagridHeaderRenderer]
    }],
    rows: [{
      type: ContentChildren,
      args: [DatagridRowRenderer, {
        descendants: true
      }]
    }]
  });
})();
var CLR_DATAGRID_DIRECTIVES = [
  // Core
  ClrDatagrid,
  ClrDatagridActionBar,
  ClrDatagridActionOverflow,
  ClrDatagridCell,
  ClrDatagridColumn,
  ClrDatagridColumnSeparator,
  ClrDatagridDetail,
  ClrDatagridDetailBody,
  ClrDatagridDetailHeader,
  ClrDatagridFilter,
  ClrDatagridFooter,
  ClrDatagridHideableColumn,
  ClrDatagridItems,
  ClrDatagridPageSize,
  ClrDatagridPagination,
  ClrDatagridPlaceholder,
  ClrDatagridRow,
  ClrDatagridRowDetail,
  ClrDatagridSelectionCellDirective,
  ClrDatagridVirtualScrollDirective,
  ClrIfDetail,
  DatagridDetailRegisterer,
  WrappedCell,
  WrappedColumn,
  WrappedRow,
  // Renderers
  DatagridCellRenderer,
  DatagridHeaderRenderer,
  DatagridMainRenderer,
  DatagridRowRenderer,
  // Chocolate
  ActionableOompaLoompa,
  DatagridWillyWonka,
  ExpandableOompaLoompa,
  // Built-in shortcuts
  DatagridNumericFilter,
  DatagridStringFilter
];
var CLR_DATAGRID_INTERNAL_DIRECTIVES = [ClrDatagridColumnToggle, ClrDatagridColumnToggleButton];
var ClrDatagridModule = class {
  constructor() {
    r.addIcons(e2, n2, n3, a2, o6, o5, o4, r4, r3);
  }
};
ClrDatagridModule.ɵfac = function ClrDatagridModule_Factory(t3) {
  return new (t3 || ClrDatagridModule)();
};
ClrDatagridModule.ɵmod = ɵɵdefineNgModule({
  type: ClrDatagridModule,
  declarations: [
    // Core
    ClrDatagrid,
    ClrDatagridActionBar,
    ClrDatagridActionOverflow,
    ClrDatagridCell,
    ClrDatagridColumn,
    ClrDatagridColumnSeparator,
    ClrDatagridDetail,
    ClrDatagridDetailBody,
    ClrDatagridDetailHeader,
    ClrDatagridFilter,
    ClrDatagridFooter,
    ClrDatagridHideableColumn,
    ClrDatagridItems,
    ClrDatagridPageSize,
    ClrDatagridPagination,
    ClrDatagridPlaceholder,
    ClrDatagridRow,
    ClrDatagridRowDetail,
    ClrDatagridSelectionCellDirective,
    ClrDatagridVirtualScrollDirective,
    ClrIfDetail,
    DatagridDetailRegisterer,
    WrappedCell,
    WrappedColumn,
    WrappedRow,
    // Renderers
    DatagridCellRenderer,
    DatagridHeaderRenderer,
    DatagridMainRenderer,
    DatagridRowRenderer,
    // Chocolate
    ActionableOompaLoompa,
    DatagridWillyWonka,
    ExpandableOompaLoompa,
    // Built-in shortcuts
    DatagridNumericFilter,
    DatagridStringFilter,
    ClrDatagridColumnToggle,
    ClrDatagridColumnToggleButton
  ],
  imports: [CommonModule, CdkDragModule, CdkTrapFocusModule, ClrIconModule, ClrFormsModule, FormsModule, ClrLoadingModule, ClrConditionalModule, ClrOutsideClickModule, ClrExpandableAnimationModule, ClrSpinnerModule, ClrPopoverModuleNext, ClrKeyFocusModule],
  exports: [
    // Core
    ClrDatagrid,
    ClrDatagridActionBar,
    ClrDatagridActionOverflow,
    ClrDatagridCell,
    ClrDatagridColumn,
    ClrDatagridColumnSeparator,
    ClrDatagridDetail,
    ClrDatagridDetailBody,
    ClrDatagridDetailHeader,
    ClrDatagridFilter,
    ClrDatagridFooter,
    ClrDatagridHideableColumn,
    ClrDatagridItems,
    ClrDatagridPageSize,
    ClrDatagridPagination,
    ClrDatagridPlaceholder,
    ClrDatagridRow,
    ClrDatagridRowDetail,
    ClrDatagridSelectionCellDirective,
    ClrDatagridVirtualScrollDirective,
    ClrIfDetail,
    DatagridDetailRegisterer,
    WrappedCell,
    WrappedColumn,
    WrappedRow,
    // Renderers
    DatagridCellRenderer,
    DatagridHeaderRenderer,
    DatagridMainRenderer,
    DatagridRowRenderer,
    // Chocolate
    ActionableOompaLoompa,
    DatagridWillyWonka,
    ExpandableOompaLoompa,
    // Built-in shortcuts
    DatagridNumericFilter,
    DatagridStringFilter
  ]
});
ClrDatagridModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, CdkDragModule, CdkTrapFocusModule, ClrIconModule, ClrFormsModule, FormsModule, ClrLoadingModule, ClrConditionalModule, ClrOutsideClickModule, ClrExpandableAnimationModule, ClrSpinnerModule, ClrPopoverModuleNext, ClrKeyFocusModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDatagridModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, CdkDragModule, CdkTrapFocusModule, ClrIconModule, ClrFormsModule, FormsModule, ClrLoadingModule, ClrConditionalModule, ClrOutsideClickModule, ClrExpandableAnimationModule, ClrSpinnerModule, ClrPopoverModuleNext, ClrKeyFocusModule],
      declarations: [CLR_DATAGRID_DIRECTIVES, CLR_DATAGRID_INTERNAL_DIRECTIVES],
      exports: [CLR_DATAGRID_DIRECTIVES]
    }]
  }], function() {
    return [];
  }, null);
})();
var ClrStackViewCustomTags = class {
};
ClrStackViewCustomTags.ɵfac = function ClrStackViewCustomTags_Factory(t3) {
  return new (t3 || ClrStackViewCustomTags)();
};
ClrStackViewCustomTags.ɵdir = ɵɵdefineDirective({
  type: ClrStackViewCustomTags,
  selectors: [["clr-stack-content"]]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrStackViewCustomTags, [{
    type: Directive,
    args: [{
      selector: "clr-stack-content"
    }]
  }], null, null);
})();
var ClrStackViewLabel = class {
  constructor() {
    this._generatedId = null;
    this._id = null;
  }
  get id() {
    return this._id;
  }
  set id(val) {
    if (typeof val === "string" && val !== "") {
      this._id = val;
    } else {
      this._id = this._generatedId + "";
    }
  }
  ngOnInit() {
    this._generatedId = "clr-stack-label-" + uniqueIdFactory();
    if (!this.id) {
      this._id = this._generatedId + "";
    }
  }
};
ClrStackViewLabel.ɵfac = function ClrStackViewLabel_Factory(t3) {
  return new (t3 || ClrStackViewLabel)();
};
ClrStackViewLabel.ɵcmp = ɵɵdefineComponent({
  type: ClrStackViewLabel,
  selectors: [["clr-stack-label"]],
  hostVars: 1,
  hostBindings: function ClrStackViewLabel_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("id", ctx.id);
    }
  },
  inputs: {
    id: "id"
  },
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function ClrStackViewLabel_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrStackViewLabel, [{
    type: Component,
    args: [{
      selector: "clr-stack-label",
      template: "<ng-content></ng-content>",
      host: {
        "[attr.id]": "id"
      }
    }]
  }], null, {
    id: [{
      type: Input
    }]
  });
})();
var ClrStackBlock = class {
  /*
   * This would be more efficient with @ContentChildren, with the parent ClrStackBlock
   * querying for children StackBlocks, but this feature is not available when downgrading
   * the component for Angular 1.
   */
  constructor(parent, commonStrings) {
    this.parent = parent;
    this.commonStrings = commonStrings;
    this.expanded = false;
    this.expandable = false;
    this.expandedChange = new EventEmitter(false);
    this.focused = false;
    this.uniqueId = uniqueIdFactory();
    this._changedChildren = 0;
    this._fullyInitialized = false;
    this._changed = false;
    if (parent) {
      parent.addChild();
    }
  }
  set setChangedValue(value) {
    this._changed = value;
    if (this.parent && this._fullyInitialized) {
      if (value) {
        this.parent._changedChildren++;
      } else {
        this.parent._changedChildren--;
      }
    }
  }
  get getChangedValue() {
    return this._changed || this._changedChildren > 0 && !this.expanded;
  }
  get onStackLabelFocus() {
    return this.expandable && !this.expanded && this.focused;
  }
  get labelledById() {
    return this.stackBlockTitle.id;
  }
  get headingLevel() {
    if (this.ariaLevel) {
      return this.ariaLevel + "";
    }
    return this.parent ? "4" : "3";
  }
  get caretDirection() {
    return this.expanded ? "down" : "right";
  }
  get role() {
    return this.expandable ? "button" : null;
  }
  get tabIndex() {
    return this.expandable ? "0" : null;
  }
  get ariaExpanded() {
    if (!this.expandable) {
      return null;
    } else {
      return this.expanded ? "true" : "false";
    }
  }
  ngOnInit() {
    this._fullyInitialized = true;
  }
  addChild() {
    this.expandable = true;
  }
  toggleExpand(event) {
    if (eventIsInputEvent(event)) {
      return;
    }
    if (this.expandable) {
      this.expanded = !this.expanded;
      this.expandedChange.emit(this.expanded);
    }
  }
  getStackChildrenId() {
    return this.expanded ? `clr-stack-children-${this.uniqueId}` : null;
  }
  preventDefaultIfNotInputEvent(event) {
    if (eventIsInputEvent(event)) {
      return;
    }
    event.preventDefault();
  }
};
ClrStackBlock.ɵfac = function ClrStackBlock_Factory(t3) {
  return new (t3 || ClrStackBlock)(ɵɵdirectiveInject(ClrStackBlock, 12), ɵɵdirectiveInject(ClrCommonStringsService));
};
ClrStackBlock.ɵcmp = ɵɵdefineComponent({
  type: ClrStackBlock,
  selectors: [["clr-stack-block"]],
  contentQueries: function ClrStackBlock_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ClrStackViewLabel, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.stackBlockTitle = _t.first);
    }
  },
  hostVars: 12,
  hostBindings: function ClrStackBlock_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("role", "heading")("aria-level", ctx.headingLevel);
      ɵɵclassProp("stack-block", true)("stack-block-expanded", ctx.expanded)("stack-block-expandable", ctx.expandable)("stack-block-changed", ctx.getChangedValue)("on-focus", ctx.onStackLabelFocus);
    }
  },
  inputs: {
    expanded: [InputFlags.None, "clrSbExpanded", "expanded"],
    expandable: [InputFlags.None, "clrSbExpandable", "expandable"],
    ariaLevel: [InputFlags.None, "clrStackViewLevel", "ariaLevel"],
    setChangedValue: [InputFlags.None, "clrSbNotifyChange", "setChangedValue"]
  },
  outputs: {
    expandedChange: "clrSbExpandedChange"
  },
  ngContentSelectors: _c80,
  decls: 9,
  vars: 9,
  consts: [[1, "stack-block-label", 3, "click", "keyup.enter", "keyup.space", "keydown.space", "focus", "blur", "id"], ["shape", "angle", "class", "stack-block-caret", 4, "ngIf"], ["class", "clr-sr-only", 4, "ngIf"], [1, "stack-view-key"], [1, "stack-block-content"], [1, "stack-children", 3, "clrExpandTrigger"], ["role", "region", 3, "height", 4, "ngIf"], ["shape", "angle", 1, "stack-block-caret"], [1, "clr-sr-only"], ["role", "region"]],
  template: function ClrStackBlock_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c79);
      ɵɵelementStart(0, "div", 0);
      ɵɵlistener("click", function ClrStackBlock_Template_div_click_0_listener($event) {
        return ctx.toggleExpand($event);
      })("keyup.enter", function ClrStackBlock_Template_div_keyup_enter_0_listener($event) {
        return ctx.toggleExpand($event);
      })("keyup.space", function ClrStackBlock_Template_div_keyup_space_0_listener($event) {
        return ctx.toggleExpand($event);
      })("keydown.space", function ClrStackBlock_Template_div_keydown_space_0_listener($event) {
        return ctx.preventDefaultIfNotInputEvent($event);
      })("focus", function ClrStackBlock_Template_div_focus_0_listener() {
        return ctx.focused = true;
      })("blur", function ClrStackBlock_Template_div_blur_0_listener() {
        return ctx.focused = false;
      });
      ɵɵtemplate(1, ClrStackBlock_cds_icon_1_Template, 1, 1, "cds-icon", 1)(2, ClrStackBlock_span_2_Template, 2, 1, "span", 2);
      ɵɵelementStart(3, "div", 3);
      ɵɵprojection(4);
      ɵɵelementEnd();
      ɵɵelementStart(5, "div", 4);
      ɵɵprojection(6, 1);
      ɵɵelementEnd()();
      ɵɵelementStart(7, "clr-expandable-animation", 5);
      ɵɵtemplate(8, ClrStackBlock_div_8_Template, 2, 4, "div", 6);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("id", ctx.uniqueId);
      ɵɵattribute("role", ctx.role)("tabindex", ctx.tabIndex)("aria-expanded", ctx.ariaExpanded)("aria-controls", ctx.getStackChildrenId());
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.expandable);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.getChangedValue);
      ɵɵadvance(5);
      ɵɵproperty("clrExpandTrigger", ctx.expanded);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.expanded);
    }
  },
  dependencies: [NgIf, CdsIconCustomTag, ClrExpandableAnimation],
  styles: ["[_nghost-%COMP%]{display:block}"]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrStackBlock, [{
    type: Component,
    args: [{
      selector: "clr-stack-block",
      template: `
    <!-- The 'preventDefault' for the space keydown event prevents the page
         from scrolling when a stack block is toggled via the space key. -->
    <div
      class="stack-block-label"
      (click)="toggleExpand($event)"
      (keyup.enter)="toggleExpand($event)"
      (keyup.space)="toggleExpand($event)"
      (keydown.space)="preventDefaultIfNotInputEvent($event)"
      (focus)="focused = true"
      (blur)="focused = false"
      [id]="uniqueId"
      [attr.role]="role"
      [attr.tabindex]="tabIndex"
      [attr.aria-expanded]="ariaExpanded"
      [attr.aria-controls]="getStackChildrenId()"
    >
      <cds-icon shape="angle" class="stack-block-caret" *ngIf="expandable" [attr.direction]="caretDirection"></cds-icon>
      <span class="clr-sr-only" *ngIf="getChangedValue">{{ commonStrings.keys.stackViewChanged }}</span>
      <div class="stack-view-key">
        <!-- This structure changed to fix #3567 and the a11y request was to move away from dl's -->
        <!-- I added the key class to update css targets for the original component style -->
        <ng-content select="clr-stack-label"></ng-content>
      </div>
      <div class="stack-block-content">
        <ng-content></ng-content>
      </div>
    </div>

    <clr-expandable-animation [clrExpandTrigger]="expanded" class="stack-children">
      <div
        [style.height]="expanded ? 'auto' : 0"
        role="region"
        *ngIf="expanded"
        [attr.id]="getStackChildrenId()"
        [attr.aria-labelledby]="labelledById"
      >
        <ng-content select="clr-stack-block"></ng-content>
      </div>
    </clr-expandable-animation>
  `,
      host: {
        "[class.stack-block]": "true",
        "[attr.role]": '"heading"',
        "[attr.aria-level]": "headingLevel"
      },
      styles: [":host{display:block}\n"]
    }]
  }], function() {
    return [{
      type: ClrStackBlock,
      decorators: [{
        type: SkipSelf
      }, {
        type: Optional
      }]
    }, {
      type: ClrCommonStringsService
    }];
  }, {
    expanded: [{
      type: Input,
      args: ["clrSbExpanded"]
    }, {
      type: HostBinding,
      args: ["class.stack-block-expanded"]
    }],
    expandable: [{
      type: Input,
      args: ["clrSbExpandable"]
    }, {
      type: HostBinding,
      args: ["class.stack-block-expandable"]
    }],
    ariaLevel: [{
      type: Input,
      args: ["clrStackViewLevel"]
    }],
    expandedChange: [{
      type: Output,
      args: ["clrSbExpandedChange"]
    }],
    stackBlockTitle: [{
      type: ContentChild,
      args: [ClrStackViewLabel]
    }],
    setChangedValue: [{
      type: Input,
      args: ["clrSbNotifyChange"]
    }],
    getChangedValue: [{
      type: HostBinding,
      args: ["class.stack-block-changed"]
    }],
    onStackLabelFocus: [{
      type: HostBinding,
      args: ["class.on-focus"]
    }]
  });
})();
function eventIsInputEvent(event) {
  const targetElement = event?.target;
  return targetElement?.tagName === "INPUT";
}
var ClrStackContentInput = class {
  constructor() {
    this.uniqueId = uniqueIdFactory();
  }
};
ClrStackContentInput.ɵfac = function ClrStackContentInput_Factory(t3) {
  return new (t3 || ClrStackContentInput)();
};
ClrStackContentInput.ɵdir = ɵɵdefineDirective({
  type: ClrStackContentInput,
  selectors: [["", "clrStackInput", ""]],
  hostVars: 3,
  hostBindings: function ClrStackContentInput_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("aria-labelledby", ctx.uniqueId);
      ɵɵclassProp("clr-input", true);
    }
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrStackContentInput, [{
    type: Directive,
    args: [{
      selector: "[clrStackInput]",
      host: {
        "[class.clr-input]": "true",
        "[attr.aria-labelledby]": "uniqueId"
      }
    }]
  }], null, null);
})();
var ClrStackView = class {
};
ClrStackView.ɵfac = function ClrStackView_Factory(t3) {
  return new (t3 || ClrStackView)();
};
ClrStackView.ɵcmp = ɵɵdefineComponent({
  type: ClrStackView,
  selectors: [["clr-stack-view"]],
  ngContentSelectors: _c82,
  decls: 3,
  vars: 0,
  consts: [[1, "stack-view"]],
  template: function ClrStackView_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c81);
      ɵɵprojection(0);
      ɵɵelementStart(1, "div", 0);
      ɵɵprojection(2, 1);
      ɵɵelementEnd();
    }
  },
  styles: ["[_nghost-%COMP%]{display:block}"]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrStackView, [{
    type: Component,
    args: [{
      selector: "clr-stack-view",
      template: `
    <ng-content select="clr-stack-header"></ng-content>
    <div class="stack-view"><ng-content></ng-content></div>
  `,
      styles: [":host{display:block}\n"]
    }]
  }], null, null);
})();
var ClrStackHeader = class {
  constructor(stackView) {
    this.stackView = stackView;
  }
};
ClrStackHeader.ɵfac = function ClrStackHeader_Factory(t3) {
  return new (t3 || ClrStackHeader)(ɵɵdirectiveInject(ClrStackView));
};
ClrStackHeader.ɵcmp = ɵɵdefineComponent({
  type: ClrStackHeader,
  selectors: [["clr-stack-header"]],
  ngContentSelectors: _c84,
  decls: 5,
  vars: 0,
  consts: [[1, "stack-header"], [1, "stack-title"], [1, "stack-actions"]],
  template: function ClrStackHeader_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c83);
      ɵɵelementStart(0, "div", 0)(1, "h4", 1);
      ɵɵprojection(2);
      ɵɵelementEnd();
      ɵɵelementStart(3, "span", 2);
      ɵɵprojection(4, 1);
      ɵɵelementEnd()();
    }
  },
  styles: ["[_nghost-%COMP%]{display:block}"]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrStackHeader, [{
    type: Component,
    args: [{
      selector: "clr-stack-header",
      template: `
    <div class="stack-header">
      <h4 class="stack-title"><ng-content></ng-content></h4>

      <span class="stack-actions">
        <ng-content select=".stack-action"></ng-content>
      </span>
    </div>
  `,
      styles: [":host{display:block}\n"]
    }]
  }], function() {
    return [{
      type: ClrStackView
    }];
  }, null);
})();
var CLR_STACK_VIEW_DIRECTIVES = [ClrStackView, ClrStackHeader, ClrStackBlock, ClrStackContentInput, ClrStackViewLabel, ClrStackViewCustomTags];
var ClrStackViewModule = class {
  constructor() {
    r.addIcons(o3);
  }
};
ClrStackViewModule.ɵfac = function ClrStackViewModule_Factory(t3) {
  return new (t3 || ClrStackViewModule)();
};
ClrStackViewModule.ɵmod = ɵɵdefineNgModule({
  type: ClrStackViewModule,
  declarations: [ClrStackView, ClrStackHeader, ClrStackBlock, ClrStackContentInput, ClrStackViewLabel, ClrStackViewCustomTags],
  imports: [CommonModule, FormsModule, ClrIconModule, ClrExpandableAnimationModule],
  exports: [ClrStackView, ClrStackHeader, ClrStackBlock, ClrStackContentInput, ClrStackViewLabel, ClrStackViewCustomTags]
});
ClrStackViewModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, FormsModule, ClrIconModule, ClrExpandableAnimationModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrStackViewModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, FormsModule, ClrIconModule, ClrExpandableAnimationModule],
      declarations: [CLR_STACK_VIEW_DIRECTIVES],
      exports: [CLR_STACK_VIEW_DIRECTIVES]
    }]
  }], function() {
    return [];
  }, null);
})();
var TreeFeaturesService = class {
  constructor() {
    this.selectable = false;
    this.eager = true;
    this.childrenFetched = new Subject();
  }
};
TreeFeaturesService.ɵfac = function TreeFeaturesService_Factory(t3) {
  return new (t3 || TreeFeaturesService)();
};
TreeFeaturesService.ɵprov = ɵɵdefineInjectable({
  token: TreeFeaturesService,
  factory: TreeFeaturesService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TreeFeaturesService, [{
    type: Injectable
  }], null, null);
})();
function treeFeaturesFactory(existing) {
  return existing || new TreeFeaturesService();
}
var TREE_FEATURES_PROVIDER = {
  provide: TreeFeaturesService,
  useFactory: treeFeaturesFactory,
  /*
   * The Optional + SkipSelf pattern ensures that in case of nested components, only the root one will
   * instantiate a new service and all its children will reuse the root's instance.
   * If there are several roots (in this case, several independent trees on a page), each root will instantiate
   * its own service so they won't interfere with one another.
   *
   * TL;DR - Optional + SkipSelf = 1 instance of TreeFeaturesService per tree.
   */
  deps: [[new Optional(), new SkipSelf(), TreeFeaturesService]]
};
var RecursiveChildren = class {
  constructor(featuresService, expandService) {
    this.featuresService = featuresService;
    this.expandService = expandService;
    if (expandService) {
      this.subscription = this.expandService.expandChange.subscribe((value) => {
        if (!value && this.parent && !this.featuresService.eager && this.featuresService.recursion) {
          this.parent.clearChildren();
        }
      });
    }
  }
  ngAfterContentInit() {
    this.setAriaRoles();
  }
  shouldRender() {
    return this.featuresService.recursion && // In the smart case, we eagerly render all the recursive children
    // to make sure two-way bindings for selection are available.
    // They will be hidden with CSS by the parent.
    (this.featuresService.eager || !this.expandService || this.expandService.expanded);
  }
  getContext(node) {
    return {
      $implicit: node.model,
      clrModel: node
    };
  }
  ngOnDestroy() {
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
  }
  setAriaRoles() {
    this.role = this.parent ? "group" : null;
  }
};
RecursiveChildren.ɵfac = function RecursiveChildren_Factory(t3) {
  return new (t3 || RecursiveChildren)(ɵɵdirectiveInject(TreeFeaturesService), ɵɵdirectiveInject(IfExpandService, 8));
};
RecursiveChildren.ɵcmp = ɵɵdefineComponent({
  type: RecursiveChildren,
  selectors: [["clr-recursive-children"]],
  hostVars: 1,
  hostBindings: function RecursiveChildren_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("role", ctx.role);
    }
  },
  inputs: {
    parent: "parent",
    children: "children"
  },
  decls: 1,
  vars: 1,
  consts: [[4, "ngIf"], [4, "ngFor", "ngForOf"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"]],
  template: function RecursiveChildren_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, RecursiveChildren_ng_container_0_Template, 2, 1, "ng-container", 0);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.shouldRender());
    }
  },
  dependencies: [NgForOf, NgIf, NgTemplateOutlet],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RecursiveChildren, [{
    type: Component,
    args: [{
      selector: "clr-recursive-children",
      template: `
    <ng-container *ngIf="shouldRender()">
      <ng-container *ngFor="let child of parent?.children || children">
        <ng-container *ngTemplateOutlet="featuresService.recursion.template; context: getContext(child)"></ng-container>
      </ng-container>
    </ng-container>
  `,
      host: {
        "[attr.role]": "role"
        // Safari + VO needs direct relationship between treeitem and group; no element should exist between them
      }
    }]
  }], function() {
    return [{
      type: TreeFeaturesService
    }, {
      type: IfExpandService,
      decorators: [{
        type: Optional
      }]
    }];
  }, {
    parent: [{
      type: Input,
      args: ["parent"]
    }],
    children: [{
      type: Input,
      args: ["children"]
    }]
  });
})();
function isPromise(o9) {
  return o9 && typeof o9.then === "function";
}
var ClrSelectedState;
(function(ClrSelectedState2) {
  ClrSelectedState2[ClrSelectedState2["UNSELECTED"] = 0] = "UNSELECTED";
  ClrSelectedState2[ClrSelectedState2["SELECTED"] = 1] = "SELECTED";
  ClrSelectedState2[ClrSelectedState2["INDETERMINATE"] = 2] = "INDETERMINATE";
})(ClrSelectedState || (ClrSelectedState = {}));
var TreeNodeModel = class {
  constructor() {
    this.loading$ = new BehaviorSubject(false);
    this.selected = new BehaviorSubject(ClrSelectedState.UNSELECTED);
    this._loading = false;
  }
  get loading() {
    return this._loading;
  }
  set loading(isLoading) {
    this._loading = isLoading;
    this.loading$.next(isLoading);
  }
  get disabled() {
    return !!(this._disabled || this.parent?.disabled);
  }
  set disabled(value) {
    this._disabled = value;
  }
  destroy() {
    this.selected.complete();
  }
  // Propagate by default when eager, don't propagate in the lazy-loaded tree.
  setSelected(state2, propagateUp, propagateDown) {
    if (state2 === this.selected.value) {
      return;
    }
    this.selected.next(state2);
    if (propagateDown && state2 !== ClrSelectedState.INDETERMINATE && this.children) {
      this.children.forEach((child) => {
        if (!child.disabled) {
          child.setSelected(state2, false, true);
        }
      });
    }
    if (propagateUp && this.parent) {
      this.parent._updateSelectionFromChildren();
    }
  }
  toggleSelection(propagate) {
    if (this.disabled) {
      return;
    }
    const newState = this.selected.value === ClrSelectedState.SELECTED ? ClrSelectedState.UNSELECTED : ClrSelectedState.SELECTED;
    this.setSelected(newState, true, propagate);
  }
  /*
   * Internal, but needs to be called by other nodes
   */
  _updateSelectionFromChildren() {
    const newState = this.computeSelectionStateFromChildren();
    if (newState === this.selected.value) {
      return;
    }
    this.selected.next(newState);
    if (this.parent) {
      this.parent._updateSelectionFromChildren();
    }
  }
  computeSelectionStateFromChildren() {
    let oneSelected = false;
    let oneUnselected = false;
    for (const child of this.children) {
      switch (child.selected.value) {
        case ClrSelectedState.INDETERMINATE:
          if (child.disabled) {
            continue;
          }
          return ClrSelectedState.INDETERMINATE;
        case ClrSelectedState.SELECTED:
          oneSelected = true;
          if (oneUnselected) {
            return ClrSelectedState.INDETERMINATE;
          }
          break;
        case ClrSelectedState.UNSELECTED:
        default:
          oneUnselected = true;
          if (oneSelected) {
            return ClrSelectedState.INDETERMINATE;
          }
          break;
      }
    }
    if (!oneSelected) {
      return ClrSelectedState.UNSELECTED;
    } else if (!oneUnselected) {
      return ClrSelectedState.SELECTED;
    } else {
      return ClrSelectedState.UNSELECTED;
    }
  }
};
var RecursiveTreeNodeModel = class _RecursiveTreeNodeModel extends TreeNodeModel {
  constructor(model, parent, getChildren, featuresService) {
    super();
    this.getChildren = getChildren;
    this.featuresService = featuresService;
    this.childrenFetched = false;
    this._children = [];
    this.model = model;
    this.parent = parent;
  }
  get children() {
    this.fetchChildren();
    return this._children;
  }
  set children(value) {
    this._children = value;
  }
  destroy() {
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
    super.destroy();
  }
  clearChildren() {
    this._children.forEach((child) => child.destroy());
    delete this._children;
    this.childrenFetched = false;
  }
  fetchChildren() {
    if (this.childrenFetched) {
      return;
    }
    const asyncChildren = this.getChildren(this.model);
    if (isPromise(asyncChildren)) {
      this.loading = true;
      asyncChildren.then((raw) => {
        this._children = this.wrapChildren(raw);
        this.loading = false;
      });
    } else if (isObservable(asyncChildren)) {
      this.loading = true;
      this.subscription = asyncChildren.subscribe((raw) => {
        this._children = this.wrapChildren(raw);
        this.loading = false;
      });
    } else if (asyncChildren) {
      this._children = this.wrapChildren(asyncChildren);
    } else {
      this._children = [];
    }
    this.childrenFetched = true;
    if (this.featuresService) {
      this.featuresService.childrenFetched.next();
    }
  }
  wrapChildren(rawModels) {
    return rawModels.map((m3) => new _RecursiveTreeNodeModel(m3, this, this.getChildren, this.featuresService));
  }
};
var ClrRecursiveForOf = class {
  constructor(template, featuresService, cdr) {
    this.template = template;
    this.featuresService = featuresService;
    this.cdr = cdr;
  }
  // I'm using OnChanges instead of OnInit to easily keep up to date with dynamic trees. Maybe optimizable later.
  ngOnChanges() {
    let wrapped;
    if (Array.isArray(this.nodes)) {
      wrapped = this.nodes.map((node) => new RecursiveTreeNodeModel(node, null, this.getChildren, this.featuresService));
    } else {
      wrapped = [new RecursiveTreeNodeModel(this.nodes, null, this.getChildren, this.featuresService)];
    }
    if (!this.childrenFetchSubscription) {
      this.childrenFetchSubscription = this.featuresService.childrenFetched.pipe(debounceTime(0)).subscribe(() => {
        this.cdr.detectChanges();
      });
    }
    this.featuresService.recursion = {
      template: this.template,
      root: wrapped
    };
  }
  ngOnDestroy() {
    if (this.childrenFetchSubscription) {
      this.childrenFetchSubscription.unsubscribe();
    }
  }
};
ClrRecursiveForOf.ɵfac = function ClrRecursiveForOf_Factory(t3) {
  return new (t3 || ClrRecursiveForOf)(ɵɵdirectiveInject(TemplateRef), ɵɵdirectiveInject(TreeFeaturesService), ɵɵdirectiveInject(ChangeDetectorRef));
};
ClrRecursiveForOf.ɵdir = ɵɵdefineDirective({
  type: ClrRecursiveForOf,
  selectors: [["", "clrRecursiveFor", "", "clrRecursiveForOf", ""]],
  inputs: {
    nodes: [InputFlags.None, "clrRecursiveForOf", "nodes"],
    getChildren: [InputFlags.None, "clrRecursiveForGetChildren", "getChildren"]
  },
  features: [ɵɵNgOnChangesFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrRecursiveForOf, [{
    type: Directive,
    args: [{
      selector: "[clrRecursiveFor][clrRecursiveForOf]"
    }]
  }], function() {
    return [{
      type: TemplateRef
    }, {
      type: TreeFeaturesService
    }, {
      type: ChangeDetectorRef
    }];
  }, {
    nodes: [{
      type: Input,
      args: ["clrRecursiveForOf"]
    }],
    getChildren: [{
      type: Input,
      args: ["clrRecursiveForGetChildren"]
    }]
  });
})();
var TreeFocusManagerService = class {
  constructor() {
    this._focusRequest = new Subject();
    this._focusChange = new Subject();
  }
  get focusRequest() {
    return this._focusRequest.asObservable();
  }
  get focusChange() {
    return this._focusChange.asObservable();
  }
  focusNode(model) {
    if (model) {
      this._focusRequest.next(model.nodeId);
    }
  }
  broadcastFocusedNode(nodeId) {
    if (this.focusedNodeId !== nodeId) {
      this.focusedNodeId = nodeId;
      this._focusChange.next(nodeId);
    }
  }
  focusParent(model) {
    if (model) {
      this.focusNode(model.parent);
    }
  }
  focusFirstVisibleNode() {
    const focusModel = this.rootNodeModels && this.rootNodeModels[0];
    this.focusNode(focusModel);
  }
  focusLastVisibleNode() {
    this.focusNode(this.findLastVisibleInTree());
  }
  focusNodeAbove(model) {
    this.focusNode(this.findNodeAbove(model));
  }
  focusNodeBelow(model) {
    this.focusNode(this.findNodeBelow(model));
  }
  focusNodeStartsWith(searchString, model) {
    this.focusNode(this.findClosestNodeStartsWith(searchString, model));
  }
  findSiblings(model) {
    if (model.parent) {
      return model.parent.children;
    } else {
      return this.rootNodeModels;
    }
  }
  findLastVisibleInNode(model) {
    if (!model) {
      return null;
    }
    if (model.expanded && model.children.length > 0) {
      const children = model.children;
      const lastChild = children[children.length - 1];
      return this.findLastVisibleInNode(lastChild);
    } else {
      return model;
    }
  }
  findNextFocusable(model) {
    if (!model) {
      return null;
    }
    const siblings = this.findSiblings(model);
    const selfIndex = siblings.indexOf(model);
    if (selfIndex < siblings.length - 1) {
      return siblings[selfIndex + 1];
    } else if (selfIndex === siblings.length - 1) {
      return this.findNextFocusable(model.parent);
    }
    return null;
  }
  findLastVisibleInTree() {
    const lastRootNode = this.rootNodeModels && this.rootNodeModels.length && this.rootNodeModels[this.rootNodeModels.length - 1];
    return this.findLastVisibleInNode(lastRootNode);
  }
  findNodeAbove(model) {
    if (!model) {
      return null;
    }
    const siblings = this.findSiblings(model);
    const selfIndex = siblings.indexOf(model);
    if (selfIndex === 0) {
      return model.parent;
    } else if (selfIndex > 0) {
      return this.findLastVisibleInNode(siblings[selfIndex - 1]);
    }
    return null;
  }
  findNodeBelow(model) {
    if (!model) {
      return null;
    }
    if (model.expanded && model.children.length > 0) {
      return model.children[0];
    } else {
      return this.findNextFocusable(model);
    }
  }
  findDescendentNodeStartsWith(searchString, model) {
    if (model.expanded && model.children.length > 0) {
      for (const childModel of model.children) {
        const found = this.findNodeStartsWith(searchString, childModel);
        if (found) {
          return found;
        }
      }
    }
    return null;
  }
  findSiblingNodeStartsWith(searchString, model) {
    const siblings = this.findSiblings(model);
    const selfIndex = siblings.indexOf(model);
    for (let i2 = selfIndex + 1; i2 < siblings.length; i2++) {
      const siblingModel = siblings[i2];
      const found = this.findNodeStartsWith(searchString, siblingModel);
      if (found) {
        return found;
      }
    }
    return null;
  }
  findRootNodeStartsWith(searchString, model) {
    for (const rootModel of this.rootNodeModels) {
      if (model.parent && model.parent === rootModel) {
        continue;
      }
      const found = this.findNodeStartsWith(searchString, rootModel);
      if (found) {
        return found;
      }
    }
    return null;
  }
  findNodeStartsWith(searchString, model) {
    if (!model) {
      return null;
    }
    if (model.textContent.startsWith(searchString)) {
      return model;
    }
    return this.findDescendentNodeStartsWith(searchString, model);
  }
  findClosestNodeStartsWith(searchString, model) {
    if (!model) {
      return null;
    }
    const foundFromDescendents = this.findDescendentNodeStartsWith(searchString, model);
    if (foundFromDescendents) {
      return foundFromDescendents;
    }
    const foundFromSiblings = this.findSiblingNodeStartsWith(searchString, model);
    if (foundFromSiblings) {
      return foundFromSiblings;
    }
    const foundFromRootNodes = this.findRootNodeStartsWith(searchString, model);
    if (foundFromRootNodes) {
      return foundFromRootNodes;
    }
    return this.findNodeStartsWith(searchString, model.parent);
  }
};
TreeFocusManagerService.ɵfac = function TreeFocusManagerService_Factory(t3) {
  return new (t3 || TreeFocusManagerService)();
};
TreeFocusManagerService.ɵprov = ɵɵdefineInjectable({
  token: TreeFocusManagerService,
  factory: TreeFocusManagerService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TreeFocusManagerService, [{
    type: Injectable
  }], null, null);
})();
var DeclarativeTreeNodeModel = class extends TreeNodeModel {
  constructor(parent) {
    super();
    this.parent = parent;
    if (parent) {
      parent._addChild(this);
    }
    this.children = [];
  }
  destroy() {
    if (this.parent) {
      this.parent._removeChild(this);
    }
    super.destroy();
  }
  _addChild(child) {
    this.children.push(child);
  }
  _removeChild(child) {
    const index = this.children.indexOf(child);
    if (index > -1) {
      this.children.splice(index, 1);
    }
  }
};
var ClrTreeNodeLink = class {
  constructor(el) {
    this.el = el;
  }
  get active() {
    return this.el.nativeElement.classList.contains("active");
  }
  activate() {
    if (this.el.nativeElement && this.el.nativeElement.click) {
      this.el.nativeElement.click();
    }
  }
};
ClrTreeNodeLink.ɵfac = function ClrTreeNodeLink_Factory(t3) {
  return new (t3 || ClrTreeNodeLink)(ɵɵdirectiveInject(ElementRef));
};
ClrTreeNodeLink.ɵdir = ɵɵdefineDirective({
  type: ClrTreeNodeLink,
  selectors: [["", 8, "clr-treenode-link"]]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrTreeNodeLink, [{
    type: Directive,
    args: [{
      selector: ".clr-treenode-link"
    }]
  }], function() {
    return [{
      type: ElementRef
    }];
  }, null);
})();
var LVIEW_CONTEXT_INDEX = 8;
var TREE_TYPE_AHEAD_TIMEOUT = 200;
var ClrTreeNode = class {
  constructor(platformId, parent, featuresService, expandService, commonStrings, focusManager, elementRef, injector) {
    this.platformId = platformId;
    this.featuresService = featuresService;
    this.expandService = expandService;
    this.commonStrings = commonStrings;
    this.focusManager = focusManager;
    this.elementRef = elementRef;
    this.selectedChange = new EventEmitter(false);
    this.expandedChange = new EventEmitter();
    this.STATES = ClrSelectedState;
    this.isModelLoading = false;
    this.nodeId = uniqueIdFactory();
    this.contentContainerTabindex = -1;
    this.skipEmitChange = false;
    this.typeAheadKeyBuffer = "";
    this.typeAheadKeyEvent = new Subject();
    this.subscriptions = [];
    if (this.featuresService.recursion) {
      if (injector.view) {
        this._model = injector.view.context.clrModel;
      } else {
        this._model = injector._lView[LVIEW_CONTEXT_INDEX].clrModel;
      }
    } else {
      this._model = new DeclarativeTreeNodeModel(parent ? parent._model : null);
    }
    this._model.nodeId = this.nodeId;
  }
  get disabled() {
    return this._model.disabled;
  }
  set disabled(value) {
    this._model.disabled = value;
  }
  get selected() {
    return this._model.selected.value;
  }
  set selected(value) {
    this.featuresService.selectable = true;
    if (value === null || typeof value === "undefined") {
      value = ClrSelectedState.UNSELECTED;
    }
    if (typeof value === "boolean") {
      value = value ? ClrSelectedState.SELECTED : ClrSelectedState.UNSELECTED;
    }
    this.skipEmitChange = true;
    this._model.setSelected(value, this.featuresService.eager, this.featuresService.eager);
    this.skipEmitChange = false;
  }
  // I'm caving on this, for tree nodes I think we can tolerate having a two-way binding on the component
  // rather than enforce the clrIfExpanded structural directive for dynamic cases. Mostly because for the smart
  // case, you can't use a structural directive, it would need to go on an ng-container.
  get expanded() {
    return this.expandService.expanded;
  }
  set expanded(value) {
    this.expandService.expanded = value;
  }
  set clrForTypeAhead(value) {
    this._model.textContent = trimAndLowerCase(value || this.elementRef.nativeElement.textContent);
  }
  get ariaSelected() {
    if (this.isSelectable()) {
      return this._model.selected.value === ClrSelectedState.SELECTED;
    } else if (this.treeNodeLink?.active) {
      return true;
    } else {
      return null;
    }
  }
  get treeNodeContentTextOnly() {
    return this.treeNodeLinkList.length === 0;
  }
  get treeNodeLink() {
    return this.treeNodeLinkList && this.treeNodeLinkList.first;
  }
  get isParent() {
    return this._model.children && this._model.children.length > 0;
  }
  ngOnInit() {
    this._model.expanded = this.expanded;
    this._model.disabled = this.disabled;
    this.subscriptions.push(this._model.selected.pipe(filter(() => !this.skipEmitChange)).subscribe((value) => {
      this.selectedChange.emit(value);
    }));
    this.subscriptions.push(this.expandService.expandChange.subscribe((value) => {
      this.expandedChange.emit(value);
      this._model.expanded = value;
    }));
    this.subscriptions.push(this.focusManager.focusRequest.subscribe((nodeId) => {
      if (this.nodeId === nodeId) {
        this.focusTreeNode();
      }
    }), this.focusManager.focusChange.subscribe((nodeId) => {
      this.checkTabIndex(nodeId);
    }));
    this.subscriptions.push(this._model.loading$.pipe(debounceTime(0)).subscribe((isLoading) => this.isModelLoading = isLoading));
  }
  ngAfterContentInit() {
    this.subscriptions.push(this.typeAheadKeyEvent.pipe(debounceTime(TREE_TYPE_AHEAD_TIMEOUT)).subscribe((bufferedKeys) => {
      this.focusManager.focusNodeStartsWith(bufferedKeys, this._model);
      this.typeAheadKeyBuffer = "";
    }));
  }
  ngAfterViewInit() {
    if (!this._model.textContent) {
      this._model.textContent = trimAndLowerCase(this.elementRef.nativeElement.textContent);
    }
  }
  ngOnDestroy() {
    this._model.destroy();
    this.subscriptions.forEach((sub) => sub.unsubscribe());
  }
  isExpandable() {
    if (typeof this.expandable !== "undefined") {
      return this.expandable;
    }
    return !!this.expandService.expandable || this.isParent;
  }
  isSelectable() {
    return this.featuresService.selectable;
  }
  focusTreeNode() {
    const containerEl = this.contentContainer.nativeElement;
    if (isPlatformBrowser(this.platformId) && document.activeElement !== containerEl) {
      this.setTabIndex(0);
      containerEl.focus();
      containerEl.scrollIntoView({
        block: "nearest",
        inline: "nearest"
      });
    }
  }
  broadcastFocusOnContainer() {
    this.focusManager.broadcastFocusedNode(this.nodeId);
  }
  onKeyDown(event) {
    preventArrowKeyScroll(event);
    switch (normalizeKey(event.key)) {
      case Keys.ArrowUp:
        this.focusManager.focusNodeAbove(this._model);
        break;
      case Keys.ArrowDown:
        this.focusManager.focusNodeBelow(this._model);
        break;
      case Keys.ArrowRight:
        this.expandOrFocusFirstChild();
        break;
      case Keys.ArrowLeft:
        this.collapseOrFocusParent();
        break;
      case Keys.Home:
        event.preventDefault();
        this.focusManager.focusFirstVisibleNode();
        break;
      case Keys.End:
        event.preventDefault();
        this.focusManager.focusLastVisibleNode();
        break;
      case Keys.Enter:
        this.toggleExpandOrTriggerDefault();
        break;
      case Keys.Space:
      case Keys.Spacebar:
        event.preventDefault();
        this.toggleExpandOrTriggerDefault();
        break;
      default:
        if (this._model.textContent && isKeyEitherLetterOrNumber(event)) {
          this.typeAheadKeyBuffer += event.key;
          this.typeAheadKeyEvent.next(this.typeAheadKeyBuffer);
          return;
        }
        break;
    }
    this.typeAheadKeyBuffer = "";
  }
  setTabIndex(value) {
    this.contentContainerTabindex = value;
    this.contentContainer.nativeElement.setAttribute("tabindex", value);
  }
  checkTabIndex(nodeId) {
    if (isPlatformBrowser(this.platformId) && this.nodeId !== nodeId && this.contentContainerTabindex !== -1) {
      this.setTabIndex(-1);
    }
  }
  toggleExpandOrTriggerDefault() {
    if (this.disabled) {
      return;
    }
    if (this.isExpandable() && !this.isSelectable()) {
      this.expandService.expanded = !this.expanded;
    } else {
      this.triggerDefaultAction();
    }
  }
  expandOrFocusFirstChild() {
    if (this.disabled) {
      return;
    }
    if (this.expanded) {
      if (this.isParent) {
        this.focusManager.focusNodeBelow(this._model);
      }
    } else {
      if (this.isExpandable()) {
        this.expandService.expanded = true;
      }
    }
  }
  collapseOrFocusParent() {
    if (this.disabled) {
      return;
    }
    if (this.expanded) {
      this.expandService.expanded = false;
    } else {
      this.focusManager.focusParent(this._model);
    }
  }
  triggerDefaultAction() {
    if (this.treeNodeLink) {
      this.treeNodeLink.activate();
    } else {
      if (this.isSelectable()) {
        this._model.toggleSelection(this.featuresService.eager);
      }
    }
  }
};
ClrTreeNode.ɵfac = function ClrTreeNode_Factory(t3) {
  return new (t3 || ClrTreeNode)(ɵɵdirectiveInject(PLATFORM_ID), ɵɵdirectiveInject(ClrTreeNode, 12), ɵɵdirectiveInject(TreeFeaturesService), ɵɵdirectiveInject(IfExpandService), ɵɵdirectiveInject(ClrCommonStringsService), ɵɵdirectiveInject(TreeFocusManagerService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Injector));
};
ClrTreeNode.ɵcmp = ɵɵdefineComponent({
  type: ClrTreeNode,
  selectors: [["clr-tree-node"]],
  contentQueries: function ClrTreeNode_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ClrTreeNodeLink, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.treeNodeLinkList = _t);
    }
  },
  viewQuery: function ClrTreeNode_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c85, 7, ElementRef);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.contentContainer = _t.first);
    }
  },
  hostVars: 4,
  hostBindings: function ClrTreeNode_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("clr-tree-node", true)("disabled", ctx._model.disabled);
    }
  },
  inputs: {
    expandable: [InputFlags.None, "clrExpandable", "expandable"],
    disabled: [InputFlags.None, "clrDisabled", "disabled"],
    selected: [InputFlags.None, "clrSelected", "selected"],
    expanded: [InputFlags.None, "clrExpanded", "expanded"],
    clrForTypeAhead: "clrForTypeAhead"
  },
  outputs: {
    selectedChange: "clrSelectedChange",
    expandedChange: "clrExpandedChange"
  },
  features: [ɵɵProvidersFeature([TREE_FEATURES_PROVIDER, IfExpandService, {
    provide: LoadingListener,
    useExisting: IfExpandService
  }])],
  ngContentSelectors: _c87,
  decls: 12,
  vars: 12,
  consts: [["contentContainer", ""], ["treenodeContent", ""], ["role", "treeitem", "tabindex", "-1", 1, "clr-tree-node-content-container", 3, "keydown", "focus"], ["aria-hidden", "true", "type", "button", "tabindex", "-1", "class", "clr-treenode-caret", 3, "disabled", "click", "focus", 4, "ngIf"], ["class", "clr-treenode-spinner-container", 4, "ngIf"], ["class", "clr-checkbox-wrapper clr-treenode-checkbox", 4, "ngIf"], ["class", "clr-treenode-content", 3, "clr-treenode-text-only", "mouseup", 4, "ngIf"], [1, "clr-treenode-children"], [3, "parent"], ["aria-hidden", "true", "type", "button", "tabindex", "-1", 1, "clr-treenode-caret", 3, "click", "focus", "disabled"], ["shape", "angle", 1, "clr-treenode-caret-icon"], [1, "clr-treenode-spinner-container"], [1, "clr-treenode-spinner", "spinner"], [1, "clr-checkbox-wrapper", "clr-treenode-checkbox"], ["aria-hidden", "true", "type", "checkbox", "tabindex", "-1", 1, "clr-checkbox", 3, "change", "focus", "id", "disabled", "checked", "indeterminate"], [1, "clr-control-label", 3, "for"], [3, "ngTemplateOutlet"], [1, "clr-treenode-content", 3, "mouseup"], ["class", "clr-sr-only", 4, "ngIf"], [1, "clr-sr-only"], [4, "ngIf"]],
  template: function ClrTreeNode_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵprojectionDef(_c86);
      ɵɵelementStart(0, "div", 2, 0);
      ɵɵlistener("keydown", function ClrTreeNode_Template_div_keydown_0_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.onKeyDown($event));
      })("focus", function ClrTreeNode_Template_div_focus_0_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.broadcastFocusOnContainer());
      });
      ɵɵtemplate(2, ClrTreeNode_button_2_Template, 2, 2, "button", 3)(3, ClrTreeNode_div_3_Template, 2, 0, "div", 4)(4, ClrTreeNode_div_4_Template, 4, 8, "div", 5)(5, ClrTreeNode_div_5_Template, 2, 3, "div", 6)(6, ClrTreeNode_ng_template_6_Template, 2, 1, "ng-template", null, 1, ɵɵtemplateRefExtractor);
      ɵɵelementEnd();
      ɵɵelementStart(8, "div", 7);
      ɵɵprojection(9);
      ɵɵprojection(10, 1);
      ɵɵelement(11, "clr-recursive-children", 8);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵclassProp("clr-form-control-disabled", ctx.disabled);
      ɵɵattribute("aria-disabled", ctx.disabled)("aria-expanded", ctx.isExpandable() ? ctx.expanded : null)("aria-selected", ctx.ariaSelected);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.isExpandable() && !ctx.isModelLoading && !ctx.expandService.loading);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.expandService.loading || ctx.isModelLoading);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.featuresService.selectable);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.featuresService.selectable);
      ɵɵadvance(3);
      ɵɵproperty("@toggleChildrenAnim", ctx.expandService.expanded ? "expanded" : "collapsed");
      ɵɵattribute("role", ctx.isExpandable() && !ctx.featuresService.recursion ? "group" : null);
      ɵɵadvance(3);
      ɵɵproperty("parent", ctx._model);
    }
  },
  dependencies: [NgIf, NgTemplateOutlet, CdsIconCustomTag, RecursiveChildren],
  encapsulation: 2,
  data: {
    animation: [trigger("toggleChildrenAnim", [transition("collapsed => expanded", [style({
      height: 0
    }), animate(200, style({
      height: "*"
    }))]), transition("expanded => collapsed", [style({
      height: "*"
    }), animate(200, style({
      height: 0
    }))]), state("expanded", style({
      height: "*",
      "overflow-y": "visible"
    })), state("collapsed", style({
      height: 0
    }))])]
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrTreeNode, [{
    type: Component,
    args: [{
      selector: "clr-tree-node",
      providers: [TREE_FEATURES_PROVIDER, IfExpandService, {
        provide: LoadingListener,
        useExisting: IfExpandService
      }],
      animations: [trigger("toggleChildrenAnim", [transition("collapsed => expanded", [style({
        height: 0
      }), animate(200, style({
        height: "*"
      }))]), transition("expanded => collapsed", [style({
        height: "*"
      }), animate(200, style({
        height: 0
      }))]), state("expanded", style({
        height: "*",
        "overflow-y": "visible"
      })), state("collapsed", style({
        height: 0
      }))])],
      host: {
        "[class.clr-tree-node]": "true",
        "[class.disabled]": "this._model.disabled"
      },
      template: `<!--
  ~ Copyright (c) 2016-2024 Broadcom. All Rights Reserved.
  ~ The term "Broadcom" refers to Broadcom Inc. and/or its subsidiaries.
  ~ This software is released under MIT license.
  ~ The full license information can be found in LICENSE in the root directory of this project.
  -->

<div
  #contentContainer
  role="treeitem"
  class="clr-tree-node-content-container"
  tabindex="-1"
  [class.clr-form-control-disabled]="disabled"
  [attr.aria-disabled]="disabled"
  [attr.aria-expanded]="isExpandable() ? expanded : null"
  [attr.aria-selected]="ariaSelected"
  (keydown)="onKeyDown($event)"
  (focus)="broadcastFocusOnContainer()"
>
  <button
    *ngIf="isExpandable() && !isModelLoading && !expandService.loading"
    aria-hidden="true"
    type="button"
    tabindex="-1"
    class="clr-treenode-caret"
    (click)="expandService.toggle();"
    (focus)="focusTreeNode()"
    [disabled]="disabled"
  >
    <cds-icon
      class="clr-treenode-caret-icon"
      shape="angle"
      [attr.direction]="expandService.expanded ? 'down' : 'right'"
    ></cds-icon>
  </button>
  <div class="clr-treenode-spinner-container" *ngIf="expandService.loading || isModelLoading">
    <span class="clr-treenode-spinner spinner"></span>
  </div>
  <div class="clr-checkbox-wrapper clr-treenode-checkbox" *ngIf="featuresService.selectable">
    <input
      aria-hidden="true"
      type="checkbox"
      id="{{nodeId}}-check"
      class="clr-checkbox"
      [disabled]="disabled"
      [checked]="_model.selected.value === STATES.SELECTED"
      [indeterminate]="_model.selected.value === STATES.INDETERMINATE"
      (change)="_model.toggleSelection(featuresService.eager)"
      (focus)="focusTreeNode()"
      tabindex="-1"
    />
    <label for="{{nodeId}}-check" class="clr-control-label">
      <ng-container [ngTemplateOutlet]="treenodeContent"></ng-container>
    </label>
  </div>
  <div
    class="clr-treenode-content"
    [class.clr-treenode-text-only]="treeNodeContentTextOnly"
    (mouseup)="focusTreeNode()"
    *ngIf="!featuresService.selectable"
  >
    <ng-container [ngTemplateOutlet]="treenodeContent"></ng-container>
  </div>

  <ng-template #treenodeContent>
    <ng-content></ng-content>
    <div class="clr-sr-only" *ngIf="featuresService.selectable || ariaSelected">
      <span *ngIf="ariaSelected"> selected</span>
      <span *ngIf="!ariaSelected"> unselected</span>
    </div>
  </ng-template>
</div>
<div
  class="clr-treenode-children"
  [@toggleChildrenAnim]="expandService.expanded ? 'expanded' : 'collapsed'"
  [attr.role]="isExpandable() && !featuresService.recursion ? 'group' : null"
>
  <ng-content select="clr-tree-node"></ng-content>
  <ng-content select="[clrIfExpanded]"></ng-content>
  <clr-recursive-children [parent]="_model"></clr-recursive-children>
</div>
`
    }]
  }], function() {
    return [{
      type: void 0,
      decorators: [{
        type: Inject,
        args: [PLATFORM_ID]
      }]
    }, {
      type: ClrTreeNode,
      decorators: [{
        type: Optional
      }, {
        type: SkipSelf
      }]
    }, {
      type: TreeFeaturesService
    }, {
      type: IfExpandService
    }, {
      type: ClrCommonStringsService
    }, {
      type: TreeFocusManagerService
    }, {
      type: ElementRef
    }, {
      type: Injector
    }];
  }, {
    expandable: [{
      type: Input,
      args: ["clrExpandable"]
    }],
    selectedChange: [{
      type: Output,
      args: ["clrSelectedChange"]
    }],
    expandedChange: [{
      type: Output,
      args: ["clrExpandedChange"]
    }],
    contentContainer: [{
      type: ViewChild,
      args: ["contentContainer", {
        read: ElementRef,
        static: true
      }]
    }],
    treeNodeLinkList: [{
      type: ContentChildren,
      args: [ClrTreeNodeLink, {
        descendants: false
      }]
    }],
    disabled: [{
      type: Input,
      args: ["clrDisabled"]
    }],
    selected: [{
      type: Input,
      args: ["clrSelected"]
    }],
    expanded: [{
      type: Input,
      args: ["clrExpanded"]
    }],
    clrForTypeAhead: [{
      type: Input,
      args: ["clrForTypeAhead"]
    }]
  });
})();
function trimAndLowerCase(value) {
  return value.toLocaleLowerCase().trim();
}
var ClrTree = class {
  constructor(featuresService, focusManagerService, {
    nativeElement
  }, renderer, ngZone) {
    this.featuresService = featuresService;
    this.focusManagerService = focusManagerService;
    this.subscriptions = [];
    const subscription = ngZone.runOutsideAngular(() => fromEvent(nativeElement, "focusin").subscribe((event) => {
      if (event.target === nativeElement) {
        this.focusManagerService.focusFirstVisibleNode();
        renderer.removeAttribute(nativeElement, "tabindex");
      }
    }));
    this.subscriptions.push(subscription);
  }
  set lazy(value) {
    this.featuresService.eager = !value;
  }
  get isMultiSelectable() {
    return this.featuresService.selectable && this.rootNodes.length > 0;
  }
  ngAfterContentInit() {
    this.setRootNodes();
    this.subscriptions.push(this.rootNodes.changes.subscribe(() => {
      this.setRootNodes();
    }));
  }
  ngOnDestroy() {
    this.subscriptions.forEach((sub) => sub.unsubscribe());
  }
  setRootNodes() {
    this.focusManagerService.rootNodeModels = this.rootNodes.map((node) => node._model).filter((node) => !node.parent);
  }
};
ClrTree.ɵfac = function ClrTree_Factory(t3) {
  return new (t3 || ClrTree)(ɵɵdirectiveInject(TreeFeaturesService), ɵɵdirectiveInject(TreeFocusManagerService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(NgZone));
};
ClrTree.ɵcmp = ɵɵdefineComponent({
  type: ClrTree,
  selectors: [["clr-tree"]],
  contentQueries: function ClrTree_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ClrTreeNode, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.rootNodes = _t);
    }
  },
  hostAttrs: ["tabindex", "0"],
  hostVars: 2,
  hostBindings: function ClrTree_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("role", "tree")("aria-multiselectable", ctx.isMultiSelectable);
    }
  },
  inputs: {
    lazy: [InputFlags.None, "clrLazy", "lazy"]
  },
  features: [ɵɵProvidersFeature([TREE_FEATURES_PROVIDER, TreeFocusManagerService])],
  ngContentSelectors: _c02,
  decls: 2,
  vars: 1,
  consts: [[3, "children", 4, "ngIf"], [3, "children"]],
  template: function ClrTree_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
      ɵɵtemplate(1, ClrTree_clr_recursive_children_1_Template, 1, 1, "clr-recursive-children", 0);
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.featuresService.recursion);
    }
  },
  dependencies: [NgIf, RecursiveChildren],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrTree, [{
    type: Component,
    args: [{
      selector: "clr-tree",
      template: `
    <ng-content></ng-content>
    <clr-recursive-children
      *ngIf="featuresService.recursion"
      [children]="featuresService.recursion.root"
    ></clr-recursive-children>
  `,
      providers: [TREE_FEATURES_PROVIDER, TreeFocusManagerService],
      host: {
        tabindex: "0",
        "[attr.role]": '"tree"',
        "[attr.aria-multiselectable]": "isMultiSelectable"
      }
    }]
  }], function() {
    return [{
      type: TreeFeaturesService
    }, {
      type: TreeFocusManagerService
    }, {
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: NgZone
    }];
  }, {
    rootNodes: [{
      type: ContentChildren,
      args: [ClrTreeNode]
    }],
    lazy: [{
      type: Input,
      args: ["clrLazy"]
    }]
  });
})();
var CLR_TREE_VIEW_DIRECTIVES = [ClrTree, ClrTreeNode, ClrRecursiveForOf, ClrTreeNodeLink];
var ClrTreeViewModule = class {
  constructor() {
    r.addIcons(o3);
  }
};
ClrTreeViewModule.ɵfac = function ClrTreeViewModule_Factory(t3) {
  return new (t3 || ClrTreeViewModule)();
};
ClrTreeViewModule.ɵmod = ɵɵdefineNgModule({
  type: ClrTreeViewModule,
  declarations: [ClrTree, ClrTreeNode, ClrRecursiveForOf, ClrTreeNodeLink, RecursiveChildren],
  imports: [CommonModule, ClrIconModule, ClrLoadingModule],
  exports: [ClrTree, ClrTreeNode, ClrRecursiveForOf, ClrTreeNodeLink]
});
ClrTreeViewModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, ClrIconModule, ClrLoadingModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrTreeViewModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, ClrIconModule, ClrLoadingModule],
      declarations: [CLR_TREE_VIEW_DIRECTIVES, RecursiveChildren],
      exports: [CLR_TREE_VIEW_DIRECTIVES]
    }]
  }], function() {
    return [];
  }, null);
})();
var ClrDataModule = class {
};
ClrDataModule.ɵfac = function ClrDataModule_Factory(t3) {
  return new (t3 || ClrDataModule)();
};
ClrDataModule.ɵmod = ɵɵdefineNgModule({
  type: ClrDataModule,
  exports: [ClrDatagridModule, ClrStackViewModule, ClrTreeViewModule]
});
ClrDataModule.ɵinj = ɵɵdefineInjector({
  imports: [ClrDatagridModule, ClrStackViewModule, ClrTreeViewModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDataModule, [{
    type: NgModule,
    args: [{
      exports: [ClrDatagridModule, ClrStackViewModule, ClrTreeViewModule]
    }]
  }], null, null);
})();
function wrapObservable(observable, onSubscribe, onUnsubscribe) {
  return Observable.create((observer) => {
    onSubscribe(observer);
    const subscription = observable.subscribe(observer);
    return () => {
      subscription.unsubscribe();
      if (onUnsubscribe) {
        onUnsubscribe(observer);
      }
    };
  });
}
var DropdownFocusHandler = class {
  constructor(renderer, parent, toggleService, focusService, platformId) {
    this.renderer = renderer;
    this.parent = parent;
    this.toggleService = toggleService;
    this.focusService = focusService;
    this.platformId = platformId;
    this.id = uniqueIdFactory();
    this.focusBackOnTriggerWhenClosed = false;
    this._unlistenFuncs = [];
    this.resetChildren();
    this.moveToFirstItemWhenOpen();
    if (!this.parent) {
      this.handleRootFocus();
    }
  }
  get trigger() {
    return this._trigger;
  }
  set trigger(el) {
    this._trigger = el;
    if (this.parent) {
      this._unlistenFuncs.push(this.renderer.listen(el, "keydown.arrowright", (event) => this.toggleService.toggleWithEvent(event)));
    } else {
      this._unlistenFuncs.push(this.renderer.listen(el, "keydown.arrowup", (event) => this.toggleService.toggleWithEvent(event)));
      this._unlistenFuncs.push(this.renderer.listen(el, "keydown.arrowdown", (event) => this.toggleService.toggleWithEvent(event)));
      this.focusService.listenToArrowKeys(el);
    }
  }
  get container() {
    return this._container;
  }
  set container(el) {
    this._container = el;
    this._unlistenFuncs.push(this.renderer.listen(el, "keydown.tab", (event) => this.toggleService.toggleWithEvent(event)));
    if (this.parent) {
      this._unlistenFuncs.push(this.renderer.listen(el, "keydown.escape", (event) => {
        this.focusService.move(ArrowKeyDirection.LEFT);
        event.stopPropagation();
      }));
    } else {
      this.focusService.registerContainer(el);
      this._unlistenFuncs.push(this.renderer.listen(el, "keydown.escape", (event) => this.toggleService.toggleWithEvent(event)));
      this._unlistenFuncs.push(this.renderer.listen(el, "blur", (event) => {
        this.children.pipe(take(1)).subscribe((items) => items.forEach((item) => item.blur()));
        const target = event.relatedTarget || document.activeElement;
        if (target && isPlatformBrowser(this.platformId)) {
          if (el.contains(target) || target === this.trigger) {
            return;
          }
        }
        this.focusBackOnTriggerWhenClosed = false;
        this.toggleService.open = false;
      }));
    }
  }
  ngOnDestroy() {
    this._unlistenFuncs.forEach((unlisten) => unlisten());
    this.focusService.detachListeners();
  }
  /**
   * If the dropdown was opened by clicking on the trigger, we automatically move to the first item
   */
  moveToFirstItemWhenOpen() {
    const subscription = this.toggleService.openChange.subscribe((open) => {
      if (open && this.toggleService.originalEvent) {
        setTimeout(() => {
          this.focusService.moveTo(this);
          if (this.parent) {
            this.focusService.move(ArrowKeyDirection.RIGHT);
          } else {
            this.focusService.move(ArrowKeyDirection.DOWN);
          }
        });
      }
    });
    this._unlistenFuncs.push(() => subscription.unsubscribe());
  }
  /**
   * Focus on the menu when it opens, and focus back on the root trigger when the whole dropdown becomes closed
   */
  handleRootFocus() {
    const subscription = this.toggleService.openChange.subscribe((open) => {
      if (!open) {
        this.focusService.reset(this);
        if (this.focusBackOnTriggerWhenClosed) {
          this.focus();
        }
      }
      this.focusBackOnTriggerWhenClosed = open;
    });
    this._unlistenFuncs.push(() => subscription.unsubscribe());
  }
  focus() {
    if (this.trigger && isPlatformBrowser(this.platformId)) {
      this.trigger.focus();
    }
  }
  blur() {
    if (this.trigger && isPlatformBrowser(this.platformId)) {
      this.trigger.blur();
    }
  }
  activate() {
    if (isPlatformBrowser(this.platformId)) {
      this.trigger.click();
    }
  }
  resetChildren() {
    this.children = new ReplaySubject(1);
    if (this.parent) {
      this.right = this.openAndGetChildren().pipe(map((all) => all[0]));
    } else {
      this.down = this.openAndGetChildren().pipe(map((all) => all[0]));
      this.up = this.openAndGetChildren().pipe(map((all) => all[all.length - 1]));
    }
  }
  addChildren(children) {
    Linkers.linkVertical(children);
    if (this.parent) {
      Linkers.linkParent(children, this.closeAndGetThis(), ArrowKeyDirection.LEFT);
    }
    this.children.next(children);
  }
  openAndGetChildren() {
    return wrapObservable(this.children, () => this.toggleService.open = true);
  }
  closeAndGetThis() {
    return wrapObservable(of(this), () => this.toggleService.open = false);
  }
};
DropdownFocusHandler.ɵfac = function DropdownFocusHandler_Factory(t3) {
  return new (t3 || DropdownFocusHandler)(ɵɵinject(Renderer2), ɵɵinject(DropdownFocusHandler, 12), ɵɵinject(ClrPopoverToggleService), ɵɵinject(FocusService$1), ɵɵinject(PLATFORM_ID));
};
DropdownFocusHandler.ɵprov = ɵɵdefineInjectable({
  token: DropdownFocusHandler,
  factory: DropdownFocusHandler.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DropdownFocusHandler, [{
    type: Injectable
  }], function() {
    return [{
      type: Renderer2
    }, {
      type: DropdownFocusHandler,
      decorators: [{
        type: SkipSelf
      }, {
        type: Optional
      }]
    }, {
      type: ClrPopoverToggleService
    }, {
      type: FocusService$1
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [PLATFORM_ID]
      }]
    }];
  }, null);
})();
var DROPDOWN_FOCUS_HANDLER_PROVIDER = customFocusableItemProvider(DropdownFocusHandler);
var RootDropdownService = class {
  constructor() {
    this._changes = new Subject();
  }
  get changes() {
    return this._changes.asObservable();
  }
  closeMenus() {
    this._changes.next(false);
  }
};
RootDropdownService.ɵfac = function RootDropdownService_Factory(t3) {
  return new (t3 || RootDropdownService)();
};
RootDropdownService.ɵprov = ɵɵdefineInjectable({
  token: RootDropdownService,
  factory: RootDropdownService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RootDropdownService, [{
    type: Injectable
  }], null, null);
})();
function clrRootDropdownFactory(existing) {
  return existing || new RootDropdownService();
}
var ROOT_DROPDOWN_PROVIDER = {
  provide: RootDropdownService,
  useFactory: clrRootDropdownFactory,
  deps: [[new Optional(), new SkipSelf(), RootDropdownService]]
};
var ClrDropdown = class {
  constructor(parent, toggleService, focusHandler, cdr, dropdownService) {
    this.parent = parent;
    this.toggleService = toggleService;
    this.focusHandler = focusHandler;
    this.cdr = cdr;
    this.isMenuClosable = true;
    this.subscriptions = [];
    this.subscriptions.push(dropdownService.changes.subscribe((value) => this.toggleService.open = value));
    this.subscriptions.push(toggleService.openChange.subscribe(() => this.cdr.markForCheck()));
  }
  ngOnDestroy() {
    this.subscriptions.forEach((sub) => sub.unsubscribe());
  }
};
ClrDropdown.ɵfac = function ClrDropdown_Factory(t3) {
  return new (t3 || ClrDropdown)(ɵɵdirectiveInject(ClrDropdown, 12), ɵɵdirectiveInject(ClrPopoverToggleService), ɵɵdirectiveInject(DropdownFocusHandler), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(RootDropdownService));
};
ClrDropdown.ɵcmp = ɵɵdefineComponent({
  type: ClrDropdown,
  selectors: [["clr-dropdown"]],
  hostVars: 4,
  hostBindings: function ClrDropdown_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("dropdown", true)("open", ctx.toggleService.open);
    }
  },
  inputs: {
    isMenuClosable: [InputFlags.None, "clrCloseMenuOnItemClick", "isMenuClosable"]
  },
  features: [ɵɵProvidersFeature([ROOT_DROPDOWN_PROVIDER, FOCUS_SERVICE_PROVIDER, DROPDOWN_FOCUS_HANDLER_PROVIDER]), ɵɵHostDirectivesFeature([ClrPopoverHostDirective])],
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function ClrDropdown_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDropdown, [{
    type: Component,
    args: [{
      selector: "clr-dropdown",
      template: "<ng-content></ng-content>",
      host: {
        "[class.dropdown]": "true",
        "[class.open]": "toggleService.open"
      },
      providers: [ROOT_DROPDOWN_PROVIDER, FOCUS_SERVICE_PROVIDER, DROPDOWN_FOCUS_HANDLER_PROVIDER],
      hostDirectives: [ClrPopoverHostDirective]
    }]
  }], function() {
    return [{
      type: ClrDropdown,
      decorators: [{
        type: SkipSelf
      }, {
        type: Optional
      }]
    }, {
      type: ClrPopoverToggleService
    }, {
      type: DropdownFocusHandler
    }, {
      type: ChangeDetectorRef
    }, {
      type: RootDropdownService
    }];
  }, {
    isMenuClosable: [{
      type: Input,
      args: ["clrCloseMenuOnItemClick"]
    }]
  });
})();
var BasicFocusableItem = class {
  constructor(el, renderer, platformId) {
    this.el = el;
    this.renderer = renderer;
    this.platformId = platformId;
    this.id = uniqueIdFactory();
    this.disabled = false;
    renderer.setAttribute(el.nativeElement, "id", this.id);
    renderer.setAttribute(el.nativeElement, "tabindex", "-1");
  }
  focus() {
    if (isPlatformBrowser(this.platformId)) {
      this.renderer.setAttribute(this.el.nativeElement, "tabindex", "0");
      this.el.nativeElement.focus();
      this.el.nativeElement.scrollIntoView({
        behavior: "smooth",
        block: "center",
        inline: "nearest"
      });
    }
  }
  blur() {
    if (isPlatformBrowser(this.platformId)) {
      this.renderer.setAttribute(this.el.nativeElement, "tabindex", "-1");
      this.el.nativeElement.blur();
    }
  }
  activate() {
    if (isPlatformBrowser(this.platformId)) {
      this.el.nativeElement.click();
    }
  }
};
BasicFocusableItem.ɵfac = function BasicFocusableItem_Factory(t3) {
  return new (t3 || BasicFocusableItem)(ɵɵinject(ElementRef), ɵɵinject(Renderer2), ɵɵinject(PLATFORM_ID));
};
BasicFocusableItem.ɵprov = ɵɵdefineInjectable({
  token: BasicFocusableItem,
  factory: BasicFocusableItem.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BasicFocusableItem, [{
    type: Injectable
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [PLATFORM_ID]
      }]
    }];
  }, null);
})();
var BASIC_FOCUSABLE_ITEM_PROVIDER = [{
  provide: FocusableItem,
  useClass: BasicFocusableItem
}];
var ClrDropdownItem = class {
  constructor(dropdown, _dropdownService, focusableItem) {
    this.dropdown = dropdown;
    this._dropdownService = _dropdownService;
    this.focusableItem = focusableItem;
  }
  get disabled() {
    return this.focusableItem.disabled;
  }
  set disabled(value) {
    this.focusableItem.disabled = !!value || value === "";
  }
  /**
   * Let you overwrite the focusable auto increment id.
   */
  get dropdownItemId() {
    return this.focusableItem.id;
  }
  set dropdownItemId(value) {
    this.focusableItem.id = value;
  }
  onDropdownItemClick() {
    if (this.dropdown.isMenuClosable && !this.disabled && this.dropdown.toggleService.open) {
      const rootDropdown = this.findRootDropdown();
      rootDropdown.focusHandler.focus();
      rootDropdown.focusHandler.focusBackOnTriggerWhenClosed = false;
    }
    setTimeout(() => {
      if (this.dropdown.isMenuClosable && !this.disabled) {
        this._dropdownService.closeMenus();
      }
    });
  }
  onSpaceKeydown($event) {
    this.stopImmediatePropagationIfDisabled($event);
  }
  onEnterKeydown($event) {
    this.stopImmediatePropagationIfDisabled($event);
  }
  stopImmediatePropagationIfDisabled($event) {
    if (this.disabled) {
      $event.preventDefault();
      $event.stopImmediatePropagation();
    }
  }
  findRootDropdown() {
    let rootDropdown = this.dropdown;
    while (rootDropdown.parent) {
      rootDropdown = rootDropdown.parent;
    }
    return rootDropdown;
  }
};
ClrDropdownItem.ɵfac = function ClrDropdownItem_Factory(t3) {
  return new (t3 || ClrDropdownItem)(ɵɵdirectiveInject(ClrDropdown), ɵɵdirectiveInject(RootDropdownService), ɵɵdirectiveInject(FocusableItem));
};
ClrDropdownItem.ɵdir = ɵɵdefineDirective({
  type: ClrDropdownItem,
  selectors: [["", "clrDropdownItem", ""]],
  hostVars: 7,
  hostBindings: function ClrDropdownItem_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function ClrDropdownItem_click_HostBindingHandler() {
        return ctx.onDropdownItemClick();
      })("keydown.space", function ClrDropdownItem_keydown_space_HostBindingHandler($event) {
        return ctx.onSpaceKeydown($event);
      })("keydown.enter", function ClrDropdownItem_keydown_enter_HostBindingHandler($event) {
        return ctx.onEnterKeydown($event);
      });
    }
    if (rf & 2) {
      ɵɵattribute("role", "menuitem")("aria-disabled", ctx.disabled)("id", ctx.dropdownItemId);
      ɵɵclassProp("disabled", ctx.disabled)("dropdown-item", true);
    }
  },
  inputs: {
    disabled: [InputFlags.None, "clrDisabled", "disabled"],
    dropdownItemId: [InputFlags.None, "id", "dropdownItemId"]
  },
  features: [ɵɵProvidersFeature([BASIC_FOCUSABLE_ITEM_PROVIDER])]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDropdownItem, [{
    type: Directive,
    args: [{
      selector: "[clrDropdownItem]",
      host: {
        "[class.disabled]": "disabled",
        "[class.dropdown-item]": "true",
        "[attr.role]": '"menuitem"',
        "[attr.aria-disabled]": "disabled",
        "[attr.id]": "dropdownItemId"
      },
      providers: [BASIC_FOCUSABLE_ITEM_PROVIDER]
    }]
  }], function() {
    return [{
      type: ClrDropdown
    }, {
      type: RootDropdownService
    }, {
      type: FocusableItem
    }];
  }, {
    disabled: [{
      type: Input,
      args: ["clrDisabled"]
    }],
    dropdownItemId: [{
      type: Input,
      args: ["id"]
    }],
    onDropdownItemClick: [{
      type: HostListener,
      args: ["click"]
    }],
    onSpaceKeydown: [{
      type: HostListener,
      args: ["keydown.space", ["$event"]]
    }],
    onEnterKeydown: [{
      type: HostListener,
      args: ["keydown.enter", ["$event"]]
    }]
  });
})();
var Point;
(function(Point2) {
  Point2[Point2["RIGHT_CENTER"] = 0] = "RIGHT_CENTER";
  Point2[Point2["RIGHT_TOP"] = 1] = "RIGHT_TOP";
  Point2[Point2["RIGHT_BOTTOM"] = 2] = "RIGHT_BOTTOM";
  Point2[Point2["TOP_CENTER"] = 3] = "TOP_CENTER";
  Point2[Point2["TOP_RIGHT"] = 4] = "TOP_RIGHT";
  Point2[Point2["TOP_LEFT"] = 5] = "TOP_LEFT";
  Point2[Point2["BOTTOM_CENTER"] = 6] = "BOTTOM_CENTER";
  Point2[Point2["BOTTOM_RIGHT"] = 7] = "BOTTOM_RIGHT";
  Point2[Point2["BOTTOM_LEFT"] = 8] = "BOTTOM_LEFT";
  Point2[Point2["LEFT_CENTER"] = 9] = "LEFT_CENTER";
  Point2[Point2["LEFT_TOP"] = 10] = "LEFT_TOP";
  Point2[Point2["LEFT_BOTTOM"] = 11] = "LEFT_BOTTOM";
})(Point || (Point = {}));
var POSITION_RELATIVE = "relative";
var POSITION_ABSOLUTE = "absolute";
var POSITION_FIXED = "fixed";
var OVERFLOW_SCROLL = "scroll";
var OVERFLOW_AUTO = "auto";
var Popover = class {
  constructor(element) {
    this.element = element;
    this.boundOnScrollListener = this.emitScrollEvent.bind(this);
    this.scrollableElements = [];
    element.style.position = POSITION_ABSOLUTE;
    element.style.top = 0;
    element.style.bottom = "auto";
    element.style.left = 0;
    element.style.right = "auto";
  }
  // TODO: need a way to account for parameters that change dynamically (positioning).
  anchor(anchor, anchorAlign, popoverAlign, {
    offsetX = 0,
    offsetY = 0,
    useAnchorParent = false
  } = {}) {
    this.addScrollEventListeners(anchor);
    if (useAnchorParent) {
      anchor = anchor.parentNode;
    }
    anchor.style.position = "static";
    const anchorRect = anchor.getBoundingClientRect();
    const popoverRect = this.element.getBoundingClientRect();
    let leftDiff = anchorRect.left - popoverRect.left + offsetX;
    let topDiff = anchorRect.top - popoverRect.top + offsetY;
    switch (anchorAlign) {
      case Point.LEFT_TOP:
      case Point.TOP_LEFT:
        break;
      case Point.TOP_CENTER:
        leftDiff += anchorRect.width / 2;
        break;
      case Point.TOP_RIGHT:
        leftDiff += anchorRect.width;
        break;
      case Point.RIGHT_TOP:
        leftDiff += anchorRect.width;
        break;
      case Point.LEFT_BOTTOM:
        topDiff += anchorRect.height;
        break;
      case Point.BOTTOM_LEFT:
        topDiff += anchorRect.height;
        break;
      case Point.BOTTOM_CENTER:
        topDiff += anchorRect.height;
        leftDiff += anchorRect.width / 2;
        break;
      case Point.BOTTOM_RIGHT:
        topDiff += anchorRect.height;
        leftDiff += anchorRect.width;
        break;
      case Point.RIGHT_BOTTOM:
        topDiff += anchorRect.height;
        leftDiff += anchorRect.width;
        break;
      case Point.LEFT_CENTER:
        topDiff += anchorRect.height / 2;
        break;
      case Point.RIGHT_CENTER:
        topDiff += anchorRect.height / 2;
        leftDiff += anchorRect.width;
        break;
      default:
    }
    switch (popoverAlign) {
      case Point.LEFT_TOP:
      case Point.TOP_LEFT:
        break;
      case Point.TOP_CENTER:
        leftDiff -= popoverRect.width / 2;
        break;
      case Point.TOP_RIGHT:
        leftDiff -= popoverRect.width;
        break;
      case Point.RIGHT_TOP:
        leftDiff -= popoverRect.width;
        break;
      case Point.LEFT_BOTTOM:
        topDiff -= popoverRect.height;
        break;
      case Point.BOTTOM_LEFT:
        topDiff -= popoverRect.height;
        break;
      case Point.BOTTOM_CENTER:
        topDiff -= popoverRect.height;
        leftDiff -= popoverRect.width / 2;
        break;
      case Point.BOTTOM_RIGHT:
        topDiff -= popoverRect.height;
        leftDiff -= popoverRect.width;
        break;
      case Point.RIGHT_BOTTOM:
        topDiff -= popoverRect.height;
        leftDiff -= popoverRect.width;
        break;
      case Point.LEFT_CENTER:
        topDiff -= popoverRect.height / 2;
        break;
      case Point.RIGHT_CENTER:
        topDiff -= popoverRect.height / 2;
        leftDiff -= popoverRect.width;
        break;
      default:
    }
    const popoverComputedStyle = getComputedStyle(this.element);
    const marginLeft = parseInt(popoverComputedStyle.marginLeft, 10);
    const marginRight = parseInt(popoverComputedStyle.marginRight, 10);
    const marginTop = parseInt(popoverComputedStyle.marginTop, 10);
    const marginBottom = parseInt(popoverComputedStyle.marginBottom, 10);
    switch (anchorAlign) {
      case Point.LEFT_TOP:
      case Point.TOP_LEFT:
      case Point.TOP_RIGHT:
      case Point.RIGHT_TOP:
        if (popoverAlign === Point.BOTTOM_RIGHT || popoverAlign === Point.RIGHT_BOTTOM) {
          topDiff -= marginBottom;
          leftDiff -= marginRight;
        }
        if (popoverAlign === Point.BOTTOM_LEFT || popoverAlign === Point.LEFT_BOTTOM) {
          topDiff -= marginTop;
          leftDiff += marginLeft;
        }
        if (popoverAlign === Point.TOP_LEFT || popoverAlign === Point.LEFT_TOP) {
          topDiff += marginTop;
          leftDiff += marginLeft;
        }
        if (popoverAlign === Point.TOP_RIGHT || popoverAlign === Point.RIGHT_TOP) {
          topDiff += marginTop;
          leftDiff -= marginRight;
        }
        break;
      case Point.LEFT_BOTTOM:
      case Point.BOTTOM_LEFT:
      case Point.BOTTOM_RIGHT:
      case Point.RIGHT_BOTTOM:
        if (popoverAlign === Point.BOTTOM_LEFT || popoverAlign === Point.LEFT_BOTTOM) {
          topDiff -= marginBottom;
          leftDiff += marginLeft;
        }
        if (popoverAlign === Point.BOTTOM_RIGHT || popoverAlign === Point.RIGHT_BOTTOM) {
          topDiff -= marginBottom;
          leftDiff -= marginRight;
        }
        if (popoverAlign === Point.TOP_LEFT || popoverAlign === Point.LEFT_TOP) {
          topDiff += marginTop;
          leftDiff += marginLeft;
        }
        if (popoverAlign === Point.TOP_RIGHT || popoverAlign === Point.RIGHT_TOP) {
          topDiff += marginTop;
          leftDiff -= marginRight;
        }
        break;
      case Point.TOP_CENTER:
        topDiff -= marginBottom;
        leftDiff += marginLeft;
        leftDiff -= marginRight;
        break;
      case Point.BOTTOM_CENTER:
        topDiff += marginTop;
        leftDiff += marginLeft;
        leftDiff -= marginRight;
        break;
      case Point.LEFT_CENTER:
        topDiff += marginTop;
        topDiff -= marginBottom;
        leftDiff -= marginRight;
        break;
      case Point.RIGHT_CENTER:
        topDiff += marginTop;
        topDiff -= marginBottom;
        leftDiff += marginLeft;
        break;
      default:
    }
    this.element.style.transform = `translateX(${Math.round(leftDiff)}px) translateY(${Math.round(topDiff)}px)`;
    return this._scroll.asObservable();
  }
  release() {
    this.element.style.transform = "";
    this.removeScrollEventListeners();
  }
  isPositioned(container) {
    const position = getComputedStyle(container).position;
    return position === POSITION_RELATIVE || position === POSITION_ABSOLUTE || position === POSITION_FIXED;
  }
  emitScrollEvent() {
    this._scroll.next();
  }
  addScrollEventListeners(e5) {
    this._scroll = new Subject();
    const anchor = e5;
    let current = e5;
    while (current && current !== document) {
      if (this.scrolls(current)) {
        current.addEventListener("scroll", this.boundOnScrollListener);
        this.scrollableElements.push(current);
      }
      if (current !== anchor && this.isPositioned(current)) {
        break;
      }
      current = current.parentNode;
    }
  }
  removeScrollEventListeners() {
    for (const elem of this.scrollableElements) {
      elem.removeEventListener("scroll", this.boundOnScrollListener);
    }
    this.scrollableElements.length = 0;
    if (this._scroll) {
      this._scroll.complete();
      delete this._scroll;
    }
  }
  scrolls(container) {
    const computedStyles = getComputedStyle(container);
    return computedStyles.overflowX === OVERFLOW_SCROLL || computedStyles.overflowX === OVERFLOW_AUTO || computedStyles.overflowY === OVERFLOW_SCROLL || computedStyles.overflowY === OVERFLOW_AUTO;
  }
};
var AbstractPopover = class {
  constructor(injector, parentHost) {
    this.parentHost = parentHost;
    this.closeOnOutsideClick = false;
    this.popoverOptions = {};
    this.updateAnchor = false;
    this.documentESCListener = null;
    this.closeOnOutsideClickCallback = (event) => {
      if (this.anchorElem.contains(event.target)) {
        return;
      }
      this.toggleService.open = false;
    };
    this.el = injector.get(ElementRef);
    this.toggleService = injector.get(ClrPopoverToggleService);
    this.renderer = injector.get(Renderer2);
    this.ngZone = injector.get(NgZone);
    this.ref = injector.get(ChangeDetectorRef);
    this.anchorElem = parentHost.nativeElement;
    this.popoverInstance = new Popover(this.el.nativeElement);
    this.subscription = this.toggleService.openChange.subscribe((change) => {
      if (change) {
        this.anchor();
        this.attachESCListener();
      } else {
        this.release();
        this.detachESCListener();
      }
    });
    if (this.toggleService.open) {
      this.anchor();
      this.attachESCListener();
    }
  }
  /*
   * Fallback to hide when *clrIfOpen is not being used
   */
  get isOffScreen() {
    return this.toggleService.open ? false : true;
  }
  ngAfterViewChecked() {
    if (this.updateAnchor) {
      this.updateAnchor = false;
      this.popoverInstance.anchor(this.anchorElem, this.anchorPoint, this.popoverPoint, this.popoverOptions).subscribe(() => {
        this.toggleService.open = false;
      });
      this.attachOutsideClickListener();
    }
  }
  ngOnDestroy() {
    this.release();
    this.detachESCListener();
    this.subscription.unsubscribe();
  }
  anchor() {
    this.updateAnchor = true;
  }
  release() {
    this.detachOutsideClickListener();
    this.popoverInstance.release();
  }
  attachESCListener() {
    if (this.popoverOptions.ignoreGlobalESCListener) {
      return;
    }
    this.ngZone.runOutsideAngular(() => {
      this.documentESCListener = this.renderer.listen("document", "keydown", (event) => {
        if (event && event.key) {
          if (normalizeKey(event.key) === Keys.Escape) {
            this.ngZone.run(() => {
              this.toggleService.open = false;
              this.ref.markForCheck();
            });
          }
        }
      });
    });
  }
  detachESCListener() {
    if (this.documentESCListener) {
      this.documentESCListener();
      this.documentESCListener = null;
    }
  }
  attachOutsideClickListener() {
    if (this.closeOnOutsideClick && this.toggleService.open) {
      if (document && document.addEventListener) {
        document.addEventListener("click", this.closeOnOutsideClickCallback, true);
      }
    }
  }
  detachOutsideClickListener() {
    if (this.closeOnOutsideClick) {
      if (document && document.removeEventListener) {
        document.removeEventListener("click", this.closeOnOutsideClickCallback, true);
      }
    }
  }
};
AbstractPopover.ɵfac = function AbstractPopover_Factory(t3) {
  return new (t3 || AbstractPopover)(ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(ElementRef, 4));
};
AbstractPopover.ɵdir = ɵɵdefineDirective({
  type: AbstractPopover,
  hostVars: 2,
  hostBindings: function AbstractPopover_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("is-off-screen", ctx.isOffScreen);
    }
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AbstractPopover, [{
    type: Directive
  }], function() {
    return [{
      type: Injector
    }, {
      type: ElementRef,
      decorators: [{
        type: SkipSelf
      }]
    }];
  }, {
    isOffScreen: [{
      type: HostBinding,
      args: ["class.is-off-screen"]
    }]
  });
})();
var ClrDropdownMenu = class extends AbstractPopover {
  constructor(injector, parentHost, nested, focusHandler) {
    if (!parentHost) {
      throw new Error("clr-dropdown-menu should only be used inside of a clr-dropdown");
    }
    super(injector, parentHost);
    if (!nested) {
      this.anchorPoint = Point.BOTTOM_LEFT;
      this.popoverPoint = Point.LEFT_TOP;
    } else {
      this.anchorPoint = Point.RIGHT_TOP;
      this.popoverPoint = Point.LEFT_TOP;
    }
    this.popoverOptions.allowMultipleOpen = true;
    this.popoverOptions.ignoreGlobalESCListener = true;
    this.closeOnOutsideClick = true;
    this.focusHandler = focusHandler;
  }
  set position(position) {
    switch (position) {
      case "top-right":
        this.anchorPoint = Point.TOP_RIGHT;
        this.popoverPoint = Point.RIGHT_BOTTOM;
        break;
      case "top-left":
        this.anchorPoint = Point.TOP_LEFT;
        this.popoverPoint = Point.LEFT_BOTTOM;
        break;
      case "bottom-right":
        this.anchorPoint = Point.BOTTOM_RIGHT;
        this.popoverPoint = Point.RIGHT_TOP;
        break;
      case "bottom-left":
        this.anchorPoint = Point.BOTTOM_LEFT;
        this.popoverPoint = Point.LEFT_TOP;
        break;
      case "right-top":
        this.anchorPoint = Point.RIGHT_TOP;
        this.popoverPoint = Point.LEFT_TOP;
        break;
      case "right-bottom":
        this.anchorPoint = Point.RIGHT_BOTTOM;
        this.popoverPoint = Point.LEFT_BOTTOM;
        break;
      case "left-top":
        this.anchorPoint = Point.LEFT_TOP;
        this.popoverPoint = Point.RIGHT_TOP;
        break;
      case "left-bottom":
        this.anchorPoint = Point.LEFT_BOTTOM;
        this.popoverPoint = Point.RIGHT_BOTTOM;
        break;
      default:
        this.anchorPoint = Point.BOTTOM_LEFT;
        this.popoverPoint = Point.LEFT_TOP;
        break;
    }
  }
  ngAfterContentInit() {
    this.focusHandler.container = this.el.nativeElement;
    this.items.changes.subscribe(() => this.focusHandler.addChildren(this.items.toArray()));
    this.items.notifyOnChanges();
  }
  ngOnDestroy() {
    super.ngOnDestroy();
    this.focusHandler.resetChildren();
  }
};
ClrDropdownMenu.ɵfac = function ClrDropdownMenu_Factory(t3) {
  return new (t3 || ClrDropdownMenu)(ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(POPOVER_HOST_ANCHOR, 8), ɵɵdirectiveInject(ClrDropdownMenu, 12), ɵɵdirectiveInject(DropdownFocusHandler));
};
ClrDropdownMenu.ɵcmp = ɵɵdefineComponent({
  type: ClrDropdownMenu,
  selectors: [["clr-dropdown-menu"]],
  contentQueries: function ClrDropdownMenu_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, FocusableItem, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.items = _t);
    }
  },
  hostVars: 3,
  hostBindings: function ClrDropdownMenu_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("role", "menu");
      ɵɵclassProp("dropdown-menu", true);
    }
  },
  inputs: {
    position: [InputFlags.None, "clrPosition", "position"]
  },
  features: [ɵɵInheritDefinitionFeature],
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function ClrDropdownMenu_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDropdownMenu, [{
    type: Component,
    args: [{
      selector: "clr-dropdown-menu",
      template: `<ng-content></ng-content>`,
      host: {
        "[class.dropdown-menu]": "true",
        "[attr.role]": '"menu"'
      }
    }]
  }], function() {
    return [{
      type: Injector
    }, {
      type: ElementRef,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [POPOVER_HOST_ANCHOR]
      }]
    }, {
      type: ClrDropdownMenu,
      decorators: [{
        type: Optional
      }, {
        type: SkipSelf
      }]
    }, {
      type: DropdownFocusHandler
    }];
  }, {
    items: [{
      type: ContentChildren,
      args: [FocusableItem]
    }],
    position: [{
      type: Input,
      args: ["clrPosition"]
    }]
  });
})();
var ClrDropdownTrigger = class {
  constructor(dropdown, toggleService, el, focusHandler) {
    this.toggleService = toggleService;
    this.isRootLevelToggle = true;
    if (dropdown.parent) {
      this.isRootLevelToggle = false;
    }
    focusHandler.trigger = el.nativeElement;
  }
  get active() {
    return this.toggleService.open;
  }
  onDropdownTriggerClick(event) {
    this.toggleService.toggleWithEvent(event);
  }
};
ClrDropdownTrigger.ɵfac = function ClrDropdownTrigger_Factory(t3) {
  return new (t3 || ClrDropdownTrigger)(ɵɵdirectiveInject(ClrDropdown), ɵɵdirectiveInject(ClrPopoverToggleService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(DropdownFocusHandler));
};
ClrDropdownTrigger.ɵdir = ɵɵdefineDirective({
  type: ClrDropdownTrigger,
  selectors: [["", "clrDropdownTrigger", ""], ["", "clrDropdownToggle", ""]],
  hostVars: 10,
  hostBindings: function ClrDropdownTrigger_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function ClrDropdownTrigger_click_HostBindingHandler($event) {
        return ctx.onDropdownTriggerClick($event);
      });
    }
    if (rf & 2) {
      ɵɵattribute("aria-haspopup", "menu")("aria-expanded", ctx.active);
      ɵɵclassProp("dropdown-toggle", ctx.isRootLevelToggle)("dropdown-item", !ctx.isRootLevelToggle)("expandable", !ctx.isRootLevelToggle)("active", ctx.active);
    }
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDropdownTrigger, [{
    type: Directive,
    args: [{
      // We support both selectors for legacy reasons
      selector: "[clrDropdownTrigger],[clrDropdownToggle]",
      host: {
        "[class.dropdown-toggle]": "isRootLevelToggle",
        "[class.dropdown-item]": "!isRootLevelToggle",
        "[class.expandable]": "!isRootLevelToggle",
        "[class.active]": "active",
        "[attr.aria-haspopup]": '"menu"',
        "[attr.aria-expanded]": "active"
      }
    }]
  }], function() {
    return [{
      type: ClrDropdown
    }, {
      type: ClrPopoverToggleService
    }, {
      type: ElementRef
    }, {
      type: DropdownFocusHandler
    }];
  }, {
    onDropdownTriggerClick: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }]
  });
})();
var CLR_DROPDOWN_DIRECTIVES = [ClrDropdown, ClrDropdownMenu, ClrDropdownTrigger, ClrDropdownItem];
var ClrDropdownModule = class {
};
ClrDropdownModule.ɵfac = function ClrDropdownModule_Factory(t3) {
  return new (t3 || ClrDropdownModule)();
};
ClrDropdownModule.ɵmod = ɵɵdefineNgModule({
  type: ClrDropdownModule,
  declarations: [ClrDropdown, ClrDropdownMenu, ClrDropdownTrigger, ClrDropdownItem],
  imports: [CommonModule],
  exports: [ClrDropdown, ClrDropdownMenu, ClrDropdownTrigger, ClrDropdownItem, ClrConditionalModule, ClrIconModule]
});
ClrDropdownModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, ClrConditionalModule, ClrIconModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrDropdownModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      declarations: [CLR_DROPDOWN_DIRECTIVES],
      exports: [CLR_DROPDOWN_DIRECTIVES, ClrConditionalModule, ClrIconModule]
    }]
  }], null, null);
})();
var ALERT_TYPES = ["info", "warning", "danger", "success", "neutral", "unknown", "loading"];
var AlertIconAndTypesService = class {
  constructor(commonStrings) {
    this.commonStrings = commonStrings;
    this.defaultIconShape = "info-standard";
    this._alertIconShape = "";
    this._alertType = "info";
  }
  get alertType() {
    return this._alertType;
  }
  set alertType(val) {
    if (ALERT_TYPES.indexOf(val) > -1) {
      this._alertType = val;
    }
  }
  get alertIconShape() {
    if ("" === this._alertIconShape) {
      return this.iconInfoFromType(this._alertType).shape;
    }
    return this._alertIconShape;
  }
  set alertIconShape(val) {
    if (!val) {
      this._alertIconShape = "";
    } else if (val !== this._alertIconShape) {
      this._alertIconShape = val;
    }
  }
  get alertIconTitle() {
    return this.iconInfoFromType(this._alertType).title;
  }
  iconInfoFromType(type) {
    const returnObj = {
      shape: "",
      cssClass: "",
      title: ""
    };
    switch (type) {
      case "warning":
        returnObj.shape = "warning-standard";
        returnObj.cssClass = "alert-warning";
        returnObj.title = this.commonStrings.keys.warning;
        break;
      case "danger":
        returnObj.shape = "error-standard";
        returnObj.cssClass = "alert-danger";
        returnObj.title = this.commonStrings.keys.danger;
        break;
      case "success":
        returnObj.shape = "success-standard";
        returnObj.cssClass = "alert-success";
        returnObj.title = this.commonStrings.keys.success;
        break;
      case "neutral":
        returnObj.shape = "note";
        returnObj.cssClass = "alert-neutral";
        returnObj.title = this.commonStrings.keys.neutral;
        break;
      case "unknown":
        returnObj.shape = "help";
        returnObj.cssClass = "alert-neutral";
        returnObj.title = this.commonStrings.keys.unknown;
        break;
      case "loading":
        returnObj.shape = "loading";
        returnObj.cssClass = "alert-neutral";
        returnObj.title = this.commonStrings.keys.unknown;
        break;
      default:
        returnObj.shape = this.defaultIconShape;
        returnObj.cssClass = "alert-info";
        returnObj.title = this.commonStrings.keys.info;
        break;
    }
    return returnObj;
  }
};
AlertIconAndTypesService.ɵfac = function AlertIconAndTypesService_Factory(t3) {
  return new (t3 || AlertIconAndTypesService)(ɵɵinject(ClrCommonStringsService));
};
AlertIconAndTypesService.ɵprov = ɵɵdefineInjectable({
  token: AlertIconAndTypesService,
  factory: AlertIconAndTypesService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AlertIconAndTypesService, [{
    type: Injectable
  }], function() {
    return [{
      type: ClrCommonStringsService
    }];
  }, null);
})();
var MultiAlertService = class {
  constructor() {
    this._change = new Subject();
  }
  /**
   * The Observable that lets other classes subscribe to changes
   */
  get changes() {
    return this._change.asObservable();
  }
  get current() {
    return this._current;
  }
  set current(index) {
    if (index !== this._current) {
      this._current = index;
      this._change.next(index);
    }
  }
  get activeAlerts() {
    return this.allAlerts && this.allAlerts.filter((alert) => !alert._closed);
  }
  get currentAlert() {
    return this.activeAlerts && this.activeAlerts[this.current];
  }
  set currentAlert(alert) {
    this.current = this.activeAlerts.indexOf(alert);
  }
  get count() {
    return this.activeAlerts && this.activeAlerts.length || 0;
  }
  manage(alerts) {
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
    this.allAlerts = alerts;
    this.current = typeof this._current === "number" ? this._current : 0;
    this._change.next(this.current);
    this.subscription = this.allAlerts.changes.subscribe(() => {
      if (this.current >= this.allAlerts.length) {
        this.current = Math.max(0, this.allAlerts.length - 1);
      }
    });
  }
  next() {
    this._current = this.current === this.activeAlerts.length - 1 ? 0 : this.current + 1;
    this._change.next(this._current);
  }
  previous() {
    if (this.activeAlerts.length === 0) {
      return;
    }
    this._current = this.current === 0 ? this.activeAlerts.length - 1 : this.current - 1;
    this._change.next(this._current);
  }
  open() {
    if (this.activeAlerts.length === 0) {
      return;
    }
    if (!this.currentAlert) {
      this._current = 0;
    }
    this._change.next(this._current);
  }
  close(isCurrentAlert) {
    if (this.activeAlerts.length === 0) {
      return;
    }
    if (isCurrentAlert) {
      this._current = Math.max(0, this.current - 1);
    }
    this._change.next(this._current);
  }
  destroy() {
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
  }
};
MultiAlertService.ɵfac = function MultiAlertService_Factory(t3) {
  return new (t3 || MultiAlertService)();
};
MultiAlertService.ɵprov = ɵɵdefineInjectable({
  token: MultiAlertService,
  factory: MultiAlertService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MultiAlertService, [{
    type: Injectable
  }], null, null);
})();
var ClrAlert = class {
  constructor(iconService, cdr, multiAlertService, commonStrings, renderer, hostElement) {
    this.iconService = iconService;
    this.cdr = cdr;
    this.multiAlertService = multiAlertService;
    this.commonStrings = commonStrings;
    this.renderer = renderer;
    this.hostElement = hostElement;
    this.isSmall = false;
    this.closable = true;
    this.isAppLevel = false;
    this.clrCloseButtonAriaLabel = this.commonStrings.keys.alertCloseButtonAriaLabel;
    this._closedChanged = new EventEmitter(false);
    this._closed = false;
    this.subscriptions = [];
    this._isLightweight = false;
  }
  get isLightweight() {
    return this._isLightweight;
  }
  set isLightweight(val) {
    this._isLightweight = val;
    this.configAlertType(this._origAlertType);
  }
  get alertType() {
    return this.iconService.alertType;
  }
  set alertType(val) {
    this._origAlertType = val;
    this.configAlertType(val);
  }
  set alertIconShape(value) {
    this.iconService.alertIconShape = value;
  }
  set closed(value) {
    if (value && !this._closed) {
      this.close();
    } else if (!value && this._closed) {
      this.open();
    }
  }
  get alertClass() {
    return this.iconService.iconInfoFromType(this.iconService.alertType).cssClass;
  }
  get hidden() {
    return this._hidden;
  }
  set hidden(value) {
    if (value !== this._hidden) {
      this._hidden = value;
      if (this._hidden) {
        this.renderer.addClass(this.hostElement.nativeElement, "alert-hidden");
      } else {
        this.renderer.removeClass(this.hostElement.nativeElement, "alert-hidden");
      }
      this.cdr.detectChanges();
    }
  }
  ngOnInit() {
    if (this.multiAlertService) {
      this.subscriptions.push(this.multiAlertService.changes.subscribe(() => {
        this.hidden = this.multiAlertService.currentAlert !== this;
      }));
    }
  }
  ngOnDestroy() {
    this.subscriptions.forEach((sub) => sub.unsubscribe());
  }
  configAlertType(val) {
    this.iconService.alertType = val;
  }
  open() {
    this._closed = false;
    if (this.multiAlertService) {
      this.multiAlertService.open();
    }
    this._closedChanged.emit(false);
  }
  close() {
    if (!this.closable) {
      return;
    }
    const isCurrentAlert = this.multiAlertService?.currentAlert === this;
    this._closed = true;
    if (this.multiAlertService?.activeAlerts) {
      this.multiAlertService.close(isCurrentAlert);
    }
    this._closedChanged.emit(true);
  }
};
ClrAlert.ɵfac = function ClrAlert_Factory(t3) {
  return new (t3 || ClrAlert)(ɵɵdirectiveInject(AlertIconAndTypesService), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(MultiAlertService, 8), ɵɵdirectiveInject(ClrCommonStringsService), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef));
};
ClrAlert.ɵcmp = ɵɵdefineComponent({
  type: ClrAlert,
  selectors: [["clr-alert"]],
  inputs: {
    isSmall: [InputFlags.None, "clrAlertSizeSmall", "isSmall"],
    closable: [InputFlags.None, "clrAlertClosable", "closable"],
    isAppLevel: [InputFlags.None, "clrAlertAppLevel", "isAppLevel"],
    clrCloseButtonAriaLabel: "clrCloseButtonAriaLabel",
    isLightweight: [InputFlags.None, "clrAlertLightweight", "isLightweight"],
    alertType: [InputFlags.None, "clrAlertType", "alertType"],
    alertIconShape: [InputFlags.None, "clrAlertIcon", "alertIconShape"],
    closed: [InputFlags.None, "clrAlertClosed", "closed"]
  },
  outputs: {
    _closedChanged: "clrAlertClosedChange"
  },
  features: [ɵɵProvidersFeature([AlertIconAndTypesService])],
  ngContentSelectors: _c02,
  decls: 1,
  vars: 1,
  consts: [["class", "alert", 3, "ngClass", "alert-sm", "alert-lightweight", "alert-app-level", 4, "ngIf"], [1, "alert", 3, "ngClass"], [1, "alert-items"], ["type", "button", "class", "close", 3, "click", 4, "ngIf"], ["type", "button", 1, "close", 3, "click"], ["shape", "window-close"]],
  template: function ClrAlert_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵtemplate(0, ClrAlert_div_0_Template, 4, 8, "div", 0);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", !ctx._closed);
    }
  },
  dependencies: [NgClass, NgIf, CdsIconCustomTag],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrAlert, [{
    type: Component,
    args: [{
      selector: "clr-alert",
      providers: [AlertIconAndTypesService],
      template: '<!--\n  ~ Copyright (c) 2016-2024 Broadcom. All Rights Reserved.\n  ~ The term "Broadcom" refers to Broadcom Inc. and/or its subsidiaries.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n  -->\n\n<div\n  *ngIf="!_closed"\n  class="alert"\n  [ngClass]="alertClass"\n  [class.alert-sm]="isSmall"\n  [class.alert-lightweight]="isLightweight"\n  [class.alert-app-level]="isAppLevel"\n>\n  <div class="alert-items">\n    <ng-content></ng-content>\n  </div>\n  <button type="button" class="close" *ngIf="closable" (click)="close()" [attr.aria-label]="clrCloseButtonAriaLabel">\n    <cds-icon shape="window-close"></cds-icon>\n  </button>\n</div>\n'
    }]
  }], function() {
    return [{
      type: AlertIconAndTypesService
    }, {
      type: ChangeDetectorRef
    }, {
      type: MultiAlertService,
      decorators: [{
        type: Optional
      }]
    }, {
      type: ClrCommonStringsService
    }, {
      type: Renderer2
    }, {
      type: ElementRef
    }];
  }, {
    isSmall: [{
      type: Input,
      args: ["clrAlertSizeSmall"]
    }],
    closable: [{
      type: Input,
      args: ["clrAlertClosable"]
    }],
    isAppLevel: [{
      type: Input,
      args: ["clrAlertAppLevel"]
    }],
    clrCloseButtonAriaLabel: [{
      type: Input
    }],
    _closedChanged: [{
      type: Output,
      args: ["clrAlertClosedChange"]
    }],
    isLightweight: [{
      type: Input,
      args: ["clrAlertLightweight"]
    }],
    alertType: [{
      type: Input,
      args: ["clrAlertType"]
    }],
    alertIconShape: [{
      type: Input,
      args: ["clrAlertIcon"]
    }],
    closed: [{
      type: Input,
      args: ["clrAlertClosed"]
    }]
  });
})();
var ClrAlertItem = class {
  constructor(iconService) {
    this.iconService = iconService;
  }
};
ClrAlertItem.ɵfac = function ClrAlertItem_Factory(t3) {
  return new (t3 || ClrAlertItem)(ɵɵdirectiveInject(AlertIconAndTypesService));
};
ClrAlertItem.ɵcmp = ɵɵdefineComponent({
  type: ClrAlertItem,
  selectors: [["clr-alert-item"]],
  hostAttrs: [1, "alert-item"],
  ngContentSelectors: _c02,
  decls: 4,
  vars: 2,
  consts: [[1, "alert-icon-wrapper"], ["class", "alert-spinner", "clrInline", "", 4, "ngIf"], ["class", "alert-icon", "role", "img", 4, "ngIf"], ["clrInline", "", 1, "alert-spinner"], ["role", "img", 1, "alert-icon"]],
  template: function ClrAlertItem_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "div", 0);
      ɵɵtemplate(1, ClrAlertItem_clr_spinner_1_Template, 1, 0, "clr-spinner", 1)(2, ClrAlertItem_cds_icon_2_Template, 1, 2, "cds-icon", 2);
      ɵɵelementEnd();
      ɵɵprojection(3);
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.iconService.alertIconShape === "loading");
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.iconService.alertIconShape !== "loading");
    }
  },
  dependencies: [NgIf, CdsIconCustomTag, ClrSpinner],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrAlertItem, [{
    type: Component,
    args: [{
      selector: "clr-alert-item",
      template: `
    <div class="alert-icon-wrapper">
      <clr-spinner class="alert-spinner" clrInline *ngIf="iconService.alertIconShape === 'loading'"></clr-spinner>
      <cds-icon
        class="alert-icon"
        role="img"
        *ngIf="iconService.alertIconShape !== 'loading'"
        [attr.shape]="iconService.alertIconShape"
        [attr.aria-label]="iconService.alertIconTitle"
      ></cds-icon>
    </div>
    <ng-content></ng-content>
  `,
      host: {
        class: "alert-item"
      }
    }]
  }], function() {
    return [{
      type: AlertIconAndTypesService
    }];
  }, null);
})();
var ClrAlertText = class {
};
ClrAlertText.ɵfac = function ClrAlertText_Factory(t3) {
  return new (t3 || ClrAlertText)();
};
ClrAlertText.ɵdir = ɵɵdefineDirective({
  type: ClrAlertText,
  selectors: [["", 8, "alert-text"]]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrAlertText, [{
    type: Directive,
    args: [{
      selector: ".alert-text"
    }]
  }], null, null);
})();
var ClrAlertsPager = class {
  constructor(multiAlertService, commonStrings) {
    this.multiAlertService = multiAlertService;
    this.commonStrings = commonStrings;
    this.currentAlertChange = new EventEmitter(false);
    this.currentAlertIndexChange = new EventEmitter();
  }
  /**
   * Input/Output to support two way binding on current alert instance
   */
  get currentAlert() {
    return this.multiAlertService.currentAlert;
  }
  set currentAlert(alert) {
    if (alert) {
      this.multiAlertService.currentAlert = alert;
    }
  }
  /**
   * Input/Output to support two way binding on current alert index
   */
  get currentAlertIndex() {
    return this.multiAlertService.current;
  }
  set currentAlertIndex(index) {
    this.multiAlertService.current = index;
  }
  get previousAlertAriaLabel() {
    const CURRENT = this.currentAlertIndex + 1;
    return this.commonStrings.parse(this.commonStrings.keys.alertPreviousAlertAriaLabel, {
      CURRENT: (CURRENT === 1 ? this.multiAlertService.count : CURRENT - 1).toString(),
      COUNT: this.multiAlertService.count.toString()
    });
  }
  get nextAlertAriaLabel() {
    const CURRENT = this.currentAlertIndex + 1;
    return this.commonStrings.parse(this.commonStrings.keys.alertNextAlertAriaLabel, {
      CURRENT: (CURRENT === this.multiAlertService.count ? 1 : CURRENT + 1).toString(),
      COUNT: this.multiAlertService.count.toString()
    });
  }
  ngOnInit() {
    this.multiAlertServiceChanges = this.multiAlertService.changes.subscribe((index) => {
      this.currentAlertIndexChange.emit(index);
      this.currentAlertChange.emit(this.multiAlertService.activeAlerts[index]);
    });
  }
  ngOnDestroy() {
    this.multiAlertServiceChanges.unsubscribe();
  }
  pageUp() {
    this.multiAlertService.next();
  }
  pageDown() {
    this.multiAlertService.previous();
  }
};
ClrAlertsPager.ɵfac = function ClrAlertsPager_Factory(t3) {
  return new (t3 || ClrAlertsPager)(ɵɵdirectiveInject(MultiAlertService), ɵɵdirectiveInject(ClrCommonStringsService));
};
ClrAlertsPager.ɵcmp = ɵɵdefineComponent({
  type: ClrAlertsPager,
  selectors: [["clr-alerts-pager"]],
  hostVars: 2,
  hostBindings: function ClrAlertsPager_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("alerts-pager", true);
    }
  },
  inputs: {
    currentAlert: [InputFlags.None, "clrCurrentAlert", "currentAlert"],
    currentAlertIndex: [InputFlags.None, "clrCurrentAlertIndex", "currentAlertIndex"]
  },
  outputs: {
    currentAlertChange: "clrCurrentAlertChange",
    currentAlertIndexChange: "clrCurrentAlertIndexChange"
  },
  decls: 9,
  vars: 4,
  consts: [[1, "alerts-pager-control"], [1, "alerts-page-down"], ["type", "button", 1, "alerts-pager-button", 3, "click"], ["shape", "angle", "direction", "left"], [1, "alerts-pager-text"], [1, "alerts-page-up"], ["shape", "angle", "direction", "right"]],
  template: function ClrAlertsPager_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0)(1, "div", 1)(2, "button", 2);
      ɵɵlistener("click", function ClrAlertsPager_Template_button_click_2_listener() {
        return ctx.pageDown();
      });
      ɵɵelement(3, "cds-icon", 3);
      ɵɵelementEnd()();
      ɵɵelementStart(4, "div", 4);
      ɵɵtext(5);
      ɵɵelementEnd();
      ɵɵelementStart(6, "div", 5)(7, "button", 2);
      ɵɵlistener("click", function ClrAlertsPager_Template_button_click_7_listener() {
        return ctx.pageUp();
      });
      ɵɵelement(8, "cds-icon", 6);
      ɵɵelementEnd()()();
    }
    if (rf & 2) {
      ɵɵadvance(2);
      ɵɵattribute("aria-label", ctx.previousAlertAriaLabel);
      ɵɵadvance(3);
      ɵɵtextInterpolate2("", ctx.multiAlertService.current + 1, " / ", ctx.multiAlertService.count, "");
      ɵɵadvance(2);
      ɵɵattribute("aria-label", ctx.nextAlertAriaLabel);
    }
  },
  dependencies: [CdsIconCustomTag],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrAlertsPager, [{
    type: Component,
    args: [{
      selector: "clr-alerts-pager",
      host: {
        "[class.alerts-pager]": "true"
      },
      template: '<!--\n  ~ Copyright (c) 2016-2024 Broadcom. All Rights Reserved.\n  ~ The term "Broadcom" refers to Broadcom Inc. and/or its subsidiaries.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n  -->\n\n<div class="alerts-pager-control">\n  <div class="alerts-page-down">\n    <button class="alerts-pager-button" type="button" (click)="pageDown()" [attr.aria-label]="previousAlertAriaLabel">\n      <cds-icon shape="angle" direction="left"></cds-icon>\n    </button>\n  </div>\n  <div class="alerts-pager-text">{{this.multiAlertService.current+1}} / {{this.multiAlertService.count}}</div>\n  <div class="alerts-page-up">\n    <button class="alerts-pager-button" type="button" (click)="pageUp()" [attr.aria-label]="nextAlertAriaLabel">\n      <cds-icon shape="angle" direction="right"></cds-icon>\n    </button>\n  </div>\n</div>\n'
    }]
  }], function() {
    return [{
      type: MultiAlertService
    }, {
      type: ClrCommonStringsService
    }];
  }, {
    currentAlertChange: [{
      type: Output,
      args: ["clrCurrentAlertChange"]
    }],
    currentAlertIndexChange: [{
      type: Output,
      args: ["clrCurrentAlertIndexChange"]
    }],
    currentAlert: [{
      type: Input,
      args: ["clrCurrentAlert"]
    }],
    currentAlertIndex: [{
      type: Input,
      args: ["clrCurrentAlertIndex"]
    }]
  });
})();
var ClrAlerts = class {
  constructor(multiAlertService) {
    this.multiAlertService = multiAlertService;
    this.currentAlertChange = new EventEmitter(false);
    this.currentAlertIndexChange = new EventEmitter(false);
    this.subscriptions = [];
  }
  set allAlerts(value) {
    this.multiAlertService.manage(value);
  }
  /**
   * Input/Output to support two way binding on current alert index
   */
  set _inputCurrentIndex(index) {
    if (Number.isInteger(index) && index >= 0) {
      this.multiAlertService.current = index;
    }
  }
  get currentAlertIndex() {
    return this.multiAlertService.current;
  }
  set currentAlertIndex(index) {
    this.multiAlertService.current = index;
  }
  /**
   * Input/Output to support two way binding on current alert instance
   */
  get currentAlert() {
    return this.multiAlertService.currentAlert;
  }
  set currentAlert(alert) {
    if (alert) {
      this.multiAlertService.currentAlert = alert;
    }
  }
  /**
   * Ensure we are only dealing with alerts that have not been closed yet
   */
  get alerts() {
    return this.allAlerts.filter((alert) => {
      return alert.hidden === false;
    });
  }
  get currentAlertType() {
    if (this.multiAlertService.currentAlert) {
      return this.multiAlertService.currentAlert.alertType;
    }
    return "";
  }
  ngAfterContentInit() {
    this.subscriptions.push(this.multiAlertService.changes.subscribe((index) => {
      this.currentAlertIndexChange.next(index);
      this.currentAlertChange.next(this.multiAlertService.currentAlert);
    }));
  }
  ngOnDestroy() {
    this.subscriptions.forEach((sub) => sub.unsubscribe());
    this.multiAlertService.destroy();
  }
};
ClrAlerts.ɵfac = function ClrAlerts_Factory(t3) {
  return new (t3 || ClrAlerts)(ɵɵdirectiveInject(MultiAlertService));
};
ClrAlerts.ɵcmp = ɵɵdefineComponent({
  type: ClrAlerts,
  selectors: [["clr-alerts"]],
  contentQueries: function ClrAlerts_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ClrAlert, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.allAlerts = _t);
    }
  },
  hostVars: 12,
  hostBindings: function ClrAlerts_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("alerts", true)("alert-danger", ctx.currentAlertType == "danger")("alert-info", ctx.currentAlertType == "info")("alert-success", ctx.currentAlertType == "success")("alert-warning", ctx.currentAlertType == "warning")("alert-neutral", ctx.currentAlertType == "neutral");
    }
  },
  inputs: {
    _inputCurrentIndex: [InputFlags.None, "clrCurrentAlertIndex", "_inputCurrentIndex"],
    currentAlert: [InputFlags.None, "clrCurrentAlert", "currentAlert"]
  },
  outputs: {
    currentAlertChange: "clrCurrentAlertChange",
    currentAlertIndexChange: "clrCurrentAlertIndexChange"
  },
  features: [ɵɵProvidersFeature([MultiAlertService])],
  ngContentSelectors: _c89,
  decls: 3,
  vars: 1,
  consts: [[1, "alerts-wrapper"], [3, "clrCurrentAlertIndex", 4, "ngIf"], [3, "clrCurrentAlertIndex"]],
  template: function ClrAlerts_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c88);
      ɵɵelementStart(0, "div", 0);
      ɵɵtemplate(1, ClrAlerts_clr_alerts_pager_1_Template, 1, 1, "clr-alerts-pager", 1);
      ɵɵprojection(2);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.multiAlertService.count > 1);
    }
  },
  dependencies: [NgIf, ClrAlertsPager],
  styles: ["[_nghost-%COMP%]{display:block}"]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrAlerts, [{
    type: Component,
    args: [{
      selector: "clr-alerts",
      providers: [MultiAlertService],
      host: {
        "[class.alerts]": "true",
        "[class.alert-danger]": "this.currentAlertType == 'danger'",
        "[class.alert-info]": "this.currentAlertType == 'info'",
        "[class.alert-success]": "this.currentAlertType == 'success'",
        "[class.alert-warning]": "this.currentAlertType == 'warning'",
        "[class.alert-neutral]": "this.currentAlertType == 'neutral'"
      },
      template: '<!--\n  ~ Copyright (c) 2016-2024 Broadcom. All Rights Reserved.\n  ~ The term "Broadcom" refers to Broadcom Inc. and/or its subsidiaries.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n  -->\n<div class="alerts-wrapper">\n  <clr-alerts-pager *ngIf="multiAlertService.count > 1" [clrCurrentAlertIndex]="currentAlertIndex"></clr-alerts-pager>\n  <ng-content select="clr-alert"></ng-content>\n</div>\n',
      styles: [":host{display:block}\n"]
    }]
  }], function() {
    return [{
      type: MultiAlertService
    }];
  }, {
    currentAlertChange: [{
      type: Output,
      args: ["clrCurrentAlertChange"]
    }],
    currentAlertIndexChange: [{
      type: Output,
      args: ["clrCurrentAlertIndexChange"]
    }],
    allAlerts: [{
      type: ContentChildren,
      args: [ClrAlert]
    }],
    _inputCurrentIndex: [{
      type: Input,
      args: ["clrCurrentAlertIndex"]
    }],
    currentAlert: [{
      type: Input,
      args: ["clrCurrentAlert"]
    }]
  });
})();
var CLR_ALERT_DIRECTIVES = [ClrAlert, ClrAlertItem, ClrAlerts, ClrAlertsPager, ClrAlertText];
var ClrAlertModule = class {
  constructor() {
    r.addIcons(d, d4, d2, o8, d3, C, n3);
  }
};
ClrAlertModule.ɵfac = function ClrAlertModule_Factory(t3) {
  return new (t3 || ClrAlertModule)();
};
ClrAlertModule.ɵmod = ɵɵdefineNgModule({
  type: ClrAlertModule,
  declarations: [ClrAlert, ClrAlertItem, ClrAlerts, ClrAlertsPager, ClrAlertText],
  imports: [CommonModule, ClrIconModule, ClrDropdownModule, ClrSpinnerModule],
  exports: [ClrAlert, ClrAlertItem, ClrAlerts, ClrAlertsPager, ClrAlertText]
});
ClrAlertModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, ClrIconModule, ClrDropdownModule, ClrSpinnerModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrAlertModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, ClrIconModule, ClrDropdownModule, ClrSpinnerModule],
      declarations: [CLR_ALERT_DIRECTIVES],
      exports: [CLR_ALERT_DIRECTIVES]
    }]
  }], function() {
    return [];
  }, null);
})();
var ClrEmphasisModule = class {
};
ClrEmphasisModule.ɵfac = function ClrEmphasisModule_Factory(t3) {
  return new (t3 || ClrEmphasisModule)();
};
ClrEmphasisModule.ɵmod = ɵɵdefineNgModule({
  type: ClrEmphasisModule,
  exports: [ClrAlertModule]
});
ClrEmphasisModule.ɵinj = ɵɵdefineInjector({
  imports: [ClrAlertModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrEmphasisModule, [{
    type: NgModule,
    args: [{
      exports: [ClrAlertModule]
    }]
  }], null, null);
})();
var ResponsiveNavCodes = class {
};
ResponsiveNavCodes.NAV_LEVEL_1 = 1;
ResponsiveNavCodes.NAV_LEVEL_2 = 2;
ResponsiveNavCodes.NAV_CLOSE_ALL = "NAV_CLOSE_ALL";
ResponsiveNavCodes.NAV_OPEN = "NAV_OPEN";
ResponsiveNavCodes.NAV_CLOSE = "NAV_CLOSE";
ResponsiveNavCodes.NAV_TOGGLE = "NAV_TOGGLE";
ResponsiveNavCodes.NAV_CLASS_HAMBURGER_MENU = "open-hamburger-menu";
ResponsiveNavCodes.NAV_CLASS_OVERFLOW_MENU = "open-overflow-menu";
ResponsiveNavCodes.NAV_CLASS_TRIGGER_1 = "header-hamburger-trigger";
ResponsiveNavCodes.NAV_CLASS_TRIGGER_2 = "header-overflow-trigger";
ResponsiveNavCodes.NAV_CLASS_LEVEL_1 = "clr-nav-level-1";
ResponsiveNavCodes.NAV_CLASS_LEVEL_2 = "clr-nav-level-2";
var ResponsiveNavControlMessage = class {
  constructor(_controlCode, _navLevel) {
    this._controlCode = _controlCode;
    this._navLevel = _navLevel;
  }
  get controlCode() {
    return this._controlCode;
  }
  get navLevel() {
    return this._navLevel;
  }
};
var ResponsiveNavigationService = class {
  constructor() {
    this.responsiveNavList = [];
    this.registerNavSubject = new ReplaySubject();
    this.controlNavSubject = new Subject();
    this.closeAllNavs();
  }
  get registeredNavs() {
    return this.registerNavSubject.asObservable();
  }
  get navControl() {
    return this.controlNavSubject.asObservable();
  }
  registerNav(navLevel) {
    if (!navLevel || this.isNavRegistered(navLevel)) {
      return;
    }
    this.responsiveNavList.push(navLevel);
    this.registerNavSubject.next(this.responsiveNavList);
  }
  isNavRegistered(navLevel) {
    if (this.responsiveNavList.indexOf(navLevel) > -1) {
      console.error("Multiple clr-nav-level " + navLevel + " attributes found. Please make sure that only one exists");
      return true;
    }
    return false;
  }
  unregisterNav(navLevel) {
    const index = this.responsiveNavList.indexOf(navLevel);
    if (index > -1) {
      this.responsiveNavList.splice(index, 1);
      this.registerNavSubject.next(this.responsiveNavList);
    }
  }
  sendControlMessage(controlCode, navLevel) {
    const message = new ResponsiveNavControlMessage(controlCode, navLevel);
    this.controlNavSubject.next(message);
  }
  closeAllNavs() {
    const message = new ResponsiveNavControlMessage(ResponsiveNavCodes.NAV_CLOSE_ALL, -999);
    this.controlNavSubject.next(message);
  }
};
ResponsiveNavigationService.ɵfac = function ResponsiveNavigationService_Factory(t3) {
  return new (t3 || ResponsiveNavigationService)();
};
ResponsiveNavigationService.ɵprov = ɵɵdefineInjectable({
  token: ResponsiveNavigationService,
  factory: ResponsiveNavigationService.ɵfac,
  providedIn: "root"
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ResponsiveNavigationService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], function() {
    return [];
  }, null);
})();
var ClrMainContainer = class {
  constructor(elRef, responsiveNavService) {
    this.elRef = elRef;
    this.responsiveNavService = responsiveNavService;
  }
  ngOnInit() {
    this._classList = this.elRef.nativeElement.classList;
    this._subscription = this.responsiveNavService.navControl.subscribe({
      next: (message) => {
        this.processMessage(message);
      }
    });
  }
  processMessage(message) {
    let navClass = ResponsiveNavCodes.NAV_CLASS_HAMBURGER_MENU;
    if (message.controlCode === ResponsiveNavCodes.NAV_CLOSE_ALL) {
      this._classList.remove(ResponsiveNavCodes.NAV_CLASS_HAMBURGER_MENU);
      this._classList.remove(ResponsiveNavCodes.NAV_CLASS_OVERFLOW_MENU);
    } else if (message.navLevel === ResponsiveNavCodes.NAV_LEVEL_1) {
      this.controlNav(message.controlCode, navClass);
    } else if (message.navLevel === ResponsiveNavCodes.NAV_LEVEL_2) {
      navClass = ResponsiveNavCodes.NAV_CLASS_OVERFLOW_MENU;
      this.controlNav(message.controlCode, navClass);
    }
  }
  controlNav(controlCode, navClass) {
    if (controlCode === ResponsiveNavCodes.NAV_OPEN) {
      this._classList.add(navClass);
    } else if (controlCode === ResponsiveNavCodes.NAV_CLOSE) {
      this._classList.remove(navClass);
    } else if (controlCode === ResponsiveNavCodes.NAV_TOGGLE) {
      this._classList.toggle(navClass);
    }
  }
  ngOnDestroy() {
    this._subscription.unsubscribe();
  }
};
ClrMainContainer.ɵfac = function ClrMainContainer_Factory(t3) {
  return new (t3 || ClrMainContainer)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ResponsiveNavigationService));
};
ClrMainContainer.ɵdir = ɵɵdefineDirective({
  type: ClrMainContainer,
  selectors: [["clr-main-container"]],
  hostVars: 2,
  hostBindings: function ClrMainContainer_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("main-container", true);
    }
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrMainContainer, [{
    type: Directive,
    args: [{
      selector: "clr-main-container",
      host: {
        "[class.main-container]": "true"
      }
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: ResponsiveNavigationService
    }];
  }, null);
})();
var CLR_LAYOUT_DIRECTIVES = [ClrMainContainer];
var ClrMainContainerModule = class {
};
ClrMainContainerModule.ɵfac = function ClrMainContainerModule_Factory(t3) {
  return new (t3 || ClrMainContainerModule)();
};
ClrMainContainerModule.ɵmod = ɵɵdefineNgModule({
  type: ClrMainContainerModule,
  declarations: [ClrMainContainer],
  imports: [CommonModule, ClrIconModule],
  exports: [ClrMainContainer]
});
ClrMainContainerModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, ClrIconModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrMainContainerModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, ClrIconModule],
      declarations: [CLR_LAYOUT_DIRECTIVES],
      exports: [CLR_LAYOUT_DIRECTIVES]
    }]
  }], null, null);
})();
var ClrAriaCurrentLink = class {
  constructor(rla) {
    this.rla = rla;
  }
  ngOnInit() {
    this.subscription = this.rla.isActiveChange.subscribe((isActive) => {
      this.ariaCurrent = isActive ? "page" : void 0;
    });
  }
  ngOnDestroy() {
    this.subscription.unsubscribe();
  }
};
ClrAriaCurrentLink.ɵfac = function ClrAriaCurrentLink_Factory(t3) {
  return new (t3 || ClrAriaCurrentLink)(ɵɵdirectiveInject(RouterLinkActive));
};
ClrAriaCurrentLink.ɵdir = ɵɵdefineDirective({
  type: ClrAriaCurrentLink,
  selectors: [["", "clrAriaCurrentLink", ""]],
  hostVars: 1,
  hostBindings: function ClrAriaCurrentLink_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("aria-current", ctx.ariaCurrent);
    }
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrAriaCurrentLink, [{
    type: Directive,
    args: [{
      selector: "[clrAriaCurrentLink]",
      host: {
        "[attr.aria-current]": "ariaCurrent"
      }
    }]
  }], function() {
    return [{
      type: RouterLinkActive
    }];
  }, null);
})();
var MainContainerWillyWonka = class extends WillyWonka {
};
MainContainerWillyWonka.ɵfac = /* @__PURE__ */ (() => {
  let ɵMainContainerWillyWonka_BaseFactory;
  return function MainContainerWillyWonka_Factory(t3) {
    return (ɵMainContainerWillyWonka_BaseFactory || (ɵMainContainerWillyWonka_BaseFactory = ɵɵgetInheritedFactory(MainContainerWillyWonka)))(t3 || MainContainerWillyWonka);
  };
})();
MainContainerWillyWonka.ɵdir = ɵɵdefineDirective({
  type: MainContainerWillyWonka,
  selectors: [["clr-main-container"]],
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MainContainerWillyWonka, [{
    type: Directive,
    args: [{
      selector: "clr-main-container"
    }]
  }], null, null);
})();
var NavDetectionOompaLoompa = class extends OompaLoompa {
  constructor(cdr, willyWonka, responsiveNavService) {
    if (!willyWonka) {
      throw new Error("clr-header should only be used inside of a clr-main-container");
    }
    super(cdr, willyWonka);
    this.responsiveNavService = responsiveNavService;
  }
  // NavDetectionOompaLoompa is the addition of the nav levels
  // Since we support 2 levels, the possibilities are 0, 1 or 3 (1 + 2)
  get flavor() {
    return this.responsiveNavService.responsiveNavList.reduce((sum, navLevel) => sum + navLevel, 0);
  }
};
NavDetectionOompaLoompa.ɵfac = function NavDetectionOompaLoompa_Factory(t3) {
  return new (t3 || NavDetectionOompaLoompa)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(MainContainerWillyWonka, 8), ɵɵdirectiveInject(ResponsiveNavigationService));
};
NavDetectionOompaLoompa.ɵdir = ɵɵdefineDirective({
  type: NavDetectionOompaLoompa,
  selectors: [["clr-header"]],
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NavDetectionOompaLoompa, [{
    type: Directive,
    args: [{
      selector: "clr-header"
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: MainContainerWillyWonka,
      decorators: [{
        type: Optional
      }]
    }, {
      type: ResponsiveNavigationService
    }];
  }, null);
})();
var ClrHeader = class {
  constructor(responsiveNavService, commonStrings) {
    this.responsiveNavService = responsiveNavService;
    this.commonStrings = commonStrings;
    this.role = "banner";
    this.isNavLevel1OnPage = false;
    this.isNavLevel2OnPage = false;
    this.openNavLevel = null;
    this.responsiveNavCodes = ResponsiveNavCodes;
    this._subscription = this.responsiveNavService.registeredNavs.subscribe({
      next: (navLevelList) => {
        this.initializeNavTriggers(navLevelList);
      }
    });
    this._subscription.add(this.responsiveNavService.navControl.pipe(filter(({
      controlCode
    }) => controlCode === ResponsiveNavCodes.NAV_CLOSE || controlCode === ResponsiveNavCodes.NAV_CLOSE_ALL)).subscribe(() => {
      this.openNavLevel = null;
    }));
  }
  get responsiveNavCommonString() {
    const myCommonStrings = this.commonStrings.keys;
    if (this.openNavLevel !== this.responsiveNavCodes.NAV_LEVEL_1) {
      return myCommonStrings.responsiveNavToggleOpen;
    } else {
      return myCommonStrings.responsiveNavToggleClose;
    }
  }
  get responsiveOverflowCommonString() {
    const myCommonStrings = this.commonStrings.keys;
    if (this.openNavLevel !== this.responsiveNavCodes.NAV_LEVEL_2) {
      return myCommonStrings.responsiveNavOverflowOpen;
    } else {
      return myCommonStrings.responsiveNavOverflowClose;
    }
  }
  // reset triggers. handles cases when an application has different nav levels on different pages.
  resetNavTriggers() {
    this.isNavLevel1OnPage = false;
    this.isNavLevel2OnPage = false;
  }
  // decides which triggers to show on the header
  initializeNavTriggers(navList) {
    this.resetNavTriggers();
    if (navList.length > 2) {
      console.error("More than 2 Nav Levels detected.");
      return;
    }
    navList.forEach((navLevel) => {
      if (navLevel === ResponsiveNavCodes.NAV_LEVEL_1) {
        this.isNavLevel1OnPage = true;
      } else if (navLevel === ResponsiveNavCodes.NAV_LEVEL_2) {
        this.isNavLevel2OnPage = true;
      }
    });
  }
  // closes the nav that is open
  closeOpenNav() {
    this.responsiveNavService.closeAllNavs();
  }
  /**
   * @deprecated Will be removed in with @clr/angular v15.0.0
   *
   * Use `openNav(navLevel)` instead to open the navigation and ResponsiveNavService to close it.
   */
  toggleNav(navLevel) {
    if (this.openNavLevel === navLevel) {
      this.responsiveNavService.sendControlMessage(ResponsiveNavCodes.NAV_CLOSE, navLevel);
      return;
    }
    this.openNav(navLevel);
  }
  openNav(navLevel) {
    this.openNavLevel = navLevel;
    this.responsiveNavService.sendControlMessage(ResponsiveNavCodes.NAV_OPEN, navLevel);
  }
  ngOnDestroy() {
    this._subscription.unsubscribe();
  }
};
ClrHeader.ɵfac = function ClrHeader_Factory(t3) {
  return new (t3 || ClrHeader)(ɵɵdirectiveInject(ResponsiveNavigationService), ɵɵdirectiveInject(ClrCommonStringsService));
};
ClrHeader.ɵcmp = ɵɵdefineComponent({
  type: ClrHeader,
  selectors: [["clr-header"]],
  hostVars: 3,
  hostBindings: function ClrHeader_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("role", ctx.role);
      ɵɵclassProp("header", true);
    }
  },
  inputs: {
    role: "role"
  },
  ngContentSelectors: _c02,
  decls: 4,
  vars: 2,
  consts: [["type", "button", "class", "header-hamburger-trigger", 3, "click", 4, "ngIf"], ["type", "button", "class", "header-overflow-trigger", 3, "click", 4, "ngIf"], [1, "header-backdrop", 3, "click"], ["type", "button", 1, "header-hamburger-trigger", 3, "click"], ["type", "button", 1, "header-overflow-trigger", 3, "click"]],
  template: function ClrHeader_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵtemplate(0, ClrHeader_button_0_Template, 2, 1, "button", 0);
      ɵɵprojection(1);
      ɵɵtemplate(2, ClrHeader_button_2_Template, 2, 1, "button", 1);
      ɵɵelementStart(3, "div", 2);
      ɵɵlistener("click", function ClrHeader_Template_div_click_3_listener() {
        return ctx.closeOpenNav();
      });
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.isNavLevel1OnPage);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.isNavLevel2OnPage);
    }
  },
  dependencies: [NgIf],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrHeader, [{
    type: Component,
    args: [{
      selector: "clr-header",
      template: `
    <button
      type="button"
      *ngIf="isNavLevel1OnPage"
      class="header-hamburger-trigger"
      [attr.aria-label]="responsiveNavCommonString"
      (click)="openNav(responsiveNavCodes.NAV_LEVEL_1)"
    >
      <span></span>
    </button>
    <ng-content></ng-content>
    <button
      type="button"
      *ngIf="isNavLevel2OnPage"
      class="header-overflow-trigger"
      [attr.aria-label]="responsiveOverflowCommonString"
      (click)="openNav(responsiveNavCodes.NAV_LEVEL_2)"
    >
      <span></span>
    </button>
    <div class="header-backdrop" (click)="closeOpenNav()"></div>
  `,
      host: {
        "[class.header]": "true"
      }
    }]
  }], function() {
    return [{
      type: ResponsiveNavigationService
    }, {
      type: ClrCommonStringsService
    }];
  }, {
    role: [{
      type: Input
    }, {
      type: HostBinding,
      args: ["attr.role"]
    }]
  });
})();
var createCdsCloseButton = (document2, ariaLabel) => {
  const cdsCloseButton = document2.createElement("cds-internal-close-button");
  cdsCloseButton.setAttribute("icon-size", "32");
  cdsCloseButton.setAttribute("aria-label", ariaLabel);
  cdsCloseButton.setAttribute("aria-hidden", "true");
  cdsCloseButton.setAttribute("type", "button");
  cdsCloseButton.setAttribute("hidden", "true");
  cdsCloseButton.className = "clr-nav-close";
  return cdsCloseButton;
};
var ClrNavLevel = class {
  constructor(platformId, cdkTrapFocus, responsiveNavService, elementRef, renderer, injector) {
    this.cdkTrapFocus = cdkTrapFocus;
    this.responsiveNavService = responsiveNavService;
    this.elementRef = elementRef;
    this.renderer = renderer;
    this._isOpen = false;
    if (isPlatformBrowser(platformId)) {
      this._document = injector.get(DOCUMENT);
    }
    this._subscription = responsiveNavService.navControl.pipe(filter((x) => x.navLevel === this.level), filter(({
      controlCode
    }) => controlCode === ResponsiveNavCodes.NAV_OPEN && !this.isOpen || controlCode === ResponsiveNavCodes.NAV_CLOSE && this.isOpen)).subscribe(({
      controlCode
    }) => {
      if (controlCode === ResponsiveNavCodes.NAV_OPEN) {
        this.open();
        return;
      }
      this.close();
    });
    this._subscription.add(responsiveNavService.navControl.pipe(filter(({
      controlCode
    }) => controlCode === ResponsiveNavCodes.NAV_CLOSE_ALL)).subscribe(() => this.close()));
  }
  get level() {
    return this._level;
  }
  // getter to access the responsive navigation codes from the template
  get responsiveNavCodes() {
    return ResponsiveNavCodes;
  }
  get isOpen() {
    return this._isOpen;
  }
  ngOnInit() {
    this.cdkTrapFocus.enabled = false;
    if (!this.closeButtonAriaLabel) {
      this.closeButtonAriaLabel = this._level === ResponsiveNavCodes.NAV_LEVEL_1 ? commonStringsDefault.responsiveNavToggleClose : commonStringsDefault.responsiveNavOverflowClose;
    }
    if (this.level !== ResponsiveNavCodes.NAV_LEVEL_1 && this.level !== ResponsiveNavCodes.NAV_LEVEL_2) {
      console.error("Nav Level can only be 1 or 2");
      return;
    }
    this.responsiveNavService.registerNav(this.level);
    this.addNavClass(this.level);
  }
  ngAfterViewInit() {
    const closeButton = createCdsCloseButton(this._document, this.closeButtonAriaLabel);
    this.renderer.listen(closeButton, "click", this.close.bind(this));
    this.renderer.insertBefore(this.elementRef.nativeElement, closeButton, this.elementRef.nativeElement.firstChild);
    if (this._document.body.clientWidth < LARGE_BREAKPOINT) {
      this.close();
    }
  }
  ngOnDestroy() {
    this.responsiveNavService.unregisterNav(this.level);
    this._subscription.unsubscribe();
  }
  onResize(event) {
    const target = event.target;
    if (target.innerWidth < LARGE_BREAKPOINT && this.isOpen) {
      this.close();
      return;
    }
    this.showNavigation();
  }
  // TODO: Figure out whats the best way to do this. Possible methods
  // 1. HostListener (current solution)
  // 2. Directives on the .nav-link class. We discussed on moving away from class selectors but I forget the reason
  // why
  onMouseClick(target) {
    let current = target;
    const navHost = this.elementRef.nativeElement;
    while (current) {
      if (current === navHost) {
        return;
      } else if (current.classList.contains("nav-link") && this._document.body.clientWidth < LARGE_BREAKPOINT) {
        this.close();
        return;
      }
      current = current.parentNode;
    }
  }
  addNavClass(level) {
    const navHostClassList = this.elementRef.nativeElement.classList;
    if (level === ResponsiveNavCodes.NAV_LEVEL_1) {
      navHostClassList.add(ResponsiveNavCodes.NAV_CLASS_LEVEL_1);
    } else if (level === ResponsiveNavCodes.NAV_LEVEL_2) {
      navHostClassList.add(ResponsiveNavCodes.NAV_CLASS_LEVEL_2);
    }
  }
  open() {
    this._isOpen = true;
    this.showNavigation();
    this.cdkTrapFocus.enabled = true;
    this.showCloseButton();
    this.responsiveNavService.sendControlMessage(ResponsiveNavCodes.NAV_OPEN, this.level);
  }
  close() {
    this._isOpen = false;
    this.hideNavigation();
    this.cdkTrapFocus.enabled = false;
    this.hideCloseButton();
    this.responsiveNavService.sendControlMessage(ResponsiveNavCodes.NAV_CLOSE, this.level);
  }
  hideNavigation() {
    this.renderer.setAttribute(this.elementRef.nativeElement, "aria-hidden", "true");
    this.renderer.setAttribute(this.elementRef.nativeElement, "hidden", "true");
  }
  showNavigation() {
    this.renderer.setAttribute(this.elementRef.nativeElement, "aria-hidden", "false");
    this.renderer.removeAttribute(this.elementRef.nativeElement, "hidden");
  }
  hideCloseButton() {
    this.renderer.setAttribute(this.elementRef.nativeElement, "aria-hidden", "true");
    this.renderer.setAttribute(this.elementRef.nativeElement.querySelector(".clr-nav-close"), "hidden", "true");
  }
  showCloseButton() {
    this.renderer.setAttribute(this.elementRef.nativeElement.querySelector(".clr-nav-close"), "aria-hidden", "false");
    this.renderer.removeAttribute(this.elementRef.nativeElement.querySelector(".clr-nav-close"), "hidden");
  }
};
ClrNavLevel.ɵfac = function ClrNavLevel_Factory(t3) {
  return new (t3 || ClrNavLevel)(ɵɵdirectiveInject(PLATFORM_ID), ɵɵdirectiveInject(ClrStandaloneCdkTrapFocus), ɵɵdirectiveInject(ResponsiveNavigationService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(Injector));
};
ClrNavLevel.ɵdir = ɵɵdefineDirective({
  type: ClrNavLevel,
  selectors: [["", "clr-nav-level", ""]],
  hostBindings: function ClrNavLevel_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("resize", function ClrNavLevel_resize_HostBindingHandler($event) {
        return ctx.onResize($event);
      }, false, ɵɵresolveWindow)("click", function ClrNavLevel_click_HostBindingHandler($event) {
        return ctx.onMouseClick($event.target);
      });
    }
  },
  inputs: {
    _level: [InputFlags.None, "clr-nav-level", "_level"],
    closeButtonAriaLabel: [InputFlags.None, "closeAriaLabel", "closeButtonAriaLabel"]
  },
  features: [ɵɵHostDirectivesFeature([ClrStandaloneCdkTrapFocus])]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrNavLevel, [{
    type: Directive,
    args: [{
      selector: "[clr-nav-level]",
      hostDirectives: [ClrStandaloneCdkTrapFocus]
    }]
  }], function() {
    return [{
      type: void 0,
      decorators: [{
        type: Inject,
        args: [PLATFORM_ID]
      }]
    }, {
      type: ClrStandaloneCdkTrapFocus
    }, {
      type: ResponsiveNavigationService
    }, {
      type: ElementRef
    }, {
      type: Renderer2
    }, {
      type: Injector
    }];
  }, {
    _level: [{
      type: Input,
      args: ["clr-nav-level"]
    }],
    closeButtonAriaLabel: [{
      type: Input,
      args: ["closeAriaLabel"]
    }],
    onResize: [{
      type: HostListener,
      args: ["window:resize", ["$event"]]
    }],
    onMouseClick: [{
      type: HostListener,
      args: ["click", ["$event.target"]]
    }]
  });
})();
var CLR_NAVIGATION_DIRECTIVES = [ClrHeader, ClrNavLevel, ClrAriaCurrentLink, NavDetectionOompaLoompa, MainContainerWillyWonka];
var ClrNavigationModule = class {
};
ClrNavigationModule.ɵfac = function ClrNavigationModule_Factory(t3) {
  return new (t3 || ClrNavigationModule)();
};
ClrNavigationModule.ɵmod = ɵɵdefineNgModule({
  type: ClrNavigationModule,
  declarations: [ClrHeader, ClrNavLevel, ClrAriaCurrentLink, NavDetectionOompaLoompa, MainContainerWillyWonka],
  imports: [CommonModule, ClrIconModule, ClrDropdownModule],
  exports: [ClrHeader, ClrNavLevel, ClrAriaCurrentLink, NavDetectionOompaLoompa, MainContainerWillyWonka]
});
ClrNavigationModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, ClrIconModule, ClrDropdownModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrNavigationModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, ClrIconModule, ClrDropdownModule],
      declarations: [CLR_NAVIGATION_DIRECTIVES],
      exports: [CLR_NAVIGATION_DIRECTIVES]
    }]
  }], null, null);
})();
var TemplateRefContainer = class {
};
TemplateRefContainer.ɵfac = function TemplateRefContainer_Factory(t3) {
  return new (t3 || TemplateRefContainer)();
};
TemplateRefContainer.ɵcmp = ɵɵdefineComponent({
  type: TemplateRefContainer,
  selectors: [["ng-component"]],
  viewQuery: function TemplateRefContainer_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(TemplateRef, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.template = _t.first);
    }
  },
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function TemplateRefContainer_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵtemplate(0, TemplateRefContainer_ng_template_0_Template, 1, 0, "ng-template");
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TemplateRefContainer, [{
    type: Component,
    args: [{
      template: `
    <ng-template>
      <ng-content></ng-content>
    </ng-template>
  `
    }]
  }], null, {
    template: [{
      type: ViewChild,
      args: [TemplateRef]
    }]
  });
})();
var TEMPLATE_REF_DIRECTIVES = [TemplateRefContainer];
var ClrTemplateRefModule = class {
};
ClrTemplateRefModule.ɵfac = function ClrTemplateRefModule_Factory(t3) {
  return new (t3 || ClrTemplateRefModule)();
};
ClrTemplateRefModule.ɵmod = ɵɵdefineNgModule({
  type: ClrTemplateRefModule,
  declarations: [TemplateRefContainer],
  imports: [CommonModule],
  exports: [TemplateRefContainer]
});
ClrTemplateRefModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrTemplateRefModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      declarations: [TEMPLATE_REF_DIRECTIVES],
      exports: [TEMPLATE_REF_DIRECTIVES]
    }]
  }], null, null);
})();
var TabsWillyWonka = class extends WillyWonka {
};
TabsWillyWonka.ɵfac = /* @__PURE__ */ (() => {
  let ɵTabsWillyWonka_BaseFactory;
  return function TabsWillyWonka_Factory(t3) {
    return (ɵTabsWillyWonka_BaseFactory || (ɵTabsWillyWonka_BaseFactory = ɵɵgetInheritedFactory(TabsWillyWonka)))(t3 || TabsWillyWonka);
  };
})();
TabsWillyWonka.ɵdir = ɵɵdefineDirective({
  type: TabsWillyWonka,
  selectors: [["clr-tabs"]],
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TabsWillyWonka, [{
    type: Directive,
    args: [{
      selector: "clr-tabs"
    }]
  }], null, null);
})();
var ActiveOompaLoompa = class extends OompaLoompa {
  constructor(cdr, willyWonka, id, ifActive) {
    if (!willyWonka) {
      throw new Error("clrTabLink and clr-tab-content should only be used inside of a clr-tabs");
    }
    super(cdr, willyWonka);
    this.ifActive = ifActive;
    this.id = id;
  }
  get flavor() {
    return this.ifActive.current === this.id;
  }
};
ActiveOompaLoompa.ɵfac = function ActiveOompaLoompa_Factory(t3) {
  return new (t3 || ActiveOompaLoompa)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(TabsWillyWonka, 8), ɵɵdirectiveInject(IF_ACTIVE_ID), ɵɵdirectiveInject(IfActiveService));
};
ActiveOompaLoompa.ɵdir = ɵɵdefineDirective({
  type: ActiveOompaLoompa,
  selectors: [["", "clrTabLink", ""], ["clr-tab-content"]],
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ActiveOompaLoompa, [{
    type: Directive,
    args: [{
      selector: "[clrTabLink], clr-tab-content"
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: TabsWillyWonka,
      decorators: [{
        type: Optional
      }]
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [IF_ACTIVE_ID]
      }]
    }, {
      type: IfActiveService
    }];
  }, null);
})();
var TabsLayout;
(function(TabsLayout2) {
  TabsLayout2["HORIZONTAL"] = "horizontal";
  TabsLayout2["VERTICAL"] = "vertical";
})(TabsLayout || (TabsLayout = {}));
var TabsService = class {
  constructor() {
    this.layout = TabsLayout.HORIZONTAL;
    this._children = [];
  }
  get children() {
    return this._children;
  }
  get activeTab() {
    return this.children.find((tab) => {
      return tab.active;
    });
  }
  get overflowTabs() {
    if (this.layout === TabsLayout.VERTICAL) {
      return [];
    } else {
      return this.children.filter((tab) => tab.tabLink.inOverflow === true);
    }
  }
  register(tab) {
    this._children.push(tab);
  }
  unregister(tab) {
    const index = this.children.indexOf(tab);
    if (index > -1) {
      this.children.splice(index, 1);
    }
  }
};
TabsService.ɵfac = function TabsService_Factory(t3) {
  return new (t3 || TabsService)();
};
TabsService.ɵprov = ɵɵdefineInjectable({
  token: TabsService,
  factory: TabsService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TabsService, [{
    type: Injectable
  }], null, null);
})();
var nbTabContentComponents = 0;
var ClrTabContent = class {
  constructor(ifActiveService, id, tabsService) {
    this.ifActiveService = ifActiveService;
    this.id = id;
    this.tabsService = tabsService;
    if (!this.tabContentId) {
      this.tabContentId = "clr-tab-content-" + nbTabContentComponents++;
    }
  }
  get active() {
    return this.ifActiveService.current === this.id;
  }
  get ariaLabelledBy() {
    return this.tabsService.children.find((tab) => tab.tabLink.id === this.id)?.tabLink?.tabLinkId;
  }
  // The template must be applied on the top-down phase of view-child initialization to prevent
  // components in the content from initializing before a content container exists.
  // Some child components need their container for sizing calculations.
  set templateRef(value) {
    this.viewRef = this.tabsService.tabContentViewContainer.createEmbeddedView(value);
  }
  ngOnDestroy() {
    const index = this.tabsService.tabContentViewContainer.indexOf(this.viewRef);
    if (index > -1) {
      this.tabsService.tabContentViewContainer.remove(index);
    }
  }
};
ClrTabContent.ɵfac = function ClrTabContent_Factory(t3) {
  return new (t3 || ClrTabContent)(ɵɵdirectiveInject(IfActiveService), ɵɵdirectiveInject(IF_ACTIVE_ID), ɵɵdirectiveInject(TabsService));
};
ClrTabContent.ɵcmp = ɵɵdefineComponent({
  type: ClrTabContent,
  selectors: [["clr-tab-content"]],
  viewQuery: function ClrTabContent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c90, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.templateRef = _t.first);
    }
  },
  inputs: {
    tabContentId: [InputFlags.None, "id", "tabContentId"]
  },
  ngContentSelectors: _c02,
  decls: 2,
  vars: 0,
  consts: [["tabContentProjectedRef", ""], ["role", "tabpanel", 1, "tab-content", 3, "id", "hidden"]],
  template: function ClrTabContent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵtemplate(0, ClrTabContent_ng_template_0_Template, 2, 6, "ng-template", null, 0, ɵɵtemplateRefExtractor);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrTabContent, [{
    type: Component,
    args: [{
      selector: "clr-tab-content",
      template: `
    <ng-template #tabContentProjectedRef>
      <section
        [id]="tabContentId"
        role="tabpanel"
        class="tab-content"
        [class.active]="active"
        [hidden]="!active"
        [attr.aria-labelledby]="ariaLabelledBy"
        [attr.aria-hidden]="!active"
      >
        <ng-content></ng-content>
      </section>
    </ng-template>
  `
    }]
  }], function() {
    return [{
      type: IfActiveService
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [IF_ACTIVE_ID]
      }]
    }, {
      type: TabsService
    }];
  }, {
    tabContentId: [{
      type: Input,
      args: ["id"]
    }],
    templateRef: [{
      type: ViewChild,
      args: ["tabContentProjectedRef", {
        static: true
      }]
    }]
  });
})();
var nbTabsComponent = 0;
var TABS_ID = new InjectionToken("TABS_ID");
function tokenFactory() {
  return "clr-tabs-" + nbTabsComponent++;
}
var TABS_ID_PROVIDER = {
  provide: TABS_ID,
  useFactory: tokenFactory
};
var nbTabLinkComponents = 0;
var ClrTabLink = class {
  constructor(ifActiveService, id, el, cfr, viewContainerRef, tabsService, tabsId) {
    this.ifActiveService = ifActiveService;
    this.id = id;
    this.el = el;
    this.cfr = cfr;
    this.viewContainerRef = viewContainerRef;
    this.tabsService = tabsService;
    this.tabsId = tabsId;
    if (!this.tabLinkId) {
      this.tabLinkId = "clr-tab-link-" + nbTabLinkComponents++;
    }
    const factory = this.cfr.resolveComponentFactory(TemplateRefContainer);
    this.templateRefContainer = this.viewContainerRef.createComponent(factory, void 0, void 0, [[this.el.nativeElement]]).instance;
  }
  get inOverflow() {
    return this._inOverflow && this.tabsService.layout !== TabsLayout.VERTICAL;
  }
  set inOverflow(inOverflow) {
    this._inOverflow = inOverflow;
  }
  get addLinkClasses() {
    return !this.inOverflow;
  }
  get ariaControls() {
    return this.tabsService.children.find((tab) => tab.tabLink === this)?.tabContent?.tabContentId;
  }
  get active() {
    return this.ifActiveService.current === this.id;
  }
  get tabindex() {
    return this.active ? 0 : -1;
  }
  activate() {
    this.ifActiveService.current = this.id;
  }
};
ClrTabLink.ɵfac = function ClrTabLink_Factory(t3) {
  return new (t3 || ClrTabLink)(ɵɵdirectiveInject(IfActiveService), ɵɵdirectiveInject(IF_ACTIVE_ID), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ComponentFactoryResolver$1), ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(TabsService), ɵɵdirectiveInject(TABS_ID));
};
ClrTabLink.ɵdir = ɵɵdefineDirective({
  type: ClrTabLink,
  selectors: [["", "clrTabLink", ""]],
  hostAttrs: ["role", "tab", "type", "button"],
  hostVars: 12,
  hostBindings: function ClrTabLink_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function ClrTabLink_click_HostBindingHandler() {
        return ctx.activate();
      });
    }
    if (rf & 2) {
      ɵɵhostProperty("id", ctx.tabLinkId);
      ɵɵattribute("aria-controls", ctx.ariaControls)("aria-selected", ctx.active)("tabindex", ctx.tabindex);
      ɵɵclassProp("btn", true)("btn-link", ctx.addLinkClasses)("nav-link", ctx.addLinkClasses)("active", ctx.active);
    }
  },
  inputs: {
    tabLinkId: [InputFlags.None, "id", "tabLinkId"],
    inOverflow: [InputFlags.None, "clrTabLinkInOverflow", "inOverflow"]
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrTabLink, [{
    type: Directive,
    args: [{
      selector: "[clrTabLink]",
      host: {
        "[class.btn]": "true",
        role: "tab",
        type: "button"
      }
    }]
  }], function() {
    return [{
      type: IfActiveService
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [IF_ACTIVE_ID]
      }]
    }, {
      type: ElementRef
    }, {
      type: ComponentFactoryResolver$1
    }, {
      type: ViewContainerRef
    }, {
      type: TabsService
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [TABS_ID]
      }]
    }];
  }, {
    tabLinkId: [{
      type: Input,
      args: ["id"]
    }, {
      type: HostBinding,
      args: ["id"]
    }],
    inOverflow: [{
      type: Input,
      args: ["clrTabLinkInOverflow"]
    }],
    addLinkClasses: [{
      type: HostBinding,
      args: ["class.btn-link"]
    }, {
      type: HostBinding,
      args: ["class.nav-link"]
    }],
    ariaControls: [{
      type: HostBinding,
      args: ["attr.aria-controls"]
    }],
    active: [{
      type: HostBinding,
      args: ["class.active"]
    }, {
      type: HostBinding,
      args: ["attr.aria-selected"]
    }],
    tabindex: [{
      type: HostBinding,
      args: ["attr.tabindex"]
    }],
    activate: [{
      type: HostListener,
      args: ["click"]
    }]
  });
})();
var ClrTab = class {
  constructor(ifActiveService, id, tabsService) {
    this.ifActiveService = ifActiveService;
    this.id = id;
    this.tabsService = tabsService;
    tabsService.register(this);
  }
  get active() {
    return this.ifActiveService.current === this.id;
  }
  ngOnDestroy() {
    this.tabsService.unregister(this);
  }
};
ClrTab.ɵfac = function ClrTab_Factory(t3) {
  return new (t3 || ClrTab)(ɵɵdirectiveInject(IfActiveService), ɵɵdirectiveInject(IF_ACTIVE_ID), ɵɵdirectiveInject(TabsService));
};
ClrTab.ɵcmp = ɵɵdefineComponent({
  type: ClrTab,
  selectors: [["clr-tab"]],
  contentQueries: function ClrTab_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ClrTabLink, 7);
      ɵɵcontentQuery(dirIndex, ClrTabContent, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tabLink = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tabContent = _t.first);
    }
  },
  features: [ɵɵProvidersFeature([IF_ACTIVE_ID_PROVIDER])],
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function ClrTab_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrTab, [{
    type: Component,
    args: [{
      selector: "clr-tab",
      template: `<ng-content></ng-content>`,
      providers: [IF_ACTIVE_ID_PROVIDER]
    }]
  }], function() {
    return [{
      type: IfActiveService
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [IF_ACTIVE_ID]
      }]
    }, {
      type: TabsService
    }];
  }, {
    tabLink: [{
      type: ContentChild,
      args: [ClrTabLink, {
        static: true
      }]
    }],
    tabContent: [{
      type: ContentChild,
      args: [ClrTabContent, {
        static: true
      }]
    }]
  });
})();
var ClrTabOverflowContent = class {
};
ClrTabOverflowContent.ɵfac = function ClrTabOverflowContent_Factory(t3) {
  return new (t3 || ClrTabOverflowContent)();
};
ClrTabOverflowContent.ɵcmp = ɵɵdefineComponent({
  type: ClrTabOverflowContent,
  selectors: [["clr-tab-overflow-content"]],
  hostVars: 2,
  hostBindings: function ClrTabOverflowContent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("dropdown-menu", true);
    }
  },
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function ClrTabOverflowContent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrTabOverflowContent, [{
    type: Component,
    args: [{
      selector: "clr-tab-overflow-content",
      template: `<ng-content></ng-content>`,
      host: {
        "[class.dropdown-menu]": "true"
      }
    }]
  }], null, null);
})();
var ClrTabs = class {
  constructor(ifActiveService, toggleService, tabsService, tabsId, commonStrings) {
    this.ifActiveService = ifActiveService;
    this.toggleService = toggleService;
    this.tabsService = tabsService;
    this.tabsId = tabsId;
    this.commonStrings = commonStrings;
    this.tabLinkElements = [];
    this._mousedown = false;
    this.subscriptions = [];
    this._tabLinkDirectives = [];
  }
  get layout() {
    return this.tabsService.layout;
  }
  set layout(layout) {
    if (Object.keys(TabsLayout).map((key) => {
      return TabsLayout[key];
    }).indexOf(layout) >= 0) {
      this.tabsService.layout = layout;
    }
  }
  get tabLinkDirectives() {
    return this._tabLinkDirectives;
  }
  get activeTabInOverflow() {
    return this.tabsService.overflowTabs.indexOf(this.tabsService.activeTab) > -1;
  }
  get activeTabPosition() {
    return this._tabLinkDirectives.findIndex((link) => link.active);
  }
  get isCurrentInOverflow() {
    return this.keyFocus.current >= this.overflowPosition;
  }
  get isVertical() {
    return this.layout === TabsLayout.VERTICAL;
  }
  set tabOverflowEl(value) {
    this._tabOverflowEl = value && value.nativeElement;
    if (this.toggleService.open && value) {
      this.keyFocus.focusCurrent();
    }
  }
  get overflowPosition() {
    return this._tabLinkDirectives.filter((link) => !link.inOverflow).length;
  }
  set tabContentViewContainer(value) {
    this.tabsService.tabContentViewContainer = value;
  }
  ngAfterContentInit() {
    this.subscriptions.push(this.listenForTabLinkChanges());
    if (typeof this.ifActiveService.current === "undefined" && this.tabLinkDirectives[0]) {
      this.tabLinkDirectives[0].activate();
    }
    this.keyFocus.current = this.activeTabPosition;
  }
  ngOnDestroy() {
    this.subscriptions.forEach((sub) => {
      sub.unsubscribe();
    });
  }
  toggleOverflowOnPosition(position) {
    this.toggleService.open = position >= this.overflowPosition;
  }
  resetKeyFocusCurrentToActive(event) {
    const keyFocusContainsFocus = this.keyFocus.nativeElement.contains(event.relatedTarget);
    if (!keyFocusContainsFocus && this.keyFocus.current !== this.activeTabPosition) {
      this.keyFocus.current = this.activeTabPosition;
    }
  }
  toggleOverflowOnClick() {
    if (this.isCurrentInOverflow && this.toggleService.open) {
      this.keyFocus.moveTo(this.overflowPosition - 1);
    } else {
      this.keyFocus.moveTo(this.overflowPosition);
    }
    this._mousedown = false;
  }
  openOverflowOnFocus() {
    if (!this._mousedown && !this.toggleService.open) {
      this.keyFocus.moveTo(this.activeTabPosition);
    }
  }
  closeOnFocusOut(event) {
    if (!this._tabOverflowEl.contains(event.relatedTarget) && this.toggleService.open && !this._mousedown) {
      this.toggleService.open = false;
      if (this.tabLinkElements[this.activeTabPosition] === event.relatedTarget) {
        this.keyFocus.current = this.activeTabPosition;
      }
    }
  }
  closeOnEscapeKey() {
    this.keyFocus.moveTo(this.overflowPosition - 1);
  }
  closeOnOutsideClick(event, tabOverflowTrigger) {
    if (event.target === tabOverflowTrigger || tabOverflowTrigger.contains(event.target)) {
      return;
    }
    if (!this._tabOverflowEl.contains(event.target) && this.isCurrentInOverflow) {
      this.keyFocus.moveTo(this.overflowPosition - 1);
    }
  }
  listenForTabLinkChanges() {
    return this.tabs.changes.pipe(startWith(this.tabs.map((tab) => tab.tabLink))).subscribe(() => {
      this._tabLinkDirectives = this.tabs.map((tab) => tab.tabLink);
      this.tabLinkElements = this._tabLinkDirectives.map((tab) => tab.el.nativeElement);
    });
  }
};
ClrTabs.ɵfac = function ClrTabs_Factory(t3) {
  return new (t3 || ClrTabs)(ɵɵdirectiveInject(IfActiveService), ɵɵdirectiveInject(ClrPopoverToggleService), ɵɵdirectiveInject(TabsService), ɵɵdirectiveInject(TABS_ID), ɵɵdirectiveInject(ClrCommonStringsService));
};
ClrTabs.ɵcmp = ɵɵdefineComponent({
  type: ClrTabs,
  selectors: [["clr-tabs"]],
  contentQueries: function ClrTabs_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ClrTab, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tabs = _t);
    }
  },
  viewQuery: function ClrTabs_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(ClrKeyFocus, 7);
      ɵɵviewQuery(ClrTabOverflowContent, 5, ElementRef);
      ɵɵviewQuery(_c91, 7, ViewContainerRef);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.keyFocus = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tabOverflowEl = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.tabContentViewContainer = _t.first);
    }
  },
  hostVars: 2,
  hostBindings: function ClrTabs_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("tabs-vertical", ctx.isVertical);
    }
  },
  inputs: {
    layout: [InputFlags.None, "clrLayout", "layout"]
  },
  features: [ɵɵProvidersFeature([IfActiveService, TabsService, TABS_ID_PROVIDER]), ɵɵHostDirectivesFeature([ClrPopoverHostDirective])],
  decls: 5,
  vars: 3,
  consts: [["tabContentViewContainer", ""], ["tabOverflowTrigger", ""], ["role", "tablist", "clrDirection", "both", 1, "nav", 3, "clrFocusChange", "focusout", "clrKeyFocus"], [4, "ngFor", "ngForOf"], [4, "ngIf"], ["role", "presentation", 1, "nav-item"], [3, "ngTemplateOutlet"], ["role", "presentation", 1, "tabs-overflow", "bottom-right"], ["role", "application", 1, "nav-item"], ["type", "button", "aria-hidden", "true", 1, "btn", "btn-link", "nav-link", "dropdown-toggle", 3, "mousedown", "focus", "click"], ["shape", "ellipsis-horizontal"], [3, "keydown.escape", "click", "focusout", 4, "ngIf"], [3, "keydown.escape", "click", "focusout"], [3, "ngTemplateOutlet", 4, "ngIf"]],
  template: function ClrTabs_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵelementStart(0, "ul", 2);
      ɵɵlistener("clrFocusChange", function ClrTabs_Template_ul_clrFocusChange_0_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.toggleOverflowOnPosition($event));
      })("focusout", function ClrTabs_Template_ul_focusout_0_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.resetKeyFocusCurrentToActive($event));
      });
      ɵɵtemplate(1, ClrTabs_ng_container_1_Template, 2, 1, "ng-container", 3)(2, ClrTabs_ng_container_2_Template, 7, 11, "ng-container", 4);
      ɵɵelementEnd();
      ɵɵelementContainer(3, null, 0);
    }
    if (rf & 2) {
      ɵɵproperty("clrKeyFocus", ctx.tabLinkElements);
      ɵɵadvance();
      ɵɵproperty("ngForOf", ctx.tabLinkDirectives);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.tabsService.overflowTabs.length > 0);
    }
  },
  dependencies: [NgForOf, NgIf, NgTemplateOutlet, CdsIconCustomTag, ClrKeyFocus, ClrTabOverflowContent],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrTabs, [{
    type: Component,
    args: [{
      selector: "clr-tabs",
      template: `
    <ul
      class="nav"
      role="tablist"
      [clrKeyFocus]="tabLinkElements"
      clrDirection="both"
      (clrFocusChange)="toggleOverflowOnPosition($event)"
      (focusout)="resetKeyFocusCurrentToActive($event)"
    >
      <!--tab links-->
      <ng-container *ngFor="let link of tabLinkDirectives">
        <ng-container *ngIf="link.tabsId === tabsId && !link.inOverflow">
          <li role="presentation" class="nav-item">
            <ng-container [ngTemplateOutlet]="link.templateRefContainer.template"></ng-container>
          </li>
        </ng-container>
      </ng-container>
      <ng-container *ngIf="tabsService.overflowTabs.length > 0">
        <div class="tabs-overflow bottom-right" role="presentation" [class.open]="toggleService.open">
          <li role="application" class="nav-item">
            <button
              #tabOverflowTrigger
              class="btn btn-link nav-link dropdown-toggle"
              type="button"
              aria-hidden="true"
              [attr.tabindex]="activeTabInOverflow && !toggleService.open ? 0 : -1"
              [class.active]="activeTabInOverflow"
              [class.open]="toggleService.open"
              (mousedown)="_mousedown = true"
              (focus)="openOverflowOnFocus()"
              (click)="toggleOverflowOnClick()"
              [attr.title]="commonStrings.keys.more"
            >
              <cds-icon
                shape="ellipsis-horizontal"
                [attr.status]="toggleService.open ? 'info' : null"
                [attr.title]="commonStrings.keys.more"
              ></cds-icon>
            </button>
          </li>
          <!--tab links in overflow menu-->
          <clr-tab-overflow-content
            *ngIf="toggleService.open"
            (document:keydown.escape)="closeOnEscapeKey()"
            (document:click)="closeOnOutsideClick($event, tabOverflowTrigger)"
            (focusout)="closeOnFocusOut($event)"
          >
            <ng-container *ngFor="let link of tabLinkDirectives">
              <ng-container
                *ngIf="link.tabsId === tabsId && link.inOverflow"
                [ngTemplateOutlet]="link.templateRefContainer.template"
              ></ng-container>
            </ng-container>
          </clr-tab-overflow-content>
        </div>
      </ng-container>
    </ul>
    <ng-container #tabContentViewContainer></ng-container>
  `,
      providers: [IfActiveService, TabsService, TABS_ID_PROVIDER],
      hostDirectives: [ClrPopoverHostDirective]
    }]
  }], function() {
    return [{
      type: IfActiveService
    }, {
      type: ClrPopoverToggleService
    }, {
      type: TabsService
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [TABS_ID]
      }]
    }, {
      type: ClrCommonStringsService
    }];
  }, {
    keyFocus: [{
      type: ViewChild,
      args: [ClrKeyFocus, {
        static: true
      }]
    }],
    tabs: [{
      type: ContentChildren,
      args: [ClrTab]
    }],
    layout: [{
      type: Input,
      args: ["clrLayout"]
    }],
    isVertical: [{
      type: HostBinding,
      args: ["class.tabs-vertical"]
    }],
    tabOverflowEl: [{
      type: ViewChild,
      args: [ClrTabOverflowContent, {
        read: ElementRef
      }]
    }],
    tabContentViewContainer: [{
      type: ViewChild,
      args: ["tabContentViewContainer", {
        static: true,
        read: ViewContainerRef
      }]
    }]
  });
})();
var CLR_TABS_DIRECTIVES = [ClrTabContent, ClrTab, ClrTabs, ClrTabOverflowContent, ClrTabLink, TabsWillyWonka, ActiveOompaLoompa];
var ClrTabsModule = class {
  constructor() {
    r.addIcons(i);
  }
};
ClrTabsModule.ɵfac = function ClrTabsModule_Factory(t3) {
  return new (t3 || ClrTabsModule)();
};
ClrTabsModule.ɵmod = ɵɵdefineNgModule({
  type: ClrTabsModule,
  declarations: [ClrTabContent, ClrTab, ClrTabs, ClrTabOverflowContent, ClrTabLink, TabsWillyWonka, ActiveOompaLoompa],
  imports: [CommonModule, ClrConditionalModule, ClrIconModule, ClrTemplateRefModule, ClrKeyFocusModule],
  exports: [ClrTabContent, ClrTab, ClrTabs, ClrTabOverflowContent, ClrTabLink, TabsWillyWonka, ActiveOompaLoompa, ClrConditionalModule]
});
ClrTabsModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, ClrConditionalModule, ClrIconModule, ClrTemplateRefModule, ClrKeyFocusModule, ClrConditionalModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrTabsModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, ClrConditionalModule, ClrIconModule, ClrTemplateRefModule, ClrKeyFocusModule],
      declarations: [CLR_TABS_DIRECTIVES],
      exports: [CLR_TABS_DIRECTIVES, ClrConditionalModule]
    }]
  }], function() {
    return [];
  }, null);
})();
var VerticalNavGroupRegistrationService = class {
  constructor() {
    this.navGroupCount = 0;
  }
  registerNavGroup() {
    this.navGroupCount++;
  }
  unregisterNavGroup() {
    this.navGroupCount--;
  }
};
VerticalNavGroupRegistrationService.ɵfac = function VerticalNavGroupRegistrationService_Factory(t3) {
  return new (t3 || VerticalNavGroupRegistrationService)();
};
VerticalNavGroupRegistrationService.ɵprov = ɵɵdefineInjectable({
  token: VerticalNavGroupRegistrationService,
  factory: VerticalNavGroupRegistrationService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(VerticalNavGroupRegistrationService, [{
    type: Injectable
  }], null, null);
})();
var VerticalNavIconService = class {
  constructor() {
    this._icons = 0;
  }
  get hasIcons() {
    return this._icons > 0;
  }
  registerIcon() {
    this._icons++;
  }
  unregisterIcon() {
    this._icons--;
  }
};
VerticalNavIconService.ɵfac = function VerticalNavIconService_Factory(t3) {
  return new (t3 || VerticalNavIconService)();
};
VerticalNavIconService.ɵprov = ɵɵdefineInjectable({
  token: VerticalNavIconService,
  factory: VerticalNavIconService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(VerticalNavIconService, [{
    type: Injectable
  }], null, null);
})();
var VerticalNavService = class {
  constructor() {
    this._animateOnCollapsed = new Subject();
    this._collapsedChanged = new Subject();
    this._collapsed = false;
    this._collapsible = false;
  }
  get animateOnCollapsed() {
    return this._animateOnCollapsed.asObservable();
  }
  get collapsedChanged() {
    return this._collapsedChanged.asObservable();
  }
  get collapsed() {
    return this._collapsed;
  }
  set collapsed(value) {
    value = !!value;
    if (this.collapsible && this._collapsed !== value) {
      this.updateCollapseBehavior(value);
    }
  }
  get collapsible() {
    return this._collapsible;
  }
  set collapsible(value) {
    value = !!value;
    if (this._collapsible !== value) {
      if (!value && this.collapsed) {
        this.updateCollapseBehavior(false);
      }
      this._collapsible = value;
    }
  }
  updateCollapseBehavior(value) {
    this._animateOnCollapsed.next(value);
    this._collapsed = value;
    this._collapsedChanged.next(value);
  }
};
VerticalNavService.ɵfac = function VerticalNavService_Factory(t3) {
  return new (t3 || VerticalNavService)();
};
VerticalNavService.ɵprov = ɵɵdefineInjectable({
  token: VerticalNavService,
  factory: VerticalNavService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(VerticalNavService, [{
    type: Injectable
  }], null, null);
})();
var ClrVerticalNav = class {
  constructor(_navService, _navIconService, _navGroupRegistrationService, commonStrings) {
    this._navService = _navService;
    this._navIconService = _navIconService;
    this._navGroupRegistrationService = _navGroupRegistrationService;
    this.commonStrings = commonStrings;
    this._collapsedChanged = new EventEmitter(true);
    this._sub = this._navService.collapsedChanged.subscribe((value) => {
      this._collapsedChanged.emit(value);
    });
  }
  get collapsible() {
    return this._navService.collapsible;
  }
  set collapsible(value) {
    this._navService.collapsible = value;
  }
  get collapsed() {
    return this._navService.collapsed;
  }
  set collapsed(value) {
    this._navService.collapsed = value;
  }
  get hasNavGroups() {
    return this._navGroupRegistrationService.navGroupCount > 0;
  }
  get hasIcons() {
    return this._navIconService.hasIcons;
  }
  get ariaExpanded() {
    if (!this.collapsible) {
      return null;
    }
    return !this.collapsed ? "true" : "false";
  }
  ngOnDestroy() {
    this._sub.unsubscribe();
  }
  toggleByButton() {
    this.collapsed = !this.collapsed;
  }
};
ClrVerticalNav.ɵfac = function ClrVerticalNav_Factory(t3) {
  return new (t3 || ClrVerticalNav)(ɵɵdirectiveInject(VerticalNavService), ɵɵdirectiveInject(VerticalNavIconService), ɵɵdirectiveInject(VerticalNavGroupRegistrationService), ɵɵdirectiveInject(ClrCommonStringsService));
};
ClrVerticalNav.ɵcmp = ɵɵdefineComponent({
  type: ClrVerticalNav,
  selectors: [["clr-vertical-nav"]],
  hostAttrs: [1, "clr-vertical-nav"],
  hostVars: 6,
  hostBindings: function ClrVerticalNav_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("is-collapsed", ctx.collapsed)("has-nav-groups", ctx.hasNavGroups)("has-icons", ctx.hasIcons);
    }
  },
  inputs: {
    collapsible: [InputFlags.None, "clrVerticalNavCollapsible", "collapsible"],
    collapsed: [InputFlags.None, "clrVerticalNavCollapsed", "collapsed"]
  },
  outputs: {
    _collapsedChanged: "clrVerticalNavCollapsedChange"
  },
  features: [ɵɵProvidersFeature([VerticalNavService, VerticalNavIconService, VerticalNavGroupRegistrationService])],
  ngContentSelectors: _c02,
  decls: 4,
  vars: 2,
  consts: [["type", "button", "class", "nav-trigger", 3, "on-collapse", "click", 4, "ngIf"], [1, "nav-content"], ["type", "button", "class", "nav-btn", "aria-hidden", "true", "tabindex", "-1", 3, "click", 4, "ngIf"], ["type", "button", 1, "nav-trigger", 3, "click"], ["shape", "angle-double", 1, "nav-trigger-icon"], ["type", "button", "aria-hidden", "true", "tabindex", "-1", 1, "nav-btn", 3, "click"]],
  template: function ClrVerticalNav_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵtemplate(0, ClrVerticalNav_button_0_Template, 2, 5, "button", 0);
      ɵɵelementStart(1, "div", 1);
      ɵɵprojection(2);
      ɵɵtemplate(3, ClrVerticalNav_button_3_Template, 1, 1, "button", 2);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx.collapsible);
      ɵɵadvance(3);
      ɵɵproperty("ngIf", ctx.collapsible && ctx.collapsed);
    }
  },
  dependencies: [NgIf, CdsIconCustomTag],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrVerticalNav, [{
    type: Component,
    args: [{
      selector: "clr-vertical-nav",
      providers: [VerticalNavService, VerticalNavIconService, VerticalNavGroupRegistrationService],
      host: {
        class: "clr-vertical-nav",
        "[class.is-collapsed]": "collapsed",
        "[class.has-nav-groups]": "hasNavGroups",
        "[class.has-icons]": "hasIcons"
      },
      template: `<!--
  ~ Copyright (c) 2016-2024 Broadcom. All Rights Reserved.
  ~ The term "Broadcom" refers to Broadcom Inc. and/or its subsidiaries.
  ~ This software is released under MIT license.
  ~ The full license information can be found in LICENSE in the root directory of this project.
  -->

<button
  type="button"
  class="nav-trigger"
  [class.on-collapse]="collapsed"
  [attr.aria-expanded]="ariaExpanded"
  [attr.aria-label]="commonStrings.keys.verticalNavToggle"
  (click)="toggleByButton()"
  *ngIf="collapsible"
>
  <cds-icon
    shape="angle-double"
    class="nav-trigger-icon"
    [attr.direction]="(this.collapsed) ? 'right' : 'left'"
  ></cds-icon>
</button>
<div class="nav-content">
  <ng-content></ng-content>
  <button
    type="button"
    (click)="collapsed = false"
    class="nav-btn"
    aria-hidden="true"
    tabindex="-1"
    [attr.aria-label]="commonStrings.keys.verticalNavToggle"
    *ngIf="collapsible && collapsed"
  ></button>
</div>
`
    }]
  }], function() {
    return [{
      type: VerticalNavService
    }, {
      type: VerticalNavIconService
    }, {
      type: VerticalNavGroupRegistrationService
    }, {
      type: ClrCommonStringsService
    }];
  }, {
    _collapsedChanged: [{
      type: Output,
      args: ["clrVerticalNavCollapsedChange"]
    }],
    collapsible: [{
      type: Input,
      args: ["clrVerticalNavCollapsible"]
    }],
    collapsed: [{
      type: Input,
      args: ["clrVerticalNavCollapsed"]
    }]
  });
})();
var VerticalNavGroupService = class {
  constructor() {
    this._expandChange = new Subject();
  }
  get expandChange() {
    return this._expandChange.asObservable();
  }
  expand() {
    this._expandChange.next(true);
  }
};
VerticalNavGroupService.ɵfac = function VerticalNavGroupService_Factory(t3) {
  return new (t3 || VerticalNavGroupService)();
};
VerticalNavGroupService.ɵprov = ɵɵdefineInjectable({
  token: VerticalNavGroupService,
  factory: VerticalNavGroupService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(VerticalNavGroupService, [{
    type: Injectable
  }], null, null);
})();
var EXPANDED_STATE = "expanded";
var COLLAPSED_STATE = "collapsed";
var ClrVerticalNavGroup = class {
  constructor(_itemExpand, _navGroupRegistrationService, _navGroupService, _navService, commonStrings) {
    this._itemExpand = _itemExpand;
    this._navGroupRegistrationService = _navGroupRegistrationService;
    this._navGroupService = _navGroupService;
    this._navService = _navService;
    this.commonStrings = commonStrings;
    this.expandedChange = new EventEmitter(true);
    this.wasExpanded = false;
    this._subscriptions = [];
    this._expandAnimationState = COLLAPSED_STATE;
    this._navGroupRegistrationService.registerNavGroup();
    this._subscriptions.push(this._itemExpand.expandChange.subscribe((value) => {
      if (value && this.expandAnimationState === COLLAPSED_STATE) {
        if (this._navService.collapsed) {
          this._navService.collapsed = false;
        }
        this.expandAnimationState = EXPANDED_STATE;
      } else if (!value && this.expandAnimationState === EXPANDED_STATE) {
        this.expandAnimationState = COLLAPSED_STATE;
      }
    }));
    this._subscriptions.push(this._navService.animateOnCollapsed.subscribe((goingToCollapse) => {
      if (goingToCollapse && this.expanded) {
        this.wasExpanded = true;
        this.expandAnimationState = COLLAPSED_STATE;
      } else if (!goingToCollapse && this.wasExpanded) {
        this.expandGroup();
        this.wasExpanded = false;
      }
    }));
    this._subscriptions.push(this._navGroupService.expandChange.subscribe((expand) => {
      if (expand && !this.expanded) {
        this.expandGroup();
      }
    }));
  }
  get expanded() {
    return this._itemExpand.expanded;
  }
  set expanded(value) {
    if (this._itemExpand.expanded !== value) {
      this._itemExpand.expanded = value;
      this.expandedChange.emit(value);
    }
  }
  set userExpandedInput(value) {
    value = !!value;
    if (this.expanded !== value) {
      this.toggleExpand();
    }
  }
  get expandAnimationState() {
    return this._expandAnimationState;
  }
  set expandAnimationState(value) {
    if (value !== this._expandAnimationState) {
      this._expandAnimationState = value;
    }
  }
  ngAfterContentInit() {
    if (this._navService.collapsed && this.expanded) {
      this.wasExpanded = true;
      this.expandAnimationState = COLLAPSED_STATE;
    }
  }
  ngOnDestroy() {
    this._subscriptions.forEach((sub) => sub.unsubscribe());
    this._navGroupRegistrationService.unregisterNavGroup();
  }
  expandGroup() {
    this.expanded = true;
    this.expandAnimationState = EXPANDED_STATE;
  }
  collapseGroup() {
    this.expandAnimationState = COLLAPSED_STATE;
  }
  // closes a group after the collapse animation
  expandAnimationDone($event) {
    if ($event.toState === COLLAPSED_STATE) {
      this.expanded = false;
    }
  }
  toggleExpand() {
    if (this.expanded) {
      this.collapseGroup();
    } else {
      if (this._navService.collapsed) {
        this._navService.collapsed = false;
      }
      this.expandGroup();
    }
  }
};
ClrVerticalNavGroup.ɵfac = function ClrVerticalNavGroup_Factory(t3) {
  return new (t3 || ClrVerticalNavGroup)(ɵɵdirectiveInject(IfExpandService), ɵɵdirectiveInject(VerticalNavGroupRegistrationService), ɵɵdirectiveInject(VerticalNavGroupService), ɵɵdirectiveInject(VerticalNavService), ɵɵdirectiveInject(ClrCommonStringsService));
};
ClrVerticalNavGroup.ɵcmp = ɵɵdefineComponent({
  type: ClrVerticalNavGroup,
  selectors: [["clr-vertical-nav-group"]],
  hostAttrs: [1, "nav-group"],
  hostVars: 2,
  hostBindings: function ClrVerticalNavGroup_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("is-expanded", ctx.expanded);
    }
  },
  inputs: {
    userExpandedInput: [InputFlags.None, "clrVerticalNavGroupExpanded", "userExpandedInput"]
  },
  outputs: {
    expandedChange: "clrVerticalNavGroupExpandedChange"
  },
  features: [ɵɵProvidersFeature([IfExpandService, VerticalNavGroupService])],
  ngContentSelectors: _c93,
  decls: 9,
  vars: 3,
  consts: [[1, "nav-group-content"], ["type", "button", 1, "nav-group-trigger", 3, "click"], [1, "nav-group-text"], ["shape", "angle", 1, "nav-group-trigger-icon"], [1, "nav-group-children"]],
  template: function ClrVerticalNavGroup_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c92);
      ɵɵelementStart(0, "div", 0);
      ɵɵprojection(1);
      ɵɵelementStart(2, "button", 1);
      ɵɵlistener("click", function ClrVerticalNavGroup_Template_button_click_2_listener() {
        return ctx.toggleExpand();
      });
      ɵɵprojection(3, 1);
      ɵɵelementStart(4, "div", 2);
      ɵɵprojection(5, 2);
      ɵɵelementEnd();
      ɵɵelement(6, "cds-icon", 3);
      ɵɵelementEnd()();
      ɵɵelementStart(7, "div", 4);
      ɵɵlistener("@clrExpand.done", function ClrVerticalNavGroup_Template_div_animation_clrExpand_done_7_listener($event) {
        return ctx.expandAnimationDone($event);
      });
      ɵɵprojection(8, 3);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance(2);
      ɵɵattribute("aria-expanded", ctx.expanded);
      ɵɵadvance(4);
      ɵɵattribute("direction", ctx.expanded ? "down" : "right");
      ɵɵadvance();
      ɵɵproperty("@clrExpand", ctx.expandAnimationState);
    }
  },
  dependencies: [CdsIconCustomTag],
  encapsulation: 2,
  data: {
    animation: [trigger("clrExpand", [state(EXPANDED_STATE, style({
      height: "*"
    })), state(COLLAPSED_STATE, style({
      height: 0,
      visibility: "hidden"
    })), transition(`${EXPANDED_STATE} <=> ${COLLAPSED_STATE}`, animate("0.2s ease-in-out"))])]
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrVerticalNavGroup, [{
    type: Component,
    args: [{
      selector: "clr-vertical-nav-group",
      providers: [IfExpandService, VerticalNavGroupService],
      animations: [trigger("clrExpand", [state(EXPANDED_STATE, style({
        height: "*"
      })), state(COLLAPSED_STATE, style({
        height: 0,
        visibility: "hidden"
      })), transition(`${EXPANDED_STATE} <=> ${COLLAPSED_STATE}`, animate("0.2s ease-in-out"))])],
      host: {
        class: "nav-group"
      },
      template: `<!--
  ~ Copyright (c) 2016-2024 Broadcom. All Rights Reserved.
  ~ The term "Broadcom" refers to Broadcom Inc. and/or its subsidiaries.
  ~ This software is released under MIT license.
  ~ The full license information can be found in LICENSE in the root directory of this project.
  -->

<div class="nav-group-content">
  <ng-content select="[clrVerticalNavLink]"></ng-content>
  <button class="nav-group-trigger" type="button" [attr.aria-expanded]="expanded" (click)="toggleExpand()">
    <ng-content select="[clrVerticalNavIcon]"></ng-content>
    <div class="nav-group-text">
      <ng-content></ng-content>
    </div>
    <cds-icon shape="angle" class="nav-group-trigger-icon" [attr.direction]="expanded ? 'down' : 'right'"></cds-icon>
  </button>
</div>
<!--TODO: This animation needs to be added to the clr-vertical-nav-group-children component-->
<div class="nav-group-children" [@clrExpand]="expandAnimationState" (@clrExpand.done)="expandAnimationDone($event)">
  <ng-content select="[clrIfExpanded], clr-vertical-nav-group-children"></ng-content>
</div>
`
    }]
  }], function() {
    return [{
      type: IfExpandService
    }, {
      type: VerticalNavGroupRegistrationService
    }, {
      type: VerticalNavGroupService
    }, {
      type: VerticalNavService
    }, {
      type: ClrCommonStringsService
    }];
  }, {
    expandedChange: [{
      type: Output,
      args: ["clrVerticalNavGroupExpandedChange"]
    }],
    expanded: [{
      type: HostBinding,
      args: ["class.is-expanded"]
    }],
    userExpandedInput: [{
      type: Input,
      args: ["clrVerticalNavGroupExpanded"]
    }]
  });
})();
var ClrVerticalNavGroupChildren = class {
};
ClrVerticalNavGroupChildren.ɵfac = function ClrVerticalNavGroupChildren_Factory(t3) {
  return new (t3 || ClrVerticalNavGroupChildren)();
};
ClrVerticalNavGroupChildren.ɵcmp = ɵɵdefineComponent({
  type: ClrVerticalNavGroupChildren,
  selectors: [["clr-vertical-nav-group-children"]],
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function ClrVerticalNavGroupChildren_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrVerticalNavGroupChildren, [{
    type: Component,
    args: [{
      selector: "clr-vertical-nav-group-children",
      template: `<ng-content></ng-content>`
    }]
  }], null, null);
})();
var ClrVerticalNavIcon = class {
  constructor(_verticalNavIconService) {
    this._verticalNavIconService = _verticalNavIconService;
    this._verticalNavIconService.registerIcon();
  }
  ngOnDestroy() {
    this._verticalNavIconService.unregisterIcon();
  }
};
ClrVerticalNavIcon.ɵfac = function ClrVerticalNavIcon_Factory(t3) {
  return new (t3 || ClrVerticalNavIcon)(ɵɵdirectiveInject(VerticalNavIconService));
};
ClrVerticalNavIcon.ɵdir = ɵɵdefineDirective({
  type: ClrVerticalNavIcon,
  selectors: [["", "clrVerticalNavIcon", ""]],
  hostAttrs: [1, "nav-icon"]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrVerticalNavIcon, [{
    type: Directive,
    args: [{
      selector: "[clrVerticalNavIcon]",
      host: {
        class: "nav-icon"
      }
    }]
  }], function() {
    return [{
      type: VerticalNavIconService
    }];
  }, null);
})();
var ClrVerticalNavLink = class {
  constructor(host, ref, navGroupService) {
    this.destroy$ = new Subject();
    navGroupService && fromEvent(host.nativeElement, "click").pipe(takeUntil(this.destroy$)).subscribe(() => {
      navGroupService.expand();
      ref.markForCheck();
    });
  }
  ngOnDestroy() {
    this.destroy$.next();
  }
};
ClrVerticalNavLink.ɵfac = function ClrVerticalNavLink_Factory(t3) {
  return new (t3 || ClrVerticalNavLink)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(VerticalNavGroupService, 8));
};
ClrVerticalNavLink.ɵcmp = ɵɵdefineComponent({
  type: ClrVerticalNavLink,
  selectors: [["", "clrVerticalNavLink", ""]],
  hostAttrs: [1, "nav-link"],
  attrs: _c94,
  ngContentSelectors: _c96,
  decls: 3,
  vars: 0,
  consts: [[1, "nav-text"]],
  template: function ClrVerticalNavLink_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c95);
      ɵɵprojection(0);
      ɵɵelementStart(1, "span", 0);
      ɵɵprojection(2, 1);
      ɵɵelementEnd();
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrVerticalNavLink, [{
    type: Component,
    args: [{
      selector: "[clrVerticalNavLink]",
      template: `
    <ng-content select="[clrVerticalNavIcon]"></ng-content>
    <span class="nav-text">
      <ng-content></ng-content>
    </span>
  `,
      host: {
        class: "nav-link"
      }
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: ChangeDetectorRef
    }, {
      type: VerticalNavGroupService,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [VerticalNavGroupService]
      }]
    }];
  }, null);
})();
var CLR_VERTICAL_NAV_DIRECTIVES = [ClrVerticalNav, ClrVerticalNavLink, ClrVerticalNavGroup, ClrVerticalNavGroupChildren, ClrVerticalNavIcon];
var ClrVerticalNavModule = class {
  constructor() {
    r.addIcons(o3, o4);
  }
};
ClrVerticalNavModule.ɵfac = function ClrVerticalNavModule_Factory(t3) {
  return new (t3 || ClrVerticalNavModule)();
};
ClrVerticalNavModule.ɵmod = ɵɵdefineNgModule({
  type: ClrVerticalNavModule,
  declarations: [ClrVerticalNav, ClrVerticalNavLink, ClrVerticalNavGroup, ClrVerticalNavGroupChildren, ClrVerticalNavIcon],
  imports: [CommonModule, ClrIconModule, ClrConditionalModule, ClrFocusOnViewInitModule],
  exports: [ClrVerticalNav, ClrVerticalNavLink, ClrVerticalNavGroup, ClrVerticalNavGroupChildren, ClrVerticalNavIcon, ClrConditionalModule, ClrIconModule, ClrFocusOnViewInitModule]
});
ClrVerticalNavModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, ClrIconModule, ClrConditionalModule, ClrFocusOnViewInitModule, ClrConditionalModule, ClrIconModule, ClrFocusOnViewInitModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrVerticalNavModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, ClrIconModule, ClrConditionalModule, ClrFocusOnViewInitModule],
      declarations: [CLR_VERTICAL_NAV_DIRECTIVES],
      exports: [CLR_VERTICAL_NAV_DIRECTIVES, ClrConditionalModule, ClrIconModule, ClrFocusOnViewInitModule]
    }]
  }], function() {
    return [];
  }, null);
})();
var ClrLayoutModule = class {
};
ClrLayoutModule.ɵfac = function ClrLayoutModule_Factory(t3) {
  return new (t3 || ClrLayoutModule)();
};
ClrLayoutModule.ɵmod = ɵɵdefineNgModule({
  type: ClrLayoutModule,
  exports: [ClrMainContainerModule, ClrNavigationModule, ClrTabsModule, ClrVerticalNavModule]
});
ClrLayoutModule.ɵinj = ɵɵdefineInjector({
  imports: [ClrMainContainerModule, ClrNavigationModule, ClrTabsModule, ClrVerticalNavModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrLayoutModule, [{
    type: NgModule,
    args: [{
      exports: [ClrMainContainerModule, ClrNavigationModule, ClrTabsModule, ClrVerticalNavModule]
    }]
  }], null, null);
})();
var ScrollingService = class {
  constructor(_document) {
    this._document = _document;
  }
  stopScrolling() {
    this._document.body.classList.add("no-scrolling");
  }
  resumeScrolling() {
    if (this._document.body.classList.contains("no-scrolling")) {
      this._document.body.classList.remove("no-scrolling");
    }
  }
};
ScrollingService.ɵfac = function ScrollingService_Factory(t3) {
  return new (t3 || ScrollingService)(ɵɵinject(DOCUMENT));
};
ScrollingService.ɵprov = ɵɵdefineInjectable({
  token: ScrollingService,
  factory: ScrollingService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ScrollingService, [{
    type: Injectable
  }], function() {
    return [{
      type: void 0,
      decorators: [{
        type: Inject,
        args: [DOCUMENT]
      }]
    }];
  }, null);
})();
var ClrModalConfigurationService = class {
  constructor() {
    this.fadeMove = "fadeDown";
    this.backdrop = true;
  }
};
ClrModalConfigurationService.ɵfac = function ClrModalConfigurationService_Factory(t3) {
  return new (t3 || ClrModalConfigurationService)();
};
ClrModalConfigurationService.ɵprov = ɵɵdefineInjectable({
  token: ClrModalConfigurationService,
  factory: ClrModalConfigurationService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrModalConfigurationService, [{
    type: Injectable
  }], null, null);
})();
var ClrModal = class {
  constructor(_scrollingService, commonStrings, modalStackService, configuration) {
    this._scrollingService = _scrollingService;
    this.commonStrings = commonStrings;
    this.modalStackService = modalStackService;
    this.configuration = configuration;
    this.modalId = uniqueIdFactory();
    this._open = false;
    this._openChanged = new EventEmitter(false);
    this.closable = true;
    this.closeButtonAriaLabel = this.commonStrings.keys.close;
    this.staticBackdrop = true;
    this.skipAnimation = "false";
    this.stopClose = false;
    this.altClose = new EventEmitter(false);
    this.bypassScrollService = false;
  }
  get fadeMove() {
    return this.skipAnimation ? "" : this.configuration.fadeMove;
  }
  set fadeMove(move) {
    this.configuration.fadeMove = move;
  }
  get backdrop() {
    return this.configuration.backdrop;
  }
  // Detect when _open is set to true and set no-scrolling to true
  ngOnChanges(changes) {
    if (!this.bypassScrollService && changes && Object.prototype.hasOwnProperty.call(changes, "_open")) {
      if (changes._open.currentValue) {
        this.backdrop && this._scrollingService.stopScrolling();
        this.modalStackService.trackModalOpen(this);
      } else {
        this._scrollingService.resumeScrolling();
      }
    }
  }
  ngOnDestroy() {
    this._scrollingService.resumeScrolling();
  }
  open() {
    if (this._open) {
      return;
    }
    this._open = true;
    this._openChanged.emit(true);
    this.modalStackService.trackModalOpen(this);
  }
  close() {
    if (this.stopClose) {
      this.altClose.emit(false);
      return;
    }
    if (!this.closable || !this._open) {
      return;
    }
    this._open = false;
  }
  fadeDone(e5) {
    if (e5.toState === "void") {
      this._openChanged.emit(false);
      this.modalStackService.trackModalClose(this);
    }
  }
};
ClrModal.ɵfac = function ClrModal_Factory(t3) {
  return new (t3 || ClrModal)(ɵɵdirectiveInject(ScrollingService), ɵɵdirectiveInject(ClrCommonStringsService), ɵɵdirectiveInject(ModalStackService), ɵɵdirectiveInject(ClrModalConfigurationService));
};
ClrModal.ɵcmp = ɵɵdefineComponent({
  type: ClrModal,
  selectors: [["clr-modal"]],
  hostVars: 2,
  hostBindings: function ClrModal_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("open", ctx._open);
    }
  },
  inputs: {
    _open: [InputFlags.None, "clrModalOpen", "_open"],
    closable: [InputFlags.None, "clrModalClosable", "closable"],
    closeButtonAriaLabel: [InputFlags.None, "clrModalCloseButtonAriaLabel", "closeButtonAriaLabel"],
    size: [InputFlags.None, "clrModalSize", "size"],
    staticBackdrop: [InputFlags.None, "clrModalStaticBackdrop", "staticBackdrop"],
    skipAnimation: [InputFlags.None, "clrModalSkipAnimation", "skipAnimation"],
    stopClose: [InputFlags.None, "clrModalPreventClose", "stopClose"],
    labelledBy: [InputFlags.None, "clrModalLabelledById", "labelledBy"],
    bypassScrollService: [InputFlags.None, "clrModalOverrideScrollService", "bypassScrollService"]
  },
  outputs: {
    _openChanged: "clrModalOpenChange",
    altClose: "clrModalAlternateClose"
  },
  features: [ɵɵProvidersFeature([], [ScrollingService]), ɵɵNgOnChangesFeature],
  ngContentSelectors: _c98,
  decls: 1,
  vars: 1,
  consts: [["class", "modal", 3, "modal-full-screen", 4, "ngIf"], [1, "modal"], ["cdkTrapFocus", "", "role", "dialog", "aria-modal", "true", 1, "modal-dialog", 3, "cdkTrapFocusAutoCapture"], [1, "clr-sr-only"], [1, "modal-content-wrapper"], [1, "modal-content"], [1, "modal-header--accessible"], ["cdkFocusInitial", "", "tabindex", "-1", 1, "modal-title-wrapper", 3, "id"], ["type", "button", "class", "close", 3, "click", 4, "ngIf"], [1, "modal-body-wrapper"], ["class", "modal-backdrop", "aria-hidden", "true", 3, "click", 4, "ngIf"], ["type", "button", 1, "close", 3, "click"], ["shape", "window-close"], ["aria-hidden", "true", 1, "modal-backdrop", 3, "click"]],
  template: function ClrModal_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c97);
      ɵɵtemplate(0, ClrModal_div_0_Template, 17, 17, "div", 0);
    }
    if (rf & 2) {
      ɵɵproperty("ngIf", ctx._open);
    }
  },
  dependencies: [NgIf, CdkTrapFocusModule_CdkTrapFocus, CdsIconCustomTag],
  styles: ["[_nghost-%COMP%]{display:none}.open[_nghost-%COMP%]{display:inline}"],
  data: {
    animation: [trigger("fadeMove", [transition("* => fadeDown", [style({
      opacity: 0,
      transform: "translate(0, -25%)"
    }), animate("0.2s ease-in-out")]), transition("fadeDown => *", [animate("0.2s ease-in-out", style({
      opacity: 0,
      transform: "translate(0, -25%)"
    }))]), transition("* => fadeLeft", [style({
      opacity: 0,
      transform: "translate(25%, 0)"
    }), animate("0.2s ease-in-out")]), transition("fadeLeft => *", [animate("0.2s ease-in-out", style({
      opacity: 0,
      transform: "translate(25%, 0)"
    }))])]), trigger("fade", [transition("void => *", [style({
      opacity: 0
    }), animate("0.2s ease-in-out", style({
      opacity: 0.85
    }))]), transition("* => void", [animate("0.2s ease-in-out", style({
      opacity: 0
    }))])])]
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrModal, [{
    type: Component,
    args: [{
      selector: "clr-modal",
      viewProviders: [ScrollingService],
      animations: [trigger("fadeMove", [transition("* => fadeDown", [style({
        opacity: 0,
        transform: "translate(0, -25%)"
      }), animate("0.2s ease-in-out")]), transition("fadeDown => *", [animate("0.2s ease-in-out", style({
        opacity: 0,
        transform: "translate(0, -25%)"
      }))]), transition("* => fadeLeft", [style({
        opacity: 0,
        transform: "translate(25%, 0)"
      }), animate("0.2s ease-in-out")]), transition("fadeLeft => *", [animate("0.2s ease-in-out", style({
        opacity: 0,
        transform: "translate(25%, 0)"
      }))])]), trigger("fade", [transition("void => *", [style({
        opacity: 0
      }), animate("0.2s ease-in-out", style({
        opacity: 0.85
      }))]), transition("* => void", [animate("0.2s ease-in-out", style({
        opacity: 0
      }))])])],
      template: `<!--
  ~ Copyright (c) 2016-2024 Broadcom. All Rights Reserved.
  ~ The term "Broadcom" refers to Broadcom Inc. and/or its subsidiaries.
  ~ This software is released under MIT license.
  ~ The full license information can be found in LICENSE in the root directory of this project.
  -->

<div *ngIf="_open" class="modal" [class.modal-full-screen]="size == 'full-screen'">
  <!--fixme: revisit when ngClass works with exit animation-->
  <div
    cdkTrapFocus
    [cdkTrapFocusAutoCapture]="true"
    [@fadeMove]="fadeMove"
    (@fadeMove.done)="fadeDone($event)"
    class="modal-dialog"
    [class.modal-sm]="size == 'sm'"
    [class.modal-lg]="size == 'lg'"
    [class.modal-xl]="size == 'xl'"
    role="dialog"
    aria-modal="true"
    [attr.aria-hidden]="!_open"
    [attr.aria-labelledby]="labelledBy || modalId"
  >
    <div class="clr-sr-only">{{commonStrings.keys.modalContentStart}}</div>
    <div class="modal-content-wrapper">
      <!-- only used in wizards -->
      <ng-content select=".modal-nav"></ng-content>

      <div class="modal-content">
        <div class="modal-header--accessible">
          <div class="modal-title-wrapper" id="{{modalId}}" cdkFocusInitial tabindex="-1">
            <ng-content select=".modal-title"></ng-content>
          </div>
          <button
            type="button"
            [attr.aria-label]="closeButtonAriaLabel || commonStrings.keys.close"
            class="close"
            *ngIf="closable"
            (click)="close()"
          >
            <cds-icon shape="window-close"></cds-icon>
          </button>
        </div>
        <div class="modal-body-wrapper">
          <ng-content select=".modal-body"></ng-content>
        </div>
        <ng-content select=".modal-footer"></ng-content>
      </div>
    </div>
    <div class="clr-sr-only">{{commonStrings.keys.modalContentEnd}}</div>
  </div>

  <div [@fade] *ngIf="backdrop" class="modal-backdrop" aria-hidden="true" (click)="staticBackdrop || close()"></div>
</div>
`,
      styles: [":host{display:none}:host.open{display:inline}\n"]
    }]
  }], function() {
    return [{
      type: ScrollingService
    }, {
      type: ClrCommonStringsService
    }, {
      type: ModalStackService
    }, {
      type: ClrModalConfigurationService
    }];
  }, {
    _open: [{
      type: Input,
      args: ["clrModalOpen"]
    }, {
      type: HostBinding,
      args: ["class.open"]
    }],
    _openChanged: [{
      type: Output,
      args: ["clrModalOpenChange"]
    }],
    closable: [{
      type: Input,
      args: ["clrModalClosable"]
    }],
    closeButtonAriaLabel: [{
      type: Input,
      args: ["clrModalCloseButtonAriaLabel"]
    }],
    size: [{
      type: Input,
      args: ["clrModalSize"]
    }],
    staticBackdrop: [{
      type: Input,
      args: ["clrModalStaticBackdrop"]
    }],
    skipAnimation: [{
      type: Input,
      args: ["clrModalSkipAnimation"]
    }],
    stopClose: [{
      type: Input,
      args: ["clrModalPreventClose"]
    }],
    altClose: [{
      type: Output,
      args: ["clrModalAlternateClose"]
    }],
    labelledBy: [{
      type: Input,
      args: ["clrModalLabelledById"]
    }],
    bypassScrollService: [{
      type: Input,
      args: ["clrModalOverrideScrollService"]
    }]
  });
})();
var ClrModalBody = class {
  constructor(renderer, host, ngZone) {
    this.renderer = renderer;
    this.host = host;
    this.tabindex = "0";
    this.unlisteners = [];
    ngZone.runOutsideAngular(() => {
      this.observer = new ResizeObserver(() => this.addOrRemoveTabIndex());
      this.observer.observe(this.host.nativeElement);
      this.unlisteners.push(this.renderer.listen(this.host.nativeElement, "mouseup", () => {
        this.addOrRemoveTabIndex();
      }), this.renderer.listen(this.host.nativeElement, "mousedown", () => {
        this.removeTabIndex();
      }));
    });
  }
  ngOnDestroy() {
    while (this.unlisteners.length) {
      this.unlisteners.pop()();
    }
    this.observer.disconnect();
    this.observer = null;
  }
  addTabIndex() {
    this.renderer.setAttribute(this.host.nativeElement, "tabindex", this.tabindex);
  }
  removeTabIndex() {
    this.renderer.removeAttribute(this.host.nativeElement, "tabindex");
  }
  addOrRemoveTabIndex() {
    const modalBody = this.host.nativeElement.parentElement;
    if (modalBody && modalBody.clientHeight < modalBody.scrollHeight) {
      this.addTabIndex();
    } else {
      this.removeTabIndex();
    }
  }
};
ClrModalBody.ɵfac = function ClrModalBody_Factory(t3) {
  return new (t3 || ClrModalBody)(ɵɵdirectiveInject(Renderer2), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone));
};
ClrModalBody.ɵdir = ɵɵdefineDirective({
  type: ClrModalBody,
  selectors: [["", 8, "modal-body"]]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrModalBody, [{
    type: Directive,
    args: [{
      selector: ".modal-body"
    }]
  }], function() {
    return [{
      type: Renderer2
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }];
  }, null);
})();
var CLR_MODAL_DIRECTIVES = [ClrModal, ClrModalBody];
var ClrModalModule = class {
  constructor() {
    r.addIcons(n3);
  }
};
ClrModalModule.ɵfac = function ClrModalModule_Factory(t3) {
  return new (t3 || ClrModalModule)();
};
ClrModalModule.ɵmod = ɵɵdefineNgModule({
  type: ClrModalModule,
  declarations: [ClrModal, ClrModalBody],
  imports: [CommonModule, CdkTrapFocusModule, ClrIconModule],
  exports: [ClrModal, ClrModalBody, ClrIconModule]
});
ClrModalModule.ɵinj = ɵɵdefineInjector({
  providers: [ClrModalConfigurationService],
  imports: [CommonModule, CdkTrapFocusModule, ClrIconModule, ClrIconModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrModalModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, CdkTrapFocusModule, ClrIconModule],
      declarations: [CLR_MODAL_DIRECTIVES],
      exports: [CLR_MODAL_DIRECTIVES, ClrIconModule],
      providers: [ClrModalConfigurationService]
    }]
  }], function() {
    return [];
  }, null);
})();
var ClrSidePanel = class {
  constructor(element, configuration) {
    this.element = element;
    this.configuration = configuration;
    this._open = false;
    this.openChange = new EventEmitter(false);
    this.skipAnimation = "false";
    this.staticBackdrop = false;
    this.preventClose = false;
    this.altClose = new EventEmitter(false);
  }
  get clrSidePanelBackdrop() {
    return this.configuration.backdrop;
  }
  set clrSidePanelBackdrop(backdrop) {
    if (backdrop !== void 0) {
      this.configuration.backdrop = backdrop;
    }
  }
  ngOnInit() {
    this.configuration.fadeMove = "fadeLeft";
  }
  open() {
    this.modal.open();
  }
  close() {
    this.modal.close();
  }
  documentClick(event) {
    if (!this.element.nativeElement.contains(event.target) && this.modal._open && !this.configuration.backdrop) {
      this.modal.close();
    }
  }
};
ClrSidePanel.ɵfac = function ClrSidePanel_Factory(t3) {
  return new (t3 || ClrSidePanel)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ClrModalConfigurationService));
};
ClrSidePanel.ɵcmp = ɵɵdefineComponent({
  type: ClrSidePanel,
  selectors: [["clr-side-panel"]],
  viewQuery: function ClrSidePanel_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(ClrModal, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.modal = _t.first);
    }
  },
  hostVars: 2,
  hostBindings: function ClrSidePanel_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("pointerup", function ClrSidePanel_pointerup_HostBindingHandler($event) {
        return ctx.documentClick($event);
      }, false, ɵɵresolveDocument);
    }
    if (rf & 2) {
      ɵɵclassProp("side-panel", true);
    }
  },
  inputs: {
    _open: [InputFlags.None, "clrSidePanelOpen", "_open"],
    closeButtonAriaLabel: [InputFlags.None, "clrSidePanelCloseButtonAriaLabel", "closeButtonAriaLabel"],
    size: [InputFlags.None, "clrSidePanelSize", "size"],
    skipAnimation: [InputFlags.None, "clrSidePanelSkipAnimation", "skipAnimation"],
    labelledById: [InputFlags.None, "clrSidePanelLabelledById", "labelledById"],
    staticBackdrop: [InputFlags.None, "clrSidePanelStaticBackdrop", "staticBackdrop"],
    preventClose: [InputFlags.None, "clrSidePanelPreventClose", "preventClose"],
    clrSidePanelBackdrop: "clrSidePanelBackdrop"
  },
  outputs: {
    openChange: "clrSidePanelOpenChange",
    altClose: "clrSidePanelAlternateClose"
  },
  ngContentSelectors: _c100,
  decls: 7,
  vars: 7,
  consts: [[3, "clrModalOpenChange", "clrModalAlternateClose", "clrModalOpen", "clrModalCloseButtonAriaLabel", "clrModalSize", "clrModalSkipAnimation", "clrModalStaticBackdrop", "clrModalLabelledById", "clrModalPreventClose"], [1, "modal-title"], [1, "modal-body"], [1, "modal-footer"]],
  template: function ClrSidePanel_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c99);
      ɵɵelementStart(0, "clr-modal", 0);
      ɵɵlistener("clrModalOpenChange", function ClrSidePanel_Template_clr_modal_clrModalOpenChange_0_listener($event) {
        return ctx.openChange.emit($event);
      })("clrModalAlternateClose", function ClrSidePanel_Template_clr_modal_clrModalAlternateClose_0_listener($event) {
        return ctx.altClose.emit($event);
      });
      ɵɵelementStart(1, "div", 1);
      ɵɵprojection(2);
      ɵɵelementEnd();
      ɵɵelementStart(3, "div", 2);
      ɵɵprojection(4, 1);
      ɵɵelementEnd();
      ɵɵelementStart(5, "div", 3);
      ɵɵprojection(6, 2);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵproperty("clrModalOpen", ctx._open)("clrModalCloseButtonAriaLabel", ctx.closeButtonAriaLabel)("clrModalSize", ctx.size)("clrModalSkipAnimation", ctx.skipAnimation)("clrModalStaticBackdrop", ctx.staticBackdrop)("clrModalLabelledById", ctx.labelledById)("clrModalPreventClose", ctx.preventClose);
    }
  },
  dependencies: [ClrModal, ClrModalBody],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrSidePanel, [{
    type: Component,
    args: [{
      selector: "clr-side-panel",
      host: {
        "[class.side-panel]": "true"
      },
      template: '<clr-modal\n  [clrModalOpen]="_open"\n  (clrModalOpenChange)="openChange.emit($event)"\n  [clrModalCloseButtonAriaLabel]="closeButtonAriaLabel"\n  [clrModalSize]="size"\n  [clrModalSkipAnimation]="skipAnimation"\n  [clrModalStaticBackdrop]="staticBackdrop"\n  [clrModalLabelledById]="labelledById"\n  [clrModalPreventClose]="preventClose"\n  (clrModalAlternateClose)="altClose.emit($event)"\n>\n  <div class="modal-title"><ng-content select=".side-panel-title"></ng-content></div>\n  <div class="modal-body"><ng-content select=".side-panel-body"></ng-content></div>\n  <div class="modal-footer"><ng-content select=".side-panel-footer"></ng-content></div>\n</clr-modal>\n'
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: ClrModalConfigurationService
    }];
  }, {
    _open: [{
      type: Input,
      args: ["clrSidePanelOpen"]
    }],
    openChange: [{
      type: Output,
      args: ["clrSidePanelOpenChange"]
    }],
    closeButtonAriaLabel: [{
      type: Input,
      args: ["clrSidePanelCloseButtonAriaLabel"]
    }],
    size: [{
      type: Input,
      args: ["clrSidePanelSize"]
    }],
    skipAnimation: [{
      type: Input,
      args: ["clrSidePanelSkipAnimation"]
    }],
    labelledById: [{
      type: Input,
      args: ["clrSidePanelLabelledById"]
    }],
    staticBackdrop: [{
      type: Input,
      args: ["clrSidePanelStaticBackdrop"]
    }],
    preventClose: [{
      type: Input,
      args: ["clrSidePanelPreventClose"]
    }],
    altClose: [{
      type: Output,
      args: ["clrSidePanelAlternateClose"]
    }],
    modal: [{
      type: ViewChild,
      args: [ClrModal]
    }],
    clrSidePanelBackdrop: [{
      type: Input
    }],
    documentClick: [{
      type: HostListener,
      args: ["document:pointerup", ["$event"]]
    }]
  });
})();
var CLR_SIDEPANEL_DIRECTIVES = [ClrSidePanel];
var ClrSidePanelModule = class {
};
ClrSidePanelModule.ɵfac = function ClrSidePanelModule_Factory(t3) {
  return new (t3 || ClrSidePanelModule)();
};
ClrSidePanelModule.ɵmod = ɵɵdefineNgModule({
  type: ClrSidePanelModule,
  declarations: [ClrSidePanel],
  imports: [CommonModule, CdkTrapFocusModule, ClrIconModule, ClrModalModule],
  exports: [ClrSidePanel, ClrIconModule]
});
ClrSidePanelModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, CdkTrapFocusModule, ClrIconModule, ClrModalModule, ClrIconModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrSidePanelModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, CdkTrapFocusModule, ClrIconModule, ClrModalModule],
      declarations: [CLR_SIDEPANEL_DIRECTIVES],
      exports: [CLR_SIDEPANEL_DIRECTIVES, ClrIconModule]
    }]
  }], null, null);
})();
var SIGNPOST_POSITIONS = {
  "top-left": {
    anchorPoint: Point.TOP_CENTER,
    popoverPoint: Point.BOTTOM_RIGHT,
    offsetY: -16,
    offsetX: 0
  },
  "top-middle": {
    anchorPoint: Point.TOP_CENTER,
    popoverPoint: Point.BOTTOM_CENTER,
    offsetY: -16,
    offsetX: 0
  },
  "top-right": {
    anchorPoint: Point.TOP_CENTER,
    popoverPoint: Point.BOTTOM_LEFT,
    offsetY: -16,
    offsetX: 0
  },
  "right-top": {
    anchorPoint: Point.RIGHT_CENTER,
    popoverPoint: Point.LEFT_BOTTOM,
    offsetY: 0,
    offsetX: 16
  },
  "right-middle": {
    anchorPoint: Point.RIGHT_CENTER,
    popoverPoint: Point.LEFT_CENTER,
    offsetY: 0,
    offsetX: 16
  },
  "right-bottom": {
    anchorPoint: Point.RIGHT_CENTER,
    popoverPoint: Point.LEFT_TOP,
    offsetY: 0,
    offsetX: 16
  },
  "bottom-right": {
    anchorPoint: Point.BOTTOM_CENTER,
    popoverPoint: Point.TOP_LEFT,
    offsetY: 16,
    offsetX: 0
  },
  "bottom-middle": {
    anchorPoint: Point.BOTTOM_CENTER,
    popoverPoint: Point.TOP_CENTER,
    offsetY: 16,
    offsetX: 0
  },
  "bottom-left": {
    anchorPoint: Point.BOTTOM_CENTER,
    popoverPoint: Point.TOP_RIGHT,
    offsetY: 16,
    offsetX: 0
  },
  "left-bottom": {
    anchorPoint: Point.LEFT_CENTER,
    popoverPoint: Point.RIGHT_TOP,
    offsetY: 0,
    offsetX: -16
  },
  "left-middle": {
    anchorPoint: Point.LEFT_CENTER,
    popoverPoint: Point.RIGHT_CENTER,
    offsetY: 0,
    offsetX: -16
  },
  "left-top": {
    anchorPoint: Point.LEFT_CENTER,
    popoverPoint: Point.RIGHT_BOTTOM,
    offsetY: 0,
    offsetX: -16
  },
  default: {
    anchorPoint: Point.RIGHT_CENTER,
    popoverPoint: Point.LEFT_CENTER,
    offsetY: 0,
    offsetX: 16
  }
};
var POSITIONS$1 = ["top-left", "top-middle", "top-right", "right-top", "right-middle", "right-bottom", "bottom-right", "bottom-middle", "bottom-left", "left-bottom", "left-middle", "left-top"];
var ClrSignpostContent = class extends AbstractPopover {
  constructor(injector, parentHost, commonStrings, signpostIdService, signpostFocusManager, platformId, document2) {
    super(injector, parentHost);
    this.commonStrings = commonStrings;
    this.signpostIdService = signpostIdService;
    this.signpostFocusManager = signpostFocusManager;
    this.platformId = platformId;
    this.signpostContentId = uniqueIdFactory();
    if (!parentHost) {
      throw new Error("clr-signpost-content should only be used inside of a clr-signpost");
    }
    this.position = "right-middle";
    this.closeOnOutsideClick = true;
    this.signpostIdService.setId(this.signpostContentId);
    this.document = document2;
  }
  /*********
   *
   * @description
   * A setter for the position of the ClrSignpostContent popover. This is a combination of the following:
   * - anchorPoint - where on the trigger to anchor the ClrSignpostContent
   * - popoverPoint - where on the ClrSignpostContent container to align with the anchorPoint
   * - offsetY - where on the Y axis to align the ClrSignpostContent so it meets specs
   * - offsetX - where on the X axis to align the ClrSignpostContent so it meets specs
   * There are 12 possible positions to place a ClrSignpostContent container:
   * - top-left
   * - top-middle
   * - top-right
   * - right-top
   * - right-middle
   * - right-bottom
   * - bottom-right
   * - bottom-middle
   * - bottom-left
   * - left-bottom
   * - left-middle
   * - left-top
   *
   * I think of it as follows for 'top-left' -> CONTAINER_SIDE-SIDE_POSITION. In this case CONTAINER_SIDE is 'top'
   * meaning the top of the trigger icon (above the icon that hides/shows) the ClrSignpostContent. And, SIDE_POSITION
   * is 'left' meaning two things: 1) the ClrSignpostContent container extends to the left and 2) the 'arrow/pointer'
   * linking the SingpostContent to the trigger points down at the horizontal center of the trigger icon.
   *
   * @param newPosition
   */
  get position() {
    return this._position;
  }
  set position(position) {
    this.renderer.removeClass(this.el.nativeElement, this.position);
    if (position && POSITIONS$1.indexOf(position) > -1) {
      this._position = position;
    } else {
      this._position = "right-middle";
    }
    this.renderer.addClass(this.el.nativeElement, this.position);
    const setPosition = SIGNPOST_POSITIONS[this.position];
    this.anchorPoint = setPosition.anchorPoint;
    this.popoverPoint = setPosition.popoverPoint;
    this.popoverOptions.offsetY = setPosition.offsetY;
    this.popoverOptions.offsetX = setPosition.offsetX;
  }
  /**********
   *
   * @description
   * Close function that uses the signpost instance to toggle the state of the content popover.
   *
   */
  close() {
    this.toggleService.open = false;
  }
  ngOnDestroy() {
    super.ngOnDestroy();
    if (isPlatformBrowser(this.platformId) && this.el.nativeElement.contains(this.document.activeElement)) {
      this.signpostFocusManager.focusTrigger();
    }
  }
};
ClrSignpostContent.ɵfac = function ClrSignpostContent_Factory(t3) {
  return new (t3 || ClrSignpostContent)(ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(POPOVER_HOST_ANCHOR, 8), ɵɵdirectiveInject(ClrCommonStringsService), ɵɵdirectiveInject(SignpostIdService), ɵɵdirectiveInject(SignpostFocusManager), ɵɵdirectiveInject(PLATFORM_ID), ɵɵdirectiveInject(DOCUMENT));
};
ClrSignpostContent.ɵcmp = ɵɵdefineComponent({
  type: ClrSignpostContent,
  selectors: [["clr-signpost-content"]],
  hostVars: 3,
  hostBindings: function ClrSignpostContent_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵhostProperty("id", ctx.signpostContentId);
      ɵɵclassProp("signpost-content", true);
    }
  },
  inputs: {
    position: [InputFlags.None, "clrPosition", "position"]
  },
  features: [ɵɵInheritDefinitionFeature],
  ngContentSelectors: _c02,
  decls: 7,
  vars: 3,
  consts: [[1, "signpost-wrap"], [1, "popover-pointer"], [1, "signpost-content-header"], ["type", "button", 1, "signpost-action", "close", 3, "click"], ["shape", "window-close"], ["tabindex", "0", 1, "signpost-content-body"]],
  template: function ClrSignpostContent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "div", 0);
      ɵɵelement(1, "div", 1);
      ɵɵelementStart(2, "div", 2)(3, "button", 3);
      ɵɵlistener("click", function ClrSignpostContent_Template_button_click_3_listener() {
        return ctx.close();
      });
      ɵɵelement(4, "cds-icon", 4);
      ɵɵelementEnd()();
      ɵɵelementStart(5, "div", 5);
      ɵɵprojection(6);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵadvance(3);
      ɵɵattribute("aria-label", ctx.commonStrings.keys.signpostClose)("aria-controls", ctx.signpostContentId);
      ɵɵadvance();
      ɵɵattribute("title", ctx.commonStrings.keys.close);
    }
  },
  dependencies: [CdsIconCustomTag],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrSignpostContent, [{
    type: Component,
    args: [{
      selector: "clr-signpost-content",
      template: `
    <div class="signpost-wrap">
      <div class="popover-pointer"></div>
      <div class="signpost-content-header">
        <button
          type="button"
          [attr.aria-label]="commonStrings.keys.signpostClose"
          class="signpost-action close"
          (click)="close()"
          [attr.aria-controls]="signpostContentId"
        >
          <cds-icon shape="window-close" [attr.title]="commonStrings.keys.close"></cds-icon>
        </button>
      </div>
      <div class="signpost-content-body" tabindex="0">
        <ng-content></ng-content>
      </div>
    </div>
  `,
      host: {
        "[class.signpost-content]": "true",
        "[id]": "signpostContentId"
      }
    }]
  }], function() {
    return [{
      type: Injector
    }, {
      type: ElementRef,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [POPOVER_HOST_ANCHOR]
      }]
    }, {
      type: ClrCommonStringsService
    }, {
      type: SignpostIdService
    }, {
      type: SignpostFocusManager
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [PLATFORM_ID]
      }]
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [DOCUMENT]
      }]
    }];
  }, {
    position: [{
      type: Input,
      args: ["clrPosition"]
    }]
  });
})();
var CLR_SIGNPOST_DIRECTIVES = [ClrSignpost, ClrSignpostContent, ClrSignpostTrigger];
var ClrSignpostModule = class {
  constructor() {
    r.addIcons(n3, r5);
  }
};
ClrSignpostModule.ɵfac = function ClrSignpostModule_Factory(t3) {
  return new (t3 || ClrSignpostModule)();
};
ClrSignpostModule.ɵmod = ɵɵdefineNgModule({
  type: ClrSignpostModule,
  declarations: [ClrSignpost, ClrSignpostContent, ClrSignpostTrigger],
  imports: [CommonModule, ClrIconModule, ClrFocusOnViewInitModule],
  exports: [ClrSignpost, ClrSignpostContent, ClrSignpostTrigger, ClrConditionalModule]
});
ClrSignpostModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, ClrIconModule, ClrFocusOnViewInitModule, ClrConditionalModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrSignpostModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, ClrIconModule, ClrFocusOnViewInitModule],
      declarations: [CLR_SIGNPOST_DIRECTIVES],
      exports: [CLR_SIGNPOST_DIRECTIVES, ClrConditionalModule]
    }]
  }], function() {
    return [];
  }, null);
})();
var TooltipIdService = class {
  constructor() {
    this._id = new Subject();
  }
  get id() {
    return this._id.asObservable();
  }
  updateId(id) {
    this._id.next(id);
  }
};
TooltipIdService.ɵfac = function TooltipIdService_Factory(t3) {
  return new (t3 || TooltipIdService)();
};
TooltipIdService.ɵprov = ɵɵdefineInjectable({
  token: TooltipIdService,
  factory: TooltipIdService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TooltipIdService, [{
    type: Injectable
  }], null, null);
})();
var TooltipMouseService = class {
  constructor(toggleService) {
    this.toggleService = toggleService;
  }
  onMouseEnterTrigger() {
    this.mouseOverTrigger = true;
    this.toggleService.open = true;
  }
  onMouseLeaveTrigger() {
    this.mouseOverTrigger = false;
    this.hideIfMouseOut();
  }
  onMouseEnterContent() {
    this.mouseOverContent = true;
  }
  onMouseLeaveContent() {
    this.mouseOverContent = false;
    this.hideIfMouseOut();
  }
  hideIfMouseOut() {
    setTimeout(() => {
      if (!this.mouseOverTrigger && !this.mouseOverContent) {
        this.toggleService.open = false;
      }
    }, 0);
  }
};
TooltipMouseService.ɵfac = function TooltipMouseService_Factory(t3) {
  return new (t3 || TooltipMouseService)(ɵɵinject(ClrPopoverToggleService));
};
TooltipMouseService.ɵprov = ɵɵdefineInjectable({
  token: TooltipMouseService,
  factory: TooltipMouseService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TooltipMouseService, [{
    type: Injectable
  }], function() {
    return [{
      type: ClrPopoverToggleService
    }];
  }, null);
})();
var ClrTooltip = class {
};
ClrTooltip.ɵfac = function ClrTooltip_Factory(t3) {
  return new (t3 || ClrTooltip)();
};
ClrTooltip.ɵcmp = ɵɵdefineComponent({
  type: ClrTooltip,
  selectors: [["clr-tooltip"]],
  hostVars: 2,
  hostBindings: function ClrTooltip_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("tooltip", true);
    }
  },
  features: [ɵɵProvidersFeature([TooltipIdService, TooltipMouseService]), ɵɵHostDirectivesFeature([ClrPopoverHostDirective])],
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function ClrTooltip_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrTooltip, [{
    type: Component,
    args: [{
      selector: "clr-tooltip",
      template: `<ng-content></ng-content>`,
      host: {
        "[class.tooltip]": "true"
      },
      providers: [TooltipIdService, TooltipMouseService],
      hostDirectives: [ClrPopoverHostDirective]
    }]
  }], null, null);
})();
function assertNever(value) {
  throw new Error(`Unhandled value: ${value}`);
}
var POSITIONS = ["bottom-left", "bottom-right", "top-left", "top-right", "right", "left"];
var SIZES = ["xs", "sm", "md", "lg"];
var defaultPosition = "right";
var defaultSize = "sm";
var ClrTooltipContent = class extends AbstractPopover {
  constructor(injector, parentHost, tooltipIdService, tooltipMouseService) {
    super(injector, parentHost);
    this.tooltipIdService = tooltipIdService;
    this.tooltipMouseService = tooltipMouseService;
    if (!parentHost) {
      throw new Error("clr-tooltip-content should only be used inside of a clr-tooltip");
    }
    this.id = uniqueIdFactory();
  }
  get id() {
    return this._id;
  }
  set id(value) {
    const id = value || "";
    this._id = id;
    this.tooltipIdService.updateId(id);
  }
  get position() {
    return this._position;
  }
  set position(value) {
    const oldPosition = this._position;
    const newPosition = POSITIONS.includes(value) ? value : defaultPosition;
    this._position = newPosition;
    this.updateCssClass({
      oldClass: `tooltip-${oldPosition}`,
      newClass: `tooltip-${newPosition}`
    });
    switch (newPosition) {
      case "top-right":
        this.anchorPoint = Point.TOP_CENTER;
        this.popoverPoint = Point.LEFT_BOTTOM;
        break;
      case "top-left":
        this.anchorPoint = Point.TOP_CENTER;
        this.popoverPoint = Point.RIGHT_BOTTOM;
        break;
      case "bottom-right":
        this.anchorPoint = Point.BOTTOM_CENTER;
        this.popoverPoint = Point.LEFT_TOP;
        break;
      case "bottom-left":
        this.anchorPoint = Point.BOTTOM_CENTER;
        this.popoverPoint = Point.RIGHT_TOP;
        break;
      case "right":
        this.anchorPoint = Point.RIGHT_CENTER;
        this.popoverPoint = Point.LEFT_TOP;
        break;
      case "left":
        this.anchorPoint = Point.LEFT_CENTER;
        this.popoverPoint = Point.RIGHT_TOP;
        break;
      default:
        assertNever(newPosition);
    }
  }
  get size() {
    return this._size;
  }
  set size(value) {
    const oldSize = this._size;
    const newSize = SIZES.includes(value) ? value : defaultSize;
    this._size = newSize;
    this.updateCssClass({
      oldClass: `tooltip-${oldSize}`,
      newClass: `tooltip-${newSize}`
    });
  }
  ngOnInit() {
    this.size = this.size || defaultSize;
    this.position = this.position || defaultPosition;
  }
  onMouseEnter() {
    this.tooltipMouseService.onMouseEnterContent();
  }
  onMouseLeave() {
    this.tooltipMouseService.onMouseLeaveContent();
  }
  updateCssClass({
    oldClass,
    newClass
  }) {
    this.renderer.removeClass(this.el.nativeElement, oldClass);
    this.renderer.addClass(this.el.nativeElement, newClass);
  }
};
ClrTooltipContent.ɵfac = function ClrTooltipContent_Factory(t3) {
  return new (t3 || ClrTooltipContent)(ɵɵdirectiveInject(Injector), ɵɵdirectiveInject(POPOVER_HOST_ANCHOR, 8), ɵɵdirectiveInject(TooltipIdService), ɵɵdirectiveInject(TooltipMouseService));
};
ClrTooltipContent.ɵcmp = ɵɵdefineComponent({
  type: ClrTooltipContent,
  selectors: [["clr-tooltip-content"]],
  hostVars: 6,
  hostBindings: function ClrTooltipContent_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("mouseenter", function ClrTooltipContent_mouseenter_HostBindingHandler() {
        return ctx.onMouseEnter();
      })("mouseleave", function ClrTooltipContent_mouseleave_HostBindingHandler() {
        return ctx.onMouseLeave();
      });
    }
    if (rf & 2) {
      ɵɵhostProperty("id", ctx.id);
      ɵɵattribute("role", "tooltip");
      ɵɵstyleProp("opacity", 1);
      ɵɵclassProp("tooltip-content", true);
    }
  },
  inputs: {
    id: "id",
    position: [InputFlags.None, "clrPosition", "position"],
    size: [InputFlags.None, "clrSize", "size"]
  },
  features: [ɵɵInheritDefinitionFeature],
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function ClrTooltipContent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrTooltipContent, [{
    type: Component,
    args: [{
      selector: "clr-tooltip-content",
      template: `<ng-content></ng-content>`,
      host: {
        "[class.tooltip-content]": "true",
        "[style.opacity]": "1",
        "[attr.role]": '"tooltip"',
        "[id]": "id"
      }
    }]
  }], function() {
    return [{
      type: Injector
    }, {
      type: ElementRef,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [POPOVER_HOST_ANCHOR]
      }]
    }, {
      type: TooltipIdService
    }, {
      type: TooltipMouseService
    }];
  }, {
    id: [{
      type: Input
    }],
    position: [{
      type: Input,
      args: ["clrPosition"]
    }],
    size: [{
      type: Input,
      args: ["clrSize"]
    }],
    onMouseEnter: [{
      type: HostListener,
      args: ["mouseenter"]
    }],
    onMouseLeave: [{
      type: HostListener,
      args: ["mouseleave"]
    }]
  });
})();
var ClrTooltipTrigger = class {
  constructor(toggleService, tooltipIdService, tooltipMouseService) {
    this.toggleService = toggleService;
    this.tooltipIdService = tooltipIdService;
    this.tooltipMouseService = tooltipMouseService;
    this.subs = [];
    this.subs.push(this.tooltipIdService.id.subscribe((tooltipId) => this.ariaDescribedBy = tooltipId));
  }
  ngOnDestroy() {
    this.subs.forEach((sub) => sub.unsubscribe());
  }
  showTooltip() {
    this.toggleService.open = true;
  }
  hideTooltip() {
    this.toggleService.open = false;
  }
  onMouseEnter() {
    this.tooltipMouseService.onMouseEnterTrigger();
  }
  onMouseLeave() {
    this.tooltipMouseService.onMouseLeaveTrigger();
  }
};
ClrTooltipTrigger.ɵfac = function ClrTooltipTrigger_Factory(t3) {
  return new (t3 || ClrTooltipTrigger)(ɵɵdirectiveInject(ClrPopoverToggleService), ɵɵdirectiveInject(TooltipIdService), ɵɵdirectiveInject(TooltipMouseService));
};
ClrTooltipTrigger.ɵdir = ɵɵdefineDirective({
  type: ClrTooltipTrigger,
  selectors: [["", "clrTooltipTrigger", ""]],
  hostAttrs: ["tabindex", "0"],
  hostVars: 4,
  hostBindings: function ClrTooltipTrigger_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("focus", function ClrTooltipTrigger_focus_HostBindingHandler() {
        return ctx.showTooltip();
      })("blur", function ClrTooltipTrigger_blur_HostBindingHandler() {
        return ctx.hideTooltip();
      })("mouseenter", function ClrTooltipTrigger_mouseenter_HostBindingHandler() {
        return ctx.onMouseEnter();
      })("mouseleave", function ClrTooltipTrigger_mouseleave_HostBindingHandler() {
        return ctx.onMouseLeave();
      });
    }
    if (rf & 2) {
      ɵɵattribute("aria-describedby", ctx.ariaDescribedBy)("role", "button");
      ɵɵclassProp("tooltip-trigger", true);
    }
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrTooltipTrigger, [{
    type: Directive,
    args: [{
      selector: "[clrTooltipTrigger]",
      host: {
        tabindex: "0",
        "[class.tooltip-trigger]": "true",
        "[attr.aria-describedby]": "ariaDescribedBy",
        "[attr.role]": '"button"'
      }
    }]
  }], function() {
    return [{
      type: ClrPopoverToggleService
    }, {
      type: TooltipIdService
    }, {
      type: TooltipMouseService
    }];
  }, {
    showTooltip: [{
      type: HostListener,
      args: ["focus"]
    }],
    hideTooltip: [{
      type: HostListener,
      args: ["blur"]
    }],
    onMouseEnter: [{
      type: HostListener,
      args: ["mouseenter"]
    }],
    onMouseLeave: [{
      type: HostListener,
      args: ["mouseleave"]
    }]
  });
})();
var CLR_TOOLTIP_DIRECTIVES = [ClrTooltip, ClrTooltipTrigger, ClrTooltipContent];
var ClrTooltipModule = class {
};
ClrTooltipModule.ɵfac = function ClrTooltipModule_Factory(t3) {
  return new (t3 || ClrTooltipModule)();
};
ClrTooltipModule.ɵmod = ɵɵdefineNgModule({
  type: ClrTooltipModule,
  declarations: [ClrTooltip, ClrTooltipTrigger, ClrTooltipContent],
  imports: [CommonModule],
  exports: [ClrTooltip, ClrTooltipTrigger, ClrTooltipContent, ClrConditionalModule, ClrIconModule]
});
ClrTooltipModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, ClrConditionalModule, ClrIconModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrTooltipModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      declarations: [CLR_TOOLTIP_DIRECTIVES],
      exports: [CLR_TOOLTIP_DIRECTIVES, ClrConditionalModule, ClrIconModule]
    }]
  }], null, null);
})();
var ClrPopoverModule = class {
};
ClrPopoverModule.ɵfac = function ClrPopoverModule_Factory(t3) {
  return new (t3 || ClrPopoverModule)();
};
ClrPopoverModule.ɵmod = ɵɵdefineNgModule({
  type: ClrPopoverModule,
  exports: [ClrDropdownModule, ClrSignpostModule, ClrTooltipModule]
});
ClrPopoverModule.ɵinj = ɵɵdefineInjector({
  imports: [ClrDropdownModule, ClrSignpostModule, ClrTooltipModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrPopoverModule, [{
    type: NgModule,
    args: [{
      exports: [ClrDropdownModule, ClrSignpostModule, ClrTooltipModule]
    }]
  }], null, null);
})();
var ClrProgressBar = class {
  constructor() {
    this.max = 100;
    this.value = 0;
    this.externalId = "";
  }
  get id() {
    return this._ID;
  }
  set id(value) {
    this._ID = value;
    this.externalId = null;
  }
  get progressClass() {
    return true;
  }
  set clrCompact(value) {
    this._compact = isBooleanAttributeSet(value);
  }
  get compactClass() {
    return this._compact;
  }
  set clrLabeled(value) {
    this._labeled = isBooleanAttributeSet(value);
  }
  get labeledClass() {
    return this._labeled;
  }
  set clrFade(value) {
    this._fade = isBooleanAttributeSet(value);
  }
  get fadeClass() {
    return this._fade;
  }
  set clrLoop(value) {
    this._loop = isBooleanAttributeSet(value);
  }
  get loopClass() {
    return this._loop;
  }
  get warningClass() {
    return this.color === "warning";
  }
  get successClass() {
    return this.color === "success";
  }
  get dangerClass() {
    return this.color === "danger";
  }
  set clrFlash(value) {
    this._flash = isBooleanAttributeSet(value);
  }
  get flashClass() {
    return this._flash;
  }
  /** @deprecated since 2.0, remove in 4.0 */
  set clrFlashDanger(value) {
    this._flashDanger = isBooleanAttributeSet(value);
  }
  get flashDangerClass() {
    return this._flashDanger;
  }
  /**
   * Make sure that we always will have something that is readable
   * for the screen reader
   */
  get displayValue() {
    if (this.displayval) {
      return this.displayval;
    }
    return `${this.value || 0}%`;
  }
  /**
   * Display optional text only when labeled is eneabled
   */
  displayStringValue() {
    return this._labeled;
  }
};
ClrProgressBar.ɵfac = function ClrProgressBar_Factory(t3) {
  return new (t3 || ClrProgressBar)();
};
ClrProgressBar.ɵcmp = ɵɵdefineComponent({
  type: ClrProgressBar,
  selectors: [["clr-progress-bar"]],
  hostVars: 21,
  hostBindings: function ClrProgressBar_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("id", ctx.externalId);
      ɵɵclassProp("progress", ctx.progressClass)("compact", ctx.compactClass)("labeled", ctx.labeledClass)("progress-fade", ctx.fadeClass)("loop", ctx.loopClass)("warning", ctx.warningClass)("success", ctx.successClass)("danger", ctx.dangerClass)("flash", ctx.flashClass)("flash-danger", ctx.flashDangerClass);
    }
  },
  inputs: {
    max: [InputFlags.None, "clrMax", "max"],
    displayval: [InputFlags.None, "clrDisplayval", "displayval"],
    color: [InputFlags.None, "clrColor", "color"],
    value: [InputFlags.None, "clrValue", "value"],
    id: "id",
    clrCompact: "clrCompact",
    clrLabeled: "clrLabeled",
    clrFade: "clrFade",
    clrLoop: "clrLoop",
    clrFlash: "clrFlash",
    clrFlashDanger: "clrFlashDanger"
  },
  decls: 2,
  vars: 5,
  consts: [[3, "id"], [4, "ngIf"]],
  template: function ClrProgressBar_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelement(0, "progress", 0);
      ɵɵtemplate(1, ClrProgressBar_span_1_Template, 2, 1, "span", 1);
    }
    if (rf & 2) {
      ɵɵproperty("id", ctx.id);
      ɵɵattribute("max", ctx.max)("value", ctx.value)("data-displayval", ctx.displayValue);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.displayStringValue());
    }
  },
  dependencies: [NgIf],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrProgressBar, [{
    type: Component,
    args: [{
      selector: "clr-progress-bar",
      template: `
    <progress [id]="id" [attr.max]="max" [attr.value]="value" [attr.data-displayval]="displayValue"></progress>
    <span *ngIf="displayStringValue()">{{ displayValue }}</span>
  `
    }]
  }], null, {
    max: [{
      type: Input,
      args: ["clrMax"]
    }],
    displayval: [{
      type: Input,
      args: ["clrDisplayval"]
    }],
    color: [{
      type: Input,
      args: ["clrColor"]
    }],
    value: [{
      type: Input,
      args: ["clrValue"]
    }],
    externalId: [{
      type: HostBinding,
      args: ["attr.id"]
    }],
    id: [{
      type: Input
    }],
    progressClass: [{
      type: HostBinding,
      args: ["class.progress"]
    }],
    clrCompact: [{
      type: Input,
      args: ["clrCompact"]
    }],
    compactClass: [{
      type: HostBinding,
      args: ["class.compact"]
    }],
    clrLabeled: [{
      type: Input,
      args: ["clrLabeled"]
    }],
    labeledClass: [{
      type: HostBinding,
      args: ["class.labeled"]
    }],
    clrFade: [{
      type: Input,
      args: ["clrFade"]
    }],
    fadeClass: [{
      type: HostBinding,
      args: ["class.progress-fade"]
    }],
    clrLoop: [{
      type: Input,
      args: ["clrLoop"]
    }],
    loopClass: [{
      type: HostBinding,
      args: ["class.loop"]
    }],
    warningClass: [{
      type: HostBinding,
      args: ["class.warning"]
    }],
    successClass: [{
      type: HostBinding,
      args: ["class.success"]
    }],
    dangerClass: [{
      type: HostBinding,
      args: ["class.danger"]
    }],
    clrFlash: [{
      type: Input,
      args: ["clrFlash"]
    }],
    flashClass: [{
      type: HostBinding,
      args: ["class.flash"]
    }],
    clrFlashDanger: [{
      type: Input,
      args: ["clrFlashDanger"]
    }],
    flashDangerClass: [{
      type: HostBinding,
      args: ["class.flash-danger"]
    }]
  });
})();
var CLR_PROGRESS_BAR_DIRECTIVES = [ClrProgressBar];
var ClrProgressBarModule = class {
};
ClrProgressBarModule.ɵfac = function ClrProgressBarModule_Factory(t3) {
  return new (t3 || ClrProgressBarModule)();
};
ClrProgressBarModule.ɵmod = ɵɵdefineNgModule({
  type: ClrProgressBarModule,
  declarations: [ClrProgressBar],
  imports: [CommonModule],
  exports: [ClrProgressBar]
});
ClrProgressBarModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrProgressBarModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule],
      declarations: [CLR_PROGRESS_BAR_DIRECTIVES],
      exports: [CLR_PROGRESS_BAR_DIRECTIVES]
    }]
  }], null, null);
})();
var ClrTimelineLayout;
(function(ClrTimelineLayout2) {
  ClrTimelineLayout2["HORIZONTAL"] = "horizontal";
  ClrTimelineLayout2["VERTICAL"] = "vertical";
})(ClrTimelineLayout || (ClrTimelineLayout = {}));
var ClrTimelineStepState;
(function(ClrTimelineStepState2) {
  ClrTimelineStepState2["NOT_STARTED"] = "not-started";
  ClrTimelineStepState2["CURRENT"] = "current";
  ClrTimelineStepState2["PROCESSING"] = "processing";
  ClrTimelineStepState2["SUCCESS"] = "success";
  ClrTimelineStepState2["ERROR"] = "error";
})(ClrTimelineStepState || (ClrTimelineStepState = {}));
var TimelineIconAttributeService = class {
  constructor(commonStrings) {
    this.attributeMap = /* @__PURE__ */ new Map();
    this.attributeMap.set(ClrTimelineStepState.NOT_STARTED, {
      iconShape: "circle",
      iconStatus: null,
      ariaLabel: commonStrings.keys.timelineStepNotStarted
    });
    this.attributeMap.set(ClrTimelineStepState.CURRENT, {
      iconShape: "dot-circle",
      iconStatus: "info",
      ariaLabel: commonStrings.keys.timelineStepCurrent
    });
    this.attributeMap.set(ClrTimelineStepState.PROCESSING, {
      iconShape: void 0,
      iconStatus: null,
      ariaLabel: commonStrings.keys.timelineStepProcessing
    });
    this.attributeMap.set(ClrTimelineStepState.SUCCESS, {
      iconShape: "success-standard",
      iconStatus: "success",
      ariaLabel: commonStrings.keys.timelineStepSuccess
    });
    this.attributeMap.set(ClrTimelineStepState.ERROR, {
      iconShape: "error-standard",
      iconStatus: "danger",
      ariaLabel: commonStrings.keys.timelineStepError
    });
  }
  getAriaLabel(step) {
    return this.attributeMap.get(step).ariaLabel;
  }
  getIconShape(step) {
    return this.attributeMap.get(step).iconShape;
  }
  getIconStatus(step) {
    return this.attributeMap.get(step).iconStatus;
  }
};
TimelineIconAttributeService.ɵfac = function TimelineIconAttributeService_Factory(t3) {
  return new (t3 || TimelineIconAttributeService)(ɵɵinject(ClrCommonStringsService));
};
TimelineIconAttributeService.ɵprov = ɵɵdefineInjectable({
  token: TimelineIconAttributeService,
  factory: TimelineIconAttributeService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TimelineIconAttributeService, [{
    type: Injectable
  }], function() {
    return [{
      type: ClrCommonStringsService
    }];
  }, null);
})();
var ClrTimeline = class {
  constructor() {
    this.layout = ClrTimelineLayout.HORIZONTAL;
  }
  get isVertical() {
    return this.layout === ClrTimelineLayout.VERTICAL;
  }
};
ClrTimeline.ɵfac = function ClrTimeline_Factory(t3) {
  return new (t3 || ClrTimeline)();
};
ClrTimeline.ɵcmp = ɵɵdefineComponent({
  type: ClrTimeline,
  selectors: [["clr-timeline"]],
  hostVars: 5,
  hostBindings: function ClrTimeline_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("role", "list");
      ɵɵclassProp("clr-timeline", true)("clr-timeline-vertical", ctx.isVertical);
    }
  },
  inputs: {
    layout: [InputFlags.None, "clrLayout", "layout"]
  },
  features: [ɵɵProvidersFeature([TimelineIconAttributeService])],
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function ClrTimeline_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrTimeline, [{
    type: Component,
    args: [{
      selector: "clr-timeline",
      template: `<ng-content></ng-content>`,
      host: {
        "[class.clr-timeline]": "true",
        "[attr.role]": '"list"'
      },
      providers: [TimelineIconAttributeService]
    }]
  }], null, {
    layout: [{
      type: Input,
      args: ["clrLayout"]
    }],
    isVertical: [{
      type: HostBinding,
      args: ["class.clr-timeline-vertical"]
    }]
  });
})();
var ClrTimelineStepTitle = class {
};
ClrTimelineStepTitle.ɵfac = function ClrTimelineStepTitle_Factory(t3) {
  return new (t3 || ClrTimelineStepTitle)();
};
ClrTimelineStepTitle.ɵcmp = ɵɵdefineComponent({
  type: ClrTimelineStepTitle,
  selectors: [["clr-timeline-step-title"]],
  hostVars: 3,
  hostBindings: function ClrTimelineStepTitle_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("aria-hidden", true);
      ɵɵclassProp("clr-timeline-step-title", true);
    }
  },
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function ClrTimelineStepTitle_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrTimelineStepTitle, [{
    type: Component,
    args: [{
      selector: "clr-timeline-step-title",
      template: `<ng-content></ng-content>`,
      host: {
        "[class.clr-timeline-step-title]": "true",
        "[attr.aria-hidden]": "true"
      }
    }]
  }], null, null);
})();
var ClrTimelineStep = class {
  constructor(iconAttributeService, platformId) {
    this.iconAttributeService = iconAttributeService;
    this.platformId = platformId;
    this.state = ClrTimelineStepState.NOT_STARTED;
  }
  get iconAriaLabel() {
    return this.iconAttributeService.getAriaLabel(this.state);
  }
  get iconShape() {
    return this.iconAttributeService.getIconShape(this.state);
  }
  get iconStatus() {
    return this.iconAttributeService.getIconStatus(this.state);
  }
  get isProcessing() {
    return this.state === ClrTimelineStepState.PROCESSING;
  }
  ngAfterContentInit() {
    if (this.stepTitle && isPlatformBrowser(this.platformId)) {
      this.stepTitleText = this.stepTitle.nativeElement.innerText;
    }
  }
};
ClrTimelineStep.ɵfac = function ClrTimelineStep_Factory(t3) {
  return new (t3 || ClrTimelineStep)(ɵɵdirectiveInject(TimelineIconAttributeService), ɵɵdirectiveInject(PLATFORM_ID));
};
ClrTimelineStep.ɵcmp = ɵɵdefineComponent({
  type: ClrTimelineStep,
  selectors: [["clr-timeline-step"]],
  contentQueries: function ClrTimelineStep_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ClrTimelineStepTitle, 5, ElementRef);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.stepTitle = _t.first);
    }
  },
  hostVars: 3,
  hostBindings: function ClrTimelineStep_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("role", "listitem");
      ɵɵclassProp("clr-timeline-step", true);
    }
  },
  inputs: {
    state: [InputFlags.None, "clrState", "state"]
  },
  ngContentSelectors: _c102,
  decls: 9,
  vars: 3,
  consts: [["processing", ""], [1, "clr-sr-only"], [4, "ngIf", "ngIfElse"], [1, "clr-timeline-step-body"], ["role", "img"], ["clrMedium", ""]],
  template: function ClrTimelineStep_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c101);
      ɵɵprojection(0);
      ɵɵelementStart(1, "span", 1);
      ɵɵtext(2);
      ɵɵelementEnd();
      ɵɵtemplate(3, ClrTimelineStep_ng_container_3_Template, 2, 3, "ng-container", 2);
      ɵɵelementStart(4, "div", 3);
      ɵɵprojection(5, 1);
      ɵɵprojection(6, 2);
      ɵɵelementEnd();
      ɵɵtemplate(7, ClrTimelineStep_ng_template_7_Template, 1, 1, "ng-template", null, 0, ɵɵtemplateRefExtractor);
    }
    if (rf & 2) {
      const processing_r2 = ɵɵreference(8);
      ɵɵadvance(2);
      ɵɵtextInterpolate(ctx.stepTitleText);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.isProcessing)("ngIfElse", processing_r2);
    }
  },
  dependencies: [NgIf, CdsIconCustomTag, ClrSpinner],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrTimelineStep, [{
    type: Component,
    args: [{
      selector: "clr-timeline-step",
      template: `
    <ng-content select="clr-timeline-step-header"></ng-content>
    <span class="clr-sr-only">{{ stepTitleText }}</span>
    <ng-container *ngIf="!isProcessing; else processing">
      <cds-icon
        [attr.status]="iconStatus"
        [attr.shape]="iconShape"
        [attr.aria-label]="iconAriaLabel"
        role="img"
      ></cds-icon>
    </ng-container>
    <div class="clr-timeline-step-body">
      <ng-content select="clr-timeline-step-title"></ng-content>
      <ng-content select="clr-timeline-step-description"></ng-content>
    </div>

    <ng-template #processing>
      <clr-spinner clrMedium [attr.aria-label]="iconAriaLabel"></clr-spinner>
    </ng-template>
  `,
      host: {
        "[class.clr-timeline-step]": "true",
        "[attr.role]": '"listitem"'
      }
    }]
  }], function() {
    return [{
      type: TimelineIconAttributeService
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [PLATFORM_ID]
      }]
    }];
  }, {
    state: [{
      type: Input,
      args: ["clrState"]
    }],
    stepTitle: [{
      type: ContentChild,
      args: [ClrTimelineStepTitle, {
        read: ElementRef
      }]
    }]
  });
})();
var ClrTimelineStepDescription = class {
};
ClrTimelineStepDescription.ɵfac = function ClrTimelineStepDescription_Factory(t3) {
  return new (t3 || ClrTimelineStepDescription)();
};
ClrTimelineStepDescription.ɵcmp = ɵɵdefineComponent({
  type: ClrTimelineStepDescription,
  selectors: [["clr-timeline-step-description"]],
  hostVars: 2,
  hostBindings: function ClrTimelineStepDescription_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("clr-timeline-step-description", true);
    }
  },
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function ClrTimelineStepDescription_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrTimelineStepDescription, [{
    type: Component,
    args: [{
      selector: "clr-timeline-step-description",
      template: `<ng-content></ng-content>`,
      host: {
        "[class.clr-timeline-step-description]": "true"
      }
    }]
  }], null, null);
})();
var ClrTimelineStepHeader = class {
};
ClrTimelineStepHeader.ɵfac = function ClrTimelineStepHeader_Factory(t3) {
  return new (t3 || ClrTimelineStepHeader)();
};
ClrTimelineStepHeader.ɵcmp = ɵɵdefineComponent({
  type: ClrTimelineStepHeader,
  selectors: [["clr-timeline-step-header"]],
  hostVars: 2,
  hostBindings: function ClrTimelineStepHeader_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("clr-timeline-step-header", true);
    }
  },
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function ClrTimelineStepHeader_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrTimelineStepHeader, [{
    type: Component,
    args: [{
      selector: "clr-timeline-step-header",
      template: `<ng-content></ng-content>`,
      host: {
        "[class.clr-timeline-step-header]": "true"
      }
    }]
  }], null, null);
})();
var CLR_TIMELINE_DIRECTIVES = [ClrTimeline, ClrTimelineStep, ClrTimelineStepDescription, ClrTimelineStepHeader, ClrTimelineStepTitle];
var ClrTimelineModule = class {
  constructor() {
    r.addIcons(o7, t, d, d3);
  }
};
ClrTimelineModule.ɵfac = function ClrTimelineModule_Factory(t3) {
  return new (t3 || ClrTimelineModule)();
};
ClrTimelineModule.ɵmod = ɵɵdefineNgModule({
  type: ClrTimelineModule,
  declarations: [ClrTimeline, ClrTimelineStep, ClrTimelineStepDescription, ClrTimelineStepHeader, ClrTimelineStepTitle],
  imports: [CommonModule, ClrIconModule, ClrSpinnerModule],
  exports: [ClrTimeline, ClrTimelineStep, ClrTimelineStepDescription, ClrTimelineStepHeader, ClrTimelineStepTitle, ClrIconModule, ClrSpinnerModule]
});
ClrTimelineModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, ClrIconModule, ClrSpinnerModule, ClrIconModule, ClrSpinnerModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrTimelineModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, ClrIconModule, ClrSpinnerModule],
      exports: [...CLR_TIMELINE_DIRECTIVES, ClrIconModule, ClrSpinnerModule],
      declarations: [CLR_TIMELINE_DIRECTIVES]
    }]
  }], function() {
    return [];
  }, null);
})();
var ButtonHubService = class {
  constructor() {
    this.buttonsReady = false;
    this._previousBtnClicked = new Subject();
    this._nextBtnClicked = new Subject();
    this._dangerBtnClicked = new Subject();
    this._cancelBtnClicked = new Subject();
    this._finishBtnClicked = new Subject();
    this._customBtnClicked = new Subject();
  }
  get previousBtnClicked() {
    return this._previousBtnClicked.asObservable();
  }
  get nextBtnClicked() {
    return this._nextBtnClicked.asObservable();
  }
  get dangerBtnClicked() {
    return this._dangerBtnClicked.asObservable();
  }
  get cancelBtnClicked() {
    return this._cancelBtnClicked.asObservable();
  }
  get finishBtnClicked() {
    return this._finishBtnClicked.asObservable();
  }
  get customBtnClicked() {
    return this._customBtnClicked.asObservable();
  }
  buttonClicked(buttonType) {
    if ("previous" === buttonType) {
      this._previousBtnClicked.next();
    } else if ("next" === buttonType) {
      this._nextBtnClicked.next();
    } else if ("finish" === buttonType) {
      this._finishBtnClicked.next();
    } else if ("danger" === buttonType) {
      this._dangerBtnClicked.next();
    } else if ("cancel" === buttonType) {
      this._cancelBtnClicked.next();
    } else {
      this._customBtnClicked.next(buttonType);
    }
  }
};
ButtonHubService.ɵfac = function ButtonHubService_Factory(t3) {
  return new (t3 || ButtonHubService)();
};
ButtonHubService.ɵprov = ɵɵdefineInjectable({
  token: ButtonHubService,
  factory: ButtonHubService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ButtonHubService, [{
    type: Injectable
  }], null, null);
})();
var PageCollectionService = class {
  constructor() {
    this._pagesReset = new Subject();
  }
  /**
   * Converts the PageCollectionService.pages QueryList to an array and returns it.
   *
   * Useful for many instances when you would prefer a QueryList to act like an array.
   *
   * @memberof PageCollectionService
   */
  get pagesAsArray() {
    return this.pages ? this.pages.toArray() : [];
  }
  /**
   * Returns the length of the pages query list.
   *
   * @memberof PageCollectionService
   */
  get pagesCount() {
    return this.pages ? this.pages.length : 0;
  }
  /**
   * Returns the next-to-last page in the query list of pages. Operates as a getter
   * so that it isn't working with stale data.
   *
   * @memberof PageCollectionService
   */
  get penultimatePage() {
    const pageCount = this.pagesCount;
    if (pageCount < 2) {
      return null;
    }
    return this.pagesAsArray[pageCount - 2];
  }
  /**
   * Returns the last page in the query list of pages. Operates as a getter
   * so that it isn't working with stale data.
   *
   * @memberof PageCollectionService
   */
  get lastPage() {
    const pageCount = this.pagesCount;
    if (pageCount < 1) {
      return null;
    }
    return this.pagesAsArray[pageCount - 1];
  }
  /**
   * Returns the first page in the query list of pages. Operates as a getter
   * so that it isn't working with stale data.
   *
   * @memberof PageCollectionService
   */
  get firstPage() {
    if (!this.pagesCount) {
      return null;
    }
    return this.pagesAsArray[0];
  }
  /**
   * An observable that the navigation service listens to in order to know when
   * the page collection completed states have been reset to false so that way it
   * can also reset the navigation to make the first page in the page collection
   * current/active.
   *
   * @memberof PageCollectionService
   */
  get pagesReset() {
    return this._pagesReset.asObservable();
  }
  /**
   * Used mostly internally, but accepts a string ID and returns a ClrWizardPage
   * object that matches the ID passed. Note that IDs here should include the prefix
   * "clr-wizard-page-".
   *
   * Returns the next-to-last page in the query list of pages. Operates as a getter
   * so that it isn't working with stale data.
   *
   * @memberof PageCollectionService
   */
  getPageById(id) {
    const foundPages = this.pages.filter((page) => id === page.id);
    return this.checkResults(foundPages, id);
  }
  /**
   * Accepts s number as a parameter and treats that number as the index of the page
   * you're looking for in the collection of pages. Returns a  wizard page object.
   *
   * @memberof PageCollectionService
   */
  getPageByIndex(index) {
    const pageCount = this.pagesCount;
    const pagesLastIndex = pageCount > 1 ? pageCount - 1 : 0;
    if (index < 0) {
      throw new Error("Cannot retrieve page with index of " + index);
    }
    if (index > pagesLastIndex) {
      throw new Error("Page index is greater than length of pages array.");
    }
    return this.pagesAsArray[index];
  }
  /**
   * Takes a wizard page object as a parameter and returns its index in the
   * collection of pages.
   *
   * @memberof PageCollectionService
   */
  getPageIndex(page) {
    const index = this.pagesAsArray.indexOf(page);
    if (index < 0) {
      throw new Error("Requested page cannot be found in collection of pages.");
    }
    return index;
  }
  /**
   * Accepts two numeric indexes and returns an array of wizard page objects that include
   * all wizard pages in the page collection from the first index to the second.
   *
   * @memberof PageCollectionService
   */
  pageRange(start, end) {
    let pages = [];
    if (start < 0 || end < 0) {
      return [];
    }
    if (start === null || typeof start === "undefined" || isNaN(start)) {
      return [];
    }
    if (end === null || typeof end === "undefined" || isNaN(end)) {
      return [];
    }
    if (end > this.pagesCount) {
      end = this.pagesCount;
    }
    pages = this.pagesAsArray;
    if (end - start === 0) {
      return [this.getPageByIndex(start)];
    }
    end = end + 1;
    return pages.slice(start, end);
  }
  /**
   * Accepts two wizard page objects and returns those page objects with all other page
   * objects between them in the page collection. It doesn't care which page is ahead of the
   * other in the parameters. It will be smart enough to figure that out  on its own.
   *
   * @memberof PageCollectionService
   */
  getPageRangeFromPages(page, otherPage) {
    const pageIndex = this.getPageIndex(page);
    const otherPageIndex = this.getPageIndex(otherPage);
    let startIndex;
    let endIndex;
    if (pageIndex <= otherPageIndex) {
      startIndex = pageIndex;
      endIndex = otherPageIndex;
    } else {
      startIndex = otherPageIndex;
      endIndex = pageIndex;
    }
    return this.pageRange(startIndex, endIndex);
  }
  /**
   * Takes a wizard page object as a parameter and returns the wizard page object of
   * the page immediately before it in the page collection. Returns null if there is
   * no page before the page it is passed.
   *
   * @memberof PageCollectionService
   */
  getPreviousPage(page) {
    const myPageIndex = this.getPageIndex(page);
    const previousPageIndex = myPageIndex - 1;
    if (previousPageIndex < 0) {
      return null;
    }
    return this.getPageByIndex(previousPageIndex);
  }
  /**
   * Accepts a wizard page object as a parameter and returns a Boolean that says if
   * the page you sent it is complete.
   *
   * @memberof PageCollectionService
   */
  previousPageIsCompleted(page) {
    if (!page) {
      return false;
    }
    const previousPage = this.getPreviousPage(page);
    if (null === previousPage) {
      return true;
    }
    return previousPage.completed;
  }
  /**
   * Takes a wizard page object as a parameter and returns the wizard page object of
   * the page immediately after it in the page collection. Returns null if there is
   * no page after the page it is passed.
   *
   * @memberof PageCollectionService
   */
  getNextPage(page) {
    const myPageIndex = this.getPageIndex(page);
    const nextPageIndex = myPageIndex + 1;
    if (nextPageIndex >= this.pagesAsArray.length) {
      return null;
    }
    return this.getPageByIndex(nextPageIndex);
  }
  /**
   * Takes a wizard page object as a parameter and generates a step item id from the
   * page ID. Returns the generated step item ID as a string.
   *
   * @memberof PageCollectionService
   */
  getStepItemIdForPage(page) {
    const pageId = page.id;
    const pageIdParts = pageId.split("-").reverse();
    pageIdParts[1] = "step";
    return pageIdParts.reverse().join("-");
  }
  /**
   * Generally only used internally to mark that a specific page has been "committed".
   * This involves marking the page complete and firing the ClrWizardPage.onCommit
   * (clrWizardPageOnCommit) output. Takes the wizard page object that you intend to
   * mark completed as a parameter.
   *
   * @memberof PageCollectionService
   */
  commitPage(page) {
    const pageHasOverrides = page.stopNext || page.preventDefault;
    page.completed = true;
    if (!pageHasOverrides) {
      page.onCommit.emit(page.id);
    }
  }
  /**
   * Sets all completed states of the pages in the page collection to false and
   * notifies the navigation service to likewise reset the navigation.
   *
   * @memberof PageCollectionService
   */
  reset() {
    this.pagesAsArray.forEach((page) => {
      page.completed = false;
    });
    this._pagesReset.next(true);
  }
  /**
   * Rolls through all the pages in the page collection to make sure there are no
   * incomplete pages sandwiched between completed pages in the workflow. Identifies
   * the first incomplete page index and sets all pages behind it to a completed
   * state of false.
   *
   * @memberof PageCollectionService
   */
  updateCompletedStates() {
    const firstIncompleteIndex = this.findFirstIncompletePageIndex();
    if (firstIncompleteIndex === this.pagesAsArray.length - 1) {
      return;
    }
    this.pagesAsArray.forEach((page, index) => {
      if (index > firstIncompleteIndex) {
        page.completed = false;
      }
    });
  }
  /**
   * Retrieves the index of the first incomplete page in the page collection.
   *
   * @memberof PageCollectionService
   */
  findFirstIncompletePageIndex() {
    let returnIndex = null;
    this.pagesAsArray.forEach((page, index) => {
      if (null === returnIndex && false === page.completed) {
        returnIndex = index;
      }
    });
    if (null === returnIndex) {
      returnIndex = this.pagesCount - 1;
    }
    return returnIndex;
  }
  findFirstIncompletePage() {
    const myIncompleteIndex = this.findFirstIncompletePageIndex();
    return this.pagesAsArray[myIncompleteIndex];
  }
  /**
   * Consolidates guard logic that prevents a couple of unfortunate edge cases with
   * look ups on the collection of pages.
   *
   * @memberof PageCollectionService
   */
  checkResults(results, requestedPageId) {
    const foundPagesCount = results.length || 0;
    if (foundPagesCount > 1) {
      throw new Error("More than one page has the requested id " + requestedPageId + ".");
    } else if (foundPagesCount < 1) {
      throw new Error("No page can be found with the id " + requestedPageId + ".");
    } else {
      return results[0];
    }
  }
};
PageCollectionService.ɵfac = function PageCollectionService_Factory(t3) {
  return new (t3 || PageCollectionService)();
};
PageCollectionService.ɵprov = ɵɵdefineInjectable({
  token: PageCollectionService,
  factory: PageCollectionService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PageCollectionService, [{
    type: Injectable
  }], null, null);
})();
var WizardNavigationService = class {
  /**
   * Creates an instance of WizardNavigationService. Also sets up subscriptions
   * that listen to the button service to determine when a button has been clicked
   * in the wizard. Is also responsible for taking action when the page collection
   * requests that navigation be reset to its pristine state.
   *
   * @memberof WizardNavigationService
   */
  constructor(pageCollection, buttonService) {
    this.pageCollection = pageCollection;
    this.buttonService = buttonService;
    this.navServiceLoaded = false;
    this.forceForwardNavigation = false;
    this.wizardHasAltCancel = false;
    this.wizardHasAltNext = false;
    this.wizardStopNavigation = false;
    this.wizardDisableStepnav = false;
    this._currentChanged = new Subject();
    this._movedToNextPage = new Subject();
    this._wizardFinished = new Subject();
    this._movedToPreviousPage = new Subject();
    this._cancelWizard = new Subject();
    this.previousButtonSubscription = this.buttonService.previousBtnClicked.subscribe(() => {
      const currentPage = this.currentPage;
      if (this.currentPageIsFirst || currentPage.previousStepDisabled) {
        return;
      }
      currentPage.previousButtonClicked.emit(currentPage);
      if (!currentPage.preventDefault) {
        this.previous();
      }
    });
    this.nextButtonSubscription = this.buttonService.nextBtnClicked.subscribe(() => {
      this.checkAndCommitCurrentPage("next");
    });
    this.dangerButtonSubscription = this.buttonService.dangerBtnClicked.subscribe(() => {
      this.checkAndCommitCurrentPage("danger");
    });
    this.finishButtonSubscription = this.buttonService.finishBtnClicked.subscribe(() => {
      this.checkAndCommitCurrentPage("finish");
    });
    this.customButtonSubscription = this.buttonService.customBtnClicked.subscribe((type) => {
      if (!this.wizardStopNavigation) {
        this.currentPage.customButtonClicked.emit(type);
      }
    });
    this.cancelButtonSubscription = this.buttonService.cancelBtnClicked.subscribe(() => {
      if (this.wizardStopNavigation) {
        return;
      }
      if (this.currentPage.preventDefault) {
        this.currentPage.pageOnCancel.emit(this.currentPage);
      } else {
        this.cancel();
      }
    });
    this.pagesResetSubscription = this.pageCollection.pagesReset.subscribe(() => {
      this.setFirstPageCurrent();
    });
  }
  /**
   * An Observable that is predominantly used amongst the subcomponents and services
   * of the wizard. It is recommended that users listen to the ClrWizardPage.onLoad
   * (clrWizardPageOnLoad) output instead of this Observable.
   *
   * @memberof WizardNavigationService
   */
  get currentPageChanged() {
    return this._currentChanged.asObservable();
  }
  /**
   * @memberof WizardNavigationService
   */
  get currentPageTitle() {
    if (!this.currentPage) {
      return null;
    }
    return this.currentPage.title;
  }
  /**
   * Returns a Boolean that tells you whether or not the current page is the first
   * page in the Wizard.
   *
   * This is helpful for determining whether a page is navigable.
   *
   * @memberof WizardNavigationService
   */
  get currentPageIsFirst() {
    return this.pageCollection.firstPage === this.currentPage;
  }
  /**
   * Returns a Boolean that tells you whether or not the current page is the
   * last page in the Wizard.
   *
   * This is used to determine which buttons should display in the wizard footer.
   *
   * @memberof WizardNavigationService
   */
  get currentPageIsLast() {
    return this.pageCollection.lastPage === this.currentPage;
  }
  /**
   * Returns the ClrWizardPage object of the current page or null.
   *
   * @memberof WizardNavigationService
   */
  get currentPage() {
    if (!this._currentPage) {
      return null;
    }
    return this._currentPage;
  }
  /**
   * Accepts a ClrWizardPage object, since that object to be the current/active
   * page in the wizard, and emits the ClrWizardPage.onLoad (clrWizardPageOnLoad)
   * event for that page.
   *
   * Note that all of this work is bypassed if the ClrWizardPage object is already
   * the current page.
   *
   * @memberof WizardNavigationService
   */
  set currentPage(page) {
    if (this._currentPage !== page && !this.wizardStopNavigation) {
      this._currentPage = page;
      page.onLoad.emit(page.id);
      this._currentChanged.next(page);
    }
  }
  /**
   * An observable used internally to alert the wizard that forward navigation
   * has occurred. It is recommended that you use the Wizard.onMoveNext
   * (clrWizardOnNext) output instead of this one.
   *
   * @memberof WizardNavigationService
   */
  get movedToNextPage() {
    return this._movedToNextPage.asObservable();
  }
  /**
   * An observable used internally to alert the wizard that the nav service
   * has approved completion of the wizard.
   *
   * It is recommended that you use the Wizard.wizardFinished (clrWizardOnFinish)
   * output instead of this one.
   *
   * @memberof WizardNavigationService
   */
  get wizardFinished() {
    return this._wizardFinished.asObservable();
  }
  /**
   * Notifies the wizard when backwards navigation has occurred via the
   * previous button.
   *
   * @memberof WizardNavigationService
   */
  get movedToPreviousPage() {
    return this._movedToPreviousPage.asObservable();
  }
  /**
   * Notifies the wizard that a user is trying to cancel it.
   *
   * @memberof WizardNavigationService
   */
  get notifyWizardCancel() {
    return this._cancelWizard.asObservable();
  }
  /**
   *
   * @memberof WizardNavigationService
   */
  ngOnDestroy() {
    this.previousButtonSubscription.unsubscribe();
    this.nextButtonSubscription.unsubscribe();
    this.dangerButtonSubscription.unsubscribe();
    this.finishButtonSubscription.unsubscribe();
    this.customButtonSubscription.unsubscribe();
    this.cancelButtonSubscription.unsubscribe();
    this.pagesResetSubscription.unsubscribe();
  }
  /**
   * This is a public function that can be used to programmatically advance
   * the user to the next page.
   *
   * When invoked, this method will move the wizard to the next page after
   * successful validation. Note that this method goes through all checks
   * and event emissions as if Wizard.next(false) had been called.
   *
   * In most cases, it makes more sense to use Wizard.next(false).
   *
   * @memberof WizardNavigationService
   */
  next() {
    if (this.currentPageIsLast) {
      this.checkAndCommitCurrentPage("finish");
    } else {
      this.checkAndCommitCurrentPage("next");
    }
  }
  /**
   * Bypasses checks and most event emissions to force a page to navigate forward.
   *
   * Comparable to calling Wizard.next() or Wizard.forceNext().
   *
   * @memberof WizardNavigationService
   */
  forceNext() {
    const currentPage = this.currentPage;
    const nextPage = this.pageCollection.getNextPage(currentPage);
    if (!nextPage) {
      throw new Error("The wizard has no next page to go to.");
    }
    if (this.wizardStopNavigation) {
      return;
    }
    if (!currentPage.completed) {
      this.pageCollection.commitPage(currentPage);
    }
    this.currentPage = nextPage;
  }
  /**
   * Accepts a button/action type as a parameter. Encapsulates all logic for
   * event emissions, state of the current page, and wizard and page level overrides.
   *
   * Avoid calling this function directly unless you really know what you're doing.
   *
   * @memberof WizardNavigationService
   */
  checkAndCommitCurrentPage(buttonType) {
    const currentPage = this.currentPage;
    if (!currentPage.readyToComplete || this.wizardStopNavigation) {
      return;
    }
    const iAmTheLastPage = this.currentPageIsLast;
    const isNext = buttonType === "next";
    const isDanger = buttonType === "danger";
    const isDangerNext = isDanger && !iAmTheLastPage;
    const isDangerFinish = isDanger && iAmTheLastPage;
    const isFinish = buttonType === "finish" || isDangerFinish;
    if (isFinish && !iAmTheLastPage) {
      return;
    }
    currentPage.primaryButtonClicked.emit(buttonType);
    if (isFinish) {
      currentPage.finishButtonClicked.emit(currentPage);
    } else if (isDanger) {
      currentPage.dangerButtonClicked.emit();
    } else if (isNext) {
      currentPage.nextButtonClicked.emit();
    }
    if (currentPage.stopNext || currentPage.preventDefault) {
      currentPage.onCommit.emit(currentPage.id);
      return;
    }
    if (isFinish) {
      if (!this.wizardHasAltNext) {
        this.pageCollection.commitPage(currentPage);
      }
      this._wizardFinished.next();
    }
    if (this.wizardHasAltNext) {
      this.pageCollection.commitPage(currentPage);
      if (isNext || isDangerNext) {
        this._movedToNextPage.next(true);
      }
      return;
    }
    if (isNext || isDangerNext) {
      this.forceNext();
    }
    if (!this.wizardHasAltNext && !this.wizardStopNavigation) {
      this._movedToNextPage.next(true);
    }
  }
  /**
   * This is a public function that can be used to programmatically conclude
   * the wizard.
   *
   * When invoked, this method will  initiate the work involved with finalizing
   * and finishing the wizard workflow. Note that this method goes through all
   * checks and event emissions as if Wizard.finish(false) had been called.
   *
   * In most cases, it makes more sense to use Wizard.finish(false).
   *
   * @memberof WizardNavigationService
   */
  finish() {
    this.checkAndCommitCurrentPage("finish");
  }
  /**
   * Programmatically moves the wizard to the page before the current page.
   *
   * In most instances, it makes more sense to call Wizard.previous()
   * which does the same thing.
   *
   * @memberof WizardNavigationService
   */
  previous() {
    if (this.currentPageIsFirst || this.wizardStopNavigation) {
      return;
    }
    const previousPage = this.pageCollection.getPreviousPage(this.currentPage);
    if (!previousPage) {
      return;
    }
    this._movedToPreviousPage.next(true);
    if (this.forceForwardNavigation) {
      this.currentPage.completed = false;
    }
    this.currentPage = previousPage;
  }
  /**
   * Allows a hook into the cancel workflow of the wizard from the nav service. Note that
   * this route goes through all checks and event emissions as if a cancel button had
   * been clicked.
   *
   * In most cases, users looking for a hook into the cancel routine are actually looking
   * for a way to close the wizard from their host component because they have prevented
   * the default cancel action.
   *
   * In this instance, it is recommended that you use Wizard.close() to avoid any event
   * emission loop resulting from an event handler calling back into routine that will
   * again evoke the events it handles.
   *
   * @memberof WizardNavigationService
   */
  cancel() {
    this._cancelWizard.next();
  }
  /**
   * Performs all required checks to determine if a user can navigate to a page. Checking at each
   * point if a page is navigable -- completed where the page immediately after the last completed
   * page.
   *
   * Takes two parameters. The first one must be either the ClrWizardPage object or the ID of the
   * ClrWizardPage object that you want to make the current page.
   *
   * The second parameter is optional and is a Boolean flag for "lazy completion". What this means
   * is the Wizard will mark all pages between the current page and the page you want to navigate
   * to as completed. This is useful for informational wizards that do not require user action,
   * allowing an easy means for users to jump ahead.
   *
   * To avoid checks on navigation, use ClrWizardPage.makeCurrent() instead.
   *
   * @memberof WizardNavigationService
   */
  goTo(pageToGoToOrId, lazyComplete = false) {
    const myPages = this.pageCollection;
    const pageToGoTo = typeof pageToGoToOrId === "string" ? myPages.getPageById(pageToGoToOrId) : pageToGoToOrId;
    const currentPage = this.currentPage;
    if (pageToGoTo === currentPage || this.wizardStopNavigation) {
      return;
    }
    const currentPageIndex = myPages.getPageIndex(currentPage);
    const goToPageIndex = myPages.getPageIndex(pageToGoTo);
    const goingForward = goToPageIndex > currentPageIndex;
    const pagesToCheck = myPages.getPageRangeFromPages(this.currentPage, pageToGoTo);
    const okayToMove = lazyComplete || this.canGoTo(pagesToCheck);
    if (!okayToMove) {
      return;
    }
    if (goingForward && lazyComplete) {
      pagesToCheck.forEach((page) => {
        if (page !== pageToGoTo) {
          page.completed = true;
        }
      });
    } else if (!goingForward && this.forceForwardNavigation) {
      pagesToCheck.forEach((page) => {
        page.completed = false;
      });
    }
    this.currentPage = pageToGoTo;
  }
  /**
   * Accepts a range of ClrWizardPage objects as a parameter. Performs the work of checking
   * those objects to determine if navigation can be accomplished.
   *
   * @memberof WizardNavigationService
   */
  canGoTo(pagesToCheck) {
    let okayToMove = true;
    const myPages = this.pageCollection;
    let previousPagePasses;
    if (!pagesToCheck || pagesToCheck.length < 1) {
      return false;
    }
    pagesToCheck.forEach((page) => {
      if (!okayToMove) {
        return;
      }
      if (page.completed) {
        return;
      }
      const previousPage = myPages.getPageIndex(page) > 0 ? myPages.getPreviousPage(page) : null;
      previousPagePasses = previousPage === null || previousPage.completed === true;
      if (!page.current && !previousPagePasses) {
        okayToMove = false;
      }
    });
    return okayToMove;
  }
  /**
   * Looks through the collection of pages to find the first one that is incomplete
   * and makes that page the current/active page.
   *
   * @memberof WizardNavigationService
   */
  setLastEnabledPageCurrent() {
    const allPages = this.pageCollection.pagesAsArray;
    let lastCompletedPageIndex = null;
    allPages.forEach((page, index) => {
      if (page.completed) {
        lastCompletedPageIndex = index;
      }
    });
    if (lastCompletedPageIndex === null) {
      lastCompletedPageIndex = 0;
    } else if (lastCompletedPageIndex + 1 < allPages.length) {
      lastCompletedPageIndex = lastCompletedPageIndex + 1;
    }
    this.currentPage = allPages[lastCompletedPageIndex];
  }
  /**
   * Finds the first page in the collection of pages and makes that page the
   * current/active page.
   *
   * @memberof WizardNavigationService
   */
  setFirstPageCurrent() {
    this.currentPage = this.pageCollection.pagesAsArray[0];
  }
  /**
   * Updates the stepnav on the left side of the wizard when pages are dynamically
   * added or removed from the collection of pages.
   *
   * @memberof WizardNavigationService
   */
  updateNavigation() {
    let toSetCurrent;
    this.pageCollection.updateCompletedStates();
    const currentPageRemoved = this.pageCollection.pagesAsArray.indexOf(this.currentPage) < 0;
    if (currentPageRemoved) {
      toSetCurrent = this.pageCollection.findFirstIncompletePage();
      this.currentPage = toSetCurrent;
    }
  }
};
WizardNavigationService.ɵfac = function WizardNavigationService_Factory(t3) {
  return new (t3 || WizardNavigationService)(ɵɵinject(PageCollectionService), ɵɵinject(ButtonHubService));
};
WizardNavigationService.ɵprov = ɵɵdefineInjectable({
  token: WizardNavigationService,
  factory: WizardNavigationService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(WizardNavigationService, [{
    type: Injectable
  }], function() {
    return [{
      type: PageCollectionService
    }, {
      type: ButtonHubService
    }];
  }, null);
})();
var HeaderActionService = class {
  constructor(navService) {
    this.navService = navService;
  }
  get wizardHasHeaderActions() {
    const wizardHdrActions = this.wizardHeaderActions;
    if (!wizardHdrActions) {
      return false;
    }
    return wizardHdrActions.toArray().length > 0;
  }
  get currentPageHasHeaderActions() {
    return this.navService.currentPage ? this.navService.currentPage.hasHeaderActions : false;
  }
  get showWizardHeaderActions() {
    return !this.currentPageHasHeaderActions && this.wizardHasHeaderActions;
  }
  get displayHeaderActionsWrapper() {
    return this.currentPageHasHeaderActions || this.wizardHasHeaderActions;
  }
};
HeaderActionService.ɵfac = function HeaderActionService_Factory(t3) {
  return new (t3 || HeaderActionService)(ɵɵinject(WizardNavigationService));
};
HeaderActionService.ɵprov = ɵɵdefineInjectable({
  token: HeaderActionService,
  factory: HeaderActionService.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HeaderActionService, [{
    type: Injectable
  }], function() {
    return [{
      type: WizardNavigationService
    }];
  }, null);
})();
var wizardHeaderActionIndex = 0;
var ClrWizardHeaderAction = class {
  constructor() {
    this.title = "";
    this._id = (wizardHeaderActionIndex++).toString();
    this.disabled = false;
    this.headerActionClicked = new EventEmitter(false);
  }
  get id() {
    return `clr-wizard-header-action-${this._id}`;
  }
  click() {
    if (this.disabled) {
      return;
    }
    this.headerActionClicked.emit(this._id);
  }
};
ClrWizardHeaderAction.ɵfac = function ClrWizardHeaderAction_Factory(t3) {
  return new (t3 || ClrWizardHeaderAction)();
};
ClrWizardHeaderAction.ɵcmp = ɵɵdefineComponent({
  type: ClrWizardHeaderAction,
  selectors: [["clr-wizard-header-action"]],
  hostAttrs: [1, "clr-wizard-header-action-wrapper"],
  inputs: {
    title: "title",
    _id: [InputFlags.None, "id", "_id"],
    disabled: [InputFlags.None, "clrWizardHeaderActionDisabled", "disabled"]
  },
  outputs: {
    headerActionClicked: "actionClicked"
  },
  ngContentSelectors: _c02,
  decls: 2,
  vars: 4,
  consts: [["type", "button", 1, "btn", "clr-wizard-header-action", "btn-link", 3, "click", "id", "title"]],
  template: function ClrWizardHeaderAction_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "button", 0);
      ɵɵlistener("click", function ClrWizardHeaderAction_Template_button_click_0_listener() {
        return ctx.click();
      });
      ɵɵprojection(1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵclassProp("disabled", ctx.disabled);
      ɵɵproperty("id", ctx.id)("title", ctx.title);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrWizardHeaderAction, [{
    type: Component,
    args: [{
      selector: "clr-wizard-header-action",
      template: `
    <button
      type="button"
      class="btn clr-wizard-header-action btn-link"
      [id]="id"
      [class.disabled]="disabled"
      (click)="click()"
      [title]="title"
    >
      <ng-content></ng-content>
    </button>
  `,
      host: {
        class: "clr-wizard-header-action-wrapper"
      }
    }]
  }], null, {
    title: [{
      type: Input,
      args: ["title"]
    }],
    _id: [{
      type: Input,
      args: ["id"]
    }],
    disabled: [{
      type: Input,
      args: ["clrWizardHeaderActionDisabled"]
    }],
    headerActionClicked: [{
      type: Output,
      args: ["actionClicked"]
    }]
  });
})();
var ClrWizardPageButtons = class {
  constructor(pageButtonsTemplateRef) {
    this.pageButtonsTemplateRef = pageButtonsTemplateRef;
  }
};
ClrWizardPageButtons.ɵfac = function ClrWizardPageButtons_Factory(t3) {
  return new (t3 || ClrWizardPageButtons)(ɵɵdirectiveInject(TemplateRef));
};
ClrWizardPageButtons.ɵdir = ɵɵdefineDirective({
  type: ClrWizardPageButtons,
  selectors: [["", "clrPageButtons", ""]]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrWizardPageButtons, [{
    type: Directive,
    args: [{
      selector: "[clrPageButtons]"
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, null);
})();
var ClrWizardPageHeaderActions = class {
  constructor(pageHeaderActionsTemplateRef) {
    this.pageHeaderActionsTemplateRef = pageHeaderActionsTemplateRef;
  }
};
ClrWizardPageHeaderActions.ɵfac = function ClrWizardPageHeaderActions_Factory(t3) {
  return new (t3 || ClrWizardPageHeaderActions)(ɵɵdirectiveInject(TemplateRef));
};
ClrWizardPageHeaderActions.ɵdir = ɵɵdefineDirective({
  type: ClrWizardPageHeaderActions,
  selectors: [["", "clrPageHeaderActions", ""]]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrWizardPageHeaderActions, [{
    type: Directive,
    args: [{
      selector: "[clrPageHeaderActions]"
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, null);
})();
var ClrWizardPageNavTitle = class {
  constructor(pageNavTitleTemplateRef) {
    this.pageNavTitleTemplateRef = pageNavTitleTemplateRef;
  }
};
ClrWizardPageNavTitle.ɵfac = function ClrWizardPageNavTitle_Factory(t3) {
  return new (t3 || ClrWizardPageNavTitle)(ɵɵdirectiveInject(TemplateRef));
};
ClrWizardPageNavTitle.ɵdir = ɵɵdefineDirective({
  type: ClrWizardPageNavTitle,
  selectors: [["", "clrPageNavTitle", ""]]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrWizardPageNavTitle, [{
    type: Directive,
    args: [{
      selector: "[clrPageNavTitle]"
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, null);
})();
var ClrWizardPageTitle = class {
  constructor(pageTitleTemplateRef) {
    this.pageTitleTemplateRef = pageTitleTemplateRef;
  }
};
ClrWizardPageTitle.ɵfac = function ClrWizardPageTitle_Factory(t3) {
  return new (t3 || ClrWizardPageTitle)(ɵɵdirectiveInject(TemplateRef));
};
ClrWizardPageTitle.ɵdir = ɵɵdefineDirective({
  type: ClrWizardPageTitle,
  selectors: [["", "clrPageTitle", ""]],
  inputs: {
    headingLevel: [InputFlags.None, "clrHeadingLevel", "headingLevel"]
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrWizardPageTitle, [{
    type: Directive,
    args: [{
      selector: "[clrPageTitle]"
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, {
    headingLevel: [{
      type: Input,
      args: ["clrHeadingLevel"]
    }]
  });
})();
var wizardPageIndex = 0;
var ClrWizardPage = class {
  /**
   * Creates an instance of ClrWizardPage.
   *
   * @memberof WizardPage
   */
  constructor(navService, pageCollection, buttonService) {
    this.navService = navService;
    this.pageCollection = pageCollection;
    this.buttonService = buttonService;
    this._id = (wizardPageIndex++).toString();
    this.preventDefault = false;
    this.nextStepDisabledChange = new EventEmitter();
    this.previousStepDisabledChange = new EventEmitter();
    this.stopCancelChange = new EventEmitter();
    this.onCommit = new EventEmitter(false);
    this.onLoad = new EventEmitter();
    this.pageOnCancel = new EventEmitter();
    this.finishButtonClicked = new EventEmitter();
    this.previousButtonClicked = new EventEmitter();
    this.nextButtonClicked = new EventEmitter();
    this.dangerButtonClicked = new EventEmitter();
    this.primaryButtonClicked = new EventEmitter();
    this.customButtonClicked = new EventEmitter();
    this._nextStepDisabled = false;
    this._previousStepDisabled = false;
    this._hasError = false;
    this._stopCancel = false;
    this._stopNext = false;
    this._complete = false;
  }
  /**
   * A property that tells whether or not the wizard should be allowed
   * to move to the next page.
   *
   * Useful for in-page validation because it prevents forward navigation
   * and visibly disables the next button.
   *
   * Does not require that you re-implement navigation routines like you
   * would if you were using ClrWizardPage.preventDefault or
   * Wizard.preventDefault.
   *
   * @memberof WizardPage
   *
   */
  get nextStepDisabled() {
    return this._nextStepDisabled;
  }
  set nextStepDisabled(val) {
    const valBool = !!val;
    if (valBool !== this._nextStepDisabled) {
      this._nextStepDisabled = valBool;
      this.nextStepDisabledChange.emit(valBool);
    }
  }
  /**
   * A property that tells whether or not the wizard should be allowed
   * to move to the previous page.
   *
   * Useful for in-page validation because it prevents backward navigation
   * and visibly disables the previous button.
   *
   * Does not require that you re-implement navigation routines like you
   * would if you were using ClrWizardPage.preventDefault or
   * Wizard.preventDefault.
   *
   * @memberof WizardPage
   *
   */
  get previousStepDisabled() {
    return this._previousStepDisabled;
  }
  set previousStepDisabled(val) {
    const valBool = !!val;
    if (valBool !== this._previousStepDisabled) {
      this._previousStepDisabled = valBool;
      this.previousStepDisabledChange.emit(valBool);
    }
  }
  /**
   * Whether the page has an error and also resolve the "falsy" value. The
   * current logic treat a "0" or an empty string as false and likewise will treat any
   * "truthy" value as true.
   *
   * @memberof WizardPage
   *
   */
  get hasError() {
    return this._hasError;
  }
  set hasError(val) {
    const valBool = !!val;
    if (valBool !== this._hasError) {
      this._hasError = valBool;
    }
  }
  /**
   * Overrides the cancel action from the page level. Allows you to use an
   * alternate function for validation or data-munging before cancelling the
   * wizard when combined with the ClrWizardPage.onCancel
   * (the clrWizardPageOnCancel output).
   *
   * Requires that you manually close the wizard from your host component,
   * usually with a call to Wizard.forceNext() or wizard.next();
   *
   * @memberof ClrWizardPage
   */
  get stopCancel() {
    return this._stopCancel;
  }
  set stopCancel(val) {
    const valBool = !!val;
    if (valBool !== this._stopCancel) {
      this._stopCancel = valBool;
      this.stopCancelChange.emit(valBool);
    }
  }
  /**
   * Overrides forward navigation from the page level. Allows you to use an
   * alternate function for validation or data-munging before moving the
   * wizard to the next pagewhen combined with the ClrWizardPage.onCommit
   * (clrWizardPageOnCommit) or ClrWizardPage.nextButtonClicked
   * (clrWizardPageNext) outputs.
   *
   * Requires that you manually tell the wizard to navigate forward from
   * the hostComponent, usually with a call to Wizard.forceNext() or
   * wizard.next();
   *
   * @memberof ClrWizardPage
   */
  get stopNext() {
    return this._stopNext;
  }
  set stopNext(val) {
    const valBool = !!val;
    if (valBool !== this._stopNext) {
      this._stopNext = valBool;
    }
  }
  /**
   * A read-only getter that generates an ID string for the wizard page from
   * either the value passed to the ClrWizardPage "id" input or a wizard page
   * counter shared across all wizard pages in the application.
   *
   * Note that the value passed into the ID input Will be prefixed with
   * "clr-wizard-page-".
   *
   * @readonly
   *
   * @memberof ClrWizardPage
   */
  get id() {
    const idIsNonZeroFalsy = !this._id && this._id !== 0;
    if (idIsNonZeroFalsy || this._id < 0) {
      this._id = (wizardPageIndex++).toString();
    }
    return `clr-wizard-page-${this._id}`;
  }
  /**
   * A read-only getter that serves as a convenience for those who would rather
   * not think in the terms of !ClrWizardPage.nextStepDisabled. For some use cases,
   * ClrWizardPage.readyToComplete is more logical and declarative.
   *
   * @memberof WizardPage
   *
   */
  get readyToComplete() {
    return !this.nextStepDisabled;
  }
  /**
   * A page is marked as completed if it is both readyToComplete and completed,
   * as in the next or finish action has been executed while this page was current.
   *
   * Note there is and open question about how to handle pages that are marked
   * complete but who are no longer readyToComplete. This might indicate an error
   * state for the ClrWizardPage. Currently, the wizard does not acknowledge this state
   * and only returns that the page is incomplete.
   *
   * @memberof WizardPage
   *
   */
  get completed() {
    return this._complete && this.readyToComplete;
  }
  /**
   * A ClrWizardPage can be manually set to completed using this boolean setter.
   * It is recommended that users rely on the convenience functions in the wizard
   * and navigation service instead of manually setting pages’ completion state.
   *
   * @memberof ClrWizardPage
   */
  set completed(value) {
    this._complete = value;
  }
  /**
   * Checks with the navigation service to see if it is the current page.
   *
   * @memberof WizardPage
   *
   */
  get current() {
    return this.navService.currentPage === this;
  }
  get disabled() {
    return !this.enabled;
  }
  /**
   * A read-only getter that returns whether or not the page is navigable
   * in the wizard. A wizard page can be navigated to if it is completed
   * or the page before it is completed.
   *
   * This getter handles the logic for enabling or disabling the links in
   * the step nav on the left Side of the wizard.
   *
   * @memberof WizardPage
   *
   */
  get enabled() {
    return this.current || this.completed || this.previousCompleted;
  }
  /**
   * A read-only getter that returns whether or not the page before this
   * ClrWizardPage is completed. This is useful for determining whether or not
   * a page is navigable if it is not current or already completed.
   *
   * @memberof WizardPage
   *
   */
  get previousCompleted() {
    const previousPage = this.pageCollection.getPreviousPage(this);
    if (!previousPage) {
      return true;
    }
    return previousPage.completed;
  }
  /**
   *
   * @memberof WizardPage
   *
   */
  get title() {
    return this.pageTitle.pageTitleTemplateRef;
  }
  /**
   *
   * @memberof WizardPage
   *
   */
  get navTitle() {
    if (this.pageNavTitle) {
      return this.pageNavTitle.pageNavTitleTemplateRef;
    }
    return this.pageTitle.pageTitleTemplateRef;
  }
  /**
   *
   * @memberof WizardPage
   *
   */
  get headerActions() {
    if (!this._headerActions) {
      return void 0;
    }
    return this._headerActions.pageHeaderActionsTemplateRef;
  }
  /**
   *
   * @memberof WizardPage
   *
   */
  get hasHeaderActions() {
    return !!this._headerActions;
  }
  /**
   *
   * @memberof WizardPage
   *
   */
  get buttons() {
    if (!this._buttons) {
      return void 0;
    }
    return this._buttons.pageButtonsTemplateRef;
  }
  /**
   * A read-only getter that returns a boolean that says whether or
   * not the ClrWizardPage includes buttons. Used to determine if the
   * Wizard should override the default button set defined as
   * its direct children.
   *
   * @memberof WizardPage
   *
   */
  get hasButtons() {
    return !!this._buttons;
  }
  /**
   * A read-only getter that returns the id used by the step nav item associated with the page.
   *
   * ClrWizardPage needs this ID string for aria information.
   *
   * @memberof WizardPage
   *
   */
  get stepItemId() {
    return this.pageCollection.getStepItemIdForPage(this);
  }
  /**
   * Links the nav service and establishes the current page if one is not defined.
   *
   * @memberof WizardPage
   *
   */
  ngOnInit() {
    const navService = this.navService;
    if (!navService.currentPage && !navService.navServiceLoaded) {
      this.makeCurrent();
      this.navService.navServiceLoaded = true;
    }
  }
  /**
   * Uses the nav service to make the ClrWizardPage the current page in the
   * wizard. Bypasses all checks but still emits the ClrWizardPage.onLoad
   * (clrWizardPageOnLoad) output.
   *
   * In most cases, it is better to use the default navigation functions
   * in Wizard.
   *
   * @memberof WizardPage
   *
   */
  makeCurrent() {
    this.navService.currentPage = this;
  }
};
ClrWizardPage.ɵfac = function ClrWizardPage_Factory(t3) {
  return new (t3 || ClrWizardPage)(ɵɵdirectiveInject(WizardNavigationService), ɵɵdirectiveInject(PageCollectionService), ɵɵdirectiveInject(ButtonHubService));
};
ClrWizardPage.ɵcmp = ɵɵdefineComponent({
  type: ClrWizardPage,
  selectors: [["clr-wizard-page"]],
  contentQueries: function ClrWizardPage_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ClrWizardPageTitle, 7);
      ɵɵcontentQuery(dirIndex, ClrWizardPageNavTitle, 7);
      ɵɵcontentQuery(dirIndex, ClrWizardPageButtons, 7);
      ɵɵcontentQuery(dirIndex, ClrWizardPageHeaderActions, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.pageTitle = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.pageNavTitle = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._buttons = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._headerActions = _t.first);
    }
  },
  hostVars: 7,
  hostBindings: function ClrWizardPage_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵhostProperty("id", ctx.id);
      ɵɵattribute("aria-hidden", !ctx.current)("aria-labelledby", ctx.stepItemId);
      ɵɵclassProp("active", ctx.current)("clr-wizard-page", true);
    }
  },
  inputs: {
    _id: [InputFlags.None, "id", "_id"],
    preventDefault: [InputFlags.None, "clrWizardPagePreventDefault", "preventDefault"],
    nextStepDisabled: [InputFlags.None, "clrWizardPageNextDisabled", "nextStepDisabled"],
    previousStepDisabled: [InputFlags.None, "clrWizardPagePreviousDisabled", "previousStepDisabled"],
    hasError: [InputFlags.None, "clrWizardPageHasError", "hasError"],
    stopCancel: [InputFlags.None, "clrWizardPagePreventDefaultCancel", "stopCancel"],
    stopNext: [InputFlags.None, "clrWizardPagePreventDefaultNext", "stopNext"]
  },
  outputs: {
    nextStepDisabledChange: "clrWizardPageNextDisabledChange",
    previousStepDisabledChange: "clrWizardPagePreviousDisabledChange",
    stopCancelChange: "clrWizardPagePreventDefaultCancelChange",
    onCommit: "clrWizardPageOnCommit",
    onLoad: "clrWizardPageOnLoad",
    pageOnCancel: "clrWizardPageOnCancel",
    finishButtonClicked: "clrWizardPageFinish",
    previousButtonClicked: "clrWizardPagePrevious",
    nextButtonClicked: "clrWizardPageNext",
    dangerButtonClicked: "clrWizardPageDanger",
    primaryButtonClicked: "clrWizardPagePrimary",
    customButtonClicked: "clrWizardPageCustomButton"
  },
  ngContentSelectors: _c02,
  decls: 1,
  vars: 0,
  template: function ClrWizardPage_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrWizardPage, [{
    type: Component,
    args: [{
      selector: "clr-wizard-page",
      template: "<ng-content></ng-content>",
      host: {
        "[id]": "id",
        "[attr.aria-hidden]": "!current",
        "[attr.aria-labelledby]": "stepItemId",
        "[class.active]": "current",
        "[class.clr-wizard-page]": "true"
      }
    }]
  }], function() {
    return [{
      type: WizardNavigationService
    }, {
      type: PageCollectionService
    }, {
      type: ButtonHubService
    }];
  }, {
    _id: [{
      type: Input,
      args: ["id"]
    }],
    preventDefault: [{
      type: Input,
      args: ["clrWizardPagePreventDefault"]
    }],
    nextStepDisabledChange: [{
      type: Output,
      args: ["clrWizardPageNextDisabledChange"]
    }],
    previousStepDisabledChange: [{
      type: Output,
      args: ["clrWizardPagePreviousDisabledChange"]
    }],
    stopCancelChange: [{
      type: Output,
      args: ["clrWizardPagePreventDefaultCancelChange"]
    }],
    onCommit: [{
      type: Output,
      args: ["clrWizardPageOnCommit"]
    }],
    onLoad: [{
      type: Output,
      args: ["clrWizardPageOnLoad"]
    }],
    pageOnCancel: [{
      type: Output,
      args: ["clrWizardPageOnCancel"]
    }],
    finishButtonClicked: [{
      type: Output,
      args: ["clrWizardPageFinish"]
    }],
    previousButtonClicked: [{
      type: Output,
      args: ["clrWizardPagePrevious"]
    }],
    nextButtonClicked: [{
      type: Output,
      args: ["clrWizardPageNext"]
    }],
    dangerButtonClicked: [{
      type: Output,
      args: ["clrWizardPageDanger"]
    }],
    primaryButtonClicked: [{
      type: Output,
      args: ["clrWizardPagePrimary"]
    }],
    customButtonClicked: [{
      type: Output,
      args: ["clrWizardPageCustomButton"]
    }],
    pageTitle: [{
      type: ContentChild,
      args: [ClrWizardPageTitle, {
        static: true
      }]
    }],
    pageNavTitle: [{
      type: ContentChild,
      args: [ClrWizardPageNavTitle, {
        static: true
      }]
    }],
    _buttons: [{
      type: ContentChild,
      args: [ClrWizardPageButtons, {
        static: true
      }]
    }],
    _headerActions: [{
      type: ContentChild,
      args: [ClrWizardPageHeaderActions, {
        static: true
      }]
    }],
    nextStepDisabled: [{
      type: Input,
      args: ["clrWizardPageNextDisabled"]
    }],
    previousStepDisabled: [{
      type: Input,
      args: ["clrWizardPagePreviousDisabled"]
    }],
    hasError: [{
      type: Input,
      args: ["clrWizardPageHasError"]
    }],
    stopCancel: [{
      type: Input,
      args: ["clrWizardPagePreventDefaultCancel"]
    }],
    stopNext: [{
      type: Input,
      args: ["clrWizardPagePreventDefaultNext"]
    }]
  });
})();
var ClrWizardTitle = class {
};
ClrWizardTitle.ɵfac = function ClrWizardTitle_Factory(t3) {
  return new (t3 || ClrWizardTitle)();
};
ClrWizardTitle.ɵdir = ɵɵdefineDirective({
  type: ClrWizardTitle,
  selectors: [["clr-wizard-title"]],
  inputs: {
    headingLevel: [InputFlags.None, "clrHeadingLevel", "headingLevel"]
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrWizardTitle, [{
    type: Directive,
    args: [{
      selector: "clr-wizard-title"
    }]
  }], null, {
    headingLevel: [{
      type: Input,
      args: ["clrHeadingLevel"]
    }]
  });
})();
var ClrWizardStepnavItem = class {
  constructor(navService, pageCollection, commonStrings) {
    this.navService = navService;
    this.pageCollection = pageCollection;
    this.commonStrings = commonStrings;
  }
  get id() {
    this.pageGuard();
    return this.pageCollection.getStepItemIdForPage(this.page);
  }
  get stepAriaCurrent() {
    return this.isCurrent && "step";
  }
  get isDisabled() {
    this.pageGuard();
    return this.page.disabled || this.navService.wizardStopNavigation || this.navService.wizardDisableStepnav;
  }
  get isCurrent() {
    this.pageGuard();
    return this.page.current;
  }
  get isComplete() {
    this.pageGuard();
    return this.page.completed;
  }
  get hasError() {
    this.pageGuard();
    return this.page.hasError && this.isComplete;
  }
  get canNavigate() {
    this.pageGuard();
    return this.pageCollection.previousPageIsCompleted(this.page);
  }
  click() {
    this.pageGuard();
    if (this.isDisabled || this.isCurrent) {
      return;
    }
    this.navService.goTo(this.page);
  }
  pageGuard() {
    if (!this.page) {
      throw new Error("Wizard stepnav item is not associated with a wizard page.");
    }
  }
};
ClrWizardStepnavItem.ɵfac = function ClrWizardStepnavItem_Factory(t3) {
  return new (t3 || ClrWizardStepnavItem)(ɵɵdirectiveInject(WizardNavigationService), ɵɵdirectiveInject(PageCollectionService), ɵɵdirectiveInject(ClrCommonStringsService));
};
ClrWizardStepnavItem.ɵcmp = ɵɵdefineComponent({
  type: ClrWizardStepnavItem,
  selectors: [["", "clr-wizard-stepnav-item", ""]],
  hostVars: 17,
  hostBindings: function ClrWizardStepnavItem_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵhostProperty("id", ctx.id);
      ɵɵattribute("aria-current", ctx.stepAriaCurrent)("aria-controls", ctx.page.id);
      ɵɵclassProp("clr-nav-link", true)("nav-item", true)("active", ctx.isCurrent)("disabled", ctx.isDisabled)("no-click", !ctx.canNavigate)("complete", ctx.isComplete)("error", ctx.hasError);
    }
  },
  inputs: {
    page: "page"
  },
  attrs: _c103,
  ngContentSelectors: _c02,
  decls: 8,
  vars: 6,
  consts: [["type", "button", 1, "btn", "btn-link", "clr-wizard-stepnav-link", 3, "click"], [1, "clr-wizard-stepnav-link-suffix"], ["shape", "error-standard", "status", "danger", "class", "clr-wizard-stepnav-item-error-icon", 4, "ngIf"], [4, "ngIf"], [1, "clr-wizard-stepnav-link-title"], [3, "ngTemplateOutlet"], ["class", "clr-sr-only", 4, "ngIf"], ["shape", "error-standard", "status", "danger", 1, "clr-wizard-stepnav-item-error-icon"], [1, "clr-sr-only"]],
  template: function ClrWizardStepnavItem_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "button", 0);
      ɵɵlistener("click", function ClrWizardStepnavItem_Template_button_click_0_listener() {
        return ctx.click();
      });
      ɵɵelementStart(1, "span", 1);
      ɵɵtemplate(2, ClrWizardStepnavItem_cds_icon_2_Template, 1, 0, "cds-icon", 2)(3, ClrWizardStepnavItem_ng_content_3_Template, 1, 0, "ng-content", 3);
      ɵɵelementEnd();
      ɵɵelementStart(4, "span", 4);
      ɵɵtemplate(5, ClrWizardStepnavItem_ng_template_5_Template, 0, 0, "ng-template", 5);
      ɵɵelementEnd();
      ɵɵtemplate(6, ClrWizardStepnavItem_span_6_Template, 2, 1, "span", 6)(7, ClrWizardStepnavItem_span_7_Template, 2, 1, "span", 6);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵattribute("disabled", ctx.isDisabled ? "" : null);
      ɵɵadvance(2);
      ɵɵproperty("ngIf", ctx.hasError);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.hasError);
      ɵɵadvance(2);
      ɵɵproperty("ngTemplateOutlet", ctx.page.navTitle);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.hasError);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.hasError && ctx.isComplete);
    }
  },
  dependencies: [NgIf, NgTemplateOutlet, CdsIconCustomTag],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrWizardStepnavItem, [{
    type: Component,
    args: [{
      selector: "[clr-wizard-stepnav-item]",
      template: `
    <button
      type="button"
      class="btn btn-link clr-wizard-stepnav-link"
      (click)="click()"
      [attr.disabled]="isDisabled ? '' : null"
    >
      <span class="clr-wizard-stepnav-link-suffix">
        <cds-icon
          shape="error-standard"
          status="danger"
          class="clr-wizard-stepnav-item-error-icon"
          *ngIf="hasError"
        ></cds-icon>
        <ng-content *ngIf="!hasError"></ng-content>
      </span>
      <span class="clr-wizard-stepnav-link-title">
        <ng-template [ngTemplateOutlet]="page.navTitle"></ng-template>
      </span>
      <span *ngIf="hasError" class="clr-sr-only">{{ commonStrings.keys.wizardStepError }}</span>
      <span *ngIf="!hasError && isComplete" class="clr-sr-only">{{ commonStrings.keys.wizardStepSuccess }}</span>
    </button>
  `,
      host: {
        "[id]": "id",
        "[attr.aria-current]": "stepAriaCurrent",
        "[attr.aria-controls]": "page.id",
        "[class.clr-nav-link]": "true",
        "[class.nav-item]": "true",
        "[class.active]": "isCurrent",
        "[class.disabled]": "isDisabled",
        "[class.no-click]": "!canNavigate",
        "[class.complete]": "isComplete",
        "[class.error]": "hasError"
      }
    }]
  }], function() {
    return [{
      type: WizardNavigationService
    }, {
      type: PageCollectionService
    }, {
      type: ClrCommonStringsService
    }];
  }, {
    page: [{
      type: Input,
      args: ["page"]
    }]
  });
})();
var ClrWizardStepnav = class {
  constructor(pageService) {
    this.pageService = pageService;
  }
};
ClrWizardStepnav.ɵfac = function ClrWizardStepnav_Factory(t3) {
  return new (t3 || ClrWizardStepnav)(ɵɵdirectiveInject(PageCollectionService));
};
ClrWizardStepnav.ɵcmp = ɵɵdefineComponent({
  type: ClrWizardStepnav,
  selectors: [["clr-wizard-stepnav"]],
  hostAttrs: [1, "clr-wizard-stepnav"],
  decls: 2,
  vars: 1,
  consts: [[1, "clr-wizard-stepnav-list"], ["clr-wizard-stepnav-item", "", "class", "clr-wizard-stepnav-item", 3, "page", 4, "ngFor", "ngForOf"], ["clr-wizard-stepnav-item", "", 1, "clr-wizard-stepnav-item", 3, "page"]],
  template: function ClrWizardStepnav_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0);
      ɵɵtemplate(1, ClrWizardStepnav_div_1_Template, 2, 2, "div", 1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngForOf", ctx.pageService.pages);
    }
  },
  dependencies: [NgForOf, ClrWizardStepnavItem],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrWizardStepnav, [{
    type: Component,
    args: [{
      selector: "clr-wizard-stepnav",
      template: `
    <div class="clr-wizard-stepnav-list">
      <div
        *ngFor="let page of pageService.pages; let i = index"
        clr-wizard-stepnav-item
        [page]="page"
        class="clr-wizard-stepnav-item"
      >
        {{ i + 1 }}
      </div>
    </div>
  `,
      host: {
        class: "clr-wizard-stepnav"
      }
    }]
  }], function() {
    return [{
      type: PageCollectionService
    }];
  }, null);
})();
var ClrWizard = class {
  constructor(platformId, commonStrings, navService, pageCollection, buttonService, headerActionService, elementRef, differs) {
    this.platformId = platformId;
    this.commonStrings = commonStrings;
    this.navService = navService;
    this.pageCollection = pageCollection;
    this.buttonService = buttonService;
    this.headerActionService = headerActionService;
    this.elementRef = elementRef;
    this.stepnavAriaLabel = this.commonStrings.keys.wizardStepnavAriaLabel;
    this.size = "xl";
    this.closable = true;
    this._stopModalAnimations = false;
    this._openChanged = new EventEmitter(false);
    this.onCancel = new EventEmitter(false);
    this.wizardFinished = new EventEmitter(false);
    this.onReset = new EventEmitter(false);
    this.currentPageChanged = new EventEmitter(false);
    this.onMoveNext = new EventEmitter(false);
    this.onMovePrevious = new EventEmitter(false);
    this._open = false;
    this.wizardId = uniqueIdFactory();
    this._forceForward = false;
    this._stopNext = false;
    this._stopCancel = false;
    this._stopNavigation = false;
    this._disableStepnav = false;
    this.subscriptions = [];
    this.subscriptions.push(this.listenForNextPageChanges(), this.listenForPreviousPageChanges(), this.listenForCancelChanges(), this.listenForFinishedChanges(), this.listenForPageChanges());
    this.differ = differs.find([]).create(null);
  }
  /**
   * Resets page completed states when navigating backwards.
   * Set using `[clrWizardForceForwardNavigation]` input.
   */
  get forceForward() {
    return this._forceForward;
  }
  set forceForward(value) {
    this._forceForward = !!value;
    this.navService.forceForwardNavigation = value;
  }
  /**
   * Toggles open/close of the wizard component.
   * Set using the `[clrWizardOpen]` input.
   */
  set clrWizardOpen(open) {
    if (open) {
      this.buttonService.buttonsReady = true;
    }
    this._open = open;
  }
  /**
   * Prevents ClrWizard from moving to the next page or closing itself on finishing.
   * Set using the `[clrWizardPreventDefaultNext]` input. Note that using stopNext
   * will require you to create your own calls to .next() and .finish() in your
   * host component to make the ClrWizard work as expected.
   */
  get stopNext() {
    return this._stopNext;
  }
  set stopNext(value) {
    this._stopNext = !!value;
    this.navService.wizardHasAltNext = value;
  }
  /**
   * Prevents ClrWizard from closing when the cancel button or close "X" is clicked.
   * Set using the `[clrWizardPreventDefaultCancel]` input.
   *
   * Note that using stopCancel will require you to create your own calls to `close()` in your host compone`nt
   * to make the ClrWizard work as expected. Useful for doing checks or prompts
   * before closing a ClrWizard.
   */
  get stopCancel() {
    return this._stopCancel;
  }
  set stopCancel(value) {
    this._stopCancel = !!value;
    this.navService.wizardHasAltCancel = value;
  }
  /**
   * Prevents ClrWizard from performing any form of navigation away from the current
   * page. Set using the `[clrWizardPreventNavigation]` input.
   * Note that stopNavigation is meant to freeze the wizard in place, typically
   * during a long validation or background action where you want the wizard to
   * display loading content but not allow the user to execute navigation in
   * the stepnav, close X, or the  back, finish, or next buttons.
   */
  get stopNavigation() {
    return this._stopNavigation;
  }
  set stopNavigation(value) {
    this._stopNavigation = !!value;
    this.navService.wizardStopNavigation = value;
  }
  /**
   * Prevents clicks on the links in the stepnav from working.
   * Set using `[clrWizardDisableStepnav]` input.
   * A more granular bypassing of navigation which can be useful when your
   * ClrWizard is in a state of completion and you don't want users to be
   * able to jump backwards and change things.
   */
  get disableStepnav() {
    return this._disableStepnav;
  }
  set disableStepnav(value) {
    this._disableStepnav = !!value;
    this.navService.wizardDisableStepnav = value;
  }
  get currentPage() {
    return this.navService.currentPage;
  }
  set currentPage(page) {
    this.navService.goTo(page, true);
  }
  get isLast() {
    return this.navService.currentPageIsLast;
  }
  get isFirst() {
    return this.navService.currentPageIsFirst;
  }
  get isInline() {
    return this.elementRef.nativeElement.classList.contains("clr-wizard--inline");
  }
  get stopModalAnimations() {
    return this._stopModalAnimations ? "true" : "false";
  }
  ngAfterContentInit() {
    this.pageCollection.pages = this.pages;
    this.headerActionService.wizardHeaderActions = this.headerActions;
    this.initializeButtons();
  }
  ngDoCheck() {
    this.updateNavOnPageChanges();
  }
  ngOnDestroy() {
    this.subscriptions.forEach((s2) => s2.unsubscribe());
  }
  /**
   * Marks Wizard as finished. By default it does not execute event
   * emissions or checks before completing and closing. This method is commonly
   * used as part of an alternative navigation with `[clrWizardPreventDefaultNext]`.
   *
   * If `skipChecksAndEmits` is true, the wizard will complete and close
   * regardless of the state of its current page. This is useful for alternative
   * navigation where event emissions have already been done and firing them again
   * may cause an event loop.
   */
  finish(skipChecksAndEmits = true) {
    if (skipChecksAndEmits) {
      this.forceFinish();
    } else {
      this.navService.finish();
    }
  }
  /**
   * Marks the wizard as finished but does run checks and emissions.
   * Good for a last step in an alternate workflow. Does the same thing as
   * calling `ClrWizard.finish(true)` or `ClrWizard.finish()` without a parameter.
   */
  forceFinish() {
    if (this.stopNavigation) {
      return;
    }
    this.close();
  }
  /**
   * Opens the wizard. If there is no current page defined, sets the first page in the wizard to be current.
   */
  open() {
    this._open = true;
    if (!this.currentPage) {
      this.navService.setFirstPageCurrent();
    }
    this.buttonService.buttonsReady = true;
    this._openChanged.emit(true);
  }
  /**
   * Closes the wizard. Call this directly instead of `cancel()` to implement alternative cancel functionality.
   */
  close() {
    if (this.stopNavigation) {
      return;
    }
    this._open = false;
    this._openChanged.emit(false);
  }
  /**
   * Used to open and close the wizard. By default the wizard will
   * close if invoked with no parameter. If parameter is true wizard will open
   * else if false will close.
   */
  toggle(open) {
    if (open) {
      this.open();
    } else {
      this.close();
    }
  }
  /**
   * Moves the wizard to the previous page.
   */
  previous() {
    this.navService.previous();
  }
  /**
   * By default, `next()` does not execute event emissions.
   * This method is commonly called as part of an alternative navigation
   * with `[clrWizardPreventDefaultNext]`. The wizard will move to the next page
   * regardless of the state of its current page. This is useful for alternative
   * navigation where event emissions have already been done and firing them again
   * may cause an event loop.
   *
   * If `skipChecksAndEmits` is false, the wizard will execute default checks
   * and emit events as normal. This is useful for custom buttons or programmatic
   * workflows that are not executing the wizards default checks and emissions.
   * It is another way to navigate without having to rewrite the wizard’s default
   * functionality from scratch.
   */
  next(skipChecksAndEmits = true) {
    if (skipChecksAndEmits) {
      this.forceNext();
    } else {
      this.navService.next();
    }
  }
  /**
   * Moves the wizard to the next page without the checks and emissions.
   * Good for a last step in an alternate workflow.
   * Alias for `ClrWizard.next(true)` or `ClrWizard.next()`
   */
  forceNext() {
    this.navService.forceNext();
  }
  /**
   * Cancels and closes the wizard. Do not use this for an override of the cancel
   * the functionality with `[clrWizardPreventDefaultCancel]`, `[clrWizardPreventPageDefaultCancel]`,
   * or `[clrWizardPagePreventDefault]` because it will initiate the same checks
   * and event emissions that invoked your event handler. Use `ClrWizard.close()` instead.
   */
  cancel() {
    this.navService.cancel();
  }
  /**
   * Overrides behavior of the underlying modal to avoid collisions with
   * alternative cancel functionality. In most cases, use `ClrWizard.cancel()` instead.
   */
  modalCancel() {
    if (this.closable) {
      this.checkAndCancel();
    }
  }
  /**
   * Checks for alternative cancel flows defined at the current page or
   * wizard level. Performs a canceled if not. Emits events that initiate
   * the alternative cancel outputs `(clrWizardPageOnCancel)` and `(clrWizardOnCancel)`.
   */
  checkAndCancel() {
    const currentPage = this.currentPage;
    const currentPageHasOverrides = currentPage.stopCancel || currentPage.preventDefault;
    if (this.stopNavigation) {
      return;
    }
    currentPage.pageOnCancel.emit();
    if (!currentPageHasOverrides) {
      this.onCancel.emit();
    }
    if (!this.stopCancel && !currentPageHasOverrides) {
      this.close();
    }
  }
  /**
   * Navigates to a given page in the Wizard. Navigation will invoke the wizard’s default
   * checks and event emissions.
   *
   * The format of the expected ID parameter can be found in the return of the
   * ClrWizardPage.id getter, usually prefixed with `clr-wizard-page-` and then either a
   * numeric ID or the ID specified for the `ClrWizardPage` component’s `id` input.
   */
  goTo(pageId) {
    if (!pageId) {
      return;
    }
    this.navService.goTo(pageId);
  }
  /**
   * Reset sets all WizardPages to incomplete and sets the first page in the `ClrWizard` to
   * be the current page, resetting the wizard navigation.
   * Use `(clrWizardOnReset)` event to reset the data or model of your wizard.
   */
  reset() {
    this.pageCollection.reset();
    this.onReset.emit();
  }
  listenForNextPageChanges() {
    return this.navService.movedToNextPage.pipe(filter(() => isPlatformBrowser(this.platformId))).subscribe(() => {
      this.onMoveNext.emit();
      this.pageTitle?.nativeElement.focus();
    });
  }
  listenForPreviousPageChanges() {
    return this.navService.movedToPreviousPage.pipe(filter(() => isPlatformBrowser(this.platformId))).subscribe(() => {
      this.onMovePrevious.emit();
      this.pageTitle?.nativeElement.focus();
    });
  }
  listenForCancelChanges() {
    return this.navService.notifyWizardCancel.subscribe(() => this.checkAndCancel());
  }
  listenForFinishedChanges() {
    return this.navService.wizardFinished.subscribe(() => this.emitWizardFinished());
  }
  listenForPageChanges() {
    return this.navService.currentPageChanged.subscribe(() => {
      this.pageTitle?.nativeElement.focus();
      this.currentPageChanged.emit();
    });
  }
  updateNavOnPageChanges() {
    const changes = this.differ.diff(this.pages);
    if (changes) {
      changes.forEachAddedItem(() => this.navService.updateNavigation());
      changes.forEachRemovedItem(() => this.navService.updateNavigation());
    }
  }
  initializeButtons() {
    if (this._open) {
      this.buttonService.buttonsReady = true;
    }
  }
  emitWizardFinished() {
    if (!this.stopNext) {
      this.forceFinish();
    }
    this.wizardFinished.emit();
  }
};
ClrWizard.ɵfac = function ClrWizard_Factory(t3) {
  return new (t3 || ClrWizard)(ɵɵdirectiveInject(PLATFORM_ID), ɵɵdirectiveInject(ClrCommonStringsService), ɵɵdirectiveInject(WizardNavigationService), ɵɵdirectiveInject(PageCollectionService), ɵɵdirectiveInject(ButtonHubService), ɵɵdirectiveInject(HeaderActionService), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(IterableDiffers));
};
ClrWizard.ɵcmp = ɵɵdefineComponent({
  type: ClrWizard,
  selectors: [["clr-wizard"]],
  contentQueries: function ClrWizard_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, ClrWizardTitle, 5);
      ɵɵcontentQuery(dirIndex, ClrWizardPage, 5);
      ɵɵcontentQuery(dirIndex, ClrWizardHeaderAction, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.wizardTitle = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.pages = _t);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.headerActions = _t);
    }
  },
  viewQuery: function ClrWizard_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c104, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.pageTitle = _t.first);
    }
  },
  hostVars: 10,
  hostBindings: function ClrWizard_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("clr-wizard", true)("wizard-md", ctx.size == "md")("wizard-lg", ctx.size == "lg")("wizard-xl", ctx.size == "xl")("lastPage", ctx.navService.currentPageIsLast);
    }
  },
  inputs: {
    stepnavAriaLabel: [InputFlags.None, "clrWizardStepnavAriaLabel", "stepnavAriaLabel"],
    size: [InputFlags.None, "clrWizardSize", "size"],
    closable: [InputFlags.None, "clrWizardClosable", "closable"],
    _stopModalAnimations: [InputFlags.None, "clrWizardPreventModalAnimation", "_stopModalAnimations"],
    forceForward: [InputFlags.None, "clrWizardForceForwardNavigation", "forceForward"],
    clrWizardOpen: "clrWizardOpen",
    stopNext: [InputFlags.None, "clrWizardPreventDefaultNext", "stopNext"],
    stopCancel: [InputFlags.None, "clrWizardPreventDefaultCancel", "stopCancel"],
    stopNavigation: [InputFlags.None, "clrWizardPreventNavigation", "stopNavigation"],
    disableStepnav: [InputFlags.None, "clrWizardDisableStepnav", "disableStepnav"]
  },
  outputs: {
    _openChanged: "clrWizardOpenChange",
    onCancel: "clrWizardOnCancel",
    wizardFinished: "clrWizardOnFinish",
    onReset: "clrWizardOnReset",
    currentPageChanged: "clrWizardCurrentPageChanged",
    onMoveNext: "clrWizardOnNext",
    onMovePrevious: "clrWizardOnPrevious"
  },
  features: [ɵɵProvidersFeature([WizardNavigationService, PageCollectionService, ButtonHubService, HeaderActionService])],
  ngContentSelectors: _c106,
  decls: 17,
  vars: 16,
  consts: [["pageTitle", ""], [3, "clrModalAlternateClose", "clrModalOpen", "clrModalSize", "clrModalClosable", "clrModalStaticBackdrop", "clrModalSkipAnimation", "clrModalOverrideScrollService", "clrModalPreventClose", "clrModalLabelledById"], ["role", "region", 1, "modal-nav", "clr-wizard-stepnav-wrapper"], ["role", "heading", 1, "clr-wizard-title", 3, "id"], ["role", "heading", 1, "modal-title"], ["tabindex", "-1", 1, "modal-title-text"], [3, "ngTemplateOutlet"], ["class", "modal-header-actions-wrapper", 4, "ngIf"], [1, "modal-body"], ["clr-wizard-pages-wrapper", "", 1, "clr-wizard-content"], [1, "modal-footer", "clr-wizard-footer"], [1, "clr-wizard-footer-buttons"], ["class", "clr-wizard-footer-buttons-wrapper", 4, "ngIf"], [1, "modal-header-actions-wrapper"], [4, "ngIf"], [1, "clr-wizard-footer-buttons-wrapper"]],
  template: function ClrWizard_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵprojectionDef(_c105);
      ɵɵelementStart(0, "clr-modal", 1);
      ɵɵlistener("clrModalAlternateClose", function ClrWizard_Template_clr_modal_clrModalAlternateClose_0_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.modalCancel());
      });
      ɵɵelementStart(1, "div", 2)(2, "div", 3);
      ɵɵprojection(3);
      ɵɵelementEnd();
      ɵɵelement(4, "clr-wizard-stepnav");
      ɵɵelementEnd();
      ɵɵelementStart(5, "div", 4)(6, "span", 5, 0);
      ɵɵtemplate(8, ClrWizard_ng_template_8_Template, 0, 0, "ng-template", 6);
      ɵɵelementEnd();
      ɵɵtemplate(9, ClrWizard_div_9_Template, 3, 2, "div", 7);
      ɵɵelementEnd();
      ɵɵelementStart(10, "div", 8)(11, "main", 9);
      ɵɵprojection(12, 1);
      ɵɵelementEnd()();
      ɵɵelementStart(13, "div", 10)(14, "div", 11);
      ɵɵtemplate(15, ClrWizard_div_15_Template, 2, 0, "div", 12)(16, ClrWizard_div_16_Template, 2, 1, "div", 12);
      ɵɵelementEnd()()();
    }
    if (rf & 2) {
      ɵɵproperty("clrModalOpen", ctx._open)("clrModalSize", ctx.size)("clrModalClosable", ctx.closable)("clrModalStaticBackdrop", true)("clrModalSkipAnimation", ctx.stopModalAnimations)("clrModalOverrideScrollService", ctx.isInline)("clrModalPreventClose", true)("clrModalLabelledById", ctx.wizardId);
      ɵɵadvance();
      ɵɵattribute("aria-label", ctx.stepnavAriaLabel);
      ɵɵadvance();
      ɵɵpropertyInterpolate("id", ctx.wizardId);
      ɵɵattribute("aria-level", ctx.wizardTitle.headingLevel || 1);
      ɵɵadvance(3);
      ɵɵattribute("aria-level", ctx.navService.currentPage.pageTitle.headingLevel || 2);
      ɵɵadvance(3);
      ɵɵproperty("ngTemplateOutlet", ctx.navService.currentPageTitle);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.headerActionService.displayHeaderActionsWrapper);
      ɵɵadvance(6);
      ɵɵproperty("ngIf", ctx.navService.currentPage && !ctx.navService.currentPage.hasButtons);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.navService.currentPage && ctx.navService.currentPage.hasButtons);
    }
  },
  dependencies: [NgIf, NgTemplateOutlet, ClrModal, ClrModalBody, ClrWizardStepnav],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrWizard, [{
    type: Component,
    args: [{
      selector: "clr-wizard",
      providers: [WizardNavigationService, PageCollectionService, ButtonHubService, HeaderActionService],
      host: {
        "[class.clr-wizard]": "true",
        "[class.wizard-md]": "size == 'md'",
        "[class.wizard-lg]": "size == 'lg'",
        "[class.wizard-xl]": "size == 'xl'",
        "[class.lastPage]": "navService.currentPageIsLast"
      },
      template: '<!--\n  ~ Copyright (c) 2016-2024 Broadcom. All Rights Reserved.\n  ~ The term "Broadcom" refers to Broadcom Inc. and/or its subsidiaries.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n  -->\n\n<clr-modal\n  [clrModalOpen]="_open"\n  [clrModalSize]="size"\n  [clrModalClosable]="closable"\n  [clrModalStaticBackdrop]="true"\n  [clrModalSkipAnimation]="stopModalAnimations"\n  [clrModalOverrideScrollService]="isInline"\n  [clrModalPreventClose]="true"\n  (clrModalAlternateClose)="modalCancel()"\n  [clrModalLabelledById]="wizardId"\n>\n  <div class="modal-nav clr-wizard-stepnav-wrapper" role="region" [attr.aria-label]="stepnavAriaLabel">\n    <div class="clr-wizard-title" id="{{wizardId}}" role="heading" [attr.aria-level]="wizardTitle.headingLevel || 1">\n      <ng-content select="clr-wizard-title"></ng-content>\n    </div>\n    <clr-wizard-stepnav></clr-wizard-stepnav>\n  </div>\n\n  <div class="modal-title" role="heading" [attr.aria-level]="navService.currentPage.pageTitle.headingLevel || 2">\n    <span tabindex="-1" #pageTitle class="modal-title-text">\n      <ng-template [ngTemplateOutlet]="navService.currentPageTitle"></ng-template>\n    </span>\n\n    <div class="modal-header-actions-wrapper" *ngIf="headerActionService.displayHeaderActionsWrapper">\n      <div *ngIf="headerActionService.showWizardHeaderActions">\n        <ng-content select="clr-wizard-header-action"></ng-content>\n      </div>\n      <div *ngIf="headerActionService.currentPageHasHeaderActions">\n        <ng-template [ngTemplateOutlet]="navService.currentPage.headerActions"></ng-template>\n      </div>\n    </div>\n  </div>\n\n  <div class="modal-body">\n    <main clr-wizard-pages-wrapper class="clr-wizard-content">\n      <ng-content></ng-content>\n    </main>\n  </div>\n  <div class="modal-footer clr-wizard-footer">\n    <div class="clr-wizard-footer-buttons">\n      <div\n        *ngIf="navService.currentPage && !navService.currentPage.hasButtons"\n        class="clr-wizard-footer-buttons-wrapper"\n      >\n        <ng-content select="clr-wizard-button"></ng-content>\n      </div>\n      <div\n        *ngIf="navService.currentPage && navService.currentPage.hasButtons"\n        class="clr-wizard-footer-buttons-wrapper"\n      >\n        <ng-template [ngTemplateOutlet]="navService.currentPage.buttons"></ng-template>\n      </div>\n    </div>\n  </div>\n</clr-modal>\n'
    }]
  }], function() {
    return [{
      type: void 0,
      decorators: [{
        type: Inject,
        args: [PLATFORM_ID]
      }]
    }, {
      type: ClrCommonStringsService
    }, {
      type: WizardNavigationService
    }, {
      type: PageCollectionService
    }, {
      type: ButtonHubService
    }, {
      type: HeaderActionService
    }, {
      type: ElementRef
    }, {
      type: IterableDiffers
    }];
  }, {
    stepnavAriaLabel: [{
      type: Input,
      args: ["clrWizardStepnavAriaLabel"]
    }],
    size: [{
      type: Input,
      args: ["clrWizardSize"]
    }],
    closable: [{
      type: Input,
      args: ["clrWizardClosable"]
    }],
    _stopModalAnimations: [{
      type: Input,
      args: ["clrWizardPreventModalAnimation"]
    }],
    _openChanged: [{
      type: Output,
      args: ["clrWizardOpenChange"]
    }],
    onCancel: [{
      type: Output,
      args: ["clrWizardOnCancel"]
    }],
    wizardFinished: [{
      type: Output,
      args: ["clrWizardOnFinish"]
    }],
    onReset: [{
      type: Output,
      args: ["clrWizardOnReset"]
    }],
    currentPageChanged: [{
      type: Output,
      args: ["clrWizardCurrentPageChanged"]
    }],
    onMoveNext: [{
      type: Output,
      args: ["clrWizardOnNext"]
    }],
    onMovePrevious: [{
      type: Output,
      args: ["clrWizardOnPrevious"]
    }],
    pageTitle: [{
      type: ViewChild,
      args: ["pageTitle"]
    }],
    pages: [{
      type: ContentChildren,
      args: [ClrWizardPage, {
        descendants: true
      }]
    }],
    headerActions: [{
      type: ContentChildren,
      args: [ClrWizardHeaderAction]
    }],
    wizardTitle: [{
      type: ContentChild,
      args: [ClrWizardTitle]
    }],
    forceForward: [{
      type: Input,
      args: ["clrWizardForceForwardNavigation"]
    }],
    clrWizardOpen: [{
      type: Input,
      args: ["clrWizardOpen"]
    }],
    stopNext: [{
      type: Input,
      args: ["clrWizardPreventDefaultNext"]
    }],
    stopCancel: [{
      type: Input,
      args: ["clrWizardPreventDefaultCancel"]
    }],
    stopNavigation: [{
      type: Input,
      args: ["clrWizardPreventNavigation"]
    }],
    disableStepnav: [{
      type: Input,
      args: ["clrWizardDisableStepnav"]
    }]
  });
})();
var DEFAULT_BUTTON_TYPES = {
  cancel: "cancel",
  previous: "previous",
  next: "next",
  finish: "finish",
  danger: "danger"
};
var CUSTOM_BUTTON_TYPES = {
  cancel: "custom-cancel",
  previous: "custom-previous",
  next: "custom-next",
  finish: "custom-finish",
  danger: "custom-danger"
};
var ClrWizardButton = class {
  constructor(navService, buttonService) {
    this.navService = navService;
    this.buttonService = buttonService;
    this.type = "";
    this.disabled = false;
    this.hidden = false;
    this.wasClicked = new EventEmitter(false);
  }
  get isCancel() {
    return this.checkDefaultAndCustomType(this.type, "cancel");
  }
  get isNext() {
    return this.checkDefaultAndCustomType(this.type, "next");
  }
  get isPrevious() {
    return this.checkDefaultAndCustomType(this.type, "previous");
  }
  get isFinish() {
    return this.checkDefaultAndCustomType(this.type, "finish");
  }
  get isDanger() {
    return this.checkDefaultAndCustomType(this.type, "danger");
  }
  get isPrimaryAction() {
    return this.isNext || this.isDanger || this.isFinish;
  }
  get _disabledAttribute() {
    if (this.isDisabled) {
      return "";
    }
    return null;
  }
  get isDisabled() {
    const disabled = true;
    const nav = this.navService;
    const page = this.navService.currentPage;
    if (!this.buttonService.buttonsReady) {
      return !disabled;
    }
    if (this.disabled || nav.wizardStopNavigation || !page) {
      return true;
    }
    if (this.isCancel) {
      return !disabled;
    }
    if (this.isPrevious && (nav.currentPageIsFirst || page.previousStepDisabled)) {
      return disabled;
    }
    if (this.isDanger && !page.readyToComplete) {
      return disabled;
    }
    if (this.isNext && (nav.currentPageIsLast || !page.readyToComplete)) {
      return disabled;
    }
    if (this.isFinish && (!nav.currentPageIsLast || !page.readyToComplete)) {
      return disabled;
    }
    return !disabled;
  }
  get isHidden() {
    const hidden = true;
    const nav = this.navService;
    if (!this.buttonService.buttonsReady) {
      return !hidden;
    }
    if (this.hidden) {
      return true;
    }
    if (this.isCancel) {
      return !hidden;
    }
    if (this.isPrevious && nav.currentPageIsFirst) {
      return hidden;
    }
    if (this.isNext && nav.currentPageIsLast) {
      return hidden;
    }
    if (this.isFinish && !nav.currentPageIsLast) {
      return hidden;
    }
    return !hidden;
  }
  click() {
    if (this.isDisabled) {
      return;
    }
    this.wasClicked.emit(this.type);
    this.buttonService.buttonClicked(this.type);
  }
  checkDefaultAndCustomType(valueToCheck = "", typeToLookUp) {
    if (DEFAULT_BUTTON_TYPES[typeToLookUp] === valueToCheck) {
      return true;
    }
    if (CUSTOM_BUTTON_TYPES[typeToLookUp] === valueToCheck) {
      return true;
    }
    return false;
  }
};
ClrWizardButton.ɵfac = function ClrWizardButton_Factory(t3) {
  return new (t3 || ClrWizardButton)(ɵɵdirectiveInject(WizardNavigationService), ɵɵdirectiveInject(ButtonHubService));
};
ClrWizardButton.ɵcmp = ɵɵdefineComponent({
  type: ClrWizardButton,
  selectors: [["clr-wizard-button"]],
  hostAttrs: [1, "clr-wizard-btn-wrapper"],
  hostVars: 1,
  hostBindings: function ClrWizardButton_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("aria-hidden", ctx.isHidden);
    }
  },
  inputs: {
    type: "type",
    disabled: [InputFlags.None, "clrWizardButtonDisabled", "disabled"],
    hidden: [InputFlags.None, "clrWizardButtonHidden", "hidden"]
  },
  outputs: {
    wasClicked: "clrWizardButtonClicked"
  },
  ngContentSelectors: _c02,
  decls: 2,
  vars: 19,
  consts: [["type", "button", 1, "btn", "clr-wizard-btn", 3, "click"]],
  template: function ClrWizardButton_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "button", 0);
      ɵɵlistener("click", function ClrWizardButton_Template_button_click_0_listener() {
        return ctx.click();
      });
      ɵɵprojection(1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵclassProp("btn-link", ctx.isCancel)("clr-wizard-btn--tertiary", ctx.isCancel)("btn-outline", ctx.isPrevious)("clr-wizard-btn--secondary", ctx.isPrevious)("btn-primary", ctx.isPrimaryAction)("clr-wizard-btn--primary", ctx.isPrimaryAction)("btn-success", ctx.isFinish)("btn-danger", ctx.isDanger)("disabled", ctx.isDisabled);
      ɵɵattribute("disabled", ctx._disabledAttribute);
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrWizardButton, [{
    type: Component,
    args: [{
      selector: "clr-wizard-button",
      template: `
    <button
      type="button"
      class="btn clr-wizard-btn"
      [class.btn-link]="isCancel"
      [class.clr-wizard-btn--tertiary]="isCancel"
      [class.btn-outline]="isPrevious"
      [class.clr-wizard-btn--secondary]="isPrevious"
      [class.btn-primary]="isPrimaryAction"
      [class.clr-wizard-btn--primary]="isPrimaryAction"
      [class.btn-success]="isFinish"
      [class.btn-danger]="isDanger"
      [class.disabled]="isDisabled"
      [attr.disabled]="_disabledAttribute"
      (click)="click()"
    >
      <ng-content></ng-content>
    </button>
  `,
      host: {
        class: "clr-wizard-btn-wrapper",
        "[attr.aria-hidden]": "isHidden"
      }
    }]
  }], function() {
    return [{
      type: WizardNavigationService
    }, {
      type: ButtonHubService
    }];
  }, {
    type: [{
      type: Input,
      args: ["type"]
    }],
    disabled: [{
      type: Input,
      args: ["clrWizardButtonDisabled"]
    }],
    hidden: [{
      type: Input,
      args: ["clrWizardButtonHidden"]
    }],
    wasClicked: [{
      type: Output,
      args: ["clrWizardButtonClicked"]
    }]
  });
})();
var CLR_WIZARD_DIRECTIVES = [ClrWizard, ClrWizardPage, ClrWizardStepnav, ClrWizardStepnavItem, ClrWizardButton, ClrWizardHeaderAction, ClrWizardTitle, ClrWizardPageTitle, ClrWizardPageNavTitle, ClrWizardPageButtons, ClrWizardPageHeaderActions];
var ClrWizardModule = class {
  constructor() {
    r.addIcons(d);
  }
};
ClrWizardModule.ɵfac = function ClrWizardModule_Factory(t3) {
  return new (t3 || ClrWizardModule)();
};
ClrWizardModule.ɵmod = ɵɵdefineNgModule({
  type: ClrWizardModule,
  declarations: [ClrWizard, ClrWizardPage, ClrWizardStepnav, ClrWizardStepnavItem, ClrWizardButton, ClrWizardHeaderAction, ClrWizardTitle, ClrWizardPageTitle, ClrWizardPageNavTitle, ClrWizardPageButtons, ClrWizardPageHeaderActions],
  imports: [CommonModule, ClrModalModule, ClrAlertModule],
  exports: [ClrWizard, ClrWizardPage, ClrWizardStepnav, ClrWizardStepnavItem, ClrWizardButton, ClrWizardHeaderAction, ClrWizardTitle, ClrWizardPageTitle, ClrWizardPageNavTitle, ClrWizardPageButtons, ClrWizardPageHeaderActions]
});
ClrWizardModule.ɵinj = ɵɵdefineInjector({
  imports: [CommonModule, ClrModalModule, ClrAlertModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClrWizardModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, ClrModalModule, ClrAlertModule],
      declarations: [CLR_WIZARD_DIRECTIVES],
      exports: [CLR_WIZARD_DIRECTIVES]
    }]
  }], function() {
    return [];
  }, null);
})();
var ClarityModule = class {
};
ClarityModule.ɵfac = function ClarityModule_Factory(t3) {
  return new (t3 || ClarityModule)();
};
ClarityModule.ɵmod = ɵɵdefineNgModule({
  type: ClarityModule,
  exports: [ClrEmphasisModule, ClrDataModule, ClrIconModule, ClrModalModule, ClrLoadingModule, ClrConditionalModule, ClrFocusOnViewInitModule, ClrButtonModule, ClrFormsModule, ClrLayoutModule, ClrPopoverModule, ClrWizardModule, ClrSidePanelModule, ClrStepperModule, ClrSpinnerModule, ClrProgressBarModule, ClrPopoverModuleNext, ClrTimelineModule]
});
ClarityModule.ɵinj = ɵɵdefineInjector({
  imports: [ClrEmphasisModule, ClrDataModule, ClrIconModule, ClrModalModule, ClrLoadingModule, ClrConditionalModule, ClrFocusOnViewInitModule, ClrButtonModule, ClrFormsModule, ClrLayoutModule, ClrPopoverModule, ClrWizardModule, ClrSidePanelModule, ClrStepperModule, ClrSpinnerModule, ClrProgressBarModule, ClrPopoverModuleNext, ClrTimelineModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClarityModule, [{
    type: NgModule,
    args: [{
      exports: [ClrEmphasisModule, ClrDataModule, ClrIconModule, ClrModalModule, ClrLoadingModule, ClrConditionalModule, ClrFocusOnViewInitModule, ClrButtonModule, ClrFormsModule, ClrLayoutModule, ClrPopoverModule, ClrWizardModule, ClrSidePanelModule, ClrStepperModule, ClrSpinnerModule, ClrProgressBarModule, ClrPopoverModuleNext, ClrTimelineModule]
    }]
  }], null, null);
})();
var CLR_MENU_POSITIONS = ["bottom-left", "bottom-right", "top-left", "top-right", "left-bottom", "left-top", "right-bottom", "right-top"];
export {
  CHANGE_KEYS,
  CLR_ALERT_DIRECTIVES,
  CLR_BUTTON_GROUP_DIRECTIVES,
  CLR_DATAGRID_DIRECTIVES,
  CLR_DATEPICKER_DIRECTIVES,
  CLR_DROPDOWN_DIRECTIVES,
  CLR_ICON_DIRECTIVES,
  CLR_LAYOUT_DIRECTIVES,
  CLR_LOADING_BUTTON_DIRECTIVES,
  CLR_LOADING_DIRECTIVES,
  CLR_MENU_POSITIONS,
  CLR_MODAL_DIRECTIVES,
  CLR_NAVIGATION_DIRECTIVES,
  CLR_PROGRESS_BAR_DIRECTIVES,
  CLR_SIDEPANEL_DIRECTIVES,
  CLR_SIGNPOST_DIRECTIVES,
  CLR_SPINNER_DIRECTIVES,
  CLR_STACK_VIEW_DIRECTIVES,
  CLR_TABS_DIRECTIVES,
  CLR_TOOLTIP_DIRECTIVES,
  CLR_TREE_VIEW_DIRECTIVES,
  CLR_VERTICAL_NAV_DIRECTIVES,
  CLR_WIZARD_DIRECTIVES,
  CONDITIONAL_DIRECTIVES,
  CUSTOM_BUTTON_TYPES,
  CdsIconCustomTag,
  ClarityModule,
  ClrAbstractContainer,
  ClrAccordion,
  ClrAccordionContent,
  ClrAccordionDescription,
  ClrAccordionModule,
  ClrAccordionPanel,
  ClrAccordionTitle,
  ClrAlert,
  ClrAlertItem,
  ClrAlertModule,
  ClrAlertText,
  ClrAlerts,
  ClrAlertsPager,
  ClrAlignment,
  ClrAriaCurrentLink,
  ClrAxis,
  ClrButton,
  ClrButtonGroup,
  ClrButtonGroupModule,
  ClrButtonModule,
  ClrCalendar,
  ClrCheckbox,
  ClrCheckboxContainer,
  ClrCheckboxModule,
  ClrCheckboxWrapper,
  ClrCombobox,
  ClrComboboxContainer,
  ClrComboboxModule,
  ClrCommonFormsModule,
  ClrCommonStringsService,
  ClrConditionalModule,
  ClrControl,
  ClrControlContainer,
  ClrControlError,
  ClrControlHelper,
  ClrControlSuccess,
  ClrDataModule,
  ClrDatagrid,
  ClrDatagridActionBar,
  ClrDatagridActionOverflow,
  ClrDatagridCell,
  ClrDatagridColumn,
  ClrDatagridColumnSeparator,
  ClrDatagridColumnToggle,
  ClrDatagridColumnToggleButton,
  ClrDatagridDetail,
  ClrDatagridDetailBody,
  ClrDatagridDetailHeader,
  ClrDatagridFilter,
  ClrDatagridFooter,
  ClrDatagridHideableColumn,
  ClrDatagridItems,
  ClrDatagridModule,
  ClrDatagridPageSize,
  ClrDatagridPagination,
  ClrDatagridPlaceholder,
  ClrDatagridRow,
  ClrDatagridRowDetail,
  ClrDatagridSortOrder,
  ClrDatalist,
  ClrDatalistContainer,
  ClrDatalistInput,
  ClrDatalistModule,
  ClrDateContainer,
  ClrDateInput,
  ClrDateInputValidator,
  ClrDatepickerModule,
  ClrDatepickerViewManager,
  ClrDay,
  ClrDaypicker,
  ClrDestroyService,
  ClrDropdown,
  ClrDropdownItem,
  ClrDropdownMenu,
  ClrDropdownModule,
  ClrDropdownTrigger,
  ClrEmphasisModule,
  ClrExpandableAnimation,
  ClrFileInput,
  ClrFileInputContainer,
  ClrFileInputModule,
  ClrFileInputValidator,
  ClrFileInputValueAccessor,
  ClrFocusOnViewInit,
  ClrFocusOnViewInitModule,
  ClrForm,
  ClrFormLayout,
  ClrFormsModule,
  ClrHeader,
  ClrIconCustomTag,
  ClrIconModule,
  ClrIfActive,
  ClrIfDetail,
  ClrIfError,
  ClrIfExpanded,
  ClrIfOpen,
  ClrIfSuccess,
  ClrInput,
  ClrInputContainer,
  ClrInputModule,
  ClrLabel,
  ClrLayout,
  ClrLayoutModule,
  ClrLoading,
  ClrLoadingButton,
  ClrLoadingButtonModule,
  ClrLoadingModule,
  ClrLoadingState,
  ClrMainContainer,
  ClrMainContainerModule,
  ClrModal,
  ClrModalBody,
  ClrModalModule,
  ClrMonthpicker,
  ClrNavLevel,
  ClrNavigationModule,
  ClrOption,
  ClrOptionItems,
  ClrOptionSelected,
  ClrOptions,
  ClrPassword,
  ClrPasswordContainer,
  ClrPasswordModule,
  ClrPopoverAnchor,
  ClrPopoverContent,
  ClrPopoverEventsService,
  ClrPopoverHostDirective,
  ClrPopoverModule,
  ClrPopoverPositionService,
  ClrPopoverToggleService,
  ClrProgressBar,
  ClrProgressBarModule,
  ClrRadio,
  ClrRadioContainer,
  ClrRadioModule,
  ClrRadioWrapper,
  ClrRange,
  ClrRangeContainer,
  ClrRangeModule,
  ClrRecursiveForOf,
  ClrSelect,
  ClrSelectContainer,
  ClrSelectModule,
  ClrSelectedState,
  ClrSide,
  ClrSidePanel,
  ClrSidePanelModule,
  ClrSignpost,
  ClrSignpostContent,
  ClrSignpostModule,
  ClrSignpostTrigger,
  ClrSpinner,
  ClrSpinnerModule,
  ClrStackBlock,
  ClrStackContentInput,
  ClrStackHeader,
  ClrStackView,
  ClrStackViewCustomTags,
  ClrStackViewLabel,
  ClrStackViewModule,
  ClrStandaloneCdkTrapFocus,
  ClrStepButton,
  ClrStepButtonType,
  ClrStepper,
  ClrStepperModule,
  ClrStepperPanel,
  ClrStopEscapePropagationDirective,
  ClrTab,
  ClrTabContent,
  ClrTabLink,
  ClrTabOverflowContent,
  ClrTabs,
  ClrTabsModule,
  ClrTextarea,
  ClrTextareaContainer,
  ClrTextareaModule,
  ClrTimeline,
  ClrTimelineLayout,
  ClrTimelineModule,
  ClrTimelineStep,
  ClrTimelineStepDescription,
  ClrTimelineStepHeader,
  ClrTimelineStepState,
  ClrTimelineStepTitle,
  ClrTooltip,
  ClrTooltipContent,
  ClrTooltipModule,
  ClrTooltipTrigger,
  ClrTree,
  ClrTreeNode,
  ClrTreeNodeLink,
  ClrTreeViewModule,
  ClrVerticalNav,
  ClrVerticalNavGroup,
  ClrVerticalNavGroupChildren,
  ClrVerticalNavIcon,
  ClrVerticalNavLink,
  ClrVerticalNavModule,
  ClrWizard,
  ClrWizardButton,
  ClrWizardHeaderAction,
  ClrWizardModule,
  ClrWizardPage,
  ClrWizardPageButtons,
  ClrWizardPageHeaderActions,
  ClrWizardPageNavTitle,
  ClrWizardPageTitle,
  ClrWizardStepnav,
  ClrWizardStepnavItem,
  ClrWizardTitle,
  ClrYearpicker,
  DEFAULT_BUTTON_TYPES,
  DatagridNumericFilter,
  DatagridPropertyComparator,
  DatagridPropertyNumericFilter,
  DatagridPropertyStringFilter,
  DatagridStringFilter,
  EXPANDABLE_ANIMATION_DIRECTIVES,
  FOCUS_ON_VIEW_INIT,
  FOCUS_ON_VIEW_INIT_DIRECTIVES,
  IS_TOGGLE,
  IS_TOGGLE_PROVIDER,
  LoadingListener,
  MainContainerWillyWonka,
  NavDetectionOompaLoompa,
  TOGGLE_SERVICE,
  TOGGLE_SERVICE_PROVIDER,
  ToggleServiceFactory,
  WrappedFormControl,
  collapse,
  commonStringsDefault,
  fade,
  fadeSlide,
  isToggleFactory,
  slide,
  AccordionOompaLoompa as ÇlrAccordionOompaLoompa,
  AccordionWillyWonka as ÇlrAccordionWillyWonka,
  ActionableOompaLoompa as ÇlrActionableOompaLoompa,
  ActiveOompaLoompa as ÇlrActiveOompaLoompa,
  ClrPopoverCloseButton as ÇlrClrPopoverCloseButton,
  ClrPopoverModuleNext as ÇlrClrPopoverModuleNext,
  ClrPopoverOpenCloseButton as ÇlrClrPopoverOpenCloseButton,
  DatagridCellRenderer as ÇlrDatagridCellRenderer,
  DatagridDetailRegisterer as ÇlrDatagridDetailRegisterer,
  DatagridHeaderRenderer as ÇlrDatagridHeaderRenderer,
  DatagridMainRenderer as ÇlrDatagridMainRenderer,
  DatagridRowRenderer as ÇlrDatagridRowRenderer,
  ClrDatagridSelectionCellDirective as ÇlrDatagridSelectionCellDirective,
  ClrDatagridVirtualScrollDirective as ÇlrDatagridVirtualScrollDirective,
  DatagridWillyWonka as ÇlrDatagridWillyWonka,
  ExpandableOompaLoompa as ÇlrExpandableOompaLoompa,
  StepperOompaLoompa as ÇlrStepperOompaLoompa,
  StepperWillyWonka as ÇlrStepperWillyWonka,
  TabsWillyWonka as ÇlrTabsWillyWonka,
  WrappedCell as ÇlrWrappedCell,
  WrappedColumn as ÇlrWrappedColumn,
  WrappedRow as ÇlrWrappedRow
};
//# sourceMappingURL=@clr_angular.js.map
